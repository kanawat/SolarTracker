CCS PCH C Compiler, Version 4.078, 38112               09-Apr-10 23:57

               Filename: solar_controller1.lst

               ROM used: 25034 bytes (76%)
                         Largest free fragment is 7730
               RAM used: 218 (14%) at main() level
                         362 (24%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
0000:  GOTO   5BF2
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   03E4
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04F2
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
16BC:  MOVFF  E8,EA
16C0:  MOVFF  E7,E9
16C4:  MOVFF  EA,03
16C8:  MOVFF  E9,FE9
16CC:  MOVFF  EA,FEA
16D0:  MOVF   FEF,F
16D2:  BZ    16DC
16D4:  INCF   xE9,F
16D6:  BTFSC  FD8.2
16D8:  INCF   xEA,F
16DA:  BRA    16C4
....................    return(sc - s); 
16DC:  MOVF   xE7,W
16DE:  SUBWF  xE9,W
16E0:  MOVWF  00
16E2:  MOVF   xE8,W
16E4:  SUBWFB xEA,W
16E6:  MOVWF  03
16E8:  MOVFF  00,01
.................... } 
16EC:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B4C:  CLRF   xD8
....................    sign = 0; 
0B4E:  CLRF   xD6
....................    base = 10; 
0B50:  MOVLW  0A
0B52:  MOVWF  xD7
....................    result = 0; 
0B54:  CLRF   xD5
0B56:  CLRF   xD4
....................  
....................    if (!s) 
0B58:  MOVF   xD2,W
0B5A:  IORWF  xD3,W
0B5C:  BNZ   0B66
....................       return 0; 
0B5E:  MOVLW  00
0B60:  MOVWF  01
0B62:  MOVWF  02
0B64:  BRA    0D32
....................    c = s[index++]; 
0B66:  MOVF   xD8,W
0B68:  INCF   xD8,F
0B6A:  CLRF   03
0B6C:  ADDWF  xD2,W
0B6E:  MOVWF  FE9
0B70:  MOVF   xD3,W
0B72:  ADDWFC 03,W
0B74:  MOVWF  FEA
0B76:  MOVFF  FEF,D9
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B7A:  MOVF   xD9,W
0B7C:  SUBLW  2D
0B7E:  BNZ   0B9A
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B80:  MOVLW  01
0B82:  MOVWF  xD6
....................       c = s[index++]; 
0B84:  MOVF   xD8,W
0B86:  INCF   xD8,F
0B88:  CLRF   03
0B8A:  ADDWF  xD2,W
0B8C:  MOVWF  FE9
0B8E:  MOVF   xD3,W
0B90:  ADDWFC 03,W
0B92:  MOVWF  FEA
0B94:  MOVFF  FEF,D9
....................    } 
....................    else if (c == '+') 
0B98:  BRA    0BB4
0B9A:  MOVF   xD9,W
0B9C:  SUBLW  2B
0B9E:  BNZ   0BB4
....................    { 
....................       c = s[index++]; 
0BA0:  MOVF   xD8,W
0BA2:  INCF   xD8,F
0BA4:  CLRF   03
0BA6:  ADDWF  xD2,W
0BA8:  MOVWF  FE9
0BAA:  MOVF   xD3,W
0BAC:  ADDWFC 03,W
0BAE:  MOVWF  FEA
0BB0:  MOVFF  FEF,D9
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0BB4:  MOVF   xD9,W
0BB6:  SUBLW  2F
0BB8:  BTFSC  FD8.0
0BBA:  BRA    0D16
0BBC:  MOVF   xD9,W
0BBE:  SUBLW  39
0BC0:  BTFSS  FD8.0
0BC2:  BRA    0D16
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0BC4:  MOVF   xD9,W
0BC6:  SUBLW  30
0BC8:  BNZ   0C0C
0BCA:  CLRF   03
0BCC:  MOVF   xD8,W
0BCE:  ADDWF  xD2,W
0BD0:  MOVWF  FE9
0BD2:  MOVF   xD3,W
0BD4:  ADDWFC 03,W
0BD6:  MOVWF  FEA
0BD8:  MOVF   FEF,W
0BDA:  SUBLW  78
0BDC:  BZ    0BF2
0BDE:  CLRF   03
0BE0:  MOVF   xD8,W
0BE2:  ADDWF  xD2,W
0BE4:  MOVWF  FE9
0BE6:  MOVF   xD3,W
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVF   FEF,W
0BEE:  SUBLW  58
0BF0:  BNZ   0C0C
....................       { 
....................          base = 16; 
0BF2:  MOVLW  10
0BF4:  MOVWF  xD7
....................          index++; 
0BF6:  INCF   xD8,F
....................          c = s[index++]; 
0BF8:  MOVF   xD8,W
0BFA:  INCF   xD8,F
0BFC:  CLRF   03
0BFE:  ADDWF  xD2,W
0C00:  MOVWF  FE9
0C02:  MOVF   xD3,W
0C04:  ADDWFC 03,W
0C06:  MOVWF  FEA
0C08:  MOVFF  FEF,D9
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C0C:  MOVF   xD7,W
0C0E:  SUBLW  0A
0C10:  BNZ   0C54
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0C12:  MOVF   xD9,W
0C14:  SUBLW  2F
0C16:  BC    0C52
0C18:  MOVF   xD9,W
0C1A:  SUBLW  39
0C1C:  BNC   0C52
....................             result = 10*result + (c - '0'); 
0C1E:  CLRF   xDB
0C20:  MOVLW  0A
0C22:  MOVWF  xDA
0C24:  MOVFF  D5,DD
0C28:  MOVFF  D4,DC
0C2C:  BRA    0B2C
0C2E:  MOVLW  30
0C30:  SUBWF  xD9,W
0C32:  ADDWF  01,W
0C34:  MOVWF  xD4
0C36:  MOVLW  00
0C38:  ADDWFC 02,W
0C3A:  MOVWF  xD5
....................             c = s[index++]; 
0C3C:  MOVF   xD8,W
0C3E:  INCF   xD8,F
0C40:  CLRF   03
0C42:  ADDWF  xD2,W
0C44:  MOVWF  FE9
0C46:  MOVF   xD3,W
0C48:  ADDWFC 03,W
0C4A:  MOVWF  FEA
0C4C:  MOVFF  FEF,D9
....................          } 
0C50:  BRA    0C12
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0C52:  BRA    0D16
0C54:  MOVF   xD7,W
0C56:  SUBLW  10
0C58:  BNZ   0D16
....................       { 
....................          c = toupper(c); 
0C5A:  MOVF   xD9,W
0C5C:  SUBLW  60
0C5E:  BC    0C6C
0C60:  MOVF   xD9,W
0C62:  SUBLW  7A
0C64:  BNC   0C6C
0C66:  MOVF   xD9,W
0C68:  ANDLW  DF
0C6A:  BRA    0C6E
0C6C:  MOVF   xD9,W
0C6E:  MOVWF  xD9
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0C70:  MOVF   xD9,W
0C72:  SUBLW  2F
0C74:  BC    0C7C
0C76:  MOVF   xD9,W
0C78:  SUBLW  39
0C7A:  BC    0C88
0C7C:  MOVF   xD9,W
0C7E:  SUBLW  40
0C80:  BC    0D16
0C82:  MOVF   xD9,W
0C84:  SUBLW  46
0C86:  BNC   0D16
....................             if (c >= '0' && c <= '9') 
0C88:  MOVF   xD9,W
0C8A:  SUBLW  2F
0C8C:  BC    0CC0
0C8E:  MOVF   xD9,W
0C90:  SUBLW  39
0C92:  BNC   0CC0
....................                result = (result << 4) + (c - '0'); 
0C94:  RLCF   xD4,W
0C96:  MOVWF  xDA
0C98:  RLCF   xD5,W
0C9A:  MOVWF  xDB
0C9C:  RLCF   xDA,F
0C9E:  RLCF   xDB,F
0CA0:  RLCF   xDA,F
0CA2:  RLCF   xDB,F
0CA4:  RLCF   xDA,F
0CA6:  RLCF   xDB,F
0CA8:  MOVLW  F0
0CAA:  ANDWF  xDA,F
0CAC:  MOVLW  30
0CAE:  SUBWF  xD9,W
0CB0:  ADDWF  xDA,W
0CB2:  MOVWF  01
0CB4:  MOVLW  00
0CB6:  ADDWFC xDB,W
0CB8:  MOVFF  01,D4
0CBC:  MOVWF  xD5
....................             else 
0CBE:  BRA    0CEC
....................                result = (result << 4) + (c - 'A' + 10); 
0CC0:  RLCF   xD4,W
0CC2:  MOVWF  xDA
0CC4:  RLCF   xD5,W
0CC6:  MOVWF  xDB
0CC8:  RLCF   xDA,F
0CCA:  RLCF   xDB,F
0CCC:  RLCF   xDA,F
0CCE:  RLCF   xDB,F
0CD0:  RLCF   xDA,F
0CD2:  RLCF   xDB,F
0CD4:  MOVLW  F0
0CD6:  ANDWF  xDA,F
0CD8:  MOVLW  41
0CDA:  SUBWF  xD9,W
0CDC:  ADDLW  0A
0CDE:  ADDWF  xDA,W
0CE0:  MOVWF  01
0CE2:  MOVLW  00
0CE4:  ADDWFC xDB,W
0CE6:  MOVFF  01,D4
0CEA:  MOVWF  xD5
....................  
....................             c = s[index++];c = toupper(c); 
0CEC:  MOVF   xD8,W
0CEE:  INCF   xD8,F
0CF0:  CLRF   03
0CF2:  ADDWF  xD2,W
0CF4:  MOVWF  FE9
0CF6:  MOVF   xD3,W
0CF8:  ADDWFC 03,W
0CFA:  MOVWF  FEA
0CFC:  MOVF   FEF,W
0CFE:  MOVWF  xD9
0D00:  SUBLW  60
0D02:  BC    0D10
0D04:  MOVF   xD9,W
0D06:  SUBLW  7A
0D08:  BNC   0D10
0D0A:  MOVF   xD9,W
0D0C:  ANDLW  DF
0D0E:  BRA    0D12
0D10:  MOVF   xD9,W
0D12:  MOVWF  xD9
....................          } 
0D14:  BRA    0C70
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0D16:  MOVF   xD7,W
0D18:  SUBLW  0A
0D1A:  BNZ   0D2A
0D1C:  DECFSZ xD6,W
0D1E:  BRA    0D2A
....................       result = -result; 
0D20:  COMF   xD4,F
0D22:  COMF   xD5,F
0D24:  INCF   xD4,F
0D26:  BTFSC  FD8.2
0D28:  INCF   xD5,F
....................  
....................    return(result); 
0D2A:  MOVFF  D4,01
0D2E:  MOVFF  D5,02
.................... } 
0D32:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
2858:  CLRF   xDA
....................    sign = 0; 
285A:  CLRF   xD8
....................    base = 10; 
285C:  MOVLW  0A
285E:  MOVWF  xD9
....................    result = 0; 
2860:  CLRF   xD7
2862:  CLRF   xD6
2864:  CLRF   xD5
2866:  CLRF   xD4
....................  
....................    if (!s) 
2868:  MOVF   xD2,W
286A:  IORWF  xD3,W
286C:  BNZ   2878
....................       return 0; 
286E:  CLRF   00
2870:  CLRF   01
2872:  CLRF   02
2874:  CLRF   03
2876:  BRA    2AF2
....................    c = s[index++]; 
2878:  MOVF   xDA,W
287A:  INCF   xDA,F
287C:  CLRF   03
287E:  ADDWF  xD2,W
2880:  MOVWF  FE9
2882:  MOVF   xD3,W
2884:  ADDWFC 03,W
2886:  MOVWF  FEA
2888:  MOVFF  FEF,DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
288C:  MOVF   xDB,W
288E:  SUBLW  2D
2890:  BNZ   28AC
....................    { 
....................       sign = 1;         // Set the sign to negative 
2892:  MOVLW  01
2894:  MOVWF  xD8
....................       c = s[index++]; 
2896:  MOVF   xDA,W
2898:  INCF   xDA,F
289A:  CLRF   03
289C:  ADDWF  xD2,W
289E:  MOVWF  FE9
28A0:  MOVF   xD3,W
28A2:  ADDWFC 03,W
28A4:  MOVWF  FEA
28A6:  MOVFF  FEF,DB
....................    } 
....................    else if (c == '+') 
28AA:  BRA    28C6
28AC:  MOVF   xDB,W
28AE:  SUBLW  2B
28B0:  BNZ   28C6
....................    { 
....................       c = s[index++]; 
28B2:  MOVF   xDA,W
28B4:  INCF   xDA,F
28B6:  CLRF   03
28B8:  ADDWF  xD2,W
28BA:  MOVWF  FE9
28BC:  MOVF   xD3,W
28BE:  ADDWFC 03,W
28C0:  MOVWF  FEA
28C2:  MOVFF  FEF,DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
28C6:  MOVF   xDB,W
28C8:  SUBLW  2F
28CA:  BTFSC  FD8.0
28CC:  BRA    2AC2
28CE:  MOVF   xDB,W
28D0:  SUBLW  39
28D2:  BTFSS  FD8.0
28D4:  BRA    2AC2
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
28D6:  MOVF   xDB,W
28D8:  SUBLW  30
28DA:  BNZ   291E
28DC:  CLRF   03
28DE:  MOVF   xDA,W
28E0:  ADDWF  xD2,W
28E2:  MOVWF  FE9
28E4:  MOVF   xD3,W
28E6:  ADDWFC 03,W
28E8:  MOVWF  FEA
28EA:  MOVF   FEF,W
28EC:  SUBLW  78
28EE:  BZ    2904
28F0:  CLRF   03
28F2:  MOVF   xDA,W
28F4:  ADDWF  xD2,W
28F6:  MOVWF  FE9
28F8:  MOVF   xD3,W
28FA:  ADDWFC 03,W
28FC:  MOVWF  FEA
28FE:  MOVF   FEF,W
2900:  SUBLW  58
2902:  BNZ   291E
....................       { 
....................          base = 16; 
2904:  MOVLW  10
2906:  MOVWF  xD9
....................          index++; 
2908:  INCF   xDA,F
....................          c = s[index++]; 
290A:  MOVF   xDA,W
290C:  INCF   xDA,F
290E:  CLRF   03
2910:  ADDWF  xD2,W
2912:  MOVWF  FE9
2914:  MOVF   xD3,W
2916:  ADDWFC 03,W
2918:  MOVWF  FEA
291A:  MOVFF  FEF,DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
291E:  MOVF   xD9,W
2920:  SUBLW  0A
2922:  BNZ   29AC
....................       { 
....................          while (c >= '0' && c <= '9') { 
2924:  MOVF   xDB,W
2926:  SUBLW  2F
2928:  BC    29AA
292A:  MOVF   xDB,W
292C:  SUBLW  39
292E:  BNC   29AA
....................             result = (result << 1) + (result << 3);  // result *= 10; 
2930:  BCF    FD8.0
2932:  RLCF   xD4,W
2934:  MOVWF  xDD
2936:  RLCF   xD5,W
2938:  MOVWF  xDE
293A:  RLCF   xD6,W
293C:  MOVWF  xDF
293E:  RLCF   xD7,W
2940:  MOVWF  xE0
2942:  RLCF   xD4,W
2944:  MOVWF  00
2946:  RLCF   xD5,W
2948:  MOVWF  01
294A:  RLCF   xD6,W
294C:  MOVWF  02
294E:  RLCF   xD7,W
2950:  MOVWF  03
2952:  RLCF   00,F
2954:  RLCF   01,F
2956:  RLCF   02,F
2958:  RLCF   03,F
295A:  RLCF   00,F
295C:  RLCF   01,F
295E:  RLCF   02,F
2960:  RLCF   03,F
2962:  MOVLW  F8
2964:  ANDWF  00,F
2966:  MOVF   xDD,W
2968:  ADDWF  00,F
296A:  MOVF   xDE,W
296C:  ADDWFC 01,F
296E:  MOVF   xDF,W
2970:  ADDWFC 02,F
2972:  MOVF   xE0,W
2974:  ADDWFC 03,F
2976:  MOVFF  03,D7
297A:  MOVFF  02,D6
297E:  MOVFF  01,D5
2982:  MOVFF  00,D4
....................             result += (c - '0'); 
2986:  MOVLW  30
2988:  SUBWF  xDB,W
298A:  ADDWF  xD4,F
298C:  MOVLW  00
298E:  ADDWFC xD5,F
2990:  ADDWFC xD6,F
2992:  ADDWFC xD7,F
....................             c = s[index++]; 
2994:  MOVF   xDA,W
2996:  INCF   xDA,F
2998:  CLRF   03
299A:  ADDWF  xD2,W
299C:  MOVWF  FE9
299E:  MOVF   xD3,W
29A0:  ADDWFC 03,W
29A2:  MOVWF  FEA
29A4:  MOVFF  FEF,DB
....................          } 
29A8:  BRA    2924
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
29AA:  BRA    2AC2
29AC:  MOVF   xD9,W
29AE:  SUBLW  10
29B0:  BTFSS  FD8.2
29B2:  BRA    2AC2
....................       { 
....................          c = toupper(c); 
29B4:  MOVF   xDB,W
29B6:  SUBLW  60
29B8:  BC    29C6
29BA:  MOVF   xDB,W
29BC:  SUBLW  7A
29BE:  BNC   29C6
29C0:  MOVF   xDB,W
29C2:  ANDLW  DF
29C4:  BRA    29C8
29C6:  MOVF   xDB,W
29C8:  MOVWF  xDB
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
29CA:  MOVF   xDB,W
29CC:  SUBLW  2F
29CE:  BC    29D6
29D0:  MOVF   xDB,W
29D2:  SUBLW  39
29D4:  BC    29E4
29D6:  MOVF   xDB,W
29D8:  SUBLW  40
29DA:  BTFSC  FD8.0
29DC:  BRA    2AC2
29DE:  MOVF   xDB,W
29E0:  SUBLW  46
29E2:  BNC   2AC2
....................             if (c >= '0' && c <= '9') 
29E4:  MOVF   xDB,W
29E6:  SUBLW  2F
29E8:  BC    2A44
29EA:  MOVF   xDB,W
29EC:  SUBLW  39
29EE:  BNC   2A44
....................                result = (result << 4) + (c - '0'); 
29F0:  RLCF   xD4,W
29F2:  MOVWF  xDD
29F4:  RLCF   xD5,W
29F6:  MOVWF  xDE
29F8:  RLCF   xD6,W
29FA:  MOVWF  xDF
29FC:  RLCF   xD7,W
29FE:  MOVWF  xE0
2A00:  RLCF   xDD,F
2A02:  RLCF   xDE,F
2A04:  RLCF   xDF,F
2A06:  RLCF   xE0,F
2A08:  RLCF   xDD,F
2A0A:  RLCF   xDE,F
2A0C:  RLCF   xDF,F
2A0E:  RLCF   xE0,F
2A10:  RLCF   xDD,F
2A12:  RLCF   xDE,F
2A14:  RLCF   xDF,F
2A16:  RLCF   xE0,F
2A18:  MOVLW  F0
2A1A:  ANDWF  xDD,F
2A1C:  MOVLW  30
2A1E:  SUBWF  xDB,W
2A20:  ADDWF  xDD,W
2A22:  MOVWF  00
2A24:  MOVLW  00
2A26:  ADDWFC xDE,W
2A28:  MOVWF  01
2A2A:  MOVLW  00
2A2C:  ADDWFC xDF,W
2A2E:  MOVWF  02
2A30:  MOVLW  00
2A32:  ADDWFC xE0,W
2A34:  MOVWF  xD7
2A36:  MOVFF  02,D6
2A3A:  MOVFF  01,D5
2A3E:  MOVFF  00,D4
....................             else 
2A42:  BRA    2A98
....................                result = (result << 4) + (c - 'A' + 10); 
2A44:  RLCF   xD4,W
2A46:  MOVWF  xDD
2A48:  RLCF   xD5,W
2A4A:  MOVWF  xDE
2A4C:  RLCF   xD6,W
2A4E:  MOVWF  xDF
2A50:  RLCF   xD7,W
2A52:  MOVWF  xE0
2A54:  RLCF   xDD,F
2A56:  RLCF   xDE,F
2A58:  RLCF   xDF,F
2A5A:  RLCF   xE0,F
2A5C:  RLCF   xDD,F
2A5E:  RLCF   xDE,F
2A60:  RLCF   xDF,F
2A62:  RLCF   xE0,F
2A64:  RLCF   xDD,F
2A66:  RLCF   xDE,F
2A68:  RLCF   xDF,F
2A6A:  RLCF   xE0,F
2A6C:  MOVLW  F0
2A6E:  ANDWF  xDD,F
2A70:  MOVLW  41
2A72:  SUBWF  xDB,W
2A74:  ADDLW  0A
2A76:  ADDWF  xDD,W
2A78:  MOVWF  00
2A7A:  MOVLW  00
2A7C:  ADDWFC xDE,W
2A7E:  MOVWF  01
2A80:  MOVLW  00
2A82:  ADDWFC xDF,W
2A84:  MOVWF  02
2A86:  MOVLW  00
2A88:  ADDWFC xE0,W
2A8A:  MOVWF  xD7
2A8C:  MOVFF  02,D6
2A90:  MOVFF  01,D5
2A94:  MOVFF  00,D4
....................  
....................             c = s[index++];c = toupper(c); 
2A98:  MOVF   xDA,W
2A9A:  INCF   xDA,F
2A9C:  CLRF   03
2A9E:  ADDWF  xD2,W
2AA0:  MOVWF  FE9
2AA2:  MOVF   xD3,W
2AA4:  ADDWFC 03,W
2AA6:  MOVWF  FEA
2AA8:  MOVF   FEF,W
2AAA:  MOVWF  xDB
2AAC:  SUBLW  60
2AAE:  BC    2ABC
2AB0:  MOVF   xDB,W
2AB2:  SUBLW  7A
2AB4:  BNC   2ABC
2AB6:  MOVF   xDB,W
2AB8:  ANDLW  DF
2ABA:  BRA    2ABE
2ABC:  MOVF   xDB,W
2ABE:  MOVWF  xDB
....................          } 
2AC0:  BRA    29CA
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2AC2:  MOVF   xD9,W
2AC4:  SUBLW  0A
2AC6:  BNZ   2AE2
2AC8:  DECFSZ xD8,W
2ACA:  BRA    2AE2
....................       result = -result; 
2ACC:  COMF   xD4,F
2ACE:  COMF   xD5,F
2AD0:  COMF   xD6,F
2AD2:  COMF   xD7,F
2AD4:  INCF   xD4,F
2AD6:  BTFSC  FD8.2
2AD8:  INCF   xD5,F
2ADA:  BTFSC  FD8.2
2ADC:  INCF   xD6,F
2ADE:  BTFSC  FD8.2
2AE0:  INCF   xD7,F
....................  
....................    return(result); 
2AE2:  MOVFF  D4,00
2AE6:  MOVFF  D5,01
2AEA:  MOVFF  D6,02
2AEE:  MOVFF  D7,03
.................... } 
2AF2:  GOTO   3114 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
14D6:  MOVLW  01
14D8:  MOVWF  xF2
14DA:  CLRF   xF3
14DC:  CLRF   xF4
14DE:  CLRF   xF5
....................      unsigned int8 i,sign=0,cnt=0; 
14E0:  CLRF   xF7
14E2:  CLRF   xF8
....................      char c; 
....................  
....................      if(num<0) { 
14E4:  BTFSC  xEE.7
14E6:  BRA    14EA
14E8:  BRA    151E
....................          sign=1;        // Check for negative number 
14EA:  MOVLW  01
14EC:  MOVWF  xF7
....................          num*=-1; 
14EE:  MOVFF  EE,FD
14F2:  MOVFF  ED,FC
14F6:  MOVFF  EC,FB
14FA:  MOVFF  EB,FA
14FE:  MOVLW  FF
1500:  MOVLB  1
1502:  MOVWF  x01
1504:  MOVWF  x00
1506:  MOVLB  0
1508:  MOVWF  xFF
150A:  MOVWF  xFE
150C:  RCALL  1392
150E:  MOVFF  03,EE
1512:  MOVFF  02,ED
1516:  MOVFF  01,EC
151A:  MOVFF  00,EB
....................      } 
....................  
....................      while(temp>0) { 
151E:  MOVF   xF2,F
1520:  BNZ   1530
1522:  MOVF   xF3,F
1524:  BNZ   1530
1526:  MOVF   xF4,F
1528:  BNZ   1530
152A:  MOVF   xF5,F
152C:  BTFSC  FD8.2
152E:  BRA    1622
....................          temp=(num/base); 
1530:  MOVFF  EE,101
1534:  MOVFF  ED,100
1538:  MOVFF  EC,FF
153C:  MOVFF  EB,FE
1540:  MOVLB  1
1542:  CLRF   x05
1544:  CLRF   x04
1546:  CLRF   x03
1548:  MOVFF  EF,102
154C:  MOVLB  0
154E:  RCALL  13EA
1550:  MOVFF  03,F5
1554:  MOVFF  02,F4
1558:  MOVFF  01,F3
155C:  MOVFF  00,F2
....................          s[cnt]=(num%base)+'0';    // Conversion 
1560:  CLRF   03
1562:  MOVF   xF8,W
1564:  ADDWF  xF0,W
1566:  MOVWF  01
1568:  MOVF   xF1,W
156A:  ADDWFC 03,F
156C:  MOVFF  01,FA
1570:  MOVFF  03,FB
1574:  MOVFF  FEA,FD
1578:  MOVFF  FE9,FC
157C:  MOVFF  EE,101
1580:  MOVFF  ED,100
1584:  MOVFF  EC,FF
1588:  MOVFF  EB,FE
158C:  MOVLB  1
158E:  CLRF   x05
1590:  CLRF   x04
1592:  CLRF   x03
1594:  MOVFF  EF,102
1598:  MOVLB  0
159A:  RCALL  13EA
159C:  MOVFF  FEF,00
15A0:  MOVFF  FEC,01
15A4:  MOVFF  FEC,02
15A8:  MOVFF  FEC,03
15AC:  MOVFF  FD,FEA
15B0:  MOVFF  FC,FE9
15B4:  MOVFF  03,101
15B8:  MOVFF  02,100
15BC:  MOVFF  01,FF
15C0:  MOVFF  00,FE
15C4:  MOVLW  30
15C6:  ADDWF  00,W
15C8:  MOVWF  00
15CA:  MOVLW  00
15CC:  ADDWFC 01,W
15CE:  MOVLW  00
15D0:  MOVLB  1
15D2:  ADDWFC 02,W
15D4:  MOVLW  00
15D6:  ADDWFC 03,W
15D8:  MOVFF  FB,FEA
15DC:  MOVFF  FA,FE9
15E0:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
15E4:  CLRF   03
15E6:  MOVLB  0
15E8:  MOVF   xF8,W
15EA:  ADDWF  xF0,W
15EC:  MOVWF  FE9
15EE:  MOVF   xF1,W
15F0:  ADDWFC 03,W
15F2:  MOVWF  FEA
15F4:  MOVF   FEF,W
15F6:  SUBLW  39
15F8:  BC    160E
....................             s[cnt]+=0x7; 
15FA:  CLRF   03
15FC:  MOVF   xF8,W
15FE:  ADDWF  xF0,W
1600:  MOVWF  FE9
1602:  MOVF   xF1,W
1604:  ADDWFC 03,W
1606:  MOVWF  FEA
1608:  MOVLW  07
160A:  ADDWF  FEF,W
160C:  MOVWF  FEF
....................  
....................          cnt++; 
160E:  INCF   xF8,F
....................          num=temp; 
1610:  MOVFF  F5,EE
1614:  MOVFF  F4,ED
1618:  MOVFF  F3,EC
161C:  MOVFF  F2,EB
....................      } 
1620:  BRA    151E
....................  
....................      if(sign==1) { 
1622:  DECFSZ xF7,W
1624:  BRA    163A
....................          s[cnt]=0x2D;      // Negative sign 
1626:  CLRF   03
1628:  MOVF   xF8,W
162A:  ADDWF  xF0,W
162C:  MOVWF  FE9
162E:  MOVF   xF1,W
1630:  ADDWFC 03,W
1632:  MOVWF  FEA
1634:  MOVLW  2D
1636:  MOVWF  FEF
....................          cnt++; 
1638:  INCF   xF8,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
163A:  CLRF   xF6
163C:  BCF    FD8.0
163E:  RRCF   xF8,W
1640:  SUBWF  xF6,W
1642:  BC    16A2
....................  
....................          c=s[i]; 
1644:  CLRF   03
1646:  MOVF   xF6,W
1648:  ADDWF  xF0,W
164A:  MOVWF  FE9
164C:  MOVF   xF1,W
164E:  ADDWFC 03,W
1650:  MOVWF  FEA
1652:  MOVFF  FEF,F9
....................          s[i]=s[cnt-i-1];        // Reverse the number 
1656:  CLRF   03
1658:  MOVF   xF6,W
165A:  ADDWF  xF0,W
165C:  MOVWF  01
165E:  MOVF   xF1,W
1660:  ADDWFC 03,F
1662:  MOVFF  03,FB
1666:  MOVF   xF6,W
1668:  SUBWF  xF8,W
166A:  ADDLW  FF
166C:  CLRF   03
166E:  ADDWF  xF0,W
1670:  MOVWF  FE9
1672:  MOVF   xF1,W
1674:  ADDWFC 03,W
1676:  MOVWF  FEA
1678:  MOVFF  FEF,FE
167C:  MOVFF  FB,FEA
1680:  MOVFF  01,FE9
1684:  MOVFF  FE,FEF
....................          s[cnt-i-1]=c; 
1688:  MOVF   xF6,W
168A:  SUBWF  xF8,W
168C:  ADDLW  FF
168E:  CLRF   03
1690:  ADDWF  xF0,W
1692:  MOVWF  FE9
1694:  MOVF   xF1,W
1696:  ADDWFC 03,W
1698:  MOVWF  FEA
169A:  MOVFF  F9,FEF
....................      } 
169E:  INCF   xF6,F
16A0:  BRA    163C
....................      s[cnt]='\0';     // End the string 
16A2:  CLRF   03
16A4:  MOVF   xF8,W
16A6:  ADDWF  xF0,W
16A8:  MOVWF  FE9
16AA:  MOVF   xF1,W
16AC:  ADDWFC 03,W
16AE:  MOVWF  FEA
16B0:  CLRF   FEF
....................      return s; 
16B2:  MOVFF  F0,01
16B6:  MOVFF  F1,02
.................... } 
16BA:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
5250:  MOVLB  1
5252:  BCF    x0C.0
....................    y = x; 
5254:  MOVFF  100,105
5258:  MOVFF  FF,104
525C:  MOVFF  FE,103
5260:  MOVFF  FD,102
....................  
....................    if (x < 0) 
5264:  MOVFF  100,14E
5268:  MOVFF  FF,14D
526C:  MOVFF  FE,14C
5270:  MOVFF  FD,14B
5274:  CLRF   x52
5276:  CLRF   x51
5278:  CLRF   x50
527A:  CLRF   x4F
527C:  MOVLB  0
527E:  CALL   3BBA
5282:  BNC   528E
....................    { 
....................       s = 1; 
5284:  MOVLB  1
5286:  BSF    x0C.0
....................       y = -y; 
5288:  MOVF   x03,W
528A:  XORLW  80
528C:  MOVWF  x03
....................    } 
....................  
....................    if (y <= 32768.0) 
528E:  MOVFF  105,14E
5292:  MOVFF  104,14D
5296:  MOVFF  103,14C
529A:  MOVFF  102,14B
529E:  MOVLB  1
52A0:  CLRF   x52
52A2:  CLRF   x51
52A4:  CLRF   x50
52A6:  MOVLW  8E
52A8:  MOVWF  x4F
52AA:  MOVLB  0
52AC:  CALL   3BBA
52B0:  BC    52B4
52B2:  BNZ   52E6
....................   res = (float32)(unsigned int16)y; 
52B4:  MOVFF  105,14E
52B8:  MOVFF  104,14D
52BC:  MOVFF  103,14C
52C0:  MOVFF  102,14B
52C4:  CALL   4194
52C8:  MOVFF  02,150
52CC:  MOVFF  01,14F
52D0:  CALL   415E
52D4:  MOVFF  03,109
52D8:  MOVFF  02,108
52DC:  MOVFF  01,107
52E0:  MOVFF  00,106
....................  
....................  else if (y < 10000000.0) 
52E4:  BRA    548C
52E6:  MOVFF  105,14E
52EA:  MOVFF  104,14D
52EE:  MOVFF  103,14C
52F2:  MOVFF  102,14B
52F6:  MOVLW  80
52F8:  MOVLB  1
52FA:  MOVWF  x52
52FC:  MOVLW  96
52FE:  MOVWF  x51
5300:  MOVLW  18
5302:  MOVWF  x50
5304:  MOVLW  96
5306:  MOVWF  x4F
5308:  MOVLB  0
530A:  CALL   3BBA
530E:  BTFSS  FD8.0
5310:  BRA    547C
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
5312:  MOVFF  105,14E
5316:  MOVFF  104,14D
531A:  MOVFF  103,14C
531E:  MOVFF  102,14B
5322:  MOVLB  1
5324:  CLRF   x52
5326:  CLRF   x51
5328:  CLRF   x50
532A:  MOVLW  8E
532C:  MOVWF  x4F
532E:  MOVLB  0
5330:  CALL   0F7C
5334:  MOVFF  03,14E
5338:  MOVFF  02,14D
533C:  MOVFF  01,14C
5340:  MOVFF  00,14B
5344:  CALL   4194
5348:  MOVFF  02,10B
534C:  MOVFF  01,10A
....................       y = 32768.0*(y/32768.0 - (float32)l); 
5350:  MOVFF  105,14E
5354:  MOVFF  104,14D
5358:  MOVFF  103,14C
535C:  MOVFF  102,14B
5360:  MOVLB  1
5362:  CLRF   x52
5364:  CLRF   x51
5366:  CLRF   x50
5368:  MOVLW  8E
536A:  MOVWF  x4F
536C:  MOVLB  0
536E:  CALL   0F7C
5372:  MOVFF  00,10D
5376:  MOVFF  01,10E
537A:  MOVFF  02,10F
537E:  MOVFF  03,110
5382:  MOVFF  10B,150
5386:  MOVFF  10A,14F
538A:  CALL   415E
538E:  BSF    FD8.1
5390:  MOVFF  110,154
5394:  MOVFF  10F,153
5398:  MOVFF  10E,152
539C:  MOVFF  10D,151
53A0:  MOVFF  03,158
53A4:  MOVFF  02,157
53A8:  MOVFF  01,156
53AC:  MOVFF  00,155
53B0:  CALL   10DA
53B4:  MOVLB  1
53B6:  CLRF   x52
53B8:  CLRF   x51
53BA:  CLRF   x50
53BC:  MOVLW  8E
53BE:  MOVWF  x4F
53C0:  MOVFF  03,156
53C4:  MOVFF  02,155
53C8:  MOVFF  01,154
53CC:  MOVFF  00,153
53D0:  MOVLB  0
53D2:  CALL   0E86
53D6:  MOVFF  03,105
53DA:  MOVFF  02,104
53DE:  MOVFF  01,103
53E2:  MOVFF  00,102
....................   res = 32768.0*(float32)l; 
53E6:  MOVFF  10B,150
53EA:  MOVFF  10A,14F
53EE:  CALL   415E
53F2:  MOVLB  1
53F4:  CLRF   x52
53F6:  CLRF   x51
53F8:  CLRF   x50
53FA:  MOVLW  8E
53FC:  MOVWF  x4F
53FE:  MOVFF  03,156
5402:  MOVFF  02,155
5406:  MOVFF  01,154
540A:  MOVFF  00,153
540E:  MOVLB  0
5410:  CALL   0E86
5414:  MOVFF  03,109
5418:  MOVFF  02,108
541C:  MOVFF  01,107
5420:  MOVFF  00,106
....................   res += (float32)(unsigned int16)y; 
5424:  MOVFF  105,14E
5428:  MOVFF  104,14D
542C:  MOVFF  103,14C
5430:  MOVFF  102,14B
5434:  CALL   4194
5438:  MOVFF  02,150
543C:  MOVFF  01,14F
5440:  CALL   415E
5444:  BCF    FD8.1
5446:  MOVFF  109,154
544A:  MOVFF  108,153
544E:  MOVFF  107,152
5452:  MOVFF  106,151
5456:  MOVFF  03,158
545A:  MOVFF  02,157
545E:  MOVFF  01,156
5462:  MOVFF  00,155
5466:  CALL   10DA
546A:  MOVFF  03,109
546E:  MOVFF  02,108
5472:  MOVFF  01,107
5476:  MOVFF  00,106
....................  } 
....................  
....................  else 
547A:  BRA    548C
....................   res = y; 
547C:  MOVFF  105,109
5480:  MOVFF  104,108
5484:  MOVFF  103,107
5488:  MOVFF  102,106
....................  
....................  y = y - (float32)(unsigned int16)y; 
548C:  MOVFF  105,14E
5490:  MOVFF  104,14D
5494:  MOVFF  103,14C
5498:  MOVFF  102,14B
549C:  CALL   4194
54A0:  MOVFF  02,150
54A4:  MOVFF  01,14F
54A8:  CALL   415E
54AC:  BSF    FD8.1
54AE:  MOVFF  105,154
54B2:  MOVFF  104,153
54B6:  MOVFF  103,152
54BA:  MOVFF  102,151
54BE:  MOVFF  03,158
54C2:  MOVFF  02,157
54C6:  MOVFF  01,156
54CA:  MOVFF  00,155
54CE:  CALL   10DA
54D2:  MOVFF  03,105
54D6:  MOVFF  02,104
54DA:  MOVFF  01,103
54DE:  MOVFF  00,102
....................  
....................  if (s) 
54E2:  MOVLB  1
54E4:  BTFSS  x0C.0
54E6:  BRA    54EE
....................   res = -res; 
54E8:  MOVF   x07,W
54EA:  XORLW  80
54EC:  MOVWF  x07
....................  
....................  if (y != 0) 
54EE:  MOVFF  105,14E
54F2:  MOVFF  104,14D
54F6:  MOVFF  103,14C
54FA:  MOVFF  102,14B
54FE:  CLRF   x52
5500:  CLRF   x51
5502:  CLRF   x50
5504:  CLRF   x4F
5506:  MOVLB  0
5508:  CALL   3BBA
550C:  BZ    5586
....................  { 
....................   if (s == 1 && n == 0) 
550E:  MOVLB  1
5510:  BTFSS  x0C.0
5512:  BRA    554C
5514:  MOVF   x01,F
5516:  BNZ   554C
....................    res -= 1.0; 
5518:  BSF    FD8.1
551A:  MOVFF  109,154
551E:  MOVFF  108,153
5522:  MOVFF  107,152
5526:  MOVFF  106,151
552A:  CLRF   x58
552C:  CLRF   x57
552E:  CLRF   x56
5530:  MOVLW  7F
5532:  MOVWF  x55
5534:  MOVLB  0
5536:  CALL   10DA
553A:  MOVFF  03,109
553E:  MOVFF  02,108
5542:  MOVFF  01,107
5546:  MOVFF  00,106
554A:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
554C:  BTFSC  x0C.0
554E:  BRA    5588
5550:  DECFSZ x01,W
5552:  BRA    5588
....................    res += 1.0; 
5554:  BCF    FD8.1
5556:  MOVFF  109,154
555A:  MOVFF  108,153
555E:  MOVFF  107,152
5562:  MOVFF  106,151
5566:  CLRF   x58
5568:  CLRF   x57
556A:  CLRF   x56
556C:  MOVLW  7F
556E:  MOVWF  x55
5570:  MOVLB  0
5572:  CALL   10DA
5576:  MOVFF  03,109
557A:  MOVFF  02,108
557E:  MOVFF  01,107
5582:  MOVFF  00,106
5586:  MOVLB  1
....................  } 
....................  if (x == 0) 
5588:  MOVFF  100,14E
558C:  MOVFF  FF,14D
5590:  MOVFF  FE,14C
5594:  MOVFF  FD,14B
5598:  CLRF   x52
559A:  CLRF   x51
559C:  CLRF   x50
559E:  CLRF   x4F
55A0:  MOVLB  0
55A2:  CALL   3BBA
55A6:  BNZ   55B4
....................     res = 0; 
55A8:  MOVLB  1
55AA:  CLRF   x09
55AC:  CLRF   x08
55AE:  CLRF   x07
55B0:  CLRF   x06
55B2:  MOVLB  0
....................  
....................  return (res); 
55B4:  MOVFF  106,00
55B8:  MOVFF  107,01
55BC:  MOVFF  108,02
55C0:  MOVFF  109,03
.................... } 
55C4:  RETLW  00
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
55E4:  MOVFF  FC,100
55E8:  MOVFF  FB,FF
55EC:  MOVFF  FA,FE
55F0:  MOVFF  F9,FD
55F4:  MOVLB  1
55F6:  CLRF   x01
55F8:  MOVLB  0
55FA:  RCALL  5250
.................... } 
55FC:  GOTO   5708 (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
55C6:  MOVFF  FB,100
55CA:  MOVFF  FA,FF
55CE:  MOVFF  F9,FE
55D2:  MOVFF  F8,FD
55D6:  MOVLW  01
55D8:  MOVLB  1
55DA:  MOVWF  x01
55DC:  MOVLB  0
55DE:  RCALL  5250
.................... } 
55E0:  GOTO   56C0 (RETURN)
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
5600:  MOVFF  EB,14E
5604:  MOVFF  EA,14D
5608:  MOVFF  E9,14C
560C:  MOVFF  E8,14B
5610:  MOVLB  1
5612:  CLRF   x52
5614:  CLRF   x51
5616:  CLRF   x50
5618:  CLRF   x4F
561A:  MOVLB  0
561C:  CALL   3BBA
5620:  BTFSC  FD8.2
5622:  BRA    5766
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
5624:  MOVFF  E7,14E
5628:  MOVFF  E6,14D
562C:  MOVFF  E5,14C
5630:  MOVFF  E4,14B
5634:  MOVFF  EB,152
5638:  MOVFF  EA,151
563C:  MOVFF  E9,150
5640:  MOVFF  E8,14F
5644:  CALL   0F7C
5648:  MOVFF  00,F0
564C:  MOVFF  01,F1
5650:  MOVFF  02,F2
5654:  MOVFF  03,F3
5658:  MOVFF  03,14E
565C:  MOVFF  02,14D
5660:  MOVFF  01,14C
5664:  MOVFF  00,14B
5668:  MOVLB  1
566A:  CLRF   x52
566C:  CLRF   x51
566E:  CLRF   x50
5670:  CLRF   x4F
5672:  MOVLB  0
5674:  CALL   3BBA
5678:  BNC   56C2
567A:  MOVFF  E7,14E
567E:  MOVFF  E6,14D
5682:  MOVFF  E5,14C
5686:  MOVFF  E4,14B
568A:  MOVFF  EB,152
568E:  MOVFF  EA,151
5692:  MOVFF  E9,150
5696:  MOVFF  E8,14F
569A:  CALL   0F7C
569E:  MOVFF  00,F4
56A2:  MOVFF  01,F5
56A6:  MOVFF  02,F6
56AA:  MOVFF  03,F7
56AE:  MOVFF  03,FB
56B2:  MOVFF  02,FA
56B6:  MOVFF  01,F9
56BA:  MOVFF  00,F8
56BE:  BRA    55C6
56C0:  BRA    5708
56C2:  MOVFF  E7,14E
56C6:  MOVFF  E6,14D
56CA:  MOVFF  E5,14C
56CE:  MOVFF  E4,14B
56D2:  MOVFF  EB,152
56D6:  MOVFF  EA,151
56DA:  MOVFF  E9,150
56DE:  MOVFF  E8,14F
56E2:  CALL   0F7C
56E6:  MOVFF  00,F5
56EA:  MOVFF  01,F6
56EE:  MOVFF  02,F7
56F2:  MOVFF  03,F8
56F6:  MOVFF  03,FC
56FA:  MOVFF  02,FB
56FE:  MOVFF  01,FA
5702:  MOVFF  00,F9
5706:  BRA    55E4
5708:  MOVFF  03,EF
570C:  MOVFF  02,EE
5710:  MOVFF  01,ED
5714:  MOVFF  00,EC
....................       return(x-(i*y)); 
5718:  MOVFF  EF,152
571C:  MOVFF  EE,151
5720:  MOVFF  ED,150
5724:  MOVFF  EC,14F
5728:  MOVFF  EB,156
572C:  MOVFF  EA,155
5730:  MOVFF  E9,154
5734:  MOVFF  E8,153
5738:  CALL   0E86
573C:  BSF    FD8.1
573E:  MOVFF  E7,154
5742:  MOVFF  E6,153
5746:  MOVFF  E5,152
574A:  MOVFF  E4,151
574E:  MOVFF  03,158
5752:  MOVFF  02,157
5756:  MOVFF  01,156
575A:  MOVFF  00,155
575E:  CALL   10DA
5762:  BRA    5766
....................    } 
....................    else 
5764:  BRA    5766
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
5766:  GOTO   59FA (RETURN)
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
4644:  MOVFF  116,14E
4648:  MOVFF  115,14D
464C:  MOVFF  114,14C
4650:  MOVFF  113,14B
4654:  MOVLB  1
4656:  CLRF   x52
4658:  CLRF   x51
465A:  CLRF   x50
465C:  CLRF   x4F
465E:  MOVLB  0
4660:  CALL   3BBA
4664:  BC    4668
4666:  BNZ   4672
....................       return(0.0); 
4668:  CLRF   00
466A:  CLRF   01
466C:  CLRF   02
466E:  CLRF   03
4670:  BRA    476C
....................  
....................    y=x; 
4672:  MOVFF  116,11A
4676:  MOVFF  115,119
467A:  MOVFF  114,118
467E:  MOVFF  113,117
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
4682:  MOVLW  01
4684:  MOVLB  1
4686:  MOVWF  x20
4688:  MOVLW  17
468A:  MOVWF  x1F
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
468C:  MOVFF  11F,FE9
4690:  MOVFF  120,FEA
4694:  MOVF   FEF,W
4696:  CLRF   x24
4698:  MOVWF  x23
469A:  MOVLW  7F
469C:  ADDWF  x23,W
469E:  MOVWF  x25
46A0:  MOVLW  00
46A2:  ADDWFC x24,W
46A4:  MOVWF  x26
46A6:  BCF    FD8.0
46A8:  RRCF   x26,W
46AA:  RRCF   x25,W
46AC:  MOVFF  120,FEA
46B0:  MOVFF  11F,FE9
46B4:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
46B6:  MOVFF  11A,11E
46BA:  MOVFF  119,11D
46BE:  MOVFF  118,11C
46C2:  MOVFF  117,11B
....................       y+=(x/y); 
46C6:  MOVFF  116,14E
46CA:  MOVFF  115,14D
46CE:  MOVFF  114,14C
46D2:  MOVFF  113,14B
46D6:  MOVFF  11A,152
46DA:  MOVFF  119,151
46DE:  MOVFF  118,150
46E2:  MOVFF  117,14F
46E6:  MOVLB  0
46E8:  CALL   0F7C
46EC:  BCF    FD8.1
46EE:  MOVFF  11A,154
46F2:  MOVFF  119,153
46F6:  MOVFF  118,152
46FA:  MOVFF  117,151
46FE:  MOVFF  03,158
4702:  MOVFF  02,157
4706:  MOVFF  01,156
470A:  MOVFF  00,155
470E:  CALL   10DA
4712:  MOVFF  03,11A
4716:  MOVFF  02,119
471A:  MOVFF  01,118
471E:  MOVFF  00,117
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
4722:  MOVLB  1
4724:  MOVFF  11F,FE9
4728:  MOVFF  120,FEA
472C:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
472E:  MOVFF  11E,14E
4732:  MOVFF  11D,14D
4736:  MOVFF  11C,14C
473A:  MOVFF  11B,14B
473E:  MOVFF  11A,152
4742:  MOVFF  119,151
4746:  MOVFF  118,150
474A:  MOVFF  117,14F
474E:  MOVLB  0
4750:  CALL   3BBA
4754:  BTFSC  FD8.2
4756:  BRA    475C
4758:  MOVLB  1
475A:  BRA    46B6
....................  
....................    return(res); 
475C:  MOVFF  11B,00
4760:  MOVFF  11C,01
4764:  MOVFF  11D,02
4768:  MOVFF  11E,03
.................... } 
476C:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
41D0:  MOVLW  7F
41D2:  MOVLB  1
41D4:  MOVWF  x31
41D6:  CLRF   x32
41D8:  CLRF   x33
41DA:  CLRF   x34
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
41DC:  MOVLW  7E
41DE:  MOVWF  x3B
41E0:  MOVLW  80
41E2:  MOVWF  x3C
41E4:  CLRF   x3D
41E6:  CLRF   x3E
41E8:  MOVLW  7A
41EA:  MOVWF  x3F
41EC:  MOVLW  2A
41EE:  MOVWF  x40
41F0:  MOVLW  AA
41F2:  MOVWF  x41
41F4:  MOVLW  A3
41F6:  MOVWF  x42
41F8:  MOVLW  75
41FA:  MOVWF  x43
41FC:  MOVLW  B6
41FE:  MOVWF  x44
4200:  MOVLW  09
4202:  MOVWF  x45
4204:  MOVLW  9C
4206:  MOVWF  x46
4208:  MOVLW  6F
420A:  MOVWF  x47
420C:  MOVLW  4F
420E:  MOVWF  x48
4210:  MOVLW  B4
4212:  MOVWF  x49
4214:  MOVLW  0B
4216:  MOVWF  x4A
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
4218:  MOVFF  128,14E
421C:  MOVFF  127,14D
4220:  MOVFF  126,14C
4224:  MOVFF  125,14B
4228:  CLRF   x52
422A:  CLRF   x51
422C:  CLRF   x50
422E:  CLRF   x4F
4230:  MOVLB  0
4232:  RCALL  3BBA
4234:  BNC   423E
4236:  MOVLB  1
4238:  MOVF   x26,W
423A:  XORLW  80
423C:  MOVWF  x26
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
423E:  MOVFF  128,14E
4242:  MOVFF  127,14D
4246:  MOVFF  126,14C
424A:  MOVFF  125,14B
424E:  MOVLW  DB
4250:  MOVLB  1
4252:  MOVWF  x52
4254:  MOVLW  0F
4256:  MOVWF  x51
4258:  MOVLW  49
425A:  MOVWF  x50
425C:  MOVLW  7F
425E:  MOVWF  x4F
4260:  MOVLB  0
4262:  CALL   0F7C
4266:  MOVFF  03,14E
426A:  MOVFF  02,14D
426E:  MOVFF  01,14C
4272:  MOVFF  00,14B
4276:  RCALL  4194
4278:  MOVFF  01,135
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
427C:  MOVFF  128,14E
4280:  MOVFF  127,14D
4284:  MOVFF  126,14C
4288:  MOVFF  125,14B
428C:  MOVLW  DB
428E:  MOVLB  1
4290:  MOVWF  x52
4292:  MOVLW  0F
4294:  MOVWF  x51
4296:  MOVLW  49
4298:  MOVWF  x50
429A:  MOVLW  7F
429C:  MOVWF  x4F
429E:  MOVLB  0
42A0:  CALL   0F7C
42A4:  MOVFF  00,14B
42A8:  MOVFF  01,14C
42AC:  MOVFF  02,14D
42B0:  MOVFF  03,14E
42B4:  MOVLB  1
42B6:  CLRF   x50
42B8:  MOVFF  135,14F
42BC:  MOVLB  0
42BE:  RCALL  415E
42C0:  BSF    FD8.1
42C2:  MOVFF  14E,154
42C6:  MOVFF  14D,153
42CA:  MOVFF  14C,152
42CE:  MOVFF  14B,151
42D2:  MOVFF  03,158
42D6:  MOVFF  02,157
42DA:  MOVFF  01,156
42DE:  MOVFF  00,155
42E2:  CALL   10DA
42E6:  MOVFF  03,13A
42EA:  MOVFF  02,139
42EE:  MOVFF  01,138
42F2:  MOVFF  00,137
....................    quad = quad % 4;                    // quadrant (0 to 3) 
42F6:  MOVLW  03
42F8:  MOVLB  1
42FA:  ANDWF  x35,F
....................  
....................    if (quad == 0 || quad == 2) 
42FC:  MOVF   x35,F
42FE:  BZ    4306
4300:  MOVF   x35,W
4302:  SUBLW  02
4304:  BNZ   4340
....................       t = frac * PI_DIV_BY_TWO; 
4306:  MOVFF  13A,152
430A:  MOVFF  139,151
430E:  MOVFF  138,150
4312:  MOVFF  137,14F
4316:  MOVLW  DB
4318:  MOVWF  x56
431A:  MOVLW  0F
431C:  MOVWF  x55
431E:  MOVLW  49
4320:  MOVWF  x54
4322:  MOVLW  7F
4324:  MOVWF  x53
4326:  MOVLB  0
4328:  CALL   0E86
432C:  MOVFF  03,130
4330:  MOVFF  02,12F
4334:  MOVFF  01,12E
4338:  MOVFF  00,12D
....................    else if (quad == 1) 
433C:  BRA    441C
433E:  MOVLB  1
4340:  DECFSZ x35,W
4342:  BRA    43B2
....................       t = (1-frac) * PI_DIV_BY_TWO; 
4344:  BSF    FD8.1
4346:  CLRF   x54
4348:  CLRF   x53
434A:  CLRF   x52
434C:  MOVLW  7F
434E:  MOVWF  x51
4350:  MOVFF  13A,158
4354:  MOVFF  139,157
4358:  MOVFF  138,156
435C:  MOVFF  137,155
4360:  MOVLB  0
4362:  CALL   10DA
4366:  MOVFF  00,14B
436A:  MOVFF  01,14C
436E:  MOVFF  02,14D
4372:  MOVFF  03,14E
4376:  MOVFF  03,152
437A:  MOVFF  02,151
437E:  MOVFF  01,150
4382:  MOVFF  00,14F
4386:  MOVLW  DB
4388:  MOVLB  1
438A:  MOVWF  x56
438C:  MOVLW  0F
438E:  MOVWF  x55
4390:  MOVLW  49
4392:  MOVWF  x54
4394:  MOVLW  7F
4396:  MOVWF  x53
4398:  MOVLB  0
439A:  CALL   0E86
439E:  MOVFF  03,130
43A2:  MOVFF  02,12F
43A6:  MOVFF  01,12E
43AA:  MOVFF  00,12D
....................    else // should be 3 
43AE:  BRA    441C
43B0:  MOVLB  1
....................       t = (frac-1) * PI_DIV_BY_TWO; 
43B2:  BSF    FD8.1
43B4:  MOVFF  13A,154
43B8:  MOVFF  139,153
43BC:  MOVFF  138,152
43C0:  MOVFF  137,151
43C4:  CLRF   x58
43C6:  CLRF   x57
43C8:  CLRF   x56
43CA:  MOVLW  7F
43CC:  MOVWF  x55
43CE:  MOVLB  0
43D0:  CALL   10DA
43D4:  MOVFF  00,14B
43D8:  MOVFF  01,14C
43DC:  MOVFF  02,14D
43E0:  MOVFF  03,14E
43E4:  MOVFF  03,152
43E8:  MOVFF  02,151
43EC:  MOVFF  01,150
43F0:  MOVFF  00,14F
43F4:  MOVLW  DB
43F6:  MOVLB  1
43F8:  MOVWF  x56
43FA:  MOVLW  0F
43FC:  MOVWF  x55
43FE:  MOVLW  49
4400:  MOVWF  x54
4402:  MOVLW  7F
4404:  MOVWF  x53
4406:  MOVLB  0
4408:  CALL   0E86
440C:  MOVFF  03,130
4410:  MOVFF  02,12F
4414:  MOVFF  01,12E
4418:  MOVFF  00,12D
....................  
....................    y = 0.999999999781; 
441C:  MOVLB  1
441E:  CLRF   x2C
4420:  CLRF   x2B
4422:  CLRF   x2A
4424:  MOVLW  7F
4426:  MOVWF  x29
....................    t = t * t; 
4428:  MOVFF  130,152
442C:  MOVFF  12F,151
4430:  MOVFF  12E,150
4434:  MOVFF  12D,14F
4438:  MOVFF  130,156
443C:  MOVFF  12F,155
4440:  MOVFF  12E,154
4444:  MOVFF  12D,153
4448:  MOVLB  0
444A:  CALL   0E86
444E:  MOVFF  03,130
4452:  MOVFF  02,12F
4456:  MOVFF  01,12E
445A:  MOVFF  00,12D
....................    for (i = 0; i <= 3; i++) 
445E:  MOVLB  1
4460:  CLRF   x36
4462:  MOVF   x36,W
4464:  SUBLW  03
4466:  BNC   4534
....................    { 
....................       t2 = t2 * t; 
4468:  MOVFF  134,152
446C:  MOVFF  133,151
4470:  MOVFF  132,150
4474:  MOVFF  131,14F
4478:  MOVFF  130,156
447C:  MOVFF  12F,155
4480:  MOVFF  12E,154
4484:  MOVFF  12D,153
4488:  MOVLB  0
448A:  CALL   0E86
448E:  MOVFF  03,134
4492:  MOVFF  02,133
4496:  MOVFF  01,132
449A:  MOVFF  00,131
....................       y = y + p[i] * t2; 
449E:  MOVLB  1
44A0:  MOVF   x36,W
44A2:  MULLW  04
44A4:  MOVF   FF3,W
44A6:  CLRF   03
44A8:  ADDLW  3B
44AA:  MOVWF  FE9
44AC:  MOVLW  01
44AE:  ADDWFC 03,W
44B0:  MOVWF  FEA
44B2:  MOVFF  FEF,14B
44B6:  MOVFF  FEC,14C
44BA:  MOVFF  FEC,14D
44BE:  MOVFF  FEC,14E
44C2:  MOVFF  14E,152
44C6:  MOVFF  14D,151
44CA:  MOVFF  14C,150
44CE:  MOVFF  14B,14F
44D2:  MOVFF  134,156
44D6:  MOVFF  133,155
44DA:  MOVFF  132,154
44DE:  MOVFF  131,153
44E2:  MOVLB  0
44E4:  CALL   0E86
44E8:  MOVFF  FEA,150
44EC:  MOVFF  FE9,14F
44F0:  BCF    FD8.1
44F2:  MOVFF  12C,154
44F6:  MOVFF  12B,153
44FA:  MOVFF  12A,152
44FE:  MOVFF  129,151
4502:  MOVFF  03,158
4506:  MOVFF  02,157
450A:  MOVFF  01,156
450E:  MOVFF  00,155
4512:  CALL   10DA
4516:  MOVFF  150,FEA
451A:  MOVFF  14F,FE9
451E:  MOVFF  03,12C
4522:  MOVFF  02,12B
4526:  MOVFF  01,12A
452A:  MOVFF  00,129
....................    } 
452E:  MOVLB  1
4530:  INCF   x36,F
4532:  BRA    4462
....................  
....................    if (quad == 2 || quad == 1) 
4534:  MOVF   x35,W
4536:  SUBLW  02
4538:  BZ    453E
453A:  DECFSZ x35,W
453C:  BRA    4544
....................       y = -y;  // correct sign 
453E:  MOVF   x2A,W
4540:  XORLW  80
4542:  MOVWF  x2A
....................  
....................    return (y); 
4544:  MOVFF  129,00
4548:  MOVFF  12A,01
454C:  MOVFF  12B,02
4550:  MOVFF  12C,03
.................... } 
4554:  MOVLB  0
4556:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
4558:  BSF    FD8.1
455A:  MOVFF  120,154
455E:  MOVFF  11F,153
4562:  MOVFF  11E,152
4566:  MOVFF  11D,151
456A:  MOVLW  DB
456C:  MOVLB  1
456E:  MOVWF  x58
4570:  MOVLW  0F
4572:  MOVWF  x57
4574:  MOVLW  49
4576:  MOVWF  x56
4578:  MOVLW  7F
457A:  MOVWF  x55
457C:  MOVLB  0
457E:  CALL   10DA
4582:  MOVFF  00,121
4586:  MOVFF  01,122
458A:  MOVFF  02,123
458E:  MOVFF  03,124
4592:  MOVFF  03,128
4596:  MOVFF  02,127
459A:  MOVFF  01,126
459E:  MOVFF  00,125
45A2:  RCALL  41D0
.................... } 
45A4:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
45A6:  MOVFF  114,128
45AA:  MOVFF  113,127
45AE:  MOVFF  112,126
45B2:  MOVFF  111,125
45B6:  RCALL  41D0
45B8:  MOVFF  03,118
45BC:  MOVFF  02,117
45C0:  MOVFF  01,116
45C4:  MOVFF  00,115
....................    if (c == 0.0) 
45C8:  MOVFF  118,14E
45CC:  MOVFF  117,14D
45D0:  MOVFF  116,14C
45D4:  MOVFF  115,14B
45D8:  MOVLB  1
45DA:  CLRF   x52
45DC:  CLRF   x51
45DE:  CLRF   x50
45E0:  CLRF   x4F
45E2:  MOVLB  0
45E4:  CALL   3BBA
45E8:  BNZ   45FC
....................       return (1.0e+36); 
45EA:  MOVLW  F6
45EC:  MOVWF  00
45EE:  MOVLW  40
45F0:  MOVWF  01
45F2:  MOVLW  97
45F4:  MOVWF  02
45F6:  MOVLW  CE
45F8:  MOVWF  03
45FA:  BRA    4642
....................  
....................    s = sin(x); 
45FC:  MOVFF  114,120
4600:  MOVFF  113,11F
4604:  MOVFF  112,11E
4608:  MOVFF  111,11D
460C:  RCALL  4558
460E:  MOVFF  03,11C
4612:  MOVFF  02,11B
4616:  MOVFF  01,11A
461A:  MOVFF  00,119
....................    return(s/c); 
461E:  MOVFF  11C,14E
4622:  MOVFF  11B,14D
4626:  MOVFF  11A,14C
462A:  MOVFF  119,14B
462E:  MOVFF  118,152
4632:  MOVFF  117,151
4636:  MOVFF  116,150
463A:  MOVFF  115,14F
463E:  CALL   0F7C
.................... } 
4642:  RETLW  00
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
4E0E:  MOVLB  1
4E10:  BCF    x0A.0
....................    y = x; 
4E12:  MOVFF  F8,FD
4E16:  MOVFF  F7,FC
4E1A:  MOVFF  F6,FB
4E1E:  MOVFF  F5,FA
....................  
....................    if (x < 0) 
4E22:  MOVFF  F8,14E
4E26:  MOVFF  F7,14D
4E2A:  MOVFF  F6,14C
4E2E:  MOVFF  F5,14B
4E32:  CLRF   x52
4E34:  CLRF   x51
4E36:  CLRF   x50
4E38:  CLRF   x4F
4E3A:  MOVLB  0
4E3C:  CALL   3BBA
4E40:  BNC   4E4E
....................    { 
....................       s = 1; 
4E42:  MOVLB  1
4E44:  BSF    x0A.0
....................       y = -y; 
4E46:  MOVLB  0
4E48:  MOVF   xFB,W
4E4A:  XORLW  80
4E4C:  MOVWF  xFB
....................    } 
....................  
....................    if (y > 0.5) 
4E4E:  MOVLB  1
4E50:  CLRF   x4E
4E52:  CLRF   x4D
4E54:  CLRF   x4C
4E56:  MOVLW  7E
4E58:  MOVWF  x4B
4E5A:  MOVFF  FD,152
4E5E:  MOVFF  FC,151
4E62:  MOVFF  FB,150
4E66:  MOVFF  FA,14F
4E6A:  MOVLB  0
4E6C:  CALL   3BBA
4E70:  BNC   4F00
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
4E72:  BSF    FD8.1
4E74:  MOVLB  1
4E76:  CLRF   x54
4E78:  CLRF   x53
4E7A:  CLRF   x52
4E7C:  MOVLW  7F
4E7E:  MOVWF  x51
4E80:  MOVFF  FD,158
4E84:  MOVFF  FC,157
4E88:  MOVFF  FB,156
4E8C:  MOVFF  FA,155
4E90:  MOVLB  0
4E92:  CALL   10DA
4E96:  MOVFF  00,10B
4E9A:  MOVFF  01,10C
4E9E:  MOVFF  02,10D
4EA2:  MOVFF  03,10E
4EA6:  MOVFF  03,14E
4EAA:  MOVFF  02,14D
4EAE:  MOVFF  01,14C
4EB2:  MOVFF  00,14B
4EB6:  MOVLB  1
4EB8:  CLRF   x52
4EBA:  CLRF   x51
4EBC:  CLRF   x50
4EBE:  MOVLW  80
4EC0:  MOVWF  x4F
4EC2:  MOVLB  0
4EC4:  CALL   0F7C
4EC8:  MOVFF  00,10F
4ECC:  MOVFF  01,110
4ED0:  MOVFF  02,111
4ED4:  MOVFF  03,112
4ED8:  MOVFF  03,116
4EDC:  MOVFF  02,115
4EE0:  MOVFF  01,114
4EE4:  MOVFF  00,113
4EE8:  CALL   4644
4EEC:  MOVFF  03,FD
4EF0:  MOVFF  02,FC
4EF4:  MOVFF  01,FB
4EF8:  MOVFF  00,FA
....................       n += 2; 
4EFC:  MOVLW  02
4EFE:  ADDWF  xF9,F
....................    } 
....................  
....................    y2=y*y; 
4F00:  MOVFF  FD,152
4F04:  MOVFF  FC,151
4F08:  MOVFF  FB,150
4F0C:  MOVFF  FA,14F
4F10:  MOVFF  FD,156
4F14:  MOVFF  FC,155
4F18:  MOVFF  FB,154
4F1C:  MOVFF  FA,153
4F20:  CALL   0E86
4F24:  MOVFF  03,109
4F28:  MOVFF  02,108
4F2C:  MOVFF  01,107
4F30:  MOVFF  00,106
....................  
....................    res = pas[0]*y2 + pas[1]; 
4F34:  MOVLW  37
4F36:  MOVLB  1
4F38:  MOVWF  x52
4F3A:  MOVLW  BF
4F3C:  MOVWF  x51
4F3E:  MOVLW  7D
4F40:  MOVWF  x50
4F42:  MOVWF  x4F
4F44:  MOVFF  109,156
4F48:  MOVFF  108,155
4F4C:  MOVFF  107,154
4F50:  MOVFF  106,153
4F54:  MOVLB  0
4F56:  CALL   0E86
4F5A:  MOVFF  00,10B
4F5E:  MOVFF  01,10C
4F62:  MOVFF  02,10D
4F66:  MOVFF  03,10E
4F6A:  BCF    FD8.1
4F6C:  MOVFF  03,154
4F70:  MOVFF  02,153
4F74:  MOVFF  01,152
4F78:  MOVFF  00,151
4F7C:  MOVLW  3D
4F7E:  MOVLB  1
4F80:  MOVWF  x58
4F82:  MOVLW  AA
4F84:  MOVWF  x57
4F86:  MOVLW  93
4F88:  MOVWF  x56
4F8A:  MOVLW  81
4F8C:  MOVWF  x55
4F8E:  MOVLB  0
4F90:  CALL   10DA
4F94:  MOVFF  03,101
4F98:  MOVFF  02,100
4F9C:  MOVFF  01,FF
4FA0:  MOVFF  00,FE
....................    res = res*y2 + pas[2]; 
4FA4:  MOVFF  101,152
4FA8:  MOVFF  100,151
4FAC:  MOVFF  FF,150
4FB0:  MOVFF  FE,14F
4FB4:  MOVFF  109,156
4FB8:  MOVFF  108,155
4FBC:  MOVFF  107,154
4FC0:  MOVFF  106,153
4FC4:  CALL   0E86
4FC8:  MOVFF  00,10B
4FCC:  MOVFF  01,10C
4FD0:  MOVFF  02,10D
4FD4:  MOVFF  03,10E
4FD8:  BCF    FD8.1
4FDA:  MOVFF  03,154
4FDE:  MOVFF  02,153
4FE2:  MOVFF  01,152
4FE6:  MOVFF  00,151
4FEA:  MOVLW  EE
4FEC:  MOVLB  1
4FEE:  MOVWF  x58
4FF0:  MOVLW  50
4FF2:  MOVWF  x57
4FF4:  MOVLW  33
4FF6:  MOVWF  x56
4FF8:  MOVLW  81
4FFA:  MOVWF  x55
4FFC:  MOVLB  0
4FFE:  CALL   10DA
5002:  MOVFF  03,101
5006:  MOVFF  02,100
500A:  MOVFF  01,FF
500E:  MOVFF  00,FE
....................  
....................    r = qas[0]*y2 + qas[1]; 
5012:  MOVLB  1
5014:  CLRF   x52
5016:  CLRF   x51
5018:  CLRF   x50
501A:  MOVLW  7F
501C:  MOVWF  x4F
501E:  MOVFF  109,156
5022:  MOVFF  108,155
5026:  MOVFF  107,154
502A:  MOVFF  106,153
502E:  MOVLB  0
5030:  CALL   0E86
5034:  MOVFF  00,10B
5038:  MOVFF  01,10C
503C:  MOVFF  02,10D
5040:  MOVFF  03,10E
5044:  BCF    FD8.1
5046:  MOVFF  03,154
504A:  MOVFF  02,153
504E:  MOVFF  01,152
5052:  MOVFF  00,151
5056:  MOVLW  0A
5058:  MOVLB  1
505A:  MOVWF  x58
505C:  MOVLW  8D
505E:  MOVWF  x57
5060:  MOVLW  B1
5062:  MOVWF  x56
5064:  MOVLW  81
5066:  MOVWF  x55
5068:  MOVLB  0
506A:  CALL   10DA
506E:  MOVFF  03,105
5072:  MOVFF  02,104
5076:  MOVFF  01,103
507A:  MOVFF  00,102
....................    r = r*y2 + qas[2]; 
507E:  MOVFF  105,152
5082:  MOVFF  104,151
5086:  MOVFF  103,150
508A:  MOVFF  102,14F
508E:  MOVFF  109,156
5092:  MOVFF  108,155
5096:  MOVFF  107,154
509A:  MOVFF  106,153
509E:  CALL   0E86
50A2:  MOVFF  00,10B
50A6:  MOVFF  01,10C
50AA:  MOVFF  02,10D
50AE:  MOVFF  03,10E
50B2:  BCF    FD8.1
50B4:  MOVFF  03,154
50B8:  MOVFF  02,153
50BC:  MOVFF  01,152
50C0:  MOVFF  00,151
50C4:  MOVLW  EE
50C6:  MOVLB  1
50C8:  MOVWF  x58
50CA:  MOVLW  50
50CC:  MOVWF  x57
50CE:  MOVLW  33
50D0:  MOVWF  x56
50D2:  MOVLW  81
50D4:  MOVWF  x55
50D6:  MOVLB  0
50D8:  CALL   10DA
50DC:  MOVFF  03,105
50E0:  MOVFF  02,104
50E4:  MOVFF  01,103
50E8:  MOVFF  00,102
....................  
....................    res = y*res/r; 
50EC:  MOVFF  FD,152
50F0:  MOVFF  FC,151
50F4:  MOVFF  FB,150
50F8:  MOVFF  FA,14F
50FC:  MOVFF  101,156
5100:  MOVFF  100,155
5104:  MOVFF  FF,154
5108:  MOVFF  FE,153
510C:  CALL   0E86
5110:  MOVFF  00,10B
5114:  MOVFF  01,10C
5118:  MOVFF  02,10D
511C:  MOVFF  03,10E
5120:  MOVFF  03,14E
5124:  MOVFF  02,14D
5128:  MOVFF  01,14C
512C:  MOVFF  00,14B
5130:  MOVFF  105,152
5134:  MOVFF  104,151
5138:  MOVFF  103,150
513C:  MOVFF  102,14F
5140:  CALL   0F7C
5144:  MOVFF  03,101
5148:  MOVFF  02,100
514C:  MOVFF  01,FF
5150:  MOVFF  00,FE
....................  
....................    if (n & 2)     // |x| > 0.5 
5154:  BTFSS  xF9.1
5156:  BRA    51B4
....................       res = PI_DIV_BY_TWO - 2.0*res; 
5158:  MOVLB  1
515A:  CLRF   x52
515C:  CLRF   x51
515E:  CLRF   x50
5160:  MOVLW  80
5162:  MOVWF  x4F
5164:  MOVFF  101,156
5168:  MOVFF  100,155
516C:  MOVFF  FF,154
5170:  MOVFF  FE,153
5174:  MOVLB  0
5176:  CALL   0E86
517A:  BSF    FD8.1
517C:  MOVLW  DB
517E:  MOVLB  1
5180:  MOVWF  x54
5182:  MOVLW  0F
5184:  MOVWF  x53
5186:  MOVLW  49
5188:  MOVWF  x52
518A:  MOVLW  7F
518C:  MOVWF  x51
518E:  MOVFF  03,158
5192:  MOVFF  02,157
5196:  MOVFF  01,156
519A:  MOVFF  00,155
519E:  MOVLB  0
51A0:  CALL   10DA
51A4:  MOVFF  03,101
51A8:  MOVFF  02,100
51AC:  MOVFF  01,FF
51B0:  MOVFF  00,FE
....................    if (s) 
51B4:  MOVLB  1
51B6:  BTFSS  x0A.0
51B8:  BRA    51C2
....................       res = -res; 
51BA:  MOVLB  0
51BC:  MOVF   xFF,W
51BE:  XORLW  80
51C0:  MOVWF  xFF
....................    if (n & 1)           // take arccos 
51C2:  MOVLB  0
51C4:  BTFSS  xF9.0
51C6:  BRA    5202
....................       res = PI_DIV_BY_TWO - res; 
51C8:  BSF    FD8.1
51CA:  MOVLW  DB
51CC:  MOVLB  1
51CE:  MOVWF  x54
51D0:  MOVLW  0F
51D2:  MOVWF  x53
51D4:  MOVLW  49
51D6:  MOVWF  x52
51D8:  MOVLW  7F
51DA:  MOVWF  x51
51DC:  MOVFF  101,158
51E0:  MOVFF  100,157
51E4:  MOVFF  FF,156
51E8:  MOVFF  FE,155
51EC:  MOVLB  0
51EE:  CALL   10DA
51F2:  MOVFF  03,101
51F6:  MOVFF  02,100
51FA:  MOVFF  01,FF
51FE:  MOVFF  00,FE
....................  
....................    return(res); 
5202:  MOVFF  FE,00
5206:  MOVFF  FF,01
520A:  MOVFF  100,02
520E:  MOVFF  101,03
.................... } 
5212:  GOTO   522C (RETURN)
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
5216:  MOVFF  F0,F8
521A:  MOVFF  EF,F7
521E:  MOVFF  EE,F6
5222:  MOVFF  ED,F5
5226:  MOVLW  01
5228:  MOVWF  xF9
522A:  BRA    4E0E
522C:  MOVFF  03,F4
5230:  MOVFF  02,F3
5234:  MOVFF  01,F2
5238:  MOVFF  00,F1
....................    return(r); 
523C:  MOVFF  F1,00
5240:  MOVFF  F2,01
5244:  MOVFF  F3,02
5248:  MOVFF  F4,03
.................... } 
524C:  GOTO   593A (RETURN)
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
3C34:  MOVLB  1
3C36:  BCF    x19.0
....................    flag = 0; 
3C38:  BCF    x19.1
....................    y = x; 
3C3A:  MOVFF  10C,110
3C3E:  MOVFF  10B,10F
3C42:  MOVFF  10A,10E
3C46:  MOVFF  109,10D
....................  
....................    if (x < 0) 
3C4A:  MOVFF  10C,14E
3C4E:  MOVFF  10B,14D
3C52:  MOVFF  10A,14C
3C56:  MOVFF  109,14B
3C5A:  CLRF   x52
3C5C:  CLRF   x51
3C5E:  CLRF   x50
3C60:  CLRF   x4F
3C62:  MOVLB  0
3C64:  RCALL  3BBA
3C66:  BNC   3C72
....................    { 
....................       s = 1; 
3C68:  MOVLB  1
3C6A:  BSF    x19.0
....................       y = -y; 
3C6C:  MOVF   x0E,W
3C6E:  XORLW  80
3C70:  MOVWF  x0E
....................    } 
....................  
....................    if (y > 1.0) 
3C72:  MOVLB  1
3C74:  CLRF   x4E
3C76:  CLRF   x4D
3C78:  CLRF   x4C
3C7A:  MOVLW  7F
3C7C:  MOVWF  x4B
3C7E:  MOVFF  110,152
3C82:  MOVFF  10F,151
3C86:  MOVFF  10E,150
3C8A:  MOVFF  10D,14F
3C8E:  MOVLB  0
3C90:  RCALL  3BBA
3C92:  BNC   3CCA
....................    { 
....................       y = 1.0/y; 
3C94:  MOVLB  1
3C96:  CLRF   x4E
3C98:  CLRF   x4D
3C9A:  CLRF   x4C
3C9C:  MOVLW  7F
3C9E:  MOVWF  x4B
3CA0:  MOVFF  110,152
3CA4:  MOVFF  10F,151
3CA8:  MOVFF  10E,150
3CAC:  MOVFF  10D,14F
3CB0:  MOVLB  0
3CB2:  CALL   0F7C
3CB6:  MOVFF  03,110
3CBA:  MOVFF  02,10F
3CBE:  MOVFF  01,10E
3CC2:  MOVFF  00,10D
....................       flag = 1; 
3CC6:  MOVLB  1
3CC8:  BSF    x19.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
3CCA:  MOVLW  0A
3CCC:  MOVLB  1
3CCE:  MOVWF  x52
3CD0:  MOVLW  89
3CD2:  MOVWF  x51
3CD4:  MOVLW  34
3CD6:  MOVWF  x50
3CD8:  MOVLW  7C
3CDA:  MOVWF  x4F
3CDC:  MOVFF  110,156
3CE0:  MOVFF  10F,155
3CE4:  MOVFF  10E,154
3CE8:  MOVFF  10D,153
3CEC:  MOVLB  0
3CEE:  CALL   0E86
3CF2:  MOVFF  00,11A
3CF6:  MOVFF  01,11B
3CFA:  MOVFF  02,11C
3CFE:  MOVFF  03,11D
3D02:  MOVFF  03,152
3D06:  MOVFF  02,151
3D0A:  MOVFF  01,150
3D0E:  MOVFF  00,14F
3D12:  MOVFF  110,156
3D16:  MOVFF  10F,155
3D1A:  MOVFF  10E,154
3D1E:  MOVFF  10D,153
3D22:  CALL   0E86
3D26:  MOVFF  00,11E
3D2A:  MOVFF  01,11F
3D2E:  MOVFF  02,120
3D32:  MOVFF  03,121
3D36:  BCF    FD8.1
3D38:  MOVFF  03,154
3D3C:  MOVFF  02,153
3D40:  MOVFF  01,152
3D44:  MOVFF  00,151
3D48:  MOVLW  7C
3D4A:  MOVLB  1
3D4C:  MOVWF  x58
3D4E:  MOVLW  79
3D50:  MOVWF  x57
3D52:  MOVLW  35
3D54:  MOVWF  x56
3D56:  MOVLW  81
3D58:  MOVWF  x55
3D5A:  MOVLB  0
3D5C:  CALL   10DA
3D60:  MOVFF  03,114
3D64:  MOVFF  02,113
3D68:  MOVFF  01,112
3D6C:  MOVFF  00,111
....................    res = res*y*y + pat[2]; 
3D70:  MOVFF  114,152
3D74:  MOVFF  113,151
3D78:  MOVFF  112,150
3D7C:  MOVFF  111,14F
3D80:  MOVFF  110,156
3D84:  MOVFF  10F,155
3D88:  MOVFF  10E,154
3D8C:  MOVFF  10D,153
3D90:  CALL   0E86
3D94:  MOVFF  00,11A
3D98:  MOVFF  01,11B
3D9C:  MOVFF  02,11C
3DA0:  MOVFF  03,11D
3DA4:  MOVFF  03,152
3DA8:  MOVFF  02,151
3DAC:  MOVFF  01,150
3DB0:  MOVFF  00,14F
3DB4:  MOVFF  110,156
3DB8:  MOVFF  10F,155
3DBC:  MOVFF  10E,154
3DC0:  MOVFF  10D,153
3DC4:  CALL   0E86
3DC8:  MOVFF  00,11E
3DCC:  MOVFF  01,11F
3DD0:  MOVFF  02,120
3DD4:  MOVFF  03,121
3DD8:  BCF    FD8.1
3DDA:  MOVFF  03,154
3DDE:  MOVFF  02,153
3DE2:  MOVFF  01,152
3DE6:  MOVFF  00,151
3DEA:  MOVLW  3F
3DEC:  MOVLB  1
3DEE:  MOVWF  x58
3DF0:  MOVLW  02
3DF2:  MOVWF  x57
3DF4:  MOVLW  33
3DF6:  MOVWF  x56
3DF8:  MOVLW  83
3DFA:  MOVWF  x55
3DFC:  MOVLB  0
3DFE:  CALL   10DA
3E02:  MOVFF  03,114
3E06:  MOVFF  02,113
3E0A:  MOVFF  01,112
3E0E:  MOVFF  00,111
....................    res = res*y*y + pat[3]; 
3E12:  MOVFF  114,152
3E16:  MOVFF  113,151
3E1A:  MOVFF  112,150
3E1E:  MOVFF  111,14F
3E22:  MOVFF  110,156
3E26:  MOVFF  10F,155
3E2A:  MOVFF  10E,154
3E2E:  MOVFF  10D,153
3E32:  CALL   0E86
3E36:  MOVFF  00,11A
3E3A:  MOVFF  01,11B
3E3E:  MOVFF  02,11C
3E42:  MOVFF  03,11D
3E46:  MOVFF  03,152
3E4A:  MOVFF  02,151
3E4E:  MOVFF  01,150
3E52:  MOVFF  00,14F
3E56:  MOVFF  110,156
3E5A:  MOVFF  10F,155
3E5E:  MOVFF  10E,154
3E62:  MOVFF  10D,153
3E66:  CALL   0E86
3E6A:  MOVFF  00,11E
3E6E:  MOVFF  01,11F
3E72:  MOVFF  02,120
3E76:  MOVFF  03,121
3E7A:  BCF    FD8.1
3E7C:  MOVFF  03,154
3E80:  MOVFF  02,153
3E84:  MOVFF  01,152
3E88:  MOVFF  00,151
3E8C:  MOVLW  33
3E8E:  MOVLB  1
3E90:  MOVWF  x58
3E92:  MOVLW  8C
3E94:  MOVWF  x57
3E96:  MOVLW  1E
3E98:  MOVWF  x56
3E9A:  MOVLW  83
3E9C:  MOVWF  x55
3E9E:  MOVLB  0
3EA0:  CALL   10DA
3EA4:  MOVFF  03,114
3EA8:  MOVFF  02,113
3EAC:  MOVFF  01,112
3EB0:  MOVFF  00,111
....................  
....................    r = qat[0]*y*y + qat[1]; 
3EB4:  MOVLB  1
3EB6:  CLRF   x52
3EB8:  CLRF   x51
3EBA:  CLRF   x50
3EBC:  MOVLW  7F
3EBE:  MOVWF  x4F
3EC0:  MOVFF  110,156
3EC4:  MOVFF  10F,155
3EC8:  MOVFF  10E,154
3ECC:  MOVFF  10D,153
3ED0:  MOVLB  0
3ED2:  CALL   0E86
3ED6:  MOVFF  00,11A
3EDA:  MOVFF  01,11B
3EDE:  MOVFF  02,11C
3EE2:  MOVFF  03,11D
3EE6:  MOVFF  03,152
3EEA:  MOVFF  02,151
3EEE:  MOVFF  01,150
3EF2:  MOVFF  00,14F
3EF6:  MOVFF  110,156
3EFA:  MOVFF  10F,155
3EFE:  MOVFF  10E,154
3F02:  MOVFF  10D,153
3F06:  CALL   0E86
3F0A:  MOVFF  00,11E
3F0E:  MOVFF  01,11F
3F12:  MOVFF  02,120
3F16:  MOVFF  03,121
3F1A:  BCF    FD8.1
3F1C:  MOVFF  03,154
3F20:  MOVFF  02,153
3F24:  MOVFF  01,152
3F28:  MOVFF  00,151
3F2C:  MOVLW  1B
3F2E:  MOVLB  1
3F30:  MOVWF  x58
3F32:  MOVLW  E4
3F34:  MOVWF  x57
3F36:  MOVLW  35
3F38:  MOVWF  x56
3F3A:  MOVLW  82
3F3C:  MOVWF  x55
3F3E:  MOVLB  0
3F40:  CALL   10DA
3F44:  MOVFF  03,118
3F48:  MOVFF  02,117
3F4C:  MOVFF  01,116
3F50:  MOVFF  00,115
....................    r = r*y*y + qat[2]; 
3F54:  MOVFF  118,152
3F58:  MOVFF  117,151
3F5C:  MOVFF  116,150
3F60:  MOVFF  115,14F
3F64:  MOVFF  110,156
3F68:  MOVFF  10F,155
3F6C:  MOVFF  10E,154
3F70:  MOVFF  10D,153
3F74:  CALL   0E86
3F78:  MOVFF  00,11A
3F7C:  MOVFF  01,11B
3F80:  MOVFF  02,11C
3F84:  MOVFF  03,11D
3F88:  MOVFF  03,152
3F8C:  MOVFF  02,151
3F90:  MOVFF  01,150
3F94:  MOVFF  00,14F
3F98:  MOVFF  110,156
3F9C:  MOVFF  10F,155
3FA0:  MOVFF  10E,154
3FA4:  MOVFF  10D,153
3FA8:  CALL   0E86
3FAC:  MOVFF  00,11E
3FB0:  MOVFF  01,11F
3FB4:  MOVFF  02,120
3FB8:  MOVFF  03,121
3FBC:  BCF    FD8.1
3FBE:  MOVFF  03,154
3FC2:  MOVFF  02,153
3FC6:  MOVFF  01,152
3FCA:  MOVFF  00,151
3FCE:  MOVLW  A4
3FD0:  MOVLB  1
3FD2:  MOVWF  x58
3FD4:  MOVLW  DB
3FD6:  MOVWF  x57
3FD8:  MOVLW  67
3FDA:  MOVWF  x56
3FDC:  MOVLW  83
3FDE:  MOVWF  x55
3FE0:  MOVLB  0
3FE2:  CALL   10DA
3FE6:  MOVFF  03,118
3FEA:  MOVFF  02,117
3FEE:  MOVFF  01,116
3FF2:  MOVFF  00,115
....................    r = r*y*y + qat[3]; 
3FF6:  MOVFF  118,152
3FFA:  MOVFF  117,151
3FFE:  MOVFF  116,150
4002:  MOVFF  115,14F
4006:  MOVFF  110,156
400A:  MOVFF  10F,155
400E:  MOVFF  10E,154
4012:  MOVFF  10D,153
4016:  CALL   0E86
401A:  MOVFF  00,11A
401E:  MOVFF  01,11B
4022:  MOVFF  02,11C
4026:  MOVFF  03,11D
402A:  MOVFF  03,152
402E:  MOVFF  02,151
4032:  MOVFF  01,150
4036:  MOVFF  00,14F
403A:  MOVFF  110,156
403E:  MOVFF  10F,155
4042:  MOVFF  10E,154
4046:  MOVFF  10D,153
404A:  CALL   0E86
404E:  MOVFF  00,11E
4052:  MOVFF  01,11F
4056:  MOVFF  02,120
405A:  MOVFF  03,121
405E:  BCF    FD8.1
4060:  MOVFF  03,154
4064:  MOVFF  02,153
4068:  MOVFF  01,152
406C:  MOVFF  00,151
4070:  MOVLW  33
4072:  MOVLB  1
4074:  MOVWF  x58
4076:  MOVLW  8C
4078:  MOVWF  x57
407A:  MOVLW  1E
407C:  MOVWF  x56
407E:  MOVLW  83
4080:  MOVWF  x55
4082:  MOVLB  0
4084:  CALL   10DA
4088:  MOVFF  03,118
408C:  MOVFF  02,117
4090:  MOVFF  01,116
4094:  MOVFF  00,115
....................  
....................    res = y*res/r; 
4098:  MOVFF  110,152
409C:  MOVFF  10F,151
40A0:  MOVFF  10E,150
40A4:  MOVFF  10D,14F
40A8:  MOVFF  114,156
40AC:  MOVFF  113,155
40B0:  MOVFF  112,154
40B4:  MOVFF  111,153
40B8:  CALL   0E86
40BC:  MOVFF  00,11A
40C0:  MOVFF  01,11B
40C4:  MOVFF  02,11C
40C8:  MOVFF  03,11D
40CC:  MOVFF  03,14E
40D0:  MOVFF  02,14D
40D4:  MOVFF  01,14C
40D8:  MOVFF  00,14B
40DC:  MOVFF  118,152
40E0:  MOVFF  117,151
40E4:  MOVFF  116,150
40E8:  MOVFF  115,14F
40EC:  CALL   0F7C
40F0:  MOVFF  03,114
40F4:  MOVFF  02,113
40F8:  MOVFF  01,112
40FC:  MOVFF  00,111
....................  
....................  
....................    if (flag)                              // for |x| > 1 
4100:  MOVLB  1
4102:  BTFSS  x19.1
4104:  BRA    4140
....................       res = PI_DIV_BY_TWO - res; 
4106:  BSF    FD8.1
4108:  MOVLW  DB
410A:  MOVWF  x54
410C:  MOVLW  0F
410E:  MOVWF  x53
4110:  MOVLW  49
4112:  MOVWF  x52
4114:  MOVLW  7F
4116:  MOVWF  x51
4118:  MOVFF  114,158
411C:  MOVFF  113,157
4120:  MOVFF  112,156
4124:  MOVFF  111,155
4128:  MOVLB  0
412A:  CALL   10DA
412E:  MOVFF  03,114
4132:  MOVFF  02,113
4136:  MOVFF  01,112
413A:  MOVFF  00,111
413E:  MOVLB  1
....................    if (s) 
4140:  BTFSS  x19.0
4142:  BRA    414A
....................       res = -res; 
4144:  MOVF   x12,W
4146:  XORLW  80
4148:  MOVWF  x12
....................  
....................    return(res); 
414A:  MOVFF  111,00
414E:  MOVFF  112,01
4152:  MOVFF  113,02
4156:  MOVFF  114,03
.................... } 
415A:  MOVLB  0
415C:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses H4,NOWDT,WDT32,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20 
....................  
.................... #define LCD_EN PIN_C0 
.................... #define FLASH_SELECT PIN_A1 // output 
.................... #define FLASH_CLOCK  PIN_C3 // output 
.................... #define FLASH_DI     PIN_C5 // output 
.................... #define FLASH_DO     PIN_C4 // input 
....................  
.................... struct flag { 
.................... 	boolean task1_armed; 
.................... 	boolean update_time; 
.................... 	boolean prev_pulse_state; 
.................... 	boolean cmd_posted; 
.................... 	boolean setup_required; 
.................... 	boolean reset_rs232; 
.................... 	boolean measured_current; 
.................... 	boolean unused7; 
.................... } flag; 
....................  
.................... struct port_e_map{ 
.................... 	boolean rs; //0 
.................... 	boolean rw; //1 
.................... 	boolean tx_en; //2 
....................     int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
.................... #byte PORTD =0xF83 
.................... #byte PORTA =0xF80 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=40000000) 
*
05A2:  CLRF   FEA
05A4:  MOVLW  EF
05A6:  MOVWF  FE9
05A8:  MOVF   FEF,W
05AA:  BZ    05C8
05AC:  MOVLW  0C
05AE:  MOVWF  01
05B0:  CLRF   00
05B2:  DECFSZ 00,F
05B4:  BRA    05B2
05B6:  DECFSZ 01,F
05B8:  BRA    05B0
05BA:  MOVLW  F7
05BC:  MOVWF  00
05BE:  DECFSZ 00,F
05C0:  BRA    05BE
05C2:  BRA    05C4
05C4:  DECFSZ FEF,F
05C6:  BRA    05AC
05C8:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N) 
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... ////////////// actuator parameter ///////// 
.................... #define DIM_A 107.5 
.................... #define DIM_P 9.3 
.................... #define DIM_M 5.5 
.................... #define DIM_K 36.0 
.................... #define DIM_B 15.8 
.................... #define MIN_STROKE 70.3  
.................... #define MAX_STROKE 128.0 
.................... #define ROW_SPACING 320.00 
.................... #define PANEL_WIDTH 160.00 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1	PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3	PIN_B3 
.................... #define CCW PIN_B4 
.................... #define PS_EN PIN_C1 
.................... #define MEAS_RLY PIN_C2 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00002 
.................... #define ADDR_TIME           0xf00004 
.................... #define ADDR_START_COUNTER  0xf00008 
.................... #rom ADDR_FULL_STROKE={0x02D8} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000} 
.................... #rom ADDR_TIME={0x0000,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
....................  
.................... //#rom ADDR_TIME={0x1C20,0x0000} 
....................  
.................... int8 line[4] = {0,0x40,0x14,0x54}; 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... char tmp_str[20],tmp_str2[20]; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... unsigned int8 timer_ms=0; 
.................... unsigned int32 next_sun_rise; 
.................... unsigned int16 current_act_position=0; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int32 JDN,jj,g; 
.................... unsigned int32 dg,c,dc,b,db,a,da,y,m,d; 
.................... unsigned int32 YY,MM,DD,time_of_day; 
.................... unsigned int32 sec_until_sun_rise; 
.................... int16 FULL_STROKE_TICK=0; 
.................... float al; 
.................... int16 move_act_time_out=4; 
.................... int16 current_measured=0; 
.................... int8 n_avg_current_measured=0; 
.................... int16 startup_counter=0; 
.................... unsigned int8 index_in_page; 
....................  
.................... void init_ext_flash(void); 
.................... void ext_flash_startContinuousRead(int pageAddress); 
.................... void ext_flash_sendData(int data, int size); 
.................... void ext_flash_send16Data(int16 data, int size); 
.................... void ext_flash_sendBytes(char* data, int size); 
.................... void ext_flash_getBytes(char* data, int16 size); 
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size); 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size); 
.................... int ext_flash_getByte(void); 
.................... void ext_flash_waitUntilReady(void); 
....................  
.................... void init_rs232() { 
.................... 	bit_clear(PIR1,4);  //TXIF=0 
*
3502:  BCF    F9E.4
.................... 	bit_clear(PIR1,5);  //RCIF=0 
3504:  BCF    F9E.5
.................... 	bit_clear(PIE1,5);  //RCIE=0 
3506:  BCF    F9D.5
.................... 	bit_clear(RCSTA,7); //SPEN=0 
3508:  BCF    FAB.7
.................... 	bit_clear(RCSTA,4); //CREN=0 
350A:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
350C:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
350E:  BCF    FAC.5
.................... 	delay_cycles(10); 
3510:  MOVLW  03
3512:  MOVWF  00
3514:  DECFSZ 00,F
3516:  BRA    3514
.................... 	bit_set(RCSTA,4); //CREN=1 
3518:  BSF    FAB.4
.................... 	bit_set(RCSTA,7); //SPEN=1 
351A:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
351C:  BSF    FAC.5
.................... 	bit_set(PIE1,5); //RCIE=1 
351E:  BSF    F9D.5
....................  
.................... } 
3520:  GOTO   5E98 (RETURN)
....................  
....................  
.................... void read_eeprom_data() 
.................... { 
.................... 	int i; 
.................... 	int16 temp_mem;	 
.................... 	temp_mem= &timer_sec; 
*
05E4:  CLRF   xD4
05E6:  MOVLW  24
05E8:  MOVWF  xD3
.................... 	for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
05EA:  CLRF   xD2
05EC:  MOVF   xD2,W
05EE:  SUBLW  03
05F0:  BNC   0634
05F2:  MOVF   xD2,W
05F4:  ADDWF  xD3,W
05F6:  MOVWF  xD5
05F8:  MOVLW  00
05FA:  ADDWFC xD4,W
05FC:  MOVWF  xD6
05FE:  MOVLW  04
0600:  ADDWF  xD2,W
0602:  MOVWF  xD7
0604:  MOVFF  FF2,D8
0608:  BCF    FF2.7
060A:  MOVFF  D7,FA9
060E:  BCF    FA6.6
0610:  BCF    FA6.7
0612:  BSF    FA6.0
0614:  MOVF   FA8,W
0616:  BTFSC  xD8.7
0618:  BSF    FF2.7
061A:  MOVWF  xD8
061C:  MOVFF  D6,FEA
0620:  MOVFF  D5,FE9
0624:  MOVFF  D8,D9
0628:  CLRF   xDB
062A:  MOVLW  01
062C:  MOVWF  xDA
062E:  RCALL  05CA
0630:  INCF   xD2,F
0632:  BRA    05EC
.................... 	temp_mem= &FULL_STROKE_TICK; 
0634:  CLRF   xD4
0636:  MOVLW  BE
0638:  MOVWF  xD3
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i),1); 
063A:  CLRF   xD2
063C:  MOVF   xD2,W
063E:  SUBLW  01
0640:  BNC   067E
0642:  MOVF   xD2,W
0644:  ADDWF  xD3,W
0646:  MOVWF  xD5
0648:  MOVLW  00
064A:  ADDWFC xD4,W
064C:  MOVWF  xD6
064E:  MOVFF  FF2,D7
0652:  BCF    FF2.7
0654:  MOVFF  D2,FA9
0658:  BCF    FA6.6
065A:  BCF    FA6.7
065C:  BSF    FA6.0
065E:  MOVF   FA8,W
0660:  BTFSC  xD7.7
0662:  BSF    FF2.7
0664:  MOVWF  xD8
0666:  MOVFF  D6,FEA
066A:  MOVFF  D5,FE9
066E:  MOVFF  D8,D9
0672:  CLRF   xDB
0674:  MOVLW  01
0676:  MOVWF  xDA
0678:  RCALL  05CA
067A:  INCF   xD2,F
067C:  BRA    063C
.................... 	temp_mem= &current_act_position; 
067E:  CLRF   xD4
0680:  MOVLW  72
0682:  MOVWF  xD3
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i),1); 
0684:  CLRF   xD2
0686:  MOVF   xD2,W
0688:  SUBLW  01
068A:  BNC   06CE
068C:  MOVF   xD2,W
068E:  ADDWF  xD3,W
0690:  MOVWF  xD5
0692:  MOVLW  00
0694:  ADDWFC xD4,W
0696:  MOVWF  xD6
0698:  MOVLW  02
069A:  ADDWF  xD2,W
069C:  MOVWF  xD7
069E:  MOVFF  FF2,D8
06A2:  BCF    FF2.7
06A4:  MOVFF  D7,FA9
06A8:  BCF    FA6.6
06AA:  BCF    FA6.7
06AC:  BSF    FA6.0
06AE:  MOVF   FA8,W
06B0:  BTFSC  xD8.7
06B2:  BSF    FF2.7
06B4:  MOVWF  xD8
06B6:  MOVFF  D6,FEA
06BA:  MOVFF  D5,FE9
06BE:  MOVFF  D8,D9
06C2:  CLRF   xDB
06C4:  MOVLW  01
06C6:  MOVWF  xDA
06C8:  RCALL  05CA
06CA:  INCF   xD2,F
06CC:  BRA    0686
.................... 	temp_mem= &startup_counter; 
06CE:  CLRF   xD4
06D0:  MOVLW  C9
06D2:  MOVWF  xD3
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
06D4:  CLRF   xD2
06D6:  MOVF   xD2,W
06D8:  SUBLW  01
06DA:  BNC   071E
06DC:  MOVF   xD2,W
06DE:  ADDWF  xD3,W
06E0:  MOVWF  xD5
06E2:  MOVLW  00
06E4:  ADDWFC xD4,W
06E6:  MOVWF  xD6
06E8:  MOVLW  08
06EA:  ADDWF  xD2,W
06EC:  MOVWF  xD7
06EE:  MOVFF  FF2,D8
06F2:  BCF    FF2.7
06F4:  MOVFF  D7,FA9
06F8:  BCF    FA6.6
06FA:  BCF    FA6.7
06FC:  BSF    FA6.0
06FE:  MOVF   FA8,W
0700:  BTFSC  xD8.7
0702:  BSF    FF2.7
0704:  MOVWF  xD8
0706:  MOVFF  D6,FEA
070A:  MOVFF  D5,FE9
070E:  MOVFF  D8,D9
0712:  CLRF   xDB
0714:  MOVLW  01
0716:  MOVWF  xDA
0718:  RCALL  05CA
071A:  INCF   xD2,F
071C:  BRA    06D6
.................... } 
071E:  GOTO   5C94 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
.................... 	int8 i; 
.................... 	for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
08BE:  CLRF   xD3
08C0:  MOVF   xD3,W
08C2:  SUBLW  03
08C4:  BNC   0926
08C6:  MOVLW  04
08C8:  ADDWF  xD3,W
08CA:  MOVWF  xD4
08CC:  MOVF   xD3,W
08CE:  MULLW  08
08D0:  MOVFF  FF3,D5
08D4:  MOVFF  27,D9
08D8:  MOVFF  26,D8
08DC:  MOVFF  25,D7
08E0:  MOVFF  24,D6
08E4:  MOVF   xD5,F
08E6:  BZ    08F6
08E8:  BCF    FD8.0
08EA:  RRCF   xD9,F
08EC:  RRCF   xD8,F
08EE:  RRCF   xD7,F
08F0:  RRCF   xD6,F
08F2:  DECFSZ xD5,F
08F4:  BRA    08E8
08F6:  MOVFF  D4,FA9
08FA:  MOVFF  D6,FA8
08FE:  BCF    FA6.6
0900:  BCF    FA6.7
0902:  BSF    FA6.2
0904:  MOVFF  FF2,00
0908:  BCF    FF2.7
090A:  MOVLB  F
090C:  MOVLW  55
090E:  MOVWF  FA7
0910:  MOVLW  AA
0912:  MOVWF  FA7
0914:  BSF    FA6.1
0916:  BTFSC  FA6.1
0918:  BRA    0916
091A:  BCF    FA6.2
091C:  MOVF   00,W
091E:  IORWF  FF2,F
0920:  MOVLB  0
0922:  INCF   xD3,F
0924:  BRA    08C0
.................... 	for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i,current_act_position>>(i*8)); 
0926:  CLRF   xD3
0928:  MOVF   xD3,W
092A:  SUBLW  01
092C:  BNC   0982
092E:  MOVLW  02
0930:  ADDWF  xD3,W
0932:  MOVWF  xD4
0934:  MOVF   xD3,W
0936:  MULLW  08
0938:  MOVFF  FF3,00
093C:  MOVFF  73,D6
0940:  MOVFF  72,D5
0944:  MOVF   00,F
0946:  BZ    0952
0948:  BCF    FD8.0
094A:  RRCF   xD6,F
094C:  RRCF   xD5,F
094E:  DECFSZ 00,F
0950:  BRA    0948
0952:  MOVFF  D4,FA9
0956:  MOVFF  D5,FA8
095A:  BCF    FA6.6
095C:  BCF    FA6.7
095E:  BSF    FA6.2
0960:  MOVFF  FF2,00
0964:  BCF    FF2.7
0966:  MOVLB  F
0968:  MOVLW  55
096A:  MOVWF  FA7
096C:  MOVLW  AA
096E:  MOVWF  FA7
0970:  BSF    FA6.1
0972:  BTFSC  FA6.1
0974:  BRA    0972
0976:  BCF    FA6.2
0978:  MOVF   00,W
097A:  IORWF  FF2,F
097C:  MOVLB  0
097E:  INCF   xD3,F
0980:  BRA    0928
.................... 	for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
0982:  CLRF   xD3
0984:  MOVF   xD3,W
0986:  SUBLW  01
0988:  BNC   09DE
098A:  MOVLW  08
098C:  ADDWF  xD3,W
098E:  MOVWF  xD4
0990:  MOVF   xD3,W
0992:  MULLW  08
0994:  MOVFF  FF3,00
0998:  MOVFF  CA,D6
099C:  MOVFF  C9,D5
09A0:  MOVF   00,F
09A2:  BZ    09AE
09A4:  BCF    FD8.0
09A6:  RRCF   xD6,F
09A8:  RRCF   xD5,F
09AA:  DECFSZ 00,F
09AC:  BRA    09A4
09AE:  MOVFF  D4,FA9
09B2:  MOVFF  D5,FA8
09B6:  BCF    FA6.6
09B8:  BCF    FA6.7
09BA:  BSF    FA6.2
09BC:  MOVFF  FF2,00
09C0:  BCF    FF2.7
09C2:  MOVLB  F
09C4:  MOVLW  55
09C6:  MOVWF  FA7
09C8:  MOVLW  AA
09CA:  MOVWF  FA7
09CC:  BSF    FA6.1
09CE:  BTFSC  FA6.1
09D0:  BRA    09CE
09D2:  BCF    FA6.2
09D4:  MOVF   00,W
09D6:  IORWF  FF2,F
09D8:  MOVLB  0
09DA:  INCF   xD3,F
09DC:  BRA    0984
.................... 	if (write_cal ==1) 
09DE:  DECFSZ xD2,W
09E0:  BRA    0A38
.................... 		for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i,FULL_STROKE_TICK>>(i*8)); 
09E2:  CLRF   xD3
09E4:  MOVF   xD3,W
09E6:  SUBLW  01
09E8:  BNC   0A38
09EA:  MOVF   xD3,W
09EC:  MULLW  08
09EE:  MOVFF  FF3,00
09F2:  MOVFF  BF,D5
09F6:  MOVFF  BE,D4
09FA:  MOVF   00,F
09FC:  BZ    0A08
09FE:  BCF    FD8.0
0A00:  RRCF   xD5,F
0A02:  RRCF   xD4,F
0A04:  DECFSZ 00,F
0A06:  BRA    09FE
0A08:  MOVFF  D3,FA9
0A0C:  MOVFF  D4,FA8
0A10:  BCF    FA6.6
0A12:  BCF    FA6.7
0A14:  BSF    FA6.2
0A16:  MOVFF  FF2,00
0A1A:  BCF    FF2.7
0A1C:  MOVLB  F
0A1E:  MOVLW  55
0A20:  MOVWF  FA7
0A22:  MOVLW  AA
0A24:  MOVWF  FA7
0A26:  BSF    FA6.1
0A28:  BTFSC  FA6.1
0A2A:  BRA    0A28
0A2C:  BCF    FA6.2
0A2E:  MOVF   00,W
0A30:  IORWF  FF2,F
0A32:  MOVLB  0
0A34:  INCF   xD3,F
0A36:  BRA    09E4
.................... } 
0A38:  RETLW  00
....................  
....................  
.................... void init_ext_flash(void) { 
....................   output_low(FLASH_CLOCK); 
*
0B20:  BCF    F94.3
0B22:  BCF    F8B.3
....................   output_high(FLASH_SELECT); 
0B24:  BCF    F92.1
0B26:  BSF    F89.1
.................... } 
0B28:  GOTO   5D3E (RETURN)
....................  
.................... /* 
.................... void ext_flash_startContinuousRead(int pageAddress) { 
....................   ext_flash_waitUntilReady(); 
....................   output_low(FLASH_SELECT); 
....................   ext_flash_sendData(0xE8, 8); 
....................   ext_flash_sendData(pageAddress, 14); 
....................   ext_flash_sendData(0, 10); 
....................   ext_flash_sendData(0, 16); 
....................   ext_flash_sendData(0, 16); 
.................... } 
....................  
.................... */ 
....................  
.................... int ext_flash_getByte(void) { 
....................   int flashData = 0; 
....................   output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   return(flashData); 
.................... } 
....................  
.................... void ext_flash_getBytes(char* data, int16 size) { 
....................    int16 i, j; 
....................    for(i = 0; i < size; i++) { 
*
26B6:  MOVLB  1
26B8:  CLRF   x00
26BA:  MOVLB  0
26BC:  CLRF   xFF
26BE:  MOVLB  1
26C0:  MOVF   x00,W
26C2:  MOVLB  0
26C4:  SUBWF  xFE,W
26C6:  BNC   272A
26C8:  BNZ   26D0
26CA:  MOVF   xFD,W
26CC:  SUBWF  xFF,W
26CE:  BC    272A
....................       for(j = 0; j < 8; j++) { 
26D0:  MOVLB  1
26D2:  CLRF   x02
26D4:  CLRF   x01
26D6:  MOVF   x02,F
26D8:  BNZ   271A
26DA:  MOVF   x01,W
26DC:  SUBLW  07
26DE:  BNC   271A
....................          output_high(FLASH_CLOCK); 
26E0:  BCF    F94.3
26E2:  BSF    F8B.3
....................          shift_left(data + i, 1, input(FLASH_DO)); 
26E4:  MOVLB  0
26E6:  MOVF   xFF,W
26E8:  ADDWF  xFB,W
26EA:  MOVLB  1
26EC:  MOVWF  x03
26EE:  MOVF   x00,W
26F0:  MOVLB  0
26F2:  ADDWFC xFC,W
26F4:  MOVLB  1
26F6:  MOVWF  x04
26F8:  BSF    F94.4
26FA:  BTFSC  F82.4
26FC:  BRA    2702
26FE:  BCF    FD8.0
2700:  BRA    2704
2702:  BSF    FD8.0
2704:  MOVFF  104,FEA
2708:  MOVFF  103,FE9
270C:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
270E:  BCF    F94.3
2710:  BCF    F8B.3
....................       } 
2712:  INCF   x01,F
2714:  BTFSC  FD8.2
2716:  INCF   x02,F
2718:  BRA    26D6
....................    } 
271A:  MOVLB  0
271C:  INCF   xFF,F
271E:  BTFSS  FD8.2
2720:  BRA    2728
2722:  MOVLB  1
2724:  INCF   x00,F
2726:  MOVLB  0
2728:  BRA    26BE
.................... } 
272A:  RETLW  00
....................  
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size) { 
....................    ext_flash_waitUntilReady(); 
272C:  RCALL  23F4
....................    output_low(FLASH_SELECT); 
272E:  BCF    F92.1
2730:  BCF    F89.1
....................    ext_flash_sendData(0xD2, 8); 
2732:  MOVLW  D2
2734:  MOVWF  xFB
2736:  MOVLW  08
2738:  MOVWF  xFC
273A:  RCALL  252A
....................    ext_flash_send16Data(pageAddress, 15); 
273C:  MOVFF  F5,FC
2740:  MOVFF  F4,FB
2744:  MOVLW  0F
2746:  MOVWF  xFD
2748:  RCALL  255A
....................    ext_flash_sendData(0, 1); 
274A:  CLRF   xFB
274C:  MOVLW  01
274E:  MOVWF  xFC
2750:  RCALL  252A
....................    ext_flash_sendData(pageIndex, 8); 
2752:  MOVFF  F6,FB
2756:  MOVLW  08
2758:  MOVWF  xFC
275A:  RCALL  252A
....................    ext_flash_sendData(0, 16); 
275C:  CLRF   xFB
275E:  MOVLW  10
2760:  MOVWF  xFC
2762:  RCALL  252A
....................    ext_flash_sendData(0, 16); 
2764:  CLRF   xFB
2766:  MOVLW  10
2768:  MOVWF  xFC
276A:  RCALL  252A
....................    ext_flash_getBytes(data, size); 
276C:  MOVFF  F8,FC
2770:  MOVFF  F7,FB
2774:  MOVFF  FA,FE
2778:  MOVFF  F9,FD
277C:  RCALL  26B6
....................    output_high(FLASH_SELECT); 
277E:  BCF    F92.1
2780:  BSF    F89.1
.................... } 
2782:  RETLW  00
....................  
.................... /* 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
....................    output_low(FLASH_SELECT); 
....................    ext_flash_sendData(0x82, 8); 
....................    ext_flash_sendData(pageAddress, 14); 
....................    ext_flash_sendData(0, 10); 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
....................    output_high(FLASH_SELECT); 
.................... } 
.................... */ 
....................  
....................  
.................... void ext_flash_sendData(int data, int size) { 
....................    do { 
....................       size--; 
*
252A:  DECF   xFC,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
252C:  MOVFF  FB,00
2530:  MOVF   xFC,W
2532:  MOVWF  01
2534:  BZ    253E
2536:  BCF    FD8.0
2538:  RRCF   00,F
253A:  DECFSZ 01,F
253C:  BRA    2536
253E:  MOVF   00,W
2540:  ANDLW  01
2542:  BNZ   2548
2544:  BCF    F8B.5
2546:  BRA    254A
2548:  BSF    F8B.5
254A:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
254C:  BCF    F94.3
254E:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
2550:  BCF    F94.3
2552:  BCF    F8B.3
....................    } while(size > 0); 
2554:  MOVF   xFC,F
2556:  BNZ   252A
.................... } 
2558:  RETLW  00
....................  
.................... void ext_flash_send16Data(int16 data, int size) { 
....................    do { 
....................       size--; 
255A:  DECF   xFD,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
255C:  MOVFF  FC,FF
2560:  MOVFF  FB,FE
2564:  MOVF   xFD,W
2566:  MOVWF  00
2568:  BZ    2574
256A:  BCF    FD8.0
256C:  RRCF   xFF,F
256E:  RRCF   xFE,F
2570:  DECFSZ 00,F
2572:  BRA    256A
2574:  MOVF   xFE,W
2576:  ANDLW  01
2578:  MOVWF  00
257A:  CLRF   03
257C:  MOVF   00,W
257E:  IORWF  03,W
2580:  BNZ   2586
2582:  BCF    F8B.5
2584:  BRA    2588
2586:  BSF    F8B.5
2588:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
258A:  BCF    F94.3
258C:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
258E:  BCF    F94.3
2590:  BCF    F8B.3
....................    } while(size > 0); 
2592:  MOVF   xFD,F
2594:  BNZ   255A
.................... } 
2596:  RETLW  00
....................  
.................... void ext_flash_sendBytes(char* data, int size) { 
....................    int i; 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
.................... } 
....................  
.................... void ext_flash_waitUntilReady(void) { 
.................... // this function read status register 
.................... // Bit7 : 1=RDY, 0=BUSY 
.................... // Bit6 : COMP, 1=Recent Main memory page compare, 0 == match 
.................... // Bit 5-2 : 0b0111 , density code for 4MBit 
.................... // Bit 1: Protect 
.................... // Bit 0: Page size. 0= 264 byte, 1=256 byte 
....................  
....................   int flashData; 
....................   int i; 
....................   output_low(FLASH_SELECT); 
*
23F4:  BCF    F92.1
23F6:  BCF    F89.1
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
23F8:  BSF    F8B.5
23FA:  BCF    F94.5
23FC:  BCF    F94.3
23FE:  BSF    F8B.3
2400:  BCF    F94.3
2402:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2404:  BSF    F8B.5
2406:  BCF    F94.5
2408:  BCF    F94.3
240A:  BSF    F8B.3
240C:  BCF    F94.3
240E:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2410:  BCF    F8B.5
2412:  BCF    F94.5
2414:  BCF    F94.3
2416:  BSF    F8B.3
2418:  BCF    F94.3
241A:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
241C:  BSF    F8B.5
241E:  BCF    F94.5
2420:  BCF    F94.3
2422:  BSF    F8B.3
2424:  BCF    F94.3
2426:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2428:  BCF    F8B.5
242A:  BCF    F94.5
242C:  BCF    F94.3
242E:  BSF    F8B.3
2430:  BCF    F94.3
2432:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2434:  BSF    F8B.5
2436:  BCF    F94.5
2438:  BCF    F94.3
243A:  BSF    F8B.3
243C:  BCF    F94.3
243E:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2440:  BSF    F8B.5
2442:  BCF    F94.5
2444:  BCF    F94.3
2446:  BSF    F8B.3
2448:  BCF    F94.3
244A:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
244C:  BSF    F8B.5
244E:  BCF    F94.5
2450:  BCF    F94.3
2452:  BSF    F8B.3
2454:  BCF    F94.3
2456:  BCF    F8B.3
....................   for(i=0;i<255;i++) { 
2458:  CLRF   xFC
245A:  INCFSZ xFC,W
245C:  BRA    2460
245E:  BRA    2524
....................     flashData = 0; 
2460:  CLRF   xFB
....................     output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2462:  BCF    F94.3
2464:  BSF    F8B.3
2466:  BSF    F94.4
2468:  MOVLW  00
246A:  BTFSC  F82.4
246C:  MOVLW  01
246E:  ADDWF  xFB,F
2470:  BCF    F94.3
2472:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2474:  BCF    F94.3
2476:  BSF    F8B.3
2478:  BCF    FD8.0
247A:  RLCF   xFB,F
247C:  BSF    F94.4
247E:  MOVLW  00
2480:  BTFSC  F82.4
2482:  MOVLW  01
2484:  ADDWF  xFB,F
2486:  BCF    F94.3
2488:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
248A:  BCF    F94.3
248C:  BSF    F8B.3
248E:  BCF    FD8.0
2490:  RLCF   xFB,F
2492:  BSF    F94.4
2494:  MOVLW  00
2496:  BTFSC  F82.4
2498:  MOVLW  01
249A:  ADDWF  xFB,F
249C:  BCF    F94.3
249E:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
24A0:  BCF    F94.3
24A2:  BSF    F8B.3
24A4:  BCF    FD8.0
24A6:  RLCF   xFB,F
24A8:  BSF    F94.4
24AA:  MOVLW  00
24AC:  BTFSC  F82.4
24AE:  MOVLW  01
24B0:  ADDWF  xFB,F
24B2:  BCF    F94.3
24B4:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
24B6:  BCF    F94.3
24B8:  BSF    F8B.3
24BA:  BCF    FD8.0
24BC:  RLCF   xFB,F
24BE:  BSF    F94.4
24C0:  MOVLW  00
24C2:  BTFSC  F82.4
24C4:  MOVLW  01
24C6:  ADDWF  xFB,F
24C8:  BCF    F94.3
24CA:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
24CC:  BCF    F94.3
24CE:  BSF    F8B.3
24D0:  BCF    FD8.0
24D2:  RLCF   xFB,F
24D4:  BSF    F94.4
24D6:  MOVLW  00
24D8:  BTFSC  F82.4
24DA:  MOVLW  01
24DC:  ADDWF  xFB,F
24DE:  BCF    F94.3
24E0:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
24E2:  BCF    F94.3
24E4:  BSF    F8B.3
24E6:  BCF    FD8.0
24E8:  RLCF   xFB,F
24EA:  BSF    F94.4
24EC:  MOVLW  00
24EE:  BTFSC  F82.4
24F0:  MOVLW  01
24F2:  ADDWF  xFB,F
24F4:  BCF    F94.3
24F6:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
24F8:  BCF    F94.3
24FA:  BSF    F8B.3
24FC:  BCF    FD8.0
24FE:  RLCF   xFB,F
2500:  BSF    F94.4
2502:  MOVLW  00
2504:  BTFSC  F82.4
2506:  MOVLW  01
2508:  ADDWF  xFB,F
250A:  BCF    F94.3
250C:  BCF    F8B.3
....................     if (bit_test(flashData,7) == 1) break; // device is not busy 
250E:  BTFSS  xFB.7
2510:  BRA    2514
2512:  BRA    2524
.................... 	delay_cycles(500); 
2514:  MOVLW  A6
2516:  MOVWF  00
2518:  DECFSZ 00,F
251A:  BRA    2518
251C:  NOP   
.................... 	restart_wdt(); 
251E:  CLRWDT
....................   } 
2520:  INCF   xFC,F
2522:  BRA    245A
....................   output_high(FLASH_SELECT); 
2524:  BCF    F92.1
2526:  BSF    F89.1
.................... } 
2528:  RETLW  00
....................  
.................... void ext_flash_block_erase() { 
....................    int i; 
....................    for(i=0;i<0xFF;i++) { 
*
2818:  CLRF   xD2
281A:  INCFSZ xD2,W
281C:  BRA    2820
281E:  BRA    2852
....................    ext_flash_waitUntilReady(); 
2820:  RCALL  23F4
....................    output_low(FLASH_SELECT); 
2822:  BCF    F92.1
2824:  BCF    F89.1
....................    ext_flash_sendData(0x50, 8); 
2826:  MOVLW  50
2828:  MOVWF  xFB
282A:  MOVLW  08
282C:  MOVWF  xFC
282E:  RCALL  252A
....................    ext_flash_sendData(0, 4); 
2830:  CLRF   xFB
2832:  MOVLW  04
2834:  MOVWF  xFC
2836:  RCALL  252A
....................    ext_flash_sendData(i, 8); 
2838:  MOVFF  D2,FB
283C:  MOVLW  08
283E:  MOVWF  xFC
2840:  RCALL  252A
....................    ext_flash_sendData(0, 12); 
2842:  CLRF   xFB
2844:  MOVLW  0C
2846:  MOVWF  xFC
2848:  RCALL  252A
....................    output_high(FLASH_SELECT); 
284A:  BCF    F92.1
284C:  BSF    F89.1
....................    } 
284E:  INCF   xD2,F
2850:  BRA    281A
....................    ext_flash_waitUntilReady(); 
2852:  RCALL  23F4
.................... } 
2854:  GOTO   34AE (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_read() { 
....................    char data; 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2C18:  CALL   23F4
....................    output_low(FLASH_SELECT); 
2C1C:  BCF    F92.1
2C1E:  BCF    F89.1
....................    ext_flash_sendData(0xD1, 8); 
2C20:  MOVLW  D1
2C22:  MOVWF  xFB
2C24:  MOVLW  08
2C26:  MOVWF  xFC
2C28:  RCALL  252A
....................    ext_flash_send16Data(0, 16); 
2C2A:  CLRF   xFC
2C2C:  CLRF   xFB
2C2E:  MOVLW  10
2C30:  MOVWF  xFD
2C32:  RCALL  255A
....................    ext_flash_sendData(0, 8); 
2C34:  CLRF   xFB
2C36:  MOVLW  08
2C38:  MOVWF  xFC
2C3A:  RCALL  252A
....................    i=255; 
2C3C:  MOVLW  FF
2C3E:  MOVWF  xD3
....................    do { 
.................... 	  ext_flash_getBytes(&data,1); 
2C40:  CLRF   xFC
2C42:  MOVLW  D2
2C44:  MOVWF  xFB
2C46:  CLRF   xFE
2C48:  MOVLW  01
2C4A:  MOVWF  xFD
2C4C:  RCALL  26B6
.................... 	  i++; 
2C4E:  INCF   xD3,F
.................... 	  if (i%16==0) printf("\r\n %02X:", i); 
2C50:  MOVF   xD3,W
2C52:  ANDLW  0F
2C54:  BNZ   2C80
2C56:  MOVLW  0D
2C58:  BTFSS  F9E.4
2C5A:  BRA    2C58
2C5C:  MOVWF  FAD
2C5E:  MOVLW  0A
2C60:  BTFSS  F9E.4
2C62:  BRA    2C60
2C64:  MOVWF  FAD
2C66:  MOVLW  20
2C68:  BTFSS  F9E.4
2C6A:  BRA    2C68
2C6C:  MOVWF  FAD
2C6E:  MOVFF  D3,EA
2C72:  MOVLW  37
2C74:  MOVWF  xEB
2C76:  RCALL  2674
2C78:  MOVLW  3A
2C7A:  BTFSS  F9E.4
2C7C:  BRA    2C7A
2C7E:  MOVWF  FAD
....................       printf("%02X ",data); 
2C80:  MOVFF  D2,EA
2C84:  MOVLW  37
2C86:  MOVWF  xEB
2C88:  RCALL  2674
2C8A:  MOVLW  20
2C8C:  BTFSS  F9E.4
2C8E:  BRA    2C8C
2C90:  MOVWF  FAD
....................  
....................    } while (i<255); 
2C92:  INCFSZ xD3,W
2C94:  BRA    2C40
....................    output_high(FLASH_SELECT);	 
2C96:  BCF    F92.1
2C98:  BSF    F89.1
.................... } 
2C9A:  GOTO   32FC (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2DAA:  CALL   23F4
....................    output_low(FLASH_SELECT); 
2DAE:  BCF    F92.1
2DB0:  BCF    F89.1
....................    ext_flash_sendData(0x84, 8); 
2DB2:  MOVLW  84
2DB4:  MOVWF  xFB
2DB6:  MOVLW  08
2DB8:  MOVWF  xFC
2DBA:  CALL   252A
....................    ext_flash_send16Data(0, 16); 
2DBE:  CLRF   xFC
2DC0:  CLRF   xFB
2DC2:  MOVLW  10
2DC4:  MOVWF  xFD
2DC6:  CALL   255A
....................    ext_flash_sendData(PageIndex, 8); 
2DCA:  MOVFF  DE,FB
2DCE:  MOVLW  08
2DD0:  MOVWF  xFC
2DD2:  CALL   252A
....................    if (nData>1) { 
2DD6:  MOVF   xDF,W
2DD8:  SUBLW  01
2DDA:  BC    2DF6
.................... 	i=255; 
2DDC:  MOVLW  FF
2DDE:  MOVWF  xE0
.................... 	do { 
.................... 	   ext_flash_sendData(data,8); 
2DE0:  MOVFF  DD,FB
2DE4:  MOVLW  08
2DE6:  MOVWF  xFC
2DE8:  CALL   252A
.................... 	   i++; 
2DEC:  INCF   xE0,F
.................... 	} while(i!=nData); 
2DEE:  MOVF   xDF,W
2DF0:  SUBWF  xE0,W
2DF2:  BNZ   2DE0
....................    } else 
2DF4:  BRA    2E02
....................    		ext_flash_sendData(data,8); 
2DF6:  MOVFF  DD,FB
2DFA:  MOVLW  08
2DFC:  MOVWF  xFC
2DFE:  CALL   252A
....................    output_high(FLASH_SELECT); 
2E02:  BCF    F92.1
2E04:  BSF    F89.1
.................... } 
2E06:  RETLW  00
....................  
.................... void ext_flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
3736:  CALL   23F4
....................    output_low(FLASH_SELECT); 
373A:  BCF    F92.1
373C:  BCF    F89.1
....................    ext_flash_sendData(0x83, 8); 
373E:  MOVLW  83
3740:  MOVWF  xFB
3742:  MOVLW  08
3744:  MOVWF  xFC
3746:  CALL   252A
....................    ext_flash_send16Data(pageAddress, 15); 
374A:  MOVFF  D9,FC
374E:  MOVFF  D8,FB
3752:  MOVLW  0F
3754:  MOVWF  xFD
3756:  CALL   255A
....................    ext_flash_send16Data(0, 9); 
375A:  CLRF   xFC
375C:  CLRF   xFB
375E:  MOVLW  09
3760:  MOVWF  xFD
3762:  CALL   255A
....................    output_high(FLASH_SELECT); 
3766:  BCF    F92.1
3768:  BSF    F89.1
.................... } 
376A:  GOTO   3B00 (RETURN)
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD = n; 
*
0A3A:  MOVFF  F7,F83
....................       delay_us(50); 
0A3E:  MOVLW  A6
0A40:  MOVWF  00
0A42:  DECFSZ 00,F
0A44:  BRA    0A42
0A46:  NOP   
....................       output_high(LCD_EN); 
0A48:  BCF    F94.0
0A4A:  BSF    F8B.0
....................       delay_us(50); 
0A4C:  MOVLW  A6
0A4E:  MOVWF  00
0A50:  DECFSZ 00,F
0A52:  BRA    0A50
0A54:  NOP   
....................       output_low(LCD_EN); 
0A56:  BCF    F94.0
0A58:  BCF    F8B.0
.................... 	  delay_us(50); 
0A5A:  MOVLW  A6
0A5C:  MOVWF  00
0A5E:  DECFSZ 00,F
0A60:  BRA    0A5E
0A62:  NOP   
.................... } 
0A64:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
.................... 	PORTE.rs=rs; 
0A66:  BTFSS  xF3.0
0A68:  BCF    F84.0
0A6A:  BTFSC  xF3.0
0A6C:  BSF    F84.0
....................     PORTE.rw=0; 
0A6E:  BCF    F84.1
.................... 	lcd_send_nibble(dat&0xF0); 
0A70:  MOVF   xF4,W
0A72:  ANDLW  F0
0A74:  MOVWF  xF5
0A76:  MOVWF  xF7
0A78:  RCALL  0A3A
.................... 	lcd_send_nibble((dat<<4)&0xF0); 
0A7A:  SWAPF  xF4,W
0A7C:  MOVWF  00
0A7E:  MOVLW  F0
0A80:  ANDWF  00,F
0A82:  MOVF   00,W
0A84:  ANDLW  F0
0A86:  MOVWF  xF6
0A88:  MOVWF  xF7
0A8A:  RCALL  0A3A
.................... 	PORTE.rs=1; 
0A8C:  BSF    F84.0
.................... } 
0A8E:  RETLW  00
....................  
.................... void lcd_init() { 
.................... 	int8 i; 
....................     PORTE.rs = 0; 
0A90:  BCF    F84.0
....................     PORTE.rw = 0; 
0A92:  BCF    F84.1
....................     output_low(LCD_EN); 
0A94:  BCF    F94.0
0A96:  BCF    F8B.0
.................... 	delay_ms(15); 
0A98:  MOVLW  0F
0A9A:  MOVWF  xEF
0A9C:  RCALL  05A2
....................     for(i=1;i<=3;++i) { 
0A9E:  MOVLW  01
0AA0:  MOVWF  xD3
0AA2:  MOVF   xD3,W
0AA4:  SUBLW  03
0AA6:  BNC   0AB8
....................        lcd_send_nibble(0x30); // retrun home 
0AA8:  MOVLW  30
0AAA:  MOVWF  xF7
0AAC:  RCALL  0A3A
....................        delay_ms(15); 
0AAE:  MOVLW  0F
0AB0:  MOVWF  xEF
0AB2:  RCALL  05A2
....................     } 
0AB4:  INCF   xD3,F
0AB6:  BRA    0AA2
....................     lcd_send_nibble(0x20); // retrun home 
0AB8:  MOVLW  20
0ABA:  MOVWF  xF7
0ABC:  RCALL  0A3A
....................     delay_ms(15); 
0ABE:  MOVLW  0F
0AC0:  MOVWF  xEF
0AC2:  RCALL  05A2
....................     lcd_send_cmd(0,0x06); 
0AC4:  CLRF   xF3
0AC6:  MOVLW  06
0AC8:  MOVWF  xF4
0ACA:  RCALL  0A66
....................     delay_us(50); 
0ACC:  MOVLW  A6
0ACE:  MOVWF  00
0AD0:  DECFSZ 00,F
0AD2:  BRA    0AD0
0AD4:  NOP   
....................     lcd_send_cmd(0,0x0c); 
0AD6:  CLRF   xF3
0AD8:  MOVLW  0C
0ADA:  MOVWF  xF4
0ADC:  RCALL  0A66
....................     delay_us(50); 
0ADE:  MOVLW  A6
0AE0:  MOVWF  00
0AE2:  DECFSZ 00,F
0AE4:  BRA    0AE2
0AE6:  NOP   
....................     lcd_send_cmd(0,0x10); 
0AE8:  CLRF   xF3
0AEA:  MOVLW  10
0AEC:  MOVWF  xF4
0AEE:  RCALL  0A66
....................     delay_us(50); 
0AF0:  MOVLW  A6
0AF2:  MOVWF  00
0AF4:  DECFSZ 00,F
0AF6:  BRA    0AF4
0AF8:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
0AFA:  CLRF   xF3
0AFC:  MOVLW  2C
0AFE:  MOVWF  xF4
0B00:  RCALL  0A66
....................     delay_us(50); 
0B02:  MOVLW  A6
0B04:  MOVWF  00
0B06:  DECFSZ 00,F
0B08:  BRA    0B06
0B0A:  NOP   
....................     lcd_send_cmd(0,0x01); 
0B0C:  CLRF   xF3
0B0E:  MOVLW  01
0B10:  MOVWF  xF4
0B12:  RCALL  0A66
....................     delay_us(50); 
0B14:  MOVLW  A6
0B16:  MOVWF  00
0B18:  DECFSZ 00,F
0B1A:  BRA    0B18
0B1C:  NOP   
....................  
.................... } 
0B1E:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
0D34:  MOVF   xF0,W
0D36:  ANDLW  03
0D38:  CLRF   03
0D3A:  ADDLW  20
0D3C:  MOVWF  FE9
0D3E:  MOVLW  00
0D40:  ADDWFC 03,W
0D42:  MOVWF  FEA
0D44:  MOVFF  FEF,F1
....................    address+=x; 
0D48:  MOVF   xEF,W
0D4A:  ADDWF  xF1,F
....................    lcd_send_cmd(0,0x80|address); 
0D4C:  MOVF   xF1,W
0D4E:  IORLW  80
0D50:  MOVWF  xF2
0D52:  CLRF   xF3
0D54:  MOVWF  xF4
0D56:  RCALL  0A66
.................... } 
0D58:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0D5A:  MOVF   xEE,W
0D5C:  XORLW  0C
0D5E:  BZ    0D6A
0D60:  XORLW  06
0D62:  BZ    0D7A
0D64:  XORLW  02
0D66:  BZ    0D86
0D68:  BRA    0D90
....................      case '\f'   : lcd_send_cmd(0,1); 
0D6A:  CLRF   xF3
0D6C:  MOVLW  01
0D6E:  MOVWF  xF4
0D70:  RCALL  0A66
....................                    delay_ms(2); 
0D72:  MOVLW  02
0D74:  MOVWF  xEF
0D76:  RCALL  05A2
....................                                            break; 
0D78:  BRA    0D9C
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0D7A:  MOVLW  01
0D7C:  MOVWF  xEF
0D7E:  MOVLW  02
0D80:  MOVWF  xF0
0D82:  RCALL  0D34
0D84:  BRA    0D9C
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
0D86:  CLRF   xF3
0D88:  MOVLW  10
0D8A:  MOVWF  xF4
0D8C:  RCALL  0A66
0D8E:  BRA    0D9C
....................      default     : lcd_send_cmd(1,c);     break; 
0D90:  MOVLW  01
0D92:  MOVWF  xF3
0D94:  MOVFF  EE,F4
0D98:  RCALL  0A66
0D9A:  BRA    0D9C
....................    } 
.................... } 
0D9C:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
.................... 	int8 i; 
.................... 	for(i=0;i<size;i++)	lcd_putc(c[i]); 
*
16EE:  CLRF   xE9
16F0:  MOVF   xE8,W
16F2:  SUBWF  xE9,W
16F4:  BC    1714
16F6:  CLRF   03
16F8:  MOVF   xE9,W
16FA:  ADDWF  xE6,W
16FC:  MOVWF  FE9
16FE:  MOVF   xE7,W
1700:  ADDWFC 03,W
1702:  MOVWF  FEA
1704:  MOVFF  FEF,EA
1708:  MOVFF  EA,EE
170C:  CALL   0D5A
1710:  INCF   xE9,F
1712:  BRA    16F0
.................... } 
1714:  RETLW  00
.................... 	 
.................... void print_date_time() { 
....................  
.................... 		JDN = (unsigned int32)((float) (Y2010_JDN*1.0+ 0.5+ (float)(UTC*1.0)/24.0 + (timer_sec)*1.0/86400.0)); 
1716:  MOVFF  27,E8
171A:  MOVFF  26,E7
171E:  MOVFF  25,E6
1722:  MOVFF  24,E5
1726:  GOTO   0E50
172A:  MOVFF  03,152
172E:  MOVFF  02,151
1732:  MOVFF  01,150
1736:  MOVFF  00,14F
173A:  MOVLB  1
173C:  CLRF   x56
173E:  CLRF   x55
1740:  CLRF   x54
1742:  MOVLW  7F
1744:  MOVWF  x53
1746:  MOVLB  0
1748:  CALL   0E86
174C:  MOVFF  00,E5
1750:  MOVFF  01,E6
1754:  MOVFF  02,E7
1758:  MOVFF  03,E8
175C:  MOVFF  03,14E
1760:  MOVFF  02,14D
1764:  MOVFF  01,14C
1768:  MOVFF  00,14B
176C:  MOVLB  1
176E:  CLRF   x52
1770:  MOVLW  C0
1772:  MOVWF  x51
1774:  MOVLW  28
1776:  MOVWF  x50
1778:  MOVLW  8F
177A:  MOVWF  x4F
177C:  MOVLB  0
177E:  CALL   0F7C
1782:  BCF    FD8.1
1784:  MOVLW  79
1786:  MOVLB  1
1788:  MOVWF  x54
178A:  MOVLW  DA
178C:  MOVWF  x53
178E:  MOVLW  15
1790:  MOVWF  x52
1792:  MOVLW  94
1794:  MOVWF  x51
1796:  MOVFF  03,158
179A:  MOVFF  02,157
179E:  MOVFF  01,156
17A2:  MOVFF  00,155
17A6:  MOVLB  0
17A8:  RCALL  10DA
17AA:  MOVFF  03,EC
17AE:  MOVFF  02,EB
17B2:  MOVFF  01,EA
17B6:  MOVFF  00,E9
17BA:  BRA    1352
17BC:  MOVFF  03,79
17C0:  MOVFF  02,78
17C4:  MOVFF  01,77
17C8:  MOVFF  00,76
.................... 		jj = JDN +32044; 
17CC:  MOVLW  2C
17CE:  ADDWF  x76,W
17D0:  MOVWF  x7A
17D2:  MOVLW  7D
17D4:  ADDWFC x77,W
17D6:  MOVWF  x7B
17D8:  MOVLW  00
17DA:  ADDWFC x78,W
17DC:  MOVWF  x7C
17DE:  MOVLW  00
17E0:  ADDWFC x79,W
17E2:  MOVWF  x7D
17E4:  CLRF   18
17E6:  BTFSC  FF2.7
17E8:  BSF    18.7
17EA:  BCF    FF2.7
.................... 		g=jj/146097; 
17EC:  MOVFF  7D,F5
17F0:  MOVFF  7C,F4
17F4:  MOVFF  7B,F3
17F8:  MOVFF  7A,F2
17FC:  CLRF   xF9
17FE:  MOVLW  02
1800:  MOVWF  xF8
1802:  MOVLW  3A
1804:  MOVWF  xF7
1806:  MOVLW  B1
1808:  MOVWF  xF6
180A:  CALL   036A
180E:  BTFSC  18.7
1810:  BSF    FF2.7
1812:  MOVFF  03,81
1816:  MOVFF  02,80
181A:  MOVFF  01,7F
181E:  MOVFF  00,7E
1822:  CLRF   18
1824:  BTFSC  FF2.7
1826:  BSF    18.7
1828:  BCF    FF2.7
.................... 		dg=jj%146097; 
182A:  MOVFF  7D,F5
182E:  MOVFF  7C,F4
1832:  MOVFF  7B,F3
1836:  MOVFF  7A,F2
183A:  CLRF   xF9
183C:  MOVLW  02
183E:  MOVWF  xF8
1840:  MOVLW  3A
1842:  MOVWF  xF7
1844:  MOVLW  B1
1846:  MOVWF  xF6
1848:  CALL   036A
184C:  BTFSC  18.7
184E:  BSF    FF2.7
1850:  MOVFF  FEF,82
1854:  MOVFF  FEC,83
1858:  MOVFF  FEC,84
185C:  MOVFF  FEC,85
1860:  CLRF   18
1862:  BTFSC  FF2.7
1864:  BSF    18.7
1866:  BCF    FF2.7
.................... 		c=(dg/36524+1)*3/4; 
1868:  MOVFF  85,F5
186C:  MOVFF  84,F4
1870:  MOVFF  83,F3
1874:  MOVFF  82,F2
1878:  CLRF   xF9
187A:  CLRF   xF8
187C:  MOVLW  8E
187E:  MOVWF  xF7
1880:  MOVLW  AC
1882:  MOVWF  xF6
1884:  CALL   036A
1888:  BTFSC  18.7
188A:  BSF    FF2.7
188C:  MOVFF  03,E8
1890:  MOVFF  02,E7
1894:  MOVFF  01,E6
1898:  MOVFF  00,E5
189C:  MOVLW  01
189E:  ADDWF  00,W
18A0:  MOVWF  xE9
18A2:  MOVLW  00
18A4:  ADDWFC 01,W
18A6:  MOVWF  xEA
18A8:  MOVLW  00
18AA:  ADDWFC 02,W
18AC:  MOVWF  xEB
18AE:  MOVLW  00
18B0:  ADDWFC 03,W
18B2:  MOVWF  xEC
18B4:  MOVWF  xFD
18B6:  MOVFF  EB,FC
18BA:  MOVFF  EA,FB
18BE:  MOVFF  E9,FA
18C2:  MOVLB  1
18C4:  CLRF   x01
18C6:  CLRF   x00
18C8:  MOVLB  0
18CA:  CLRF   xFF
18CC:  MOVLW  03
18CE:  MOVWF  xFE
18D0:  RCALL  1392
18D2:  RRCF   03,W
18D4:  MOVWF  x89
18D6:  RRCF   02,W
18D8:  MOVWF  x88
18DA:  RRCF   01,W
18DC:  MOVWF  x87
18DE:  RRCF   00,W
18E0:  MOVWF  x86
18E2:  RRCF   x89,F
18E4:  RRCF   x88,F
18E6:  RRCF   x87,F
18E8:  RRCF   x86,F
18EA:  MOVLW  3F
18EC:  ANDWF  x89,F
.................... 		dc=dg-c*36524; 
18EE:  MOVFF  89,FD
18F2:  MOVFF  88,FC
18F6:  MOVFF  87,FB
18FA:  MOVFF  86,FA
18FE:  MOVLB  1
1900:  CLRF   x01
1902:  CLRF   x00
1904:  MOVLW  8E
1906:  MOVLB  0
1908:  MOVWF  xFF
190A:  MOVLW  AC
190C:  MOVWF  xFE
190E:  RCALL  1392
1910:  MOVF   00,W
1912:  SUBWF  x82,W
1914:  MOVWF  x8A
1916:  MOVF   01,W
1918:  SUBWFB x83,W
191A:  MOVWF  x8B
191C:  MOVF   02,W
191E:  SUBWFB x84,W
1920:  MOVWF  x8C
1922:  MOVF   03,W
1924:  SUBWFB x85,W
1926:  MOVWF  x8D
1928:  CLRF   18
192A:  BTFSC  FF2.7
192C:  BSF    18.7
192E:  BCF    FF2.7
.................... 		b=dc/1461; 
1930:  MOVFF  8D,F5
1934:  MOVFF  8C,F4
1938:  MOVFF  8B,F3
193C:  MOVFF  8A,F2
1940:  CLRF   xF9
1942:  CLRF   xF8
1944:  MOVLW  05
1946:  MOVWF  xF7
1948:  MOVLW  B5
194A:  MOVWF  xF6
194C:  CALL   036A
1950:  BTFSC  18.7
1952:  BSF    FF2.7
1954:  MOVFF  03,91
1958:  MOVFF  02,90
195C:  MOVFF  01,8F
1960:  MOVFF  00,8E
1964:  CLRF   18
1966:  BTFSC  FF2.7
1968:  BSF    18.7
196A:  BCF    FF2.7
.................... 		db=dc%1461; 
196C:  MOVFF  8D,F5
1970:  MOVFF  8C,F4
1974:  MOVFF  8B,F3
1978:  MOVFF  8A,F2
197C:  CLRF   xF9
197E:  CLRF   xF8
1980:  MOVLW  05
1982:  MOVWF  xF7
1984:  MOVLW  B5
1986:  MOVWF  xF6
1988:  CALL   036A
198C:  BTFSC  18.7
198E:  BSF    FF2.7
1990:  MOVFF  FEF,92
1994:  MOVFF  FEC,93
1998:  MOVFF  FEC,94
199C:  MOVFF  FEC,95
19A0:  CLRF   18
19A2:  BTFSC  FF2.7
19A4:  BSF    18.7
19A6:  BCF    FF2.7
.................... 		a=(db/365+1)*3/4; 
19A8:  MOVFF  95,F5
19AC:  MOVFF  94,F4
19B0:  MOVFF  93,F3
19B4:  MOVFF  92,F2
19B8:  CLRF   xF9
19BA:  CLRF   xF8
19BC:  MOVLW  01
19BE:  MOVWF  xF7
19C0:  MOVLW  6D
19C2:  MOVWF  xF6
19C4:  CALL   036A
19C8:  BTFSC  18.7
19CA:  BSF    FF2.7
19CC:  MOVFF  03,E8
19D0:  MOVFF  02,E7
19D4:  MOVFF  01,E6
19D8:  MOVFF  00,E5
19DC:  MOVLW  01
19DE:  ADDWF  00,W
19E0:  MOVWF  xE9
19E2:  MOVLW  00
19E4:  ADDWFC 01,W
19E6:  MOVWF  xEA
19E8:  MOVLW  00
19EA:  ADDWFC 02,W
19EC:  MOVWF  xEB
19EE:  MOVLW  00
19F0:  ADDWFC 03,W
19F2:  MOVWF  xEC
19F4:  MOVWF  xFD
19F6:  MOVFF  EB,FC
19FA:  MOVFF  EA,FB
19FE:  MOVFF  E9,FA
1A02:  MOVLB  1
1A04:  CLRF   x01
1A06:  CLRF   x00
1A08:  MOVLB  0
1A0A:  CLRF   xFF
1A0C:  MOVLW  03
1A0E:  MOVWF  xFE
1A10:  RCALL  1392
1A12:  RRCF   03,W
1A14:  MOVWF  x99
1A16:  RRCF   02,W
1A18:  MOVWF  x98
1A1A:  RRCF   01,W
1A1C:  MOVWF  x97
1A1E:  RRCF   00,W
1A20:  MOVWF  x96
1A22:  RRCF   x99,F
1A24:  RRCF   x98,F
1A26:  RRCF   x97,F
1A28:  RRCF   x96,F
1A2A:  MOVLW  3F
1A2C:  ANDWF  x99,F
.................... 		da=db-a*365; 
1A2E:  MOVFF  99,FD
1A32:  MOVFF  98,FC
1A36:  MOVFF  97,FB
1A3A:  MOVFF  96,FA
1A3E:  MOVLB  1
1A40:  CLRF   x01
1A42:  CLRF   x00
1A44:  MOVLW  01
1A46:  MOVLB  0
1A48:  MOVWF  xFF
1A4A:  MOVLW  6D
1A4C:  MOVWF  xFE
1A4E:  RCALL  1392
1A50:  MOVF   00,W
1A52:  SUBWF  x92,W
1A54:  MOVWF  x9A
1A56:  MOVF   01,W
1A58:  SUBWFB x93,W
1A5A:  MOVWF  x9B
1A5C:  MOVF   02,W
1A5E:  SUBWFB x94,W
1A60:  MOVWF  x9C
1A62:  MOVF   03,W
1A64:  SUBWFB x95,W
1A66:  MOVWF  x9D
.................... 		y=g*400+c*100+b*4+a; 
1A68:  MOVFF  81,FD
1A6C:  MOVFF  80,FC
1A70:  MOVFF  7F,FB
1A74:  MOVFF  7E,FA
1A78:  MOVLB  1
1A7A:  CLRF   x01
1A7C:  CLRF   x00
1A7E:  MOVLW  01
1A80:  MOVLB  0
1A82:  MOVWF  xFF
1A84:  MOVLW  90
1A86:  MOVWF  xFE
1A88:  RCALL  1392
1A8A:  MOVFF  03,E8
1A8E:  MOVFF  02,E7
1A92:  MOVFF  01,E6
1A96:  MOVFF  00,E5
1A9A:  MOVFF  89,FD
1A9E:  MOVFF  88,FC
1AA2:  MOVFF  87,FB
1AA6:  MOVFF  86,FA
1AAA:  MOVLB  1
1AAC:  CLRF   x01
1AAE:  CLRF   x00
1AB0:  MOVLB  0
1AB2:  CLRF   xFF
1AB4:  MOVLW  64
1AB6:  MOVWF  xFE
1AB8:  RCALL  1392
1ABA:  MOVF   00,W
1ABC:  ADDWF  xE5,W
1ABE:  MOVWF  xE9
1AC0:  MOVF   01,W
1AC2:  ADDWFC xE6,W
1AC4:  MOVWF  xEA
1AC6:  MOVF   02,W
1AC8:  ADDWFC xE7,W
1ACA:  MOVWF  xEB
1ACC:  MOVF   03,W
1ACE:  ADDWFC xE8,W
1AD0:  MOVWF  xEC
1AD2:  RLCF   x8E,W
1AD4:  MOVWF  00
1AD6:  RLCF   x8F,W
1AD8:  MOVWF  01
1ADA:  RLCF   x90,W
1ADC:  MOVWF  02
1ADE:  RLCF   x91,W
1AE0:  MOVWF  03
1AE2:  RLCF   00,F
1AE4:  RLCF   01,F
1AE6:  RLCF   02,F
1AE8:  RLCF   03,F
1AEA:  MOVLW  FC
1AEC:  ANDWF  00,F
1AEE:  MOVF   00,W
1AF0:  ADDWF  xE9,W
1AF2:  MOVWF  xED
1AF4:  MOVF   01,W
1AF6:  ADDWFC xEA,W
1AF8:  MOVWF  xEE
1AFA:  MOVF   02,W
1AFC:  ADDWFC xEB,W
1AFE:  MOVWF  xEF
1B00:  MOVF   03,W
1B02:  ADDWFC xEC,W
1B04:  MOVWF  xF0
1B06:  MOVF   x96,W
1B08:  ADDWF  xED,W
1B0A:  MOVWF  x9E
1B0C:  MOVF   x97,W
1B0E:  ADDWFC xEE,W
1B10:  MOVWF  x9F
1B12:  MOVF   x98,W
1B14:  ADDWFC xEF,W
1B16:  MOVWF  xA0
1B18:  MOVF   x99,W
1B1A:  ADDWFC xF0,W
1B1C:  MOVWF  xA1
.................... 		m=(da*5+308)/153-2; 
1B1E:  MOVFF  9D,FD
1B22:  MOVFF  9C,FC
1B26:  MOVFF  9B,FB
1B2A:  MOVFF  9A,FA
1B2E:  MOVLB  1
1B30:  CLRF   x01
1B32:  CLRF   x00
1B34:  MOVLB  0
1B36:  CLRF   xFF
1B38:  MOVLW  05
1B3A:  MOVWF  xFE
1B3C:  RCALL  1392
1B3E:  MOVFF  03,E8
1B42:  MOVFF  02,E7
1B46:  MOVFF  01,E6
1B4A:  MOVFF  00,E5
1B4E:  MOVLW  34
1B50:  ADDWF  00,W
1B52:  MOVWF  xE9
1B54:  MOVLW  01
1B56:  ADDWFC 01,W
1B58:  MOVWF  xEA
1B5A:  MOVLW  00
1B5C:  ADDWFC 02,W
1B5E:  MOVWF  xEB
1B60:  MOVLW  00
1B62:  ADDWFC 03,W
1B64:  MOVWF  xEC
1B66:  CLRF   18
1B68:  BTFSC  FF2.7
1B6A:  BSF    18.7
1B6C:  BCF    FF2.7
1B6E:  MOVWF  xF5
1B70:  MOVFF  EB,F4
1B74:  MOVFF  EA,F3
1B78:  MOVFF  E9,F2
1B7C:  CLRF   xF9
1B7E:  CLRF   xF8
1B80:  CLRF   xF7
1B82:  MOVLW  99
1B84:  MOVWF  xF6
1B86:  CALL   036A
1B8A:  BTFSC  18.7
1B8C:  BSF    FF2.7
1B8E:  MOVLW  02
1B90:  SUBWF  00,W
1B92:  MOVWF  xA2
1B94:  MOVLW  00
1B96:  SUBWFB 01,W
1B98:  MOVWF  xA3
1B9A:  MOVLW  00
1B9C:  SUBWFB 02,W
1B9E:  MOVWF  xA4
1BA0:  MOVLW  00
1BA2:  SUBWFB 03,W
1BA4:  MOVWF  xA5
.................... 		d=da-(m+4)*153/5+122; 
1BA6:  MOVLW  04
1BA8:  ADDWF  xA2,W
1BAA:  MOVWF  xE5
1BAC:  MOVLW  00
1BAE:  ADDWFC xA3,W
1BB0:  MOVWF  xE6
1BB2:  MOVLW  00
1BB4:  ADDWFC xA4,W
1BB6:  MOVWF  xE7
1BB8:  MOVLW  00
1BBA:  ADDWFC xA5,W
1BBC:  MOVWF  xE8
1BBE:  MOVWF  xFD
1BC0:  MOVFF  E7,FC
1BC4:  MOVFF  E6,FB
1BC8:  MOVFF  E5,FA
1BCC:  MOVLB  1
1BCE:  CLRF   x01
1BD0:  CLRF   x00
1BD2:  MOVLB  0
1BD4:  CLRF   xFF
1BD6:  MOVLW  99
1BD8:  MOVWF  xFE
1BDA:  CALL   1392
1BDE:  MOVFF  03,E9
1BE2:  MOVFF  02,E8
1BE6:  MOVFF  01,E7
1BEA:  MOVFF  00,E6
1BEE:  CLRF   18
1BF0:  BTFSC  FF2.7
1BF2:  BSF    18.7
1BF4:  BCF    FF2.7
1BF6:  MOVFF  03,F5
1BFA:  MOVFF  02,F4
1BFE:  MOVFF  01,F3
1C02:  MOVFF  00,F2
1C06:  CLRF   xF9
1C08:  CLRF   xF8
1C0A:  CLRF   xF7
1C0C:  MOVLW  05
1C0E:  MOVWF  xF6
1C10:  CALL   036A
1C14:  BTFSC  18.7
1C16:  BSF    FF2.7
1C18:  MOVF   00,W
1C1A:  SUBWF  x9A,W
1C1C:  MOVWF  xE7
1C1E:  MOVF   01,W
1C20:  SUBWFB x9B,W
1C22:  MOVWF  xE8
1C24:  MOVF   02,W
1C26:  SUBWFB x9C,W
1C28:  MOVWF  xE9
1C2A:  MOVF   03,W
1C2C:  SUBWFB x9D,W
1C2E:  MOVWF  xEA
1C30:  MOVLW  7A
1C32:  ADDWF  xE7,W
1C34:  MOVWF  xA6
1C36:  MOVLW  00
1C38:  ADDWFC xE8,W
1C3A:  MOVWF  xA7
1C3C:  MOVLW  00
1C3E:  ADDWFC xE9,W
1C40:  MOVWF  xA8
1C42:  MOVLW  00
1C44:  ADDWFC xEA,W
1C46:  MOVWF  xA9
.................... 		YY=y-4800+(m+2)/12; 
1C48:  MOVLW  C0
1C4A:  SUBWF  x9E,W
1C4C:  MOVWF  xE5
1C4E:  MOVLW  12
1C50:  SUBWFB x9F,W
1C52:  MOVWF  xE6
1C54:  MOVLW  00
1C56:  SUBWFB xA0,W
1C58:  MOVWF  xE7
1C5A:  MOVLW  00
1C5C:  SUBWFB xA1,W
1C5E:  MOVWF  xE8
1C60:  MOVLW  02
1C62:  ADDWF  xA2,W
1C64:  MOVWF  xE9
1C66:  MOVLW  00
1C68:  ADDWFC xA3,W
1C6A:  MOVWF  xEA
1C6C:  MOVLW  00
1C6E:  ADDWFC xA4,W
1C70:  MOVWF  xEB
1C72:  MOVLW  00
1C74:  ADDWFC xA5,W
1C76:  MOVWF  xEC
1C78:  CLRF   18
1C7A:  BTFSC  FF2.7
1C7C:  BSF    18.7
1C7E:  BCF    FF2.7
1C80:  MOVWF  xF5
1C82:  MOVFF  EB,F4
1C86:  MOVFF  EA,F3
1C8A:  MOVFF  E9,F2
1C8E:  CLRF   xF9
1C90:  CLRF   xF8
1C92:  CLRF   xF7
1C94:  MOVLW  0C
1C96:  MOVWF  xF6
1C98:  CALL   036A
1C9C:  BTFSC  18.7
1C9E:  BSF    FF2.7
1CA0:  MOVF   00,W
1CA2:  ADDWF  xE5,W
1CA4:  MOVWF  xAA
1CA6:  MOVF   01,W
1CA8:  ADDWFC xE6,W
1CAA:  MOVWF  xAB
1CAC:  MOVF   02,W
1CAE:  ADDWFC xE7,W
1CB0:  MOVWF  xAC
1CB2:  MOVF   03,W
1CB4:  ADDWFC xE8,W
1CB6:  MOVWF  xAD
.................... 		MM=(m+2)%12+1; 
1CB8:  MOVLW  02
1CBA:  ADDWF  xA2,W
1CBC:  MOVWF  xE5
1CBE:  MOVLW  00
1CC0:  ADDWFC xA3,W
1CC2:  MOVWF  xE6
1CC4:  MOVLW  00
1CC6:  ADDWFC xA4,W
1CC8:  MOVWF  xE7
1CCA:  MOVLW  00
1CCC:  ADDWFC xA5,W
1CCE:  MOVWF  xE8
1CD0:  CLRF   18
1CD2:  BTFSC  FF2.7
1CD4:  BSF    18.7
1CD6:  BCF    FF2.7
1CD8:  MOVWF  xF5
1CDA:  MOVFF  E7,F4
1CDE:  MOVFF  E6,F3
1CE2:  MOVFF  E5,F2
1CE6:  CLRF   xF9
1CE8:  CLRF   xF8
1CEA:  CLRF   xF7
1CEC:  MOVLW  0C
1CEE:  MOVWF  xF6
1CF0:  CALL   036A
1CF4:  BTFSC  18.7
1CF6:  BSF    FF2.7
1CF8:  MOVFF  FEF,E6
1CFC:  MOVFF  FEC,E7
1D00:  MOVFF  FEC,E8
1D04:  MOVFF  FEC,E9
1D08:  MOVLW  01
1D0A:  ADDWF  xE6,W
1D0C:  MOVWF  xAE
1D0E:  MOVLW  00
1D10:  ADDWFC xE7,W
1D12:  MOVWF  xAF
1D14:  MOVLW  00
1D16:  ADDWFC xE8,W
1D18:  MOVWF  xB0
1D1A:  MOVLW  00
1D1C:  ADDWFC xE9,W
1D1E:  MOVWF  xB1
.................... 		DD=d+1; 
1D20:  MOVLW  01
1D22:  ADDWF  xA6,W
1D24:  MOVWF  xB2
1D26:  MOVLW  00
1D28:  ADDWFC xA7,W
1D2A:  MOVWF  xB3
1D2C:  MOVLW  00
1D2E:  ADDWFC xA8,W
1D30:  MOVWF  xB4
1D32:  MOVLW  00
1D34:  ADDWFC xA9,W
1D36:  MOVWF  xB5
.................... 		time_of_day = (timer_sec+((int8)UTC)*3600)%86400; 
1D38:  MOVLW  70
1D3A:  ADDWF  24,W
1D3C:  MOVWF  xE5
1D3E:  MOVLW  62
1D40:  ADDWFC 25,W
1D42:  MOVWF  xE6
1D44:  MOVLW  00
1D46:  ADDWFC 26,W
1D48:  MOVWF  xE7
1D4A:  MOVLW  00
1D4C:  ADDWFC 27,W
1D4E:  MOVWF  xE8
1D50:  CLRF   18
1D52:  BTFSC  FF2.7
1D54:  BSF    18.7
1D56:  BCF    FF2.7
1D58:  MOVWF  xF5
1D5A:  MOVFF  E7,F4
1D5E:  MOVFF  E6,F3
1D62:  MOVFF  E5,F2
1D66:  CLRF   xF9
1D68:  MOVLW  01
1D6A:  MOVWF  xF8
1D6C:  MOVLW  51
1D6E:  MOVWF  xF7
1D70:  MOVLW  80
1D72:  MOVWF  xF6
1D74:  CALL   036A
1D78:  BTFSC  18.7
1D7A:  BSF    FF2.7
1D7C:  MOVFF  FEF,B6
1D80:  MOVFF  FEC,B7
1D84:  MOVFF  FEC,B8
1D88:  MOVFF  FEC,B9
....................  
.................... 		strcpy(tmp_str,"00/00/00"); 
1D8C:  CLRF   FEA
1D8E:  MOVLW  30
1D90:  MOVWF  FE9
1D92:  MOVFF  FF2,E5
1D96:  BCF    FF2.7
1D98:  MOVLW  00
1D9A:  CALL   00AA
1D9E:  TBLRD*-
1DA0:  TBLRD*+
1DA2:  MOVF   FF5,W
1DA4:  MOVWF  FEE
1DA6:  IORLW  00
1DA8:  BNZ   1DA0
1DAA:  BTFSC  xE5.7
1DAC:  BSF    FF2.7
.................... 		itoa((int8)DD,10,tmp_str2); 
1DAE:  CLRF   xEE
1DB0:  CLRF   xED
1DB2:  CLRF   xEC
1DB4:  MOVFF  B2,EB
1DB8:  MOVLW  0A
1DBA:  MOVWF  xEF
1DBC:  CLRF   xF1
1DBE:  MOVLW  44
1DC0:  MOVWF  xF0
1DC2:  CALL   14D6
.................... 		if (strlen(tmp_str2)==1) tmp_str[1]=tmp_str2[0]; else memcpy(tmp_str,tmp_str2,2); 
1DC6:  CLRF   xE8
1DC8:  MOVLW  44
1DCA:  MOVWF  xE7
1DCC:  RCALL  16BC
1DCE:  DECFSZ 01,W
1DD0:  BRA    1DD8
1DD2:  MOVFF  44,31
1DD6:  BRA    1DF0
1DD8:  CLRF   FEA
1DDA:  MOVLW  30
1DDC:  MOVWF  FE9
1DDE:  CLRF   FE2
1DE0:  MOVLW  44
1DE2:  MOVWF  FE1
1DE4:  MOVLW  02
1DE6:  MOVWF  01
1DE8:  MOVFF  FE6,FEE
1DEC:  DECFSZ 01,F
1DEE:  BRA    1DE8
.................... 		itoa((int8)MM,10,tmp_str2); 
1DF0:  CLRF   xEE
1DF2:  CLRF   xED
1DF4:  CLRF   xEC
1DF6:  MOVFF  AE,EB
1DFA:  MOVLW  0A
1DFC:  MOVWF  xEF
1DFE:  CLRF   xF1
1E00:  MOVLW  44
1E02:  MOVWF  xF0
1E04:  CALL   14D6
.................... 		if (strlen(tmp_str2)==1) tmp_str[4]=tmp_str2[0]; else memcpy(tmp_str+3,tmp_str2,2); 
1E08:  CLRF   xE8
1E0A:  MOVLW  44
1E0C:  MOVWF  xE7
1E0E:  RCALL  16BC
1E10:  DECFSZ 01,W
1E12:  BRA    1E1A
1E14:  MOVFF  44,34
1E18:  BRA    1E32
1E1A:  CLRF   FEA
1E1C:  MOVLW  33
1E1E:  MOVWF  FE9
1E20:  CLRF   FE2
1E22:  MOVLW  44
1E24:  MOVWF  FE1
1E26:  MOVLW  02
1E28:  MOVWF  01
1E2A:  MOVFF  FE6,FEE
1E2E:  DECFSZ 01,F
1E30:  BRA    1E2A
1E32:  CLRF   18
1E34:  BTFSC  FF2.7
1E36:  BSF    18.7
1E38:  BCF    FF2.7
.................... 		itoa((int8)(YY%2000),10,tmp_str2); 
1E3A:  MOVFF  AD,F5
1E3E:  MOVFF  AC,F4
1E42:  MOVFF  AB,F3
1E46:  MOVFF  AA,F2
1E4A:  CLRF   xF9
1E4C:  CLRF   xF8
1E4E:  MOVLW  07
1E50:  MOVWF  xF7
1E52:  MOVLW  D0
1E54:  MOVWF  xF6
1E56:  CALL   036A
1E5A:  BTFSC  18.7
1E5C:  BSF    FF2.7
1E5E:  MOVFF  FEF,00
1E62:  MOVFF  FEC,01
1E66:  MOVFF  FEC,02
1E6A:  MOVFF  FEC,03
1E6E:  MOVFF  00,E5
1E72:  CLRF   xEE
1E74:  CLRF   xED
1E76:  CLRF   xEC
1E78:  MOVFF  00,EB
1E7C:  MOVLW  0A
1E7E:  MOVWF  xEF
1E80:  CLRF   xF1
1E82:  MOVLW  44
1E84:  MOVWF  xF0
1E86:  CALL   14D6
.................... 		if (strlen(tmp_str2)==1) tmp_str[7]=tmp_str2[0]; else memcpy(tmp_str+6,tmp_str2,2); 
1E8A:  CLRF   xE8
1E8C:  MOVLW  44
1E8E:  MOVWF  xE7
1E90:  RCALL  16BC
1E92:  DECFSZ 01,W
1E94:  BRA    1E9C
1E96:  MOVFF  44,37
1E9A:  BRA    1EB4
1E9C:  CLRF   FEA
1E9E:  MOVLW  36
1EA0:  MOVWF  FE9
1EA2:  CLRF   FE2
1EA4:  MOVLW  44
1EA6:  MOVWF  FE1
1EA8:  MOVLW  02
1EAA:  MOVWF  01
1EAC:  MOVFF  FE6,FEE
1EB0:  DECFSZ 01,F
1EB2:  BRA    1EAC
.................... 		lcd_gotoxy(0,0); 
1EB4:  CLRF   xEF
1EB6:  CLRF   xF0
1EB8:  CALL   0D34
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
1EBC:  CLRF   xE8
1EBE:  MOVLW  30
1EC0:  MOVWF  xE7
1EC2:  CALL   16BC
1EC6:  MOVFF  01,E5
1ECA:  CLRF   xE7
1ECC:  MOVLW  30
1ECE:  MOVWF  xE6
1ED0:  MOVFF  01,E8
1ED4:  RCALL  16EE
.................... 		strcpy(tmp_str,"00:00:00"); 
1ED6:  CLRF   FEA
1ED8:  MOVLW  30
1EDA:  MOVWF  FE9
1EDC:  MOVFF  FF2,E5
1EE0:  BCF    FF2.7
1EE2:  MOVLW  00
1EE4:  CALL   00CE
1EE8:  TBLRD*-
1EEA:  TBLRD*+
1EEC:  MOVF   FF5,W
1EEE:  MOVWF  FEE
1EF0:  IORLW  00
1EF2:  BNZ   1EEA
1EF4:  BTFSC  xE5.7
1EF6:  BSF    FF2.7
1EF8:  CLRF   18
1EFA:  BTFSC  FF2.7
1EFC:  BSF    18.7
1EFE:  BCF    FF2.7
.................... 		itoa((int8) (time_of_day/3600),10,tmp_str2); 
1F00:  MOVFF  B9,F5
1F04:  MOVFF  B8,F4
1F08:  MOVFF  B7,F3
1F0C:  MOVFF  B6,F2
1F10:  CLRF   xF9
1F12:  CLRF   xF8
1F14:  MOVLW  0E
1F16:  MOVWF  xF7
1F18:  MOVLW  10
1F1A:  MOVWF  xF6
1F1C:  CALL   036A
1F20:  BTFSC  18.7
1F22:  BSF    FF2.7
1F24:  MOVFF  00,E5
1F28:  CLRF   xEE
1F2A:  CLRF   xED
1F2C:  CLRF   xEC
1F2E:  MOVFF  00,EB
1F32:  MOVLW  0A
1F34:  MOVWF  xEF
1F36:  CLRF   xF1
1F38:  MOVLW  44
1F3A:  MOVWF  xF0
1F3C:  CALL   14D6
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1F40:  CLRF   xE8
1F42:  MOVLW  44
1F44:  MOVWF  xE7
1F46:  CALL   16BC
1F4A:  MOVF   01,W
1F4C:  SUBLW  02
1F4E:  BNC   1F94
1F50:  CLRF   xE8
1F52:  MOVLW  44
1F54:  MOVWF  xE7
1F56:  CALL   16BC
1F5A:  MOVLW  32
1F5C:  BSF    FD8.0
1F5E:  SUBFWB 01,W
1F60:  MOVWF  xE5
1F62:  MOVLW  00
1F64:  BTFSS  FD8.0
1F66:  DECF   FE8,F
1F68:  MOVWF  xE6
1F6A:  CLRF   xE8
1F6C:  MOVLW  44
1F6E:  MOVWF  xE7
1F70:  CALL   16BC
1F74:  MOVFF  01,E7
1F78:  MOVFF  E6,FEA
1F7C:  MOVFF  E5,FE9
1F80:  CLRF   FE2
1F82:  MOVLW  44
1F84:  MOVWF  FE1
1F86:  MOVF   01,W
1F88:  MOVWF  01
1F8A:  BZ    1F94
1F8C:  MOVFF  FE6,FEE
1F90:  DECFSZ 01,F
1F92:  BRA    1F8C
1F94:  CLRF   18
1F96:  BTFSC  FF2.7
1F98:  BSF    18.7
1F9A:  BCF    FF2.7
.................... 		itoa((int8) ((time_of_day%3600)/60),10,tmp_str2); 
1F9C:  MOVFF  B9,F5
1FA0:  MOVFF  B8,F4
1FA4:  MOVFF  B7,F3
1FA8:  MOVFF  B6,F2
1FAC:  CLRF   xF9
1FAE:  CLRF   xF8
1FB0:  MOVLW  0E
1FB2:  MOVWF  xF7
1FB4:  MOVLW  10
1FB6:  MOVWF  xF6
1FB8:  CALL   036A
1FBC:  BTFSC  18.7
1FBE:  BSF    FF2.7
1FC0:  MOVFF  FEF,E5
1FC4:  MOVFF  FEC,E6
1FC8:  MOVFF  FEC,E7
1FCC:  MOVFF  FEC,E8
1FD0:  MOVFF  FEA,EA
1FD4:  MOVFF  FE9,E9
1FD8:  CLRF   18
1FDA:  BTFSC  FF2.7
1FDC:  BSF    18.7
1FDE:  BCF    FF2.7
1FE0:  MOVFF  E8,F5
1FE4:  MOVFF  E7,F4
1FE8:  MOVFF  E6,F3
1FEC:  MOVFF  E5,F2
1FF0:  CLRF   xF9
1FF2:  CLRF   xF8
1FF4:  CLRF   xF7
1FF6:  MOVLW  3C
1FF8:  MOVWF  xF6
1FFA:  CALL   036A
1FFE:  BTFSC  18.7
2000:  BSF    FF2.7
2002:  MOVFF  EA,FEA
2006:  MOVFF  E9,FE9
200A:  MOVFF  00,E6
200E:  CLRF   xEE
2010:  CLRF   xED
2012:  CLRF   xEC
2014:  MOVFF  00,EB
2018:  MOVLW  0A
201A:  MOVWF  xEF
201C:  CLRF   xF1
201E:  MOVLW  44
2020:  MOVWF  xF0
2022:  CALL   14D6
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2026:  CLRF   xE8
2028:  MOVLW  44
202A:  MOVWF  xE7
202C:  CALL   16BC
2030:  MOVF   01,W
2032:  SUBLW  02
2034:  BNC   207A
2036:  CLRF   xE8
2038:  MOVLW  44
203A:  MOVWF  xE7
203C:  CALL   16BC
2040:  MOVLW  35
2042:  BSF    FD8.0
2044:  SUBFWB 01,W
2046:  MOVWF  xE5
2048:  MOVLW  00
204A:  BTFSS  FD8.0
204C:  DECF   FE8,F
204E:  MOVWF  xE6
2050:  CLRF   xE8
2052:  MOVLW  44
2054:  MOVWF  xE7
2056:  CALL   16BC
205A:  MOVFF  01,E7
205E:  MOVFF  E6,FEA
2062:  MOVFF  E5,FE9
2066:  CLRF   FE2
2068:  MOVLW  44
206A:  MOVWF  FE1
206C:  MOVF   01,W
206E:  MOVWF  01
2070:  BZ    207A
2072:  MOVFF  FE6,FEE
2076:  DECFSZ 01,F
2078:  BRA    2072
207A:  CLRF   18
207C:  BTFSC  FF2.7
207E:  BSF    18.7
2080:  BCF    FF2.7
.................... 		itoa((int8) (time_of_day%60),10,tmp_str2); 
2082:  MOVFF  B9,F5
2086:  MOVFF  B8,F4
208A:  MOVFF  B7,F3
208E:  MOVFF  B6,F2
2092:  CLRF   xF9
2094:  CLRF   xF8
2096:  CLRF   xF7
2098:  MOVLW  3C
209A:  MOVWF  xF6
209C:  CALL   036A
20A0:  BTFSC  18.7
20A2:  BSF    FF2.7
20A4:  MOVFF  FEF,00
20A8:  MOVFF  FEC,01
20AC:  MOVFF  FEC,02
20B0:  MOVFF  FEC,03
20B4:  MOVFF  00,E5
20B8:  CLRF   xEE
20BA:  CLRF   xED
20BC:  CLRF   xEC
20BE:  MOVFF  00,EB
20C2:  MOVLW  0A
20C4:  MOVWF  xEF
20C6:  CLRF   xF1
20C8:  MOVLW  44
20CA:  MOVWF  xF0
20CC:  CALL   14D6
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
20D0:  CLRF   xE8
20D2:  MOVLW  44
20D4:  MOVWF  xE7
20D6:  CALL   16BC
20DA:  MOVF   01,W
20DC:  SUBLW  02
20DE:  BNC   2124
20E0:  CLRF   xE8
20E2:  MOVLW  44
20E4:  MOVWF  xE7
20E6:  CALL   16BC
20EA:  MOVLW  38
20EC:  BSF    FD8.0
20EE:  SUBFWB 01,W
20F0:  MOVWF  xE5
20F2:  MOVLW  00
20F4:  BTFSS  FD8.0
20F6:  DECF   FE8,F
20F8:  MOVWF  xE6
20FA:  CLRF   xE8
20FC:  MOVLW  44
20FE:  MOVWF  xE7
2100:  CALL   16BC
2104:  MOVFF  01,E7
2108:  MOVFF  E6,FEA
210C:  MOVFF  E5,FE9
2110:  CLRF   FE2
2112:  MOVLW  44
2114:  MOVWF  FE1
2116:  MOVF   01,W
2118:  MOVWF  01
211A:  BZ    2124
211C:  MOVFF  FE6,FEE
2120:  DECFSZ 01,F
2122:  BRA    211C
.................... 		lcd_gotoxy(10,0); 
2124:  MOVLW  0A
2126:  MOVWF  xEF
2128:  CLRF   xF0
212A:  CALL   0D34
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
212E:  CLRF   xE8
2130:  MOVLW  30
2132:  MOVWF  xE7
2134:  CALL   16BC
2138:  MOVFF  01,E5
213C:  CLRF   xE7
213E:  MOVLW  30
2140:  MOVWF  xE6
2142:  MOVFF  01,E8
2146:  CALL   16EE
....................  
....................  
.................... } 
214A:  RETLW  00
....................  
.................... void download_sun_table(int16 nPage) { 
....................     int16 i,j; 
.................... 	disable_interrupts(GLOBAL); 
*
2598:  BCF    FF2.6
259A:  BCF    FF2.7
259C:  BTFSC  FF2.7
259E:  BRA    259A
.................... 	restart_wdt(); 
25A0:  CLRWDT
.................... 	setup_wdt(WDT_OFF); 
25A2:  BCF    FD1.0
....................     output_high(FLASH_SELECT); 
25A4:  BCF    F92.1
25A6:  BSF    F89.1
....................     while(kbhit()) getc(); 
25A8:  BTFSS  F9E.5
25AA:  BRA    25B4
25AC:  BTFSS  F9E.5
25AE:  BRA    25AC
25B0:  MOVF   FAE,W
25B2:  BRA    25A8
....................     for (j=0;j<nPage+1;j++) { 
25B4:  CLRF   xD9
25B6:  CLRF   xD8
25B8:  MOVLW  01
25BA:  ADDWF  xD4,W
25BC:  MOVWF  01
25BE:  MOVLW  00
25C0:  ADDWFC xD5,W
25C2:  MOVWF  03
25C4:  MOVF   xD9,W
25C6:  SUBWF  03,W
25C8:  BNC   2668
25CA:  BNZ   25D2
25CC:  MOVF   01,W
25CE:  SUBWF  xD8,W
25D0:  BC    2668
....................      	ext_flash_waitUntilReady(); 
25D2:  RCALL  23F4
....................         printf("OK\r\n"); 
25D4:  CLRF   xDA
25D6:  MOVF   xDA,W
25D8:  CALL   00F2
25DC:  INCF   xDA,F
25DE:  MOVWF  00
25E0:  MOVF   00,W
25E2:  BTFSS  F9E.4
25E4:  BRA    25E2
25E6:  MOVWF  FAD
25E8:  MOVLW  04
25EA:  SUBWF  xDA,W
25EC:  BNZ   25D6
....................    		output_low(FLASH_SELECT); 
25EE:  BCF    F92.1
25F0:  BCF    F89.1
....................         if (j%2) ext_flash_sendData(0x82, 8); else ext_flash_sendData(0x85, 8); 
25F2:  MOVF   xD8,W
25F4:  ANDLW  01
25F6:  MOVWF  00
25F8:  CLRF   03
25FA:  MOVF   00,W
25FC:  IORWF  03,W
25FE:  BZ    260C
2600:  MOVLW  82
2602:  MOVWF  xFB
2604:  MOVLW  08
2606:  MOVWF  xFC
2608:  RCALL  252A
260A:  BRA    2616
260C:  MOVLW  85
260E:  MOVWF  xFB
2610:  MOVLW  08
2612:  MOVWF  xFC
2614:  RCALL  252A
....................    		ext_flash_send16Data(j+10, 15); // page address 
2616:  MOVLW  0A
2618:  ADDWF  xD8,W
261A:  MOVWF  xDA
261C:  MOVLW  00
261E:  ADDWFC xD9,W
2620:  MOVWF  xDB
2622:  MOVWF  xFC
2624:  MOVFF  DA,FB
2628:  MOVLW  0F
262A:  MOVWF  xFD
262C:  RCALL  255A
.................... 		ext_flash_send16Data(0, 9); 
262E:  CLRF   xFC
2630:  CLRF   xFB
2632:  MOVLW  09
2634:  MOVWF  xFD
2636:  RCALL  255A
.................... 		for (i=0;i<256;i++) { 
2638:  CLRF   xD7
263A:  CLRF   xD6
263C:  MOVF   xD7,W
263E:  SUBLW  00
2640:  BNC   265C
....................             ext_flash_sendData(getc(), 8); 
2642:  BTFSS  F9E.5
2644:  BRA    2642
2646:  MOVFF  FAE,DA
264A:  MOVFF  DA,FB
264E:  MOVLW  08
2650:  MOVWF  xFC
2652:  RCALL  252A
.................... 		} 
2654:  INCF   xD6,F
2656:  BTFSC  FD8.2
2658:  INCF   xD7,F
265A:  BRA    263C
....................        output_high(FLASH_SELECT); 
265C:  BCF    F92.1
265E:  BSF    F89.1
.................... 	} 
2660:  INCF   xD8,F
2662:  BTFSC  FD8.2
2664:  INCF   xD9,F
2666:  BRA    25B8
.................... 	enable_interrupts(GLOBAL); 
2668:  MOVLW  C0
266A:  IORWF  FF2,F
.................... 	restart_wdt(); 
266C:  CLRWDT
.................... 	setup_wdt(WDT_ON); 
266E:  BSF    FD1.0
....................  
.................... } 
2670:  GOTO   34AE (RETURN)
.................... /* 
.................... void print_page_data(int16 nPage) { 
....................     char temp[256]; 
....................     int16 i; 
....................     int32 time_index; 
....................  
.................... 	ext_flash_readPage(nPage,0,temp,264); 
....................     for(i=0;i<264;i++) { 
.................... 		if((i%16) ==0) printf("\r\n%02X : ",i); 
.................... 		printf("%02X ",temp[i]); 
.................... 	} 
.................... 	memcpy(&time_index,temp,4); 
....................     printf("\r\n Timer Index: %Lu",time_index);	 
....................  
.................... } 
.................... */ 
.................... void print_page_data(int16 nPage) { 
....................     char temp[17]; 
....................     int8 i; 
.................... 	int8 j; 
....................  
....................     for(i=0;i<16;i++) { 
*
2784:  CLRF   xE7
2786:  MOVF   xE7,W
2788:  SUBLW  0F
278A:  BNC   2814
.................... 		printf("\r\n%02X : ",i); 
278C:  MOVLW  0D
278E:  BTFSS  F9E.4
2790:  BRA    278E
2792:  MOVWF  FAD
2794:  MOVLW  0A
2796:  BTFSS  F9E.4
2798:  BRA    2796
279A:  MOVWF  FAD
279C:  MOVFF  E7,EA
27A0:  MOVLW  37
27A2:  MOVWF  xEB
27A4:  RCALL  2674
27A6:  MOVLW  20
27A8:  BTFSS  F9E.4
27AA:  BRA    27A8
27AC:  MOVWF  FAD
27AE:  MOVLW  3A
27B0:  BTFSS  F9E.4
27B2:  BRA    27B0
27B4:  MOVWF  FAD
27B6:  MOVLW  20
27B8:  BTFSS  F9E.4
27BA:  BRA    27B8
27BC:  MOVWF  FAD
.................... 		ext_flash_readPage(nPage,i*16,temp,16); 
27BE:  MOVF   xE7,W
27C0:  MULLW  10
27C2:  MOVFF  FF3,E9
27C6:  MOVFF  D5,F5
27CA:  MOVFF  D4,F4
27CE:  MOVFF  E9,F6
27D2:  CLRF   xF8
27D4:  MOVLW  D6
27D6:  MOVWF  xF7
27D8:  CLRF   xFA
27DA:  MOVLW  10
27DC:  MOVWF  xF9
27DE:  RCALL  272C
.................... 		for (j=0;j<16;j++) printf("%02X ",temp[j]); 
27E0:  CLRF   xE8
27E2:  MOVF   xE8,W
27E4:  SUBLW  0F
27E6:  BNC   2810
27E8:  CLRF   03
27EA:  MOVF   xE8,W
27EC:  ADDLW  D6
27EE:  MOVWF  FE9
27F0:  MOVLW  00
27F2:  ADDWFC 03,W
27F4:  MOVWF  FEA
27F6:  MOVFF  FEF,E9
27FA:  MOVFF  E9,EA
27FE:  MOVLW  37
2800:  MOVWF  xEB
2802:  RCALL  2674
2804:  MOVLW  20
2806:  BTFSS  F9E.4
2808:  BRA    2806
280A:  MOVWF  FAD
280C:  INCF   xE8,F
280E:  BRA    27E2
.................... 	} 
2810:  INCF   xE7,F
2812:  BRA    2786
.................... } 
2814:  GOTO   3096 (RETURN)
....................  
.................... int32 get_timer_index(int16 nDay) { // 1 page contain 2 subpage 
....................     char temp[6]; 
....................     int32 time_index; 
.................... 	ext_flash_readPage((nDay/2)+10,128*(nDay%2),temp,4); 
*
2B90:  BCF    FD8.0
2B92:  RRCF   xE3,W
2B94:  MOVWF  xEF
2B96:  RRCF   xE2,W
2B98:  MOVWF  xEE
2B9A:  MOVLW  0A
2B9C:  ADDWF  xEE,W
2B9E:  MOVWF  xF0
2BA0:  MOVLW  00
2BA2:  ADDWFC xEF,W
2BA4:  MOVWF  xF1
2BA6:  MOVF   xE2,W
2BA8:  ANDLW  01
2BAA:  MOVWF  00
2BAC:  CLRF   03
2BAE:  MOVWF  02
2BB0:  RLCF   00,W
2BB2:  MOVWF  xF2
2BB4:  RLCF   03,W
2BB6:  MOVWF  xF3
2BB8:  RLCF   xF2,F
2BBA:  RLCF   xF3,F
2BBC:  RLCF   xF2,F
2BBE:  RLCF   xF3,F
2BC0:  RLCF   xF2,F
2BC2:  RLCF   xF3,F
2BC4:  RLCF   xF2,F
2BC6:  RLCF   xF3,F
2BC8:  RLCF   xF2,F
2BCA:  RLCF   xF3,F
2BCC:  RLCF   xF2,F
2BCE:  RLCF   xF3,F
2BD0:  MOVLW  80
2BD2:  ANDWF  xF2,F
2BD4:  MOVFF  F1,F5
2BD8:  MOVFF  F0,F4
2BDC:  MOVFF  F2,F6
2BE0:  CLRF   xF8
2BE2:  MOVLW  E4
2BE4:  MOVWF  xF7
2BE6:  CLRF   xFA
2BE8:  MOVLW  04
2BEA:  MOVWF  xF9
2BEC:  RCALL  272C
.................... 	memcpy(&time_index,temp,4); 
2BEE:  CLRF   FEA
2BF0:  MOVLW  EA
2BF2:  MOVWF  FE9
2BF4:  CLRF   FE2
2BF6:  MOVLW  E4
2BF8:  MOVWF  FE1
2BFA:  MOVLW  04
2BFC:  MOVWF  01
2BFE:  MOVFF  FE6,FEE
2C02:  DECFSZ 01,F
2C04:  BRA    2BFE
.................... 	return time_index; 
2C06:  MOVFF  EA,00
2C0A:  MOVFF  EB,01
2C0E:  MOVFF  EC,02
2C12:  MOVFF  ED,03
.................... } 
2C16:  RETLW  00
....................  
.................... int16 find_day_number(int32 tsec) // return day number after 1-jan-2010, we use this to search for sun angle in flash memory page 
.................... { 
.................... 	return (((tsec+((int8)UTC)*3600)/86400)%1461); 
*
2AF6:  MOVLW  70
2AF8:  ADDWF  xE2,W
2AFA:  MOVWF  xE6
2AFC:  MOVLW  62
2AFE:  ADDWFC xE3,W
2B00:  MOVWF  xE7
2B02:  MOVLW  00
2B04:  ADDWFC xE4,W
2B06:  MOVWF  xE8
2B08:  MOVLW  00
2B0A:  ADDWFC xE5,W
2B0C:  MOVWF  xE9
2B0E:  CLRF   18
2B10:  BTFSC  FF2.7
2B12:  BSF    18.7
2B14:  BCF    FF2.7
2B16:  MOVWF  xF5
2B18:  MOVFF  E8,F4
2B1C:  MOVFF  E7,F3
2B20:  MOVFF  E6,F2
2B24:  CLRF   xF9
2B26:  MOVLW  01
2B28:  MOVWF  xF8
2B2A:  MOVLW  51
2B2C:  MOVWF  xF7
2B2E:  MOVLW  80
2B30:  MOVWF  xF6
2B32:  CALL   036A
2B36:  BTFSC  18.7
2B38:  BSF    FF2.7
2B3A:  MOVFF  03,EA
2B3E:  MOVFF  02,E9
2B42:  MOVFF  01,E8
2B46:  MOVFF  00,E7
2B4A:  CLRF   18
2B4C:  BTFSC  FF2.7
2B4E:  BSF    18.7
2B50:  BCF    FF2.7
2B52:  MOVFF  03,F5
2B56:  MOVFF  02,F4
2B5A:  MOVFF  01,F3
2B5E:  MOVFF  00,F2
2B62:  CLRF   xF9
2B64:  CLRF   xF8
2B66:  MOVLW  05
2B68:  MOVWF  xF7
2B6A:  MOVLW  B5
2B6C:  MOVWF  xF6
2B6E:  CALL   036A
2B72:  BTFSC  18.7
2B74:  BSF    FF2.7
2B76:  MOVFF  FEF,00
2B7A:  MOVFF  FEC,01
2B7E:  MOVFF  FEC,02
2B82:  MOVFF  FEC,03
2B86:  MOVFF  01,02
2B8A:  MOVFF  00,01
.................... } 
2B8E:  RETLW  00
....................  
.................... unsigned int8 current_sun_angle(unsigned int32 t_sec) { 
.................... 	unsigned int16 today;  // current day (count after epoch) 
.................... 	unsigned int32 sun_rise_t_sec; // time of day . compensated for time zone 
.................... 	unsigned int8 sun_data; 
.................... 	today = find_day_number(t_sec); // day after epoch 
*
3524:  MOVFF  DA,E5
3528:  MOVFF  D9,E4
352C:  MOVFF  D8,E3
3530:  MOVFF  D7,E2
3534:  CALL   2AF6
3538:  MOVFF  02,DC
353C:  MOVFF  01,DB
....................     sun_rise_t_sec = get_timer_index(today)*450; 
3540:  MOVFF  DC,E3
3544:  MOVFF  DB,E2
3548:  CALL   2B90
354C:  MOVFF  03,E5
3550:  MOVFF  02,E4
3554:  MOVFF  01,E3
3558:  MOVFF  00,E2
355C:  MOVFF  FEA,E7
3560:  MOVFF  FE9,E6
3564:  MOVFF  03,FD
3568:  MOVFF  02,FC
356C:  MOVFF  01,FB
3570:  MOVFF  00,FA
3574:  MOVLB  1
3576:  CLRF   x01
3578:  CLRF   x00
357A:  MOVLW  01
357C:  MOVLB  0
357E:  MOVWF  xFF
3580:  MOVLW  C2
3582:  MOVWF  xFE
3584:  CALL   1392
3588:  MOVFF  E7,FEA
358C:  MOVFF  E6,FE9
3590:  MOVFF  03,E0
3594:  MOVFF  02,DF
3598:  MOVFF  01,DE
359C:  MOVFF  00,DD
35A0:  CLRF   18
35A2:  BTFSC  FF2.7
35A4:  BSF    18.7
35A6:  BCF    FF2.7
....................     if (sun_rise_t_sec > t_sec%SEC_IN_4_YEARS) return 0x0; // sun havent up yet, angle is 0 
35A8:  MOVFF  DA,F5
35AC:  MOVFF  D9,F4
35B0:  MOVFF  D8,F3
35B4:  MOVFF  D7,F2
35B8:  MOVLW  07
35BA:  MOVWF  xF9
35BC:  MOVLW  86
35BE:  MOVWF  xF8
35C0:  MOVLW  1F
35C2:  MOVWF  xF7
35C4:  MOVLW  80
35C6:  MOVWF  xF6
35C8:  CALL   036A
35CC:  BTFSC  18.7
35CE:  BSF    FF2.7
35D0:  MOVFF  FEF,00
35D4:  MOVFF  FEC,01
35D8:  MOVFF  FEC,02
35DC:  MOVFF  FEC,03
35E0:  MOVF   03,W
35E2:  SUBWF  xE0,W
35E4:  BNC   3604
35E6:  BNZ   35FE
35E8:  MOVF   02,W
35EA:  SUBWF  xDF,W
35EC:  BNC   3604
35EE:  BNZ   35FE
35F0:  MOVF   01,W
35F2:  SUBWF  xDE,W
35F4:  BNC   3604
35F6:  BNZ   35FE
35F8:  MOVF   xDD,W
35FA:  SUBWF  00,W
35FC:  BC    3604
35FE:  MOVLW  00
3600:  MOVWF  01
3602:  BRA    3732
3604:  CLRF   18
3606:  BTFSC  FF2.7
3608:  BSF    18.7
360A:  BCF    FF2.7
.................... 	index_in_page = (t_sec%SEC_IN_4_YEARS-sun_rise_t_sec)/450; 
360C:  MOVFF  DA,F5
3610:  MOVFF  D9,F4
3614:  MOVFF  D8,F3
3618:  MOVFF  D7,F2
361C:  MOVLW  07
361E:  MOVWF  xF9
3620:  MOVLW  86
3622:  MOVWF  xF8
3624:  MOVLW  1F
3626:  MOVWF  xF7
3628:  MOVLW  80
362A:  MOVWF  xF6
362C:  CALL   036A
3630:  BTFSC  18.7
3632:  BSF    FF2.7
3634:  MOVFF  FEF,E2
3638:  MOVFF  FEC,E3
363C:  MOVFF  FEC,E4
3640:  MOVFF  FEC,E5
3644:  MOVF   xDD,W
3646:  SUBWF  xE2,W
3648:  MOVWF  xE6
364A:  MOVF   xDE,W
364C:  SUBWFB xE3,W
364E:  MOVWF  xE7
3650:  MOVF   xDF,W
3652:  SUBWFB xE4,W
3654:  MOVWF  xE8
3656:  MOVF   xE0,W
3658:  SUBWFB xE5,W
365A:  MOVWF  xE9
365C:  MOVFF  FEA,EB
3660:  MOVFF  FE9,EA
3664:  CLRF   18
3666:  BTFSC  FF2.7
3668:  BSF    18.7
366A:  BCF    FF2.7
366C:  MOVWF  xF5
366E:  MOVFF  E8,F4
3672:  MOVFF  E7,F3
3676:  MOVFF  E6,F2
367A:  CLRF   xF9
367C:  CLRF   xF8
367E:  MOVLW  01
3680:  MOVWF  xF7
3682:  MOVLW  C2
3684:  MOVWF  xF6
3686:  CALL   036A
368A:  BTFSC  18.7
368C:  BSF    FF2.7
368E:  MOVFF  EB,FEA
3692:  MOVFF  EA,FE9
3696:  MOVFF  00,CB
....................     if (index_in_page>=124) return 0xFF; // exceed page size , sun went down 
369A:  MOVF   xCB,W
369C:  SUBLW  7B
369E:  BC    36A6
36A0:  MOVLW  FF
36A2:  MOVWF  01
36A4:  BRA    3732
....................     ext_flash_readPage((today/2)+10,128*(today%2)+4+index_in_page,&sun_data,1); 
36A6:  BCF    FD8.0
36A8:  RRCF   xDC,W
36AA:  MOVWF  xE3
36AC:  RRCF   xDB,W
36AE:  MOVWF  xE2
36B0:  MOVLW  0A
36B2:  ADDWF  xE2,W
36B4:  MOVWF  xE4
36B6:  MOVLW  00
36B8:  ADDWFC xE3,W
36BA:  MOVWF  xE5
36BC:  MOVF   xDB,W
36BE:  ANDLW  01
36C0:  MOVWF  00
36C2:  CLRF   03
36C4:  MOVWF  02
36C6:  RLCF   00,W
36C8:  MOVWF  xE6
36CA:  RLCF   03,W
36CC:  MOVWF  xE7
36CE:  RLCF   xE6,F
36D0:  RLCF   xE7,F
36D2:  RLCF   xE6,F
36D4:  RLCF   xE7,F
36D6:  RLCF   xE6,F
36D8:  RLCF   xE7,F
36DA:  RLCF   xE6,F
36DC:  RLCF   xE7,F
36DE:  RLCF   xE6,F
36E0:  RLCF   xE7,F
36E2:  RLCF   xE6,F
36E4:  RLCF   xE7,F
36E6:  MOVLW  80
36E8:  ANDWF  xE6,F
36EA:  MOVLW  04
36EC:  ADDWF  xE6,W
36EE:  MOVWF  xE8
36F0:  MOVLW  00
36F2:  ADDWFC xE7,W
36F4:  MOVWF  xE9
36F6:  MOVF   xCB,W
36F8:  ADDWF  xE8,W
36FA:  MOVWF  xEA
36FC:  MOVLW  00
36FE:  ADDWFC xE9,W
3700:  MOVWF  xEB
3702:  MOVFF  E5,F5
3706:  MOVFF  E4,F4
370A:  MOVFF  EA,F6
370E:  CLRF   xF8
3710:  MOVLW  E1
3712:  MOVWF  xF7
3714:  CLRF   xFA
3716:  MOVLW  01
3718:  MOVWF  xF9
371A:  CALL   272C
.................... 	if ((index_in_page>5) && (sun_data==0)) return 0xFF; // sun went down 
371E:  MOVF   xCB,W
3720:  SUBLW  05
3722:  BC    372E
3724:  MOVF   xE1,F
3726:  BNZ   372E
3728:  MOVLW  FF
372A:  MOVWF  01
372C:  BRA    3732
.................... 	return sun_data; 
372E:  MOVFF  E1,01
.................... 	 
.................... } 
3732:  GOTO   391A (RETURN)
....................  
....................  
.................... int16 move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,boolean direction,boolean abort_when_task_armed) { 
.................... 	// direction 0 = east, 1=west 
.................... 	unsigned int16 xxx=0; 
*
214C:  CLRF   xDE
214E:  CLRF   xDF
.................... 	unsigned int16 yyy=0; 
2150:  CLRF   xE0
2152:  CLRF   xE1
.................... 	int16 actuator_pulse=0; 
2154:  CLRF   xE2
2156:  CLRF   xE3
.................... 	int8 rt=5; 
2158:  MOVLW  05
215A:  MOVWF  xE4
.................... 	output_low(CCW); 
215C:  BCF    F93.4
215E:  BCF    F8A.4
.................... 	output_low(EN0); 
2160:  BCF    F93.0
2162:  BCF    F8A.0
.................... 	output_low(EN1); 
2164:  BCF    F93.1
2166:  BCF    F8A.1
.................... 	output_low(EN2); 
2168:  BCF    F93.2
216A:  BCF    F8A.2
.................... 	output_low(EN3); 
216C:  BCF    F93.3
216E:  BCF    F8A.3
.................... 	output_low(PS_EN); 
2170:  BCF    F94.1
2172:  BCF    F8B.1
....................  
.................... 	if (!direction)	output_high(CCW); 
2174:  MOVF   xDC,F
2176:  BNZ   217C
2178:  BCF    F93.4
217A:  BSF    F8A.4
.................... 	output_high(PS_EN); 
217C:  BCF    F94.1
217E:  BSF    F8B.1
.................... 	output_high(EN0); 
2180:  BCF    F93.0
2182:  BSF    F8A.0
....................     delay_ms(10); 
2184:  MOVLW  0A
2186:  MOVWF  xEF
2188:  CALL   05A2
....................  
.................... 	flag.prev_pulse_state = input(PIN_A2); //A2 = sensor wire for actuator 1 
218C:  BSF    F92.2
218E:  BCF    1F.2
2190:  BTFSC  F80.2
2192:  BSF    1F.2
.................... 	tick = timer_sec; 
2194:  MOVFF  27,2B
2198:  MOVFF  26,2A
219C:  MOVFF  25,29
21A0:  MOVFF  24,28
.................... 	tick2 = timer_sec; 
21A4:  MOVFF  27,2F
21A8:  MOVFF  26,2E
21AC:  MOVFF  25,2D
21B0:  MOVFF  24,2C
.................... 	actuator_pulse =0; 
21B4:  CLRF   xE3
21B6:  CLRF   xE2
.................... 	while(1) { 
.................... 		xxx = (int16) (timer_sec-tick); 
21B8:  MOVF   28,W
21BA:  SUBWF  24,W
21BC:  MOVWF  00
21BE:  MOVF   29,W
21C0:  SUBWFB 25,W
21C2:  MOVWF  01
21C4:  MOVF   2A,W
21C6:  SUBWFB 26,W
21C8:  MOVF   2B,W
21CA:  SUBWFB 27,W
21CC:  MOVFF  01,DF
21D0:  MOVFF  00,DE
.................... 		yyy = (int16) (timer_sec-tick2); 
21D4:  MOVF   2C,W
21D6:  SUBWF  24,W
21D8:  MOVWF  00
21DA:  MOVF   2D,W
21DC:  SUBWFB 25,W
21DE:  MOVWF  01
21E0:  MOVF   2E,W
21E2:  SUBWFB 26,W
21E4:  MOVF   2F,W
21E6:  SUBWFB 27,W
21E8:  MOVFF  01,E1
21EC:  MOVFF  00,E0
.................... 		if ( xxx>= time_out_sec)  
21F0:  MOVF   xD9,W
21F2:  SUBWF  xDF,W
21F4:  BNC   2200
21F6:  BNZ   21FE
21F8:  MOVF   xD8,W
21FA:  SUBWF  xDE,W
21FC:  BNC   2200
.................... 			break; 
21FE:  BRA    22E6
....................  		if (actuator_pulse >= nPulse) 
2200:  MOVF   xD7,W
2202:  SUBWF  xE3,W
2204:  BNC   2212
2206:  BNZ   220E
2208:  MOVF   xD6,W
220A:  SUBWF  xE2,W
220C:  BNC   2212
.................... 			output_low(EN0); 
220E:  BCF    F93.0
2210:  BCF    F8A.0
.................... 		if ( yyy >=stuck_sec) 
2212:  MOVF   xDB,W
2214:  SUBWF  xE1,W
2216:  BNC   2222
2218:  BNZ   2220
221A:  MOVF   xDA,W
221C:  SUBWF  xE0,W
221E:  BNC   2222
.................... 			break; 
2220:  BRA    22E6
.................... 		if (abort_when_task_armed && (flag.task1_armed||flag.cmd_posted)) 
2222:  MOVF   xDD,F
2224:  BZ    2230
2226:  BTFSC  1F.0
2228:  BRA    222E
222A:  BTFSS  1F.3
222C:  BRA    2230
.................... 			break; 
222E:  BRA    22E6
.................... 		if (flag.prev_pulse_state != input(PIN_A2)) { 
2230:  MOVLW  00
2232:  BTFSC  1F.2
2234:  MOVLW  01
2236:  MOVWF  xE5
2238:  BSF    F92.2
223A:  MOVLW  00
223C:  BTFSC  F80.2
223E:  MOVLW  01
2240:  SUBWF  xE5,W
2242:  BZ    22DA
.................... 			tick2 = timer_sec; 
2244:  MOVFF  27,2F
2248:  MOVFF  26,2E
224C:  MOVFF  25,2D
2250:  MOVFF  24,2C
.................... 			flag.prev_pulse_state = input(PIN_A2); 
2254:  BSF    F92.2
2256:  BCF    1F.2
2258:  BTFSC  F80.2
225A:  BSF    1F.2
.................... 			if (!direction && (current_act_position >0)) current_act_position--; 
225C:  MOVF   xDC,F
225E:  BNZ   2270
2260:  MOVF   x72,F
2262:  BNZ   2268
2264:  MOVF   x73,F
2266:  BZ    2270
2268:  MOVF   x72,W
226A:  BTFSC  FD8.2
226C:  DECF   x73,F
226E:  DECF   x72,F
.................... 			if (direction && (current_act_position < FULL_STROKE_TICK)) current_act_position++; 
2270:  MOVF   xDC,F
2272:  BZ    2288
2274:  MOVF   x73,W
2276:  SUBWF  xBF,W
2278:  BNC   2288
227A:  BNZ   2282
227C:  MOVF   xBE,W
227E:  SUBWF  x72,W
2280:  BC    2288
2282:  INCF   x72,F
2284:  BTFSC  FD8.2
2286:  INCF   x73,F
.................... 			actuator_pulse=actuator_pulse+1; 
2288:  MOVLW  01
228A:  ADDWF  xE2,F
228C:  MOVLW  00
228E:  ADDWFC xE3,F
.................... 			lcd_gotoxy(16,2); 
2290:  MOVLW  10
2292:  MOVWF  xEF
2294:  MOVLW  02
2296:  MOVWF  xF0
2298:  CALL   0D34
.................... 			if (actuator_pulse%2==0)	lcd_putc('/'); else  lcd_putc('\\'); 
229C:  MOVF   xE2,W
229E:  ANDLW  01
22A0:  MOVWF  xE5
22A2:  CLRF   xE6
22A4:  MOVF   xE5,F
22A6:  BNZ   22B6
22A8:  MOVF   xE6,F
22AA:  BNZ   22B6
22AC:  MOVLW  2F
22AE:  MOVWF  xEE
22B0:  CALL   0D5A
22B4:  BRA    22BE
22B6:  MOVLW  5C
22B8:  MOVWF  xEE
22BA:  CALL   0D5A
.................... 			lcd_gotoxy(17,2); 
22BE:  MOVLW  11
22C0:  MOVWF  xEF
22C2:  MOVLW  02
22C4:  MOVWF  xF0
22C6:  CALL   0D34
.................... 			printf(lcd_putc,"%03lu",current_act_position); 
22CA:  MOVLW  0A
22CC:  MOVWF  FE9
22CE:  MOVFF  73,E6
22D2:  MOVFF  72,E5
22D6:  CALL   0D9E
.................... 		} 
.................... 		if (flag.update_time) { 
22DA:  BTFSS  1F.1
22DC:  BRA    22E4
.................... 			flag.update_time = false; 
22DE:  BCF    1F.1
.................... 			print_date_time(); 
22E0:  CALL   1716
.................... 		} 
.................... 	} 
22E4:  BRA    21B8
....................     printf(lcd_putc,"%03lu",current_act_position); 
22E6:  MOVLW  0A
22E8:  MOVWF  FE9
22EA:  MOVFF  73,E6
22EE:  MOVFF  72,E5
22F2:  CALL   0D9E
.................... 	output_low(EN0); 
22F6:  BCF    F93.0
22F8:  BCF    F8A.0
.................... 	output_low(EN1); 
22FA:  BCF    F93.1
22FC:  BCF    F8A.1
.................... 	output_low(EN2); 
22FE:  BCF    F93.2
2300:  BCF    F8A.2
.................... 	output_low(EN3); 
2302:  BCF    F93.3
2304:  BCF    F8A.3
.................... 	output_low(PS_EN); 
2306:  BCF    F94.1
2308:  BCF    F8B.1
.................... 	output_low(CCW); 
230A:  BCF    F93.4
230C:  BCF    F8A.4
.................... 	return actuator_pulse; 
230E:  MOVFF  E2,01
2312:  MOVFF  E3,02
.................... } 
2316:  RETLW  00
....................  
.................... int8 task1() { 
.................... 	int8 sun_angle; 
.................... 		lcd_init(); 
*
376E:  CALL   0A90
3772:  CLRF   18
3774:  BTFSC  FF2.7
3776:  BSF    18.7
3778:  BCF    FF2.7
.................... 		if (timer_sec%SEC_IN_4_YEARS >= next_sun_rise) {// now the sun has risen, get tomorrow sun rise time. 
377A:  MOVFF  27,F5
377E:  MOVFF  26,F4
3782:  MOVFF  25,F3
3786:  MOVFF  24,F2
378A:  MOVLW  07
378C:  MOVWF  xF9
378E:  MOVLW  86
3790:  MOVWF  xF8
3792:  MOVLW  1F
3794:  MOVWF  xF7
3796:  MOVLW  80
3798:  MOVWF  xF6
379A:  CALL   036A
379E:  BTFSC  18.7
37A0:  BSF    FF2.7
37A2:  MOVFF  FEF,D3
37A6:  MOVFF  FEC,D4
37AA:  MOVFF  FEC,D5
37AE:  MOVFF  FEC,D6
37B2:  MOVF   x71,W
37B4:  SUBWF  xD6,W
37B6:  BTFSS  FD8.0
37B8:  BRA    38A4
37BA:  BNZ   37D2
37BC:  MOVF   x70,W
37BE:  SUBWF  xD5,W
37C0:  BNC   38A4
37C2:  BNZ   37D2
37C4:  MOVF   x6F,W
37C6:  SUBWF  xD4,W
37C8:  BNC   38A4
37CA:  BNZ   37D2
37CC:  MOVF   x6E,W
37CE:  SUBWF  xD3,W
37D0:  BNC   38A4
.................... 	    	next_sun_rise=get_timer_index(find_day_number((next_sun_rise+86400)%SEC_IN_4_YEARS))*450; 
37D2:  MOVLW  80
37D4:  ADDWF  x6E,W
37D6:  MOVWF  xD3
37D8:  MOVLW  51
37DA:  ADDWFC x6F,W
37DC:  MOVWF  xD4
37DE:  MOVLW  01
37E0:  ADDWFC x70,W
37E2:  MOVWF  xD5
37E4:  MOVLW  00
37E6:  ADDWFC x71,W
37E8:  MOVWF  xD6
37EA:  CLRF   18
37EC:  BTFSC  FF2.7
37EE:  BSF    18.7
37F0:  BCF    FF2.7
37F2:  MOVWF  xF5
37F4:  MOVFF  D5,F4
37F8:  MOVFF  D4,F3
37FC:  MOVFF  D3,F2
3800:  MOVLW  07
3802:  MOVWF  xF9
3804:  MOVLW  86
3806:  MOVWF  xF8
3808:  MOVLW  1F
380A:  MOVWF  xF7
380C:  MOVLW  80
380E:  MOVWF  xF6
3810:  CALL   036A
3814:  BTFSC  18.7
3816:  BSF    FF2.7
3818:  MOVFF  FEF,D4
381C:  MOVFF  FEC,D5
3820:  MOVFF  FEC,D6
3824:  MOVFF  FEC,D7
3828:  MOVFF  D7,E5
382C:  MOVFF  D6,E4
3830:  MOVFF  D5,E3
3834:  MOVFF  D4,E2
3838:  CALL   2AF6
383C:  MOVFF  02,D6
3840:  MOVFF  01,D5
3844:  MOVFF  02,E3
3848:  MOVFF  01,E2
384C:  CALL   2B90
3850:  MOVFF  03,D9
3854:  MOVFF  02,D8
3858:  MOVFF  01,D7
385C:  MOVFF  00,D6
3860:  MOVFF  FEA,DB
3864:  MOVFF  FE9,DA
3868:  MOVFF  03,FD
386C:  MOVFF  02,FC
3870:  MOVFF  01,FB
3874:  MOVFF  00,FA
3878:  MOVLB  1
387A:  CLRF   x01
387C:  CLRF   x00
387E:  MOVLW  01
3880:  MOVLB  0
3882:  MOVWF  xFF
3884:  MOVLW  C2
3886:  MOVWF  xFE
3888:  CALL   1392
388C:  MOVFF  DB,FEA
3890:  MOVFF  DA,FE9
3894:  MOVFF  03,71
3898:  MOVFF  02,70
389C:  MOVFF  01,6F
38A0:  MOVFF  00,6E
.................... 		} 
....................         sec_until_sun_rise = (int32) (next_sun_rise-timer_sec); 
38A4:  MOVF   24,W
38A6:  SUBWF  x6E,W
38A8:  MOVWF  00
38AA:  MOVF   25,W
38AC:  SUBWFB x6F,W
38AE:  MOVWF  01
38B0:  MOVF   26,W
38B2:  SUBWFB x70,W
38B4:  MOVWF  02
38B6:  MOVF   27,W
38B8:  SUBWFB x71,W
38BA:  MOVWF  xBD
38BC:  MOVFF  02,BC
38C0:  MOVFF  01,BB
38C4:  MOVFF  00,BA
38C8:  CLRF   18
38CA:  BTFSC  FF2.7
38CC:  BSF    18.7
38CE:  BCF    FF2.7
.................... 		sun_angle=current_sun_angle(timer_sec%SEC_IN_4_YEARS); 
38D0:  MOVFF  27,F5
38D4:  MOVFF  26,F4
38D8:  MOVFF  25,F3
38DC:  MOVFF  24,F2
38E0:  MOVLW  07
38E2:  MOVWF  xF9
38E4:  MOVLW  86
38E6:  MOVWF  xF8
38E8:  MOVLW  1F
38EA:  MOVWF  xF7
38EC:  MOVLW  80
38EE:  MOVWF  xF6
38F0:  CALL   036A
38F4:  BTFSC  18.7
38F6:  BSF    FF2.7
38F8:  MOVFF  FEF,D3
38FC:  MOVFF  FEC,D4
3900:  MOVFF  FEC,D5
3904:  MOVFF  FEC,D6
3908:  MOVFF  D6,DA
390C:  MOVFF  D5,D9
3910:  MOVFF  D4,D8
3914:  MOVFF  D3,D7
3918:  BRA    3524
391A:  MOVFF  01,D2
....................  
.................... 		// prepare buffer1 
.................... 		if (sun_angle==0x00) // sun havent' come up yet, clear buffer1 
391E:  MOVF   xD2,F
3920:  BNZ   39AC
3922:  CLRF   18
3924:  BTFSC  FF2.7
3926:  BSF    18.7
3928:  BCF    FF2.7
.................... 		{ 
.................... 			if(find_day_number(timer_sec%SEC_IN_4_YEARS)%2==0)  
392A:  MOVFF  27,F5
392E:  MOVFF  26,F4
3932:  MOVFF  25,F3
3936:  MOVFF  24,F2
393A:  MOVLW  07
393C:  MOVWF  xF9
393E:  MOVLW  86
3940:  MOVWF  xF8
3942:  MOVLW  1F
3944:  MOVWF  xF7
3946:  MOVLW  80
3948:  MOVWF  xF6
394A:  CALL   036A
394E:  BTFSC  18.7
3950:  BSF    FF2.7
3952:  MOVFF  FEF,D3
3956:  MOVFF  FEC,D4
395A:  MOVFF  FEC,D5
395E:  MOVFF  FEC,D6
3962:  MOVFF  D6,E5
3966:  MOVFF  D5,E4
396A:  MOVFF  D4,E3
396E:  MOVFF  D3,E2
3972:  CALL   2AF6
3976:  MOVFF  02,D5
397A:  MOVF   01,W
397C:  MOVWF  xD4
397E:  ANDLW  01
3980:  MOVWF  xD6
3982:  CLRF   xD7
3984:  MOVF   xD6,F
3986:  BNZ   399C
3988:  MOVF   xD7,F
398A:  BNZ   399C
.................... 				ext_flash_buffer1_write(0xAA,0,127); 
398C:  MOVLW  AA
398E:  MOVWF  xDD
3990:  CLRF   xDE
3992:  MOVLW  7F
3994:  MOVWF  xDF
3996:  CALL   2DAA
.................... 			else 
399A:  BRA    39AC
.................... 				ext_flash_buffer1_write(0xAA,128,127); 
399C:  MOVLW  AA
399E:  MOVWF  xDD
39A0:  MOVLW  80
39A2:  MOVWF  xDE
39A4:  MOVLW  7F
39A6:  MOVWF  xDF
39A8:  CALL   2DAA
.................... 		} 
....................  
.................... 		if ((sun_angle == 0xFF) || (sun_angle == 0x00)) // sundown 
39AC:  INCFSZ xD2,W
39AE:  BRA    39B2
39B0:  BRA    39B6
39B2:  MOVF   xD2,F
39B4:  BNZ   39BA
.................... 			sun_angle = 180; 
39B6:  MOVLW  B4
39B8:  MOVWF  xD2
....................  
.................... 		if (sun_angle != 180) { 
39BA:  MOVF   xD2,W
39BC:  SUBLW  B4
39BE:  BTFSC  FD8.2
39C0:  BRA    3B00
.................... 			ext_flash_buffer1_write((int8)(current_measured/n_avg_current_measured),128*(find_day_number(timer_sec%SEC_IN_4_YEARS)%2)+4+index_in_page,1); 
39C2:  MOVFF  C7,D5
39C6:  MOVFF  C6,D4
39CA:  CLRF   xD7
39CC:  MOVFF  C8,D6
39D0:  CALL   2C9E
39D4:  MOVFF  01,D3
39D8:  CLRF   18
39DA:  BTFSC  FF2.7
39DC:  BSF    18.7
39DE:  BCF    FF2.7
39E0:  MOVFF  27,F5
39E4:  MOVFF  26,F4
39E8:  MOVFF  25,F3
39EC:  MOVFF  24,F2
39F0:  MOVLW  07
39F2:  MOVWF  xF9
39F4:  MOVLW  86
39F6:  MOVWF  xF8
39F8:  MOVLW  1F
39FA:  MOVWF  xF7
39FC:  MOVLW  80
39FE:  MOVWF  xF6
3A00:  CALL   036A
3A04:  BTFSC  18.7
3A06:  BSF    FF2.7
3A08:  MOVFF  FEF,D4
3A0C:  MOVFF  FEC,D5
3A10:  MOVFF  FEC,D6
3A14:  MOVFF  FEC,D7
3A18:  MOVFF  D7,E5
3A1C:  MOVFF  D6,E4
3A20:  MOVFF  D5,E3
3A24:  MOVFF  D4,E2
3A28:  CALL   2AF6
3A2C:  MOVFF  02,D6
3A30:  MOVF   01,W
3A32:  MOVWF  xD5
3A34:  ANDLW  01
3A36:  MOVWF  00
3A38:  CLRF   03
3A3A:  MOVWF  02
3A3C:  RLCF   00,W
3A3E:  MOVWF  xD7
3A40:  RLCF   03,W
3A42:  MOVWF  xD8
3A44:  RLCF   xD7,F
3A46:  RLCF   xD8,F
3A48:  RLCF   xD7,F
3A4A:  RLCF   xD8,F
3A4C:  RLCF   xD7,F
3A4E:  RLCF   xD8,F
3A50:  RLCF   xD7,F
3A52:  RLCF   xD8,F
3A54:  RLCF   xD7,F
3A56:  RLCF   xD8,F
3A58:  RLCF   xD7,F
3A5A:  RLCF   xD8,F
3A5C:  MOVLW  80
3A5E:  ANDWF  xD7,F
3A60:  MOVLW  04
3A62:  ADDWF  xD7,W
3A64:  MOVWF  xD9
3A66:  MOVLW  00
3A68:  ADDWFC xD8,W
3A6A:  MOVWF  xDA
3A6C:  MOVF   xCB,W
3A6E:  ADDWF  xD9,W
3A70:  MOVWF  xDB
3A72:  MOVLW  00
3A74:  ADDWFC xDA,W
3A76:  MOVWF  xDC
3A78:  MOVFF  D3,DD
3A7C:  MOVFF  DB,DE
3A80:  MOVLW  01
3A82:  MOVWF  xDF
3A84:  CALL   2DAA
3A88:  CLRF   18
3A8A:  BTFSC  FF2.7
3A8C:  BSF    18.7
3A8E:  BCF    FF2.7
.................... 			ext_flash_write_buffer1_to_main_memory(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
3A90:  MOVFF  27,F5
3A94:  MOVFF  26,F4
3A98:  MOVFF  25,F3
3A9C:  MOVFF  24,F2
3AA0:  MOVLW  07
3AA2:  MOVWF  xF9
3AA4:  MOVLW  86
3AA6:  MOVWF  xF8
3AA8:  MOVLW  1F
3AAA:  MOVWF  xF7
3AAC:  MOVLW  80
3AAE:  MOVWF  xF6
3AB0:  CALL   036A
3AB4:  BTFSC  18.7
3AB6:  BSF    FF2.7
3AB8:  MOVFF  FEF,D3
3ABC:  MOVFF  FEC,D4
3AC0:  MOVFF  FEC,D5
3AC4:  MOVFF  FEC,D6
3AC8:  MOVFF  D6,E5
3ACC:  MOVFF  D5,E4
3AD0:  MOVFF  D4,E3
3AD4:  MOVFF  D3,E2
3AD8:  CALL   2AF6
3ADC:  MOVFF  02,D5
3AE0:  MOVFF  01,D4
3AE4:  BCF    FD8.0
3AE6:  RRCF   02,W
3AE8:  MOVWF  03
3AEA:  RRCF   01,W
3AEC:  MOVWF  02
3AEE:  ADDLW  F2
3AF0:  MOVWF  xD6
3AF2:  MOVLW  03
3AF4:  ADDWFC 03,W
3AF6:  MOVWF  xD7
3AF8:  MOVWF  xD9
3AFA:  MOVFF  D6,D8
3AFE:  BRA    3736
.................... 		} 
.................... /* 
.................... 		strcpy(tmp_str,"#Days:     "); 
.................... 		itoa((int16)find_day_number(timer_sec%SEC_IN_4_YEARS),10,tmp_str2); 
.................... 		memcpy(tmp_str+7+strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
.................... 		lcd_gotoxy(0,1); 
.................... 		lcd_gotoxy(0,1);		 
.................... 		lcd_gotoxy(0,1); 
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
.................... */ 
.................... 		strcpy(tmp_str,"Sun@   deg"); 
3B00:  CLRF   FEA
3B02:  MOVLW  30
3B04:  MOVWF  FE9
3B06:  MOVFF  FF2,D3
3B0A:  BCF    FF2.7
3B0C:  MOVLW  00
3B0E:  CALL   0112
3B12:  TBLRD*-
3B14:  TBLRD*+
3B16:  MOVF   FF5,W
3B18:  MOVWF  FEE
3B1A:  IORLW  00
3B1C:  BNZ   3B14
3B1E:  BTFSC  xD3.7
3B20:  BSF    FF2.7
.................... 		itoa((int8)sun_angle,10,tmp_str2); 
3B22:  CLRF   xEE
3B24:  CLRF   xED
3B26:  CLRF   xEC
3B28:  MOVFF  D2,EB
3B2C:  MOVLW  0A
3B2E:  MOVWF  xEF
3B30:  CLRF   xF1
3B32:  MOVLW  44
3B34:  MOVWF  xF0
3B36:  CALL   14D6
.................... 		if (strlen(tmp_str2)<=3) memcpy(tmp_str+7-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3B3A:  CLRF   xE8
3B3C:  MOVLW  44
3B3E:  MOVWF  xE7
3B40:  CALL   16BC
3B44:  MOVF   01,W
3B46:  SUBLW  03
3B48:  BNC   3B8E
3B4A:  CLRF   xE8
3B4C:  MOVLW  44
3B4E:  MOVWF  xE7
3B50:  CALL   16BC
3B54:  MOVLW  37
3B56:  BSF    FD8.0
3B58:  SUBFWB 01,W
3B5A:  MOVWF  xD3
3B5C:  MOVLW  00
3B5E:  BTFSS  FD8.0
3B60:  DECF   FE8,F
3B62:  MOVWF  xD4
3B64:  CLRF   xE8
3B66:  MOVLW  44
3B68:  MOVWF  xE7
3B6A:  CALL   16BC
3B6E:  MOVFF  01,D5
3B72:  MOVFF  D4,FEA
3B76:  MOVFF  D3,FE9
3B7A:  CLRF   FE2
3B7C:  MOVLW  44
3B7E:  MOVWF  FE1
3B80:  MOVF   01,W
3B82:  MOVWF  01
3B84:  BZ    3B8E
3B86:  MOVFF  FE6,FEE
3B8A:  DECFSZ 01,F
3B8C:  BRA    3B86
.................... 	    lcd_gotoxy(0,1); 
3B8E:  CLRF   xEF
3B90:  MOVLW  01
3B92:  MOVWF  xF0
3B94:  CALL   0D34
.................... 		lcd_put_str(tmp_str,strlen(tmp_str));			 
3B98:  CLRF   xE8
3B9A:  MOVLW  30
3B9C:  MOVWF  xE7
3B9E:  CALL   16BC
3BA2:  MOVFF  01,D3
3BA6:  CLRF   xE7
3BA8:  MOVLW  30
3BAA:  MOVWF  xE6
3BAC:  MOVFF  01,E8
3BB0:  CALL   16EE
....................  
.................... 		return sun_angle; 
3BB4:  MOVFF  D2,01
....................  
.................... } 
3BB8:  RETLW  00
....................  
.................... unsigned int8 get_backtrack_angle(unsigned int8 alpha) { 
....................  
.................... 	float tan_alpha,ll,dd; 
.................... 	float beta; 
.................... 	ll = PANEL_WIDTH; 
*
576A:  CLRF   xDB
576C:  CLRF   xDA
576E:  MOVLW  20
5770:  MOVWF  xD9
5772:  MOVLW  86
5774:  MOVWF  xD8
.................... 	dd = ROW_SPACING; 
5776:  CLRF   xDF
5778:  CLRF   xDE
577A:  MOVLW  20
577C:  MOVWF  xDD
577E:  MOVLW  87
5780:  MOVWF  xDC
.................... 	tan_alpha = tan( (float) (alpha) *PI/180.0); 
5782:  MOVLB  1
5784:  CLRF   x50
5786:  MOVFF  D3,14F
578A:  MOVLB  0
578C:  CALL   415E
5790:  MOVFF  00,E4
5794:  MOVFF  01,E5
5798:  MOVFF  02,E6
579C:  MOVFF  03,E7
57A0:  MOVFF  03,152
57A4:  MOVFF  02,151
57A8:  MOVFF  01,150
57AC:  MOVFF  00,14F
57B0:  MOVLW  DB
57B2:  MOVLB  1
57B4:  MOVWF  x56
57B6:  MOVLW  0F
57B8:  MOVWF  x55
57BA:  MOVLW  49
57BC:  MOVWF  x54
57BE:  MOVLW  80
57C0:  MOVWF  x53
57C2:  MOVLB  0
57C4:  CALL   0E86
57C8:  MOVFF  00,E8
57CC:  MOVFF  01,E9
57D0:  MOVFF  02,EA
57D4:  MOVFF  03,EB
57D8:  MOVFF  03,14E
57DC:  MOVFF  02,14D
57E0:  MOVFF  01,14C
57E4:  MOVFF  00,14B
57E8:  MOVLB  1
57EA:  CLRF   x52
57EC:  CLRF   x51
57EE:  MOVLW  34
57F0:  MOVWF  x50
57F2:  MOVLW  86
57F4:  MOVWF  x4F
57F6:  MOVLB  0
57F8:  CALL   0F7C
57FC:  MOVFF  00,EC
5800:  MOVFF  01,ED
5804:  MOVFF  02,EE
5808:  MOVFF  03,EF
580C:  MOVFF  03,114
5810:  MOVFF  02,113
5814:  MOVFF  01,112
5818:  MOVFF  00,111
581C:  CALL   45A6
5820:  MOVFF  03,D7
5824:  MOVFF  02,D6
5828:  MOVFF  01,D5
582C:  MOVFF  00,D4
....................  
.................... 	beta = acos(-1*dd/(ll*sqrt(1.0+tan_alpha*tan_alpha))) -atan(-1.0*tan_alpha); 
5830:  MOVLB  1
5832:  CLRF   x52
5834:  CLRF   x51
5836:  MOVLW  80
5838:  MOVWF  x50
583A:  MOVLW  7F
583C:  MOVWF  x4F
583E:  MOVFF  DF,156
5842:  MOVFF  DE,155
5846:  MOVFF  DD,154
584A:  MOVFF  DC,153
584E:  MOVLB  0
5850:  CALL   0E86
5854:  MOVFF  00,E4
5858:  MOVFF  01,E5
585C:  MOVFF  02,E6
5860:  MOVFF  03,E7
5864:  MOVFF  D7,152
5868:  MOVFF  D6,151
586C:  MOVFF  D5,150
5870:  MOVFF  D4,14F
5874:  MOVFF  D7,156
5878:  MOVFF  D6,155
587C:  MOVFF  D5,154
5880:  MOVFF  D4,153
5884:  CALL   0E86
5888:  BCF    FD8.1
588A:  MOVLB  1
588C:  CLRF   x54
588E:  CLRF   x53
5890:  CLRF   x52
5892:  MOVLW  7F
5894:  MOVWF  x51
5896:  MOVFF  03,158
589A:  MOVFF  02,157
589E:  MOVFF  01,156
58A2:  MOVFF  00,155
58A6:  MOVLB  0
58A8:  CALL   10DA
58AC:  MOVFF  00,E8
58B0:  MOVFF  01,E9
58B4:  MOVFF  02,EA
58B8:  MOVFF  03,EB
58BC:  MOVFF  03,116
58C0:  MOVFF  02,115
58C4:  MOVFF  01,114
58C8:  MOVFF  00,113
58CC:  CALL   4644
58D0:  MOVFF  DB,152
58D4:  MOVFF  DA,151
58D8:  MOVFF  D9,150
58DC:  MOVFF  D8,14F
58E0:  MOVFF  03,156
58E4:  MOVFF  02,155
58E8:  MOVFF  01,154
58EC:  MOVFF  00,153
58F0:  CALL   0E86
58F4:  MOVFF  E7,14E
58F8:  MOVFF  E6,14D
58FC:  MOVFF  E5,14C
5900:  MOVFF  E4,14B
5904:  MOVFF  03,152
5908:  MOVFF  02,151
590C:  MOVFF  01,150
5910:  MOVFF  00,14F
5914:  CALL   0F7C
5918:  MOVFF  00,E9
591C:  MOVFF  01,EA
5920:  MOVFF  02,EB
5924:  MOVFF  03,EC
5928:  MOVFF  03,F0
592C:  MOVFF  02,EF
5930:  MOVFF  01,EE
5934:  MOVFF  00,ED
5938:  BRA    5216
593A:  MOVFF  00,EA
593E:  MOVFF  01,EB
5942:  MOVFF  02,EC
5946:  MOVFF  03,ED
594A:  MOVLB  1
594C:  CLRF   x52
594E:  CLRF   x51
5950:  MOVLW  80
5952:  MOVWF  x50
5954:  MOVLW  7F
5956:  MOVWF  x4F
5958:  MOVFF  D7,156
595C:  MOVFF  D6,155
5960:  MOVFF  D5,154
5964:  MOVFF  D4,153
5968:  MOVLB  0
596A:  CALL   0E86
596E:  MOVFF  00,EE
5972:  MOVFF  01,EF
5976:  MOVFF  02,F0
597A:  MOVFF  03,F1
597E:  MOVFF  03,10C
5982:  MOVFF  02,10B
5986:  MOVFF  01,10A
598A:  MOVFF  00,109
598E:  CALL   3C34
5992:  MOVFF  FEA,F0
5996:  MOVFF  FE9,EF
599A:  BSF    FD8.1
599C:  MOVFF  ED,154
59A0:  MOVFF  EC,153
59A4:  MOVFF  EB,152
59A8:  MOVFF  EA,151
59AC:  MOVFF  03,158
59B0:  MOVFF  02,157
59B4:  MOVFF  01,156
59B8:  MOVFF  00,155
59BC:  CALL   10DA
59C0:  MOVFF  F0,FEA
59C4:  MOVFF  EF,FE9
59C8:  MOVFF  03,E3
59CC:  MOVFF  02,E2
59D0:  MOVFF  01,E1
59D4:  MOVFF  00,E0
.................... 	return fmod(beta,PI)*180.0/PI; 
59D8:  MOVFF  E3,E7
59DC:  MOVFF  E2,E6
59E0:  MOVFF  E1,E5
59E4:  MOVFF  E0,E4
59E8:  MOVLW  DB
59EA:  MOVWF  xEB
59EC:  MOVLW  0F
59EE:  MOVWF  xEA
59F0:  MOVLW  49
59F2:  MOVWF  xE9
59F4:  MOVLW  80
59F6:  MOVWF  xE8
59F8:  BRA    5600
59FA:  MOVFF  00,E4
59FE:  MOVFF  01,E5
5A02:  MOVFF  02,E6
5A06:  MOVFF  03,E7
5A0A:  MOVFF  03,152
5A0E:  MOVFF  02,151
5A12:  MOVFF  01,150
5A16:  MOVFF  00,14F
5A1A:  MOVLB  1
5A1C:  CLRF   x56
5A1E:  CLRF   x55
5A20:  MOVLW  34
5A22:  MOVWF  x54
5A24:  MOVLW  86
5A26:  MOVWF  x53
5A28:  MOVLB  0
5A2A:  CALL   0E86
5A2E:  MOVFF  00,E8
5A32:  MOVFF  01,E9
5A36:  MOVFF  02,EA
5A3A:  MOVFF  03,EB
5A3E:  MOVFF  03,14E
5A42:  MOVFF  02,14D
5A46:  MOVFF  01,14C
5A4A:  MOVFF  00,14B
5A4E:  MOVLW  DB
5A50:  MOVLB  1
5A52:  MOVWF  x52
5A54:  MOVLW  0F
5A56:  MOVWF  x51
5A58:  MOVLW  49
5A5A:  MOVWF  x50
5A5C:  MOVLW  80
5A5E:  MOVWF  x4F
5A60:  MOVLB  0
5A62:  CALL   0F7C
5A66:  MOVFF  03,14E
5A6A:  MOVFF  02,14D
5A6E:  MOVFF  01,14C
5A72:  MOVFF  00,14B
5A76:  CALL   4194
5A7A:  MOVF   01,W
.................... } 
5A7C:  RETLW  00
....................  
.................... #int_timer0 
.................... void timer0_ovf() 
.................... {   // overflow every 100ms 
.................... 	set_timer0(get_timer0()+3036); 
*
03E4:  MOVF   FD6,W
03E6:  MOVFF  FD7,03
03EA:  MOVLB  1
03EC:  MOVWF  x66
03EE:  MOVFF  FD7,167
03F2:  MOVLW  DC
03F4:  ADDWF  x66,W
03F6:  MOVWF  x68
03F8:  MOVLW  0B
03FA:  ADDWFC FD7,W
03FC:  MOVWF  FD7
03FE:  MOVFF  168,FD6
.................... 	timer_ms++; 
0402:  MOVLB  0
0404:  INCF   x6D,F
.................... 	restart_wdt(); 
0406:  CLRWDT
.................... 	if(timer_ms >=5) { 
0408:  MOVF   x6D,W
040A:  SUBLW  04
040C:  BTFSC  FD8.0
040E:  BRA    04EC
.................... 		timer_sec+=1;  
0410:  MOVLW  01
0412:  ADDWF  24,F
0414:  MOVLW  00
0416:  ADDWFC 25,F
0418:  ADDWFC 26,F
041A:  ADDWFC 27,F
.................... 		timer_ms=0; 
041C:  CLRF   x6D
.................... 		flag.update_time = true; 
041E:  BSF    1F.1
.................... 		if ((timer_sec%15) ==0) 
0420:  MOVFF  27,F5
0424:  MOVFF  26,F4
0428:  MOVFF  25,F3
042C:  MOVFF  24,F2
0430:  CLRF   xF9
0432:  CLRF   xF8
0434:  CLRF   xF7
0436:  MOVLW  0F
0438:  MOVWF  xF6
043A:  RCALL  036A
043C:  MOVFF  FEF,166
0440:  MOVFF  FEC,167
0444:  MOVFF  FEC,168
0448:  MOVFF  FEC,169
044C:  MOVLB  1
044E:  MOVF   x66,F
0450:  BNZ   0460
0452:  MOVF   x67,F
0454:  BNZ   0460
0456:  MOVF   x68,F
0458:  BNZ   0460
045A:  MOVF   x69,F
045C:  BNZ   0460
.................... 			flag.measured_current=true; 
045E:  BSF    1F.6
.................... 		if ((timer_sec%450) ==0) 
0460:  MOVFF  27,F5
0464:  MOVFF  26,F4
0468:  MOVFF  25,F3
046C:  MOVFF  24,F2
0470:  MOVLB  0
0472:  CLRF   xF9
0474:  CLRF   xF8
0476:  MOVLW  01
0478:  MOVWF  xF7
047A:  MOVLW  C2
047C:  MOVWF  xF6
047E:  RCALL  036A
0480:  MOVFF  FEF,166
0484:  MOVFF  FEC,167
0488:  MOVFF  FEC,168
048C:  MOVFF  FEC,169
0490:  MOVLB  1
0492:  MOVF   x66,F
0494:  BNZ   04A4
0496:  MOVF   x67,F
0498:  BNZ   04A4
049A:  MOVF   x68,F
049C:  BNZ   04A4
049E:  MOVF   x69,F
04A0:  BNZ   04A4
.................... 			flag.task1_armed=true; 
04A2:  BSF    1F.0
.................... 		if (timer_sec%300==30) flag.reset_rs232=true; 
04A4:  MOVFF  27,F5
04A8:  MOVFF  26,F4
04AC:  MOVFF  25,F3
04B0:  MOVFF  24,F2
04B4:  MOVLB  0
04B6:  CLRF   xF9
04B8:  CLRF   xF8
04BA:  MOVLW  01
04BC:  MOVWF  xF7
04BE:  MOVLW  2C
04C0:  MOVWF  xF6
04C2:  RCALL  036A
04C4:  MOVFF  FEF,166
04C8:  MOVFF  FEC,167
04CC:  MOVFF  FEC,168
04D0:  MOVFF  FEC,169
04D4:  MOVLB  1
04D6:  MOVF   x66,W
04D8:  SUBLW  1E
04DA:  BNZ   04EA
04DC:  MOVF   x67,F
04DE:  BNZ   04EA
04E0:  MOVF   x68,F
04E2:  BNZ   04EA
04E4:  MOVF   x69,F
04E6:  BTFSC  FD8.2
04E8:  BSF    1F.5
04EA:  MOVLB  0
....................     } 
....................  
.................... } 
....................  
....................  
04EC:  BCF    FF2.2
04EE:  GOTO   0064
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
.................... 	char c; 
....................     c=getc(); 
04F2:  BTFSS  F9E.5
04F4:  BRA    04F2
04F6:  MOVFF  FAE,166
04FA:  MOVLB  1
....................      if(c==8) {  // Backspace 
04FC:  MOVF   x66,W
04FE:  SUBLW  08
0500:  BNZ   052A
....................         if(cmd_len>0) { 
0502:  MOVLB  0
0504:  MOVF   x6C,F
0506:  BZ    0526
....................           cmd_len--; 
0508:  DECF   x6C,F
....................           printf("%c",c); 
050A:  MOVLB  1
050C:  MOVF   x66,W
050E:  BTFSS  F9E.4
0510:  BRA    050E
0512:  MOVWF  FAD
....................           printf(" "); 
0514:  MOVLW  20
0516:  BTFSS  F9E.4
0518:  BRA    0516
051A:  MOVWF  FAD
....................           printf("%c",c); 
051C:  MOVF   x66,W
051E:  BTFSS  F9E.4
0520:  BRA    051E
0522:  MOVWF  FAD
0524:  MOVLB  0
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0526:  BRA    055C
0528:  MOVLB  1
052A:  MOVF   x66,W
052C:  SUBLW  1F
052E:  BC    055C
0530:  MOVF   x66,W
0532:  SUBLW  7E
0534:  BNC   055C
....................        if(cmd_len<=MAX_CMD_LEN) { 
0536:  MOVLB  0
0538:  MOVF   x6C,W
053A:  SUBLW  12
053C:  BNC   055C
....................          cmd_msg[cmd_len++]=c; 
053E:  MOVF   x6C,W
0540:  INCF   x6C,F
0542:  CLRF   03
0544:  ADDLW  58
0546:  MOVWF  FE9
0548:  MOVLW  00
054A:  ADDWFC 03,W
054C:  MOVWF  FEA
054E:  MOVFF  166,FEF
....................          printf("%c",c); 
0552:  MOVLB  1
0554:  MOVF   x66,W
0556:  BTFSS  F9E.4
0558:  BRA    0556
055A:  MOVWF  FAD
....................        }  
....................     if (c==13) {  
055C:  MOVLB  1
055E:  MOVF   x66,W
0560:  SUBLW  0D
0562:  BNZ   059A
.................... 	printf("\r\n>"); 
0564:  MOVLW  0D
0566:  BTFSS  F9E.4
0568:  BRA    0566
056A:  MOVWF  FAD
056C:  MOVLW  0A
056E:  BTFSS  F9E.4
0570:  BRA    056E
0572:  MOVWF  FAD
0574:  MOVLW  3E
0576:  BTFSS  F9E.4
0578:  BRA    0576
057A:  MOVWF  FAD
.................... 	cmd_msg[cmd_len]=0; 
057C:  CLRF   03
057E:  MOVLB  0
0580:  MOVF   x6C,W
0582:  ADDLW  58
0584:  MOVWF  FE9
0586:  MOVLW  00
0588:  ADDWFC 03,W
058A:  MOVWF  FEA
058C:  CLRF   FEF
.................... 	if(cmd_len>1)flag.cmd_posted=true; 
058E:  MOVF   x6C,W
0590:  SUBLW  01
0592:  BTFSS  FD8.0
0594:  BSF    1F.3
.................... 	cmd_len =0; 
0596:  CLRF   x6C
0598:  MOVLB  1
....................  
....................   } 
.................... } 
....................  
059A:  BCF    F9E.5
059C:  MOVLB  0
059E:  GOTO   0064
.................... float actuator_length(int8 sun_angle) { 
.................... // return actuator length in cm at given sun_angle 
.................... float len_a,len_b,len_c,len_p,len_m,len_k,len_l; 
.................... float sin_beta,cos_beta,tan_beta; 
.................... float temp1; 
.................... float alpha; 
.................... //if (sun_angle < 30) return; 
.................... //if (sun_angle > 150) return; 
.................... len_a = DIM_A; 
*
476E:  CLRF   xD8
4770:  CLRF   xD7
4772:  MOVLW  57
4774:  MOVWF  xD6
4776:  MOVLW  85
4778:  MOVWF  xD5
.................... len_b = DIM_B; 
477A:  MOVLW  CD
477C:  MOVWF  xDC
477E:  MOVLW  CC
4780:  MOVWF  xDB
4782:  MOVLW  7C
4784:  MOVWF  xDA
4786:  MOVLW  82
4788:  MOVWF  xD9
.................... len_p = DIM_P; 
478A:  MOVLW  CD
478C:  MOVWF  xE4
478E:  MOVLW  CC
4790:  MOVWF  xE3
4792:  MOVLW  14
4794:  MOVWF  xE2
4796:  MOVLW  82
4798:  MOVWF  xE1
.................... len_k = DIM_K; 
479A:  CLRF   xEC
479C:  CLRF   xEB
479E:  MOVLW  10
47A0:  MOVWF  xEA
47A2:  MOVLW  84
47A4:  MOVWF  xE9
.................... len_m = DIM_M; 
47A6:  CLRF   xE8
47A8:  CLRF   xE7
47AA:  MOVLW  30
47AC:  MOVWF  xE6
47AE:  MOVLW  81
47B0:  MOVWF  xE5
.................... len_p = DIM_P; 
47B2:  MOVLW  CD
47B4:  MOVWF  xE4
47B6:  MOVLW  CC
47B8:  MOVWF  xE3
47BA:  MOVLW  14
47BC:  MOVWF  xE2
47BE:  MOVLW  82
47C0:  MOVWF  xE1
.................... alpha = atan(len_b/len_k); 
47C2:  MOVFF  DC,14E
47C6:  MOVFF  DB,14D
47CA:  MOVFF  DA,14C
47CE:  MOVFF  D9,14B
47D2:  MOVFF  EC,152
47D6:  MOVFF  EB,151
47DA:  MOVFF  EA,150
47DE:  MOVFF  E9,14F
47E2:  CALL   0F7C
47E6:  MOVFF  00,105
47EA:  MOVFF  01,106
47EE:  MOVFF  02,107
47F2:  MOVFF  03,108
47F6:  MOVFF  03,10C
47FA:  MOVFF  02,10B
47FE:  MOVFF  01,10A
4802:  MOVFF  00,109
4806:  CALL   3C34
480A:  MOVFF  03,104
480E:  MOVFF  02,103
4812:  MOVFF  01,102
4816:  MOVFF  00,101
.................... sin_beta = sin((sun_angle*PI/180.0)-alpha); 
481A:  MOVLB  1
481C:  CLRF   x50
481E:  MOVFF  D4,14F
4822:  MOVLB  0
4824:  RCALL  415E
4826:  MOVFF  03,152
482A:  MOVFF  02,151
482E:  MOVFF  01,150
4832:  MOVFF  00,14F
4836:  MOVLW  DB
4838:  MOVLB  1
483A:  MOVWF  x56
483C:  MOVLW  0F
483E:  MOVWF  x55
4840:  MOVLW  49
4842:  MOVWF  x54
4844:  MOVLW  80
4846:  MOVWF  x53
4848:  MOVLB  0
484A:  CALL   0E86
484E:  MOVFF  00,105
4852:  MOVFF  01,106
4856:  MOVFF  02,107
485A:  MOVFF  03,108
485E:  MOVFF  03,14E
4862:  MOVFF  02,14D
4866:  MOVFF  01,14C
486A:  MOVFF  00,14B
486E:  MOVLB  1
4870:  CLRF   x52
4872:  CLRF   x51
4874:  MOVLW  34
4876:  MOVWF  x50
4878:  MOVLW  86
487A:  MOVWF  x4F
487C:  MOVLB  0
487E:  CALL   0F7C
4882:  MOVFF  00,109
4886:  MOVFF  01,10A
488A:  MOVFF  02,10B
488E:  MOVFF  03,10C
4892:  BSF    FD8.1
4894:  MOVFF  03,154
4898:  MOVFF  02,153
489C:  MOVFF  01,152
48A0:  MOVFF  00,151
48A4:  MOVFF  104,158
48A8:  MOVFF  103,157
48AC:  MOVFF  102,156
48B0:  MOVFF  101,155
48B4:  CALL   10DA
48B8:  MOVFF  00,10D
48BC:  MOVFF  01,10E
48C0:  MOVFF  02,10F
48C4:  MOVFF  03,110
48C8:  MOVFF  03,120
48CC:  MOVFF  02,11F
48D0:  MOVFF  01,11E
48D4:  MOVFF  00,11D
48D8:  RCALL  4558
48DA:  MOVFF  03,F4
48DE:  MOVFF  02,F3
48E2:  MOVFF  01,F2
48E6:  MOVFF  00,F1
.................... cos_beta = cos((sun_angle*PI/180.0)-alpha); 
48EA:  MOVLB  1
48EC:  CLRF   x50
48EE:  MOVFF  D4,14F
48F2:  MOVLB  0
48F4:  RCALL  415E
48F6:  MOVFF  03,152
48FA:  MOVFF  02,151
48FE:  MOVFF  01,150
4902:  MOVFF  00,14F
4906:  MOVLW  DB
4908:  MOVLB  1
490A:  MOVWF  x56
490C:  MOVLW  0F
490E:  MOVWF  x55
4910:  MOVLW  49
4912:  MOVWF  x54
4914:  MOVLW  80
4916:  MOVWF  x53
4918:  MOVLB  0
491A:  CALL   0E86
491E:  MOVFF  00,105
4922:  MOVFF  01,106
4926:  MOVFF  02,107
492A:  MOVFF  03,108
492E:  MOVFF  03,14E
4932:  MOVFF  02,14D
4936:  MOVFF  01,14C
493A:  MOVFF  00,14B
493E:  MOVLB  1
4940:  CLRF   x52
4942:  CLRF   x51
4944:  MOVLW  34
4946:  MOVWF  x50
4948:  MOVLW  86
494A:  MOVWF  x4F
494C:  MOVLB  0
494E:  CALL   0F7C
4952:  MOVFF  00,109
4956:  MOVFF  01,10A
495A:  MOVFF  02,10B
495E:  MOVFF  03,10C
4962:  BSF    FD8.1
4964:  MOVFF  03,154
4968:  MOVFF  02,153
496C:  MOVFF  01,152
4970:  MOVFF  00,151
4974:  MOVFF  104,158
4978:  MOVFF  103,157
497C:  MOVFF  102,156
4980:  MOVFF  101,155
4984:  CALL   10DA
4988:  MOVFF  00,10D
498C:  MOVFF  01,10E
4990:  MOVFF  02,10F
4994:  MOVFF  03,110
4998:  MOVFF  03,128
499C:  MOVFF  02,127
49A0:  MOVFF  01,126
49A4:  MOVFF  00,125
49A8:  RCALL  41D0
49AA:  MOVFF  03,F8
49AE:  MOVFF  02,F7
49B2:  MOVFF  01,F6
49B6:  MOVFF  00,F5
.................... tan_beta = tan((sun_angle*PI/180.0)-alpha); 
49BA:  MOVLB  1
49BC:  CLRF   x50
49BE:  MOVFF  D4,14F
49C2:  MOVLB  0
49C4:  CALL   415E
49C8:  MOVFF  03,152
49CC:  MOVFF  02,151
49D0:  MOVFF  01,150
49D4:  MOVFF  00,14F
49D8:  MOVLW  DB
49DA:  MOVLB  1
49DC:  MOVWF  x56
49DE:  MOVLW  0F
49E0:  MOVWF  x55
49E2:  MOVLW  49
49E4:  MOVWF  x54
49E6:  MOVLW  80
49E8:  MOVWF  x53
49EA:  MOVLB  0
49EC:  CALL   0E86
49F0:  MOVFF  00,105
49F4:  MOVFF  01,106
49F8:  MOVFF  02,107
49FC:  MOVFF  03,108
4A00:  MOVFF  03,14E
4A04:  MOVFF  02,14D
4A08:  MOVFF  01,14C
4A0C:  MOVFF  00,14B
4A10:  MOVLB  1
4A12:  CLRF   x52
4A14:  CLRF   x51
4A16:  MOVLW  34
4A18:  MOVWF  x50
4A1A:  MOVLW  86
4A1C:  MOVWF  x4F
4A1E:  MOVLB  0
4A20:  CALL   0F7C
4A24:  MOVFF  00,109
4A28:  MOVFF  01,10A
4A2C:  MOVFF  02,10B
4A30:  MOVFF  03,10C
4A34:  BSF    FD8.1
4A36:  MOVFF  03,154
4A3A:  MOVFF  02,153
4A3E:  MOVFF  01,152
4A42:  MOVFF  00,151
4A46:  MOVFF  104,158
4A4A:  MOVFF  103,157
4A4E:  MOVFF  102,156
4A52:  MOVFF  101,155
4A56:  CALL   10DA
4A5A:  MOVFF  00,10D
4A5E:  MOVFF  01,10E
4A62:  MOVFF  02,10F
4A66:  MOVFF  03,110
4A6A:  MOVFF  03,114
4A6E:  MOVFF  02,113
4A72:  MOVFF  01,112
4A76:  MOVFF  00,111
4A7A:  RCALL  45A6
4A7C:  MOVFF  03,FC
4A80:  MOVFF  02,FB
4A84:  MOVFF  01,FA
4A88:  MOVFF  00,F9
....................  
....................  
.................... len_c = sqrt(len_k*len_k+len_b*len_b)-len_p/sin_beta; 
4A8C:  MOVFF  EC,152
4A90:  MOVFF  EB,151
4A94:  MOVFF  EA,150
4A98:  MOVFF  E9,14F
4A9C:  MOVFF  EC,156
4AA0:  MOVFF  EB,155
4AA4:  MOVFF  EA,154
4AA8:  MOVFF  E9,153
4AAC:  CALL   0E86
4AB0:  MOVFF  00,105
4AB4:  MOVFF  01,106
4AB8:  MOVFF  02,107
4ABC:  MOVFF  03,108
4AC0:  MOVFF  DC,152
4AC4:  MOVFF  DB,151
4AC8:  MOVFF  DA,150
4ACC:  MOVFF  D9,14F
4AD0:  MOVFF  DC,156
4AD4:  MOVFF  DB,155
4AD8:  MOVFF  DA,154
4ADC:  MOVFF  D9,153
4AE0:  CALL   0E86
4AE4:  BCF    FD8.1
4AE6:  MOVFF  108,154
4AEA:  MOVFF  107,153
4AEE:  MOVFF  106,152
4AF2:  MOVFF  105,151
4AF6:  MOVFF  03,158
4AFA:  MOVFF  02,157
4AFE:  MOVFF  01,156
4B02:  MOVFF  00,155
4B06:  CALL   10DA
4B0A:  MOVFF  00,109
4B0E:  MOVFF  01,10A
4B12:  MOVFF  02,10B
4B16:  MOVFF  03,10C
4B1A:  MOVFF  03,116
4B1E:  MOVFF  02,115
4B22:  MOVFF  01,114
4B26:  MOVFF  00,113
4B2A:  RCALL  4644
4B2C:  MOVFF  00,10A
4B30:  MOVFF  01,10B
4B34:  MOVFF  02,10C
4B38:  MOVFF  03,10D
4B3C:  MOVFF  E4,14E
4B40:  MOVFF  E3,14D
4B44:  MOVFF  E2,14C
4B48:  MOVFF  E1,14B
4B4C:  MOVFF  F4,152
4B50:  MOVFF  F3,151
4B54:  MOVFF  F2,150
4B58:  MOVFF  F1,14F
4B5C:  CALL   0F7C
4B60:  MOVFF  FEA,10F
4B64:  MOVFF  FE9,10E
4B68:  BSF    FD8.1
4B6A:  MOVFF  10D,154
4B6E:  MOVFF  10C,153
4B72:  MOVFF  10B,152
4B76:  MOVFF  10A,151
4B7A:  MOVFF  03,158
4B7E:  MOVFF  02,157
4B82:  MOVFF  01,156
4B86:  MOVFF  00,155
4B8A:  CALL   10DA
4B8E:  MOVFF  10F,FEA
4B92:  MOVFF  10E,FE9
4B96:  MOVFF  03,E0
4B9A:  MOVFF  02,DF
4B9E:  MOVFF  01,DE
4BA2:  MOVFF  00,DD
.................... temp1 = len_a - (len_p/tan_beta)-len_c*cos_beta; 
4BA6:  MOVFF  E4,14E
4BAA:  MOVFF  E3,14D
4BAE:  MOVFF  E2,14C
4BB2:  MOVFF  E1,14B
4BB6:  MOVFF  FC,152
4BBA:  MOVFF  FB,151
4BBE:  MOVFF  FA,150
4BC2:  MOVFF  F9,14F
4BC6:  CALL   0F7C
4BCA:  BSF    FD8.1
4BCC:  MOVFF  D8,154
4BD0:  MOVFF  D7,153
4BD4:  MOVFF  D6,152
4BD8:  MOVFF  D5,151
4BDC:  MOVFF  03,158
4BE0:  MOVFF  02,157
4BE4:  MOVFF  01,156
4BE8:  MOVFF  00,155
4BEC:  CALL   10DA
4BF0:  MOVFF  00,105
4BF4:  MOVFF  01,106
4BF8:  MOVFF  02,107
4BFC:  MOVFF  03,108
4C00:  MOVFF  E0,152
4C04:  MOVFF  DF,151
4C08:  MOVFF  DE,150
4C0C:  MOVFF  DD,14F
4C10:  MOVFF  F8,156
4C14:  MOVFF  F7,155
4C18:  MOVFF  F6,154
4C1C:  MOVFF  F5,153
4C20:  CALL   0E86
4C24:  BSF    FD8.1
4C26:  MOVFF  108,154
4C2A:  MOVFF  107,153
4C2E:  MOVFF  106,152
4C32:  MOVFF  105,151
4C36:  MOVFF  03,158
4C3A:  MOVFF  02,157
4C3E:  MOVFF  01,156
4C42:  MOVFF  00,155
4C46:  CALL   10DA
4C4A:  MOVFF  03,100
4C4E:  MOVFF  02,FF
4C52:  MOVFF  01,FE
4C56:  MOVFF  00,FD
.................... len_l = len_c*sin_beta*len_c*sin_beta+temp1*temp1-len_m*len_m; 
4C5A:  MOVFF  E0,152
4C5E:  MOVFF  DF,151
4C62:  MOVFF  DE,150
4C66:  MOVFF  DD,14F
4C6A:  MOVFF  F4,156
4C6E:  MOVFF  F3,155
4C72:  MOVFF  F2,154
4C76:  MOVFF  F1,153
4C7A:  CALL   0E86
4C7E:  MOVFF  00,105
4C82:  MOVFF  01,106
4C86:  MOVFF  02,107
4C8A:  MOVFF  03,108
4C8E:  MOVFF  03,152
4C92:  MOVFF  02,151
4C96:  MOVFF  01,150
4C9A:  MOVFF  00,14F
4C9E:  MOVFF  E0,156
4CA2:  MOVFF  DF,155
4CA6:  MOVFF  DE,154
4CAA:  MOVFF  DD,153
4CAE:  CALL   0E86
4CB2:  MOVFF  00,109
4CB6:  MOVFF  01,10A
4CBA:  MOVFF  02,10B
4CBE:  MOVFF  03,10C
4CC2:  MOVFF  03,152
4CC6:  MOVFF  02,151
4CCA:  MOVFF  01,150
4CCE:  MOVFF  00,14F
4CD2:  MOVFF  F4,156
4CD6:  MOVFF  F3,155
4CDA:  MOVFF  F2,154
4CDE:  MOVFF  F1,153
4CE2:  CALL   0E86
4CE6:  MOVFF  00,10D
4CEA:  MOVFF  01,10E
4CEE:  MOVFF  02,10F
4CF2:  MOVFF  03,110
4CF6:  MOVFF  100,152
4CFA:  MOVFF  FF,151
4CFE:  MOVFF  FE,150
4D02:  MOVFF  FD,14F
4D06:  MOVFF  100,156
4D0A:  MOVFF  FF,155
4D0E:  MOVFF  FE,154
4D12:  MOVFF  FD,153
4D16:  CALL   0E86
4D1A:  BCF    FD8.1
4D1C:  MOVFF  110,154
4D20:  MOVFF  10F,153
4D24:  MOVFF  10E,152
4D28:  MOVFF  10D,151
4D2C:  MOVFF  03,158
4D30:  MOVFF  02,157
4D34:  MOVFF  01,156
4D38:  MOVFF  00,155
4D3C:  CALL   10DA
4D40:  MOVFF  00,111
4D44:  MOVFF  01,112
4D48:  MOVFF  02,113
4D4C:  MOVFF  03,114
4D50:  MOVFF  E8,152
4D54:  MOVFF  E7,151
4D58:  MOVFF  E6,150
4D5C:  MOVFF  E5,14F
4D60:  MOVFF  E8,156
4D64:  MOVFF  E7,155
4D68:  MOVFF  E6,154
4D6C:  MOVFF  E5,153
4D70:  CALL   0E86
4D74:  BSF    FD8.1
4D76:  MOVFF  114,154
4D7A:  MOVFF  113,153
4D7E:  MOVFF  112,152
4D82:  MOVFF  111,151
4D86:  MOVFF  03,158
4D8A:  MOVFF  02,157
4D8E:  MOVFF  01,156
4D92:  MOVFF  00,155
4D96:  CALL   10DA
4D9A:  MOVFF  03,F0
4D9E:  MOVFF  02,EF
4DA2:  MOVFF  01,EE
4DA6:  MOVFF  00,ED
.................... len_l = sqrt(len_l); 
4DAA:  MOVFF  F0,116
4DAE:  MOVFF  EF,115
4DB2:  MOVFF  EE,114
4DB6:  MOVFF  ED,113
4DBA:  RCALL  4644
4DBC:  MOVFF  03,F0
4DC0:  MOVFF  02,EF
4DC4:  MOVFF  01,EE
4DC8:  MOVFF  00,ED
....................  
.................... if (len_l<50.0) 
4DCC:  MOVFF  F0,14E
4DD0:  MOVFF  EF,14D
4DD4:  MOVFF  EE,14C
4DD8:  MOVFF  ED,14B
4DDC:  MOVLB  1
4DDE:  CLRF   x52
4DE0:  CLRF   x51
4DE2:  MOVLW  48
4DE4:  MOVWF  x50
4DE6:  MOVLW  84
4DE8:  MOVWF  x4F
4DEA:  MOVLB  0
4DEC:  CALL   3BBA
4DF0:  BNC   4DFC
.................... 	return 0.0; 
4DF2:  CLRF   00
4DF4:  CLRF   01
4DF6:  CLRF   02
4DF8:  CLRF   03
4DFA:  BRA    4E0C
....................  
.................... return len_l; 
4DFC:  MOVFF  ED,00
4E00:  MOVFF  EE,01
4E04:  MOVFF  EF,02
4E08:  MOVFF  F0,03
.................... } 
4E0C:  RETLW  00
....................  
....................  
....................  
.................... void process_cmd_msg(){ 
....................     flag.cmd_posted =false; 
*
2E08:  BCF    1F.3
.................... 	switch (cmd_msg[0]) { 
2E0A:  MOVLW  63
2E0C:  SUBWF  58,W
2E0E:  ADDLW  E9
2E10:  BTFSC  FD8.0
2E12:  BRA    34AE
2E14:  ADDLW  17
2E16:  GOTO   34B0
.................... 		case 'm':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2E1A:  CLRF   FEA
2E1C:  MOVLW  58
2E1E:  MOVWF  FE9
2E20:  CLRF   FE2
2E22:  MOVLW  59
2E24:  MOVWF  FE1
2E26:  MOVLW  12
2E28:  MOVWF  01
2E2A:  MOVFF  FE6,FEE
2E2E:  DECFSZ 01,F
2E30:  BRA    2E2A
....................         	if (atol(cmd_msg)==0) break; 
2E32:  CLRF   xD3
2E34:  MOVLW  58
2E36:  MOVWF  xD2
2E38:  CALL   0B4C
2E3C:  MOVFF  02,D3
2E40:  MOVFF  01,D2
2E44:  MOVF   xD2,F
2E46:  BNZ   2E4E
2E48:  MOVF   xD3,F
2E4A:  BNZ   2E4E
2E4C:  BRA    34AE
.................... 			move_act(atol(cmd_msg),9000,move_act_time_out*2,1,0); 
2E4E:  CLRF   xD3
2E50:  MOVLW  58
2E52:  MOVWF  xD2
2E54:  CALL   0B4C
2E58:  MOVFF  02,D3
2E5C:  MOVFF  01,D2
2E60:  BCF    FD8.0
2E62:  RLCF   xC4,W
2E64:  MOVWF  xD4
2E66:  RLCF   xC5,W
2E68:  MOVWF  xD5
2E6A:  MOVFF  02,D7
2E6E:  MOVFF  01,D6
2E72:  MOVLW  23
2E74:  MOVWF  xD9
2E76:  MOVLW  28
2E78:  MOVWF  xD8
2E7A:  MOVFF  D5,DB
2E7E:  MOVFF  D4,DA
2E82:  MOVLW  01
2E84:  MOVWF  xDC
2E86:  CLRF   xDD
2E88:  CALL   214C
.................... 			break; 	} 
2E8C:  BRA    34AE
....................  
.................... 		case 'n':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2E8E:  CLRF   FEA
2E90:  MOVLW  58
2E92:  MOVWF  FE9
2E94:  CLRF   FE2
2E96:  MOVLW  59
2E98:  MOVWF  FE1
2E9A:  MOVLW  12
2E9C:  MOVWF  01
2E9E:  MOVFF  FE6,FEE
2EA2:  DECFSZ 01,F
2EA4:  BRA    2E9E
....................         	if (atol(cmd_msg)==0) break; 
2EA6:  CLRF   xD3
2EA8:  MOVLW  58
2EAA:  MOVWF  xD2
2EAC:  CALL   0B4C
2EB0:  MOVFF  02,D3
2EB4:  MOVFF  01,D2
2EB8:  MOVF   xD2,F
2EBA:  BNZ   2EC2
2EBC:  MOVF   xD3,F
2EBE:  BNZ   2EC2
2EC0:  BRA    34AE
.................... 			move_act(atol(cmd_msg),9000,move_act_time_out*2,0,0); 
2EC2:  CLRF   xD3
2EC4:  MOVLW  58
2EC6:  MOVWF  xD2
2EC8:  CALL   0B4C
2ECC:  MOVFF  02,D3
2ED0:  MOVFF  01,D2
2ED4:  BCF    FD8.0
2ED6:  RLCF   xC4,W
2ED8:  MOVWF  xD4
2EDA:  RLCF   xC5,W
2EDC:  MOVWF  xD5
2EDE:  MOVFF  02,D7
2EE2:  MOVFF  01,D6
2EE6:  MOVLW  23
2EE8:  MOVWF  xD9
2EEA:  MOVLW  28
2EEC:  MOVWF  xD8
2EEE:  MOVFF  D5,DB
2EF2:  MOVFF  D4,DA
2EF6:  CLRF   xDC
2EF8:  CLRF   xDD
2EFA:  CALL   214C
.................... 			break; 	} 
2EFE:  BRA    34AE
.................... 		case 'k':{ 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2F00:  CLRF   FEA
2F02:  MOVLW  58
2F04:  MOVWF  FE9
2F06:  CLRF   FE2
2F08:  MOVLW  59
2F0A:  MOVWF  FE1
2F0C:  MOVLW  12
2F0E:  MOVWF  01
2F10:  MOVFF  FE6,FEE
2F14:  DECFSZ 01,F
2F16:  BRA    2F10
....................         	if (atol(cmd_msg)==1) { 
2F18:  CLRF   xD3
2F1A:  MOVLW  58
2F1C:  MOVWF  xD2
2F1E:  CALL   0B4C
2F22:  MOVFF  02,D3
2F26:  MOVFF  01,D2
2F2A:  DECFSZ 01,W
2F2C:  BRA    2F3E
2F2E:  MOVF   xD3,F
2F30:  BNZ   2F3E
.................... 				setup_timer_0(RTCC_DIV_32); 
2F32:  MOVLW  84
2F34:  MOVWF  FD5
.................... 				move_act_time_out =4; 
2F36:  CLRF   xC5
2F38:  MOVLW  04
2F3A:  MOVWF  xC4
.................... 			} else if(atol(cmd_msg)==2) { 
2F3C:  BRA    2F62
2F3E:  CLRF   xD3
2F40:  MOVLW  58
2F42:  MOVWF  xD2
2F44:  CALL   0B4C
2F48:  MOVFF  02,D3
2F4C:  MOVF   01,W
2F4E:  MOVWF  xD2
2F50:  SUBLW  02
2F52:  BNZ   2F62
2F54:  MOVF   xD3,F
2F56:  BNZ   2F62
.................... 				setup_timer_0(RTCC_DIV_2); 
2F58:  MOVLW  80
2F5A:  MOVWF  FD5
.................... 				move_act_time_out =32; 
2F5C:  CLRF   xC5
2F5E:  MOVLW  20
2F60:  MOVWF  xC4
.................... 			} 
.................... 			break; 	}		 
2F62:  BRA    34AE
.................... 		case 'd':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2F64:  CLRF   FEA
2F66:  MOVLW  58
2F68:  MOVWF  FE9
2F6A:  CLRF   FE2
2F6C:  MOVLW  59
2F6E:  MOVWF  FE1
2F70:  MOVLW  12
2F72:  MOVWF  01
2F74:  MOVFF  FE6,FEE
2F78:  DECFSZ 01,F
2F7A:  BRA    2F74
....................         	if (atol(cmd_msg)==0) break; 
2F7C:  CLRF   xD3
2F7E:  MOVLW  58
2F80:  MOVWF  xD2
2F82:  CALL   0B4C
2F86:  MOVFF  02,D3
2F8A:  MOVFF  01,D2
2F8E:  MOVF   xD2,F
2F90:  BNZ   2F98
2F92:  MOVF   xD3,F
2F94:  BNZ   2F98
2F96:  BRA    34AE
.................... 			printf("\r\n   start downloading %ld pages of data....",atol(cmd_msg)); 
2F98:  CLRF   xD3
2F9A:  MOVLW  58
2F9C:  MOVWF  xD2
2F9E:  CALL   0B4C
2FA2:  MOVFF  02,D3
2FA6:  MOVFF  01,D2
2FAA:  CLRF   xD4
2FAC:  MOVF   xD4,W
2FAE:  CALL   0138
2FB2:  INCF   xD4,F
2FB4:  MOVWF  00
2FB6:  MOVF   00,W
2FB8:  BTFSS  F9E.4
2FBA:  BRA    2FB8
2FBC:  MOVWF  FAD
2FBE:  MOVLW  17
2FC0:  SUBWF  xD4,W
2FC2:  BNZ   2FAC
2FC4:  MOVLW  10
2FC6:  MOVWF  FE9
2FC8:  MOVFF  D3,D6
2FCC:  MOVFF  D2,D5
2FD0:  CALL   2318
2FD4:  MOVLW  1A
2FD6:  MOVWF  xD5
2FD8:  MOVF   xD5,W
2FDA:  CALL   0138
2FDE:  INCF   xD5,F
2FE0:  MOVWF  00
2FE2:  MOVF   00,W
2FE4:  BTFSS  F9E.4
2FE6:  BRA    2FE4
2FE8:  MOVWF  FAD
2FEA:  MOVLW  2C
2FEC:  SUBWF  xD5,W
2FEE:  BNZ   2FD8
....................         	download_sun_table(atol(cmd_msg)); 
2FF0:  CLRF   xD3
2FF2:  MOVLW  58
2FF4:  MOVWF  xD2
2FF6:  CALL   0B4C
2FFA:  MOVFF  02,D3
2FFE:  MOVFF  01,D2
3002:  MOVFF  02,D5
3006:  MOVFF  01,D4
300A:  GOTO   2598
.................... 			break; 	} 
.................... 		case 'r': { 
.................... 			disable_interrupts(GLOBAL); 
300E:  BCF    FF2.6
3010:  BCF    FF2.7
3012:  BTFSC  FF2.7
3014:  BRA    3010
.................... 			restart_wdt(); 
3016:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
3018:  BCF    FD1.0
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
301A:  CLRF   FEA
301C:  MOVLW  58
301E:  MOVWF  FE9
3020:  CLRF   FE2
3022:  MOVLW  59
3024:  MOVWF  FE1
3026:  MOVLW  12
3028:  MOVWF  01
302A:  MOVFF  FE6,FEE
302E:  DECFSZ 01,F
3030:  BRA    302A
.................... 			PORTE.tx_en=1; 
3032:  BSF    F84.2
.................... 			printf("\r\n PAGE %ld:",atol(cmd_msg)); 
3034:  CLRF   xD3
3036:  MOVLW  58
3038:  MOVWF  xD2
303A:  CALL   0B4C
303E:  MOVFF  02,D3
3042:  MOVFF  01,D2
3046:  CLRF   xD4
3048:  MOVF   xD4,W
304A:  CALL   0180
304E:  INCF   xD4,F
3050:  MOVWF  00
3052:  MOVF   00,W
3054:  BTFSS  F9E.4
3056:  BRA    3054
3058:  MOVWF  FAD
305A:  MOVLW  08
305C:  SUBWF  xD4,W
305E:  BNZ   3048
3060:  MOVLW  10
3062:  MOVWF  FE9
3064:  MOVFF  D3,D6
3068:  MOVFF  D2,D5
306C:  CALL   2318
3070:  MOVLW  3A
3072:  BTFSS  F9E.4
3074:  BRA    3072
3076:  MOVWF  FAD
.................... 			print_page_data(atol(cmd_msg)); 
3078:  CLRF   xD3
307A:  MOVLW  58
307C:  MOVWF  xD2
307E:  CALL   0B4C
3082:  MOVFF  02,D3
3086:  MOVFF  01,D2
308A:  MOVFF  02,D5
308E:  MOVFF  01,D4
3092:  GOTO   2784
.................... 			enable_interrupts(GLOBAL); 
3096:  MOVLW  C0
3098:  IORWF  FF2,F
.................... 			restart_wdt(); 
309A:  CLRWDT
.................... 			setup_wdt(WDT_ON); 
309C:  BSF    FD1.0
....................             break; } 
309E:  BRA    34AE
....................         case 'e': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
30A0:  CLRF   FEA
30A2:  MOVLW  58
30A4:  MOVWF  FE9
30A6:  CLRF   FE2
30A8:  MOVLW  59
30AA:  MOVWF  FE1
30AC:  MOVLW  12
30AE:  MOVWF  01
30B0:  MOVFF  FE6,FEE
30B4:  DECFSZ 01,F
30B6:  BRA    30B0
....................             if (atol(cmd_msg)!=22) break; 
30B8:  CLRF   xD3
30BA:  MOVLW  58
30BC:  MOVWF  xD2
30BE:  CALL   0B4C
30C2:  MOVFF  02,D3
30C6:  MOVF   01,W
30C8:  MOVWF  xD2
30CA:  SUBLW  16
30CC:  BNZ   30D2
30CE:  MOVF   xD3,F
30D0:  BZ    30D4
30D2:  BRA    34AE
.................... 			printf("\r\n   deleting entire flash data "); 
30D4:  CLRF   xD2
30D6:  MOVF   xD2,W
30D8:  CALL   01A8
30DC:  INCF   xD2,F
30DE:  MOVWF  00
30E0:  MOVF   00,W
30E2:  BTFSS  F9E.4
30E4:  BRA    30E2
30E6:  MOVWF  FAD
30E8:  MOVLW  20
30EA:  SUBWF  xD2,W
30EC:  BNZ   30D6
.................... 			ext_flash_block_erase(); 
30EE:  GOTO   2818
....................             break; } 
.................... 		case 't': { // timer set 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
30F2:  CLRF   FEA
30F4:  MOVLW  58
30F6:  MOVWF  FE9
30F8:  CLRF   FE2
30FA:  MOVLW  59
30FC:  MOVWF  FE1
30FE:  MOVLW  12
3100:  MOVWF  01
3102:  MOVFF  FE6,FEE
3106:  DECFSZ 01,F
3108:  BRA    3102
.................... 			timer_sec=atoi32(cmd_msg); 
310A:  CLRF   xD3
310C:  MOVLW  58
310E:  MOVWF  xD2
3110:  GOTO   2858
3114:  MOVFF  03,27
3118:  MOVFF  02,26
311C:  MOVFF  01,25
3120:  MOVFF  00,24
.................... 			lcd_send_cmd(0,0x02); 
3124:  CLRF   xF3
3126:  MOVLW  02
3128:  MOVWF  xF4
312A:  CALL   0A66
312E:  CLRF   18
3130:  BTFSC  FF2.7
3132:  BSF    18.7
3134:  BCF    FF2.7
.................... 			next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
3136:  MOVFF  27,F5
313A:  MOVFF  26,F4
313E:  MOVFF  25,F3
3142:  MOVFF  24,F2
3146:  MOVLW  07
3148:  MOVWF  xF9
314A:  MOVLW  86
314C:  MOVWF  xF8
314E:  MOVLW  1F
3150:  MOVWF  xF7
3152:  MOVLW  80
3154:  MOVWF  xF6
3156:  CALL   036A
315A:  BTFSC  18.7
315C:  BSF    FF2.7
315E:  MOVFF  FEF,D2
3162:  MOVFF  FEC,D3
3166:  MOVFF  FEC,D4
316A:  MOVFF  FEC,D5
316E:  MOVFF  D5,E5
3172:  MOVFF  D4,E4
3176:  MOVFF  D3,E3
317A:  MOVFF  D2,E2
317E:  RCALL  2AF6
3180:  MOVFF  02,D4
3184:  MOVFF  01,D3
3188:  MOVFF  02,E3
318C:  MOVFF  01,E2
3190:  RCALL  2B90
3192:  MOVFF  03,D7
3196:  MOVFF  02,D6
319A:  MOVFF  01,D5
319E:  MOVFF  00,D4
31A2:  MOVFF  FEA,D9
31A6:  MOVFF  FE9,D8
31AA:  MOVFF  03,FD
31AE:  MOVFF  02,FC
31B2:  MOVFF  01,FB
31B6:  MOVFF  00,FA
31BA:  MOVLB  1
31BC:  CLRF   x01
31BE:  CLRF   x00
31C0:  MOVLW  01
31C2:  MOVLB  0
31C4:  MOVWF  xFF
31C6:  MOVLW  C2
31C8:  MOVWF  xFE
31CA:  CALL   1392
31CE:  MOVFF  D9,FEA
31D2:  MOVFF  D8,FE9
31D6:  MOVFF  03,71
31DA:  MOVFF  02,70
31DE:  MOVFF  01,6F
31E2:  MOVFF  00,6E
.................... 			enable_interrupts(INT_TIMER0);    
31E6:  BSF    FF2.5
.................... 			enable_interrupts(GLOBAL);  
31E8:  MOVLW  C0
31EA:  IORWF  FF2,F
.................... 			flag.task1_armed=true; 
31EC:  BSF    1F.0
.................... 			write_eeprom_data(0); // save full_stroke_tick and current_position 
31EE:  CLRF   xD2
31F0:  CALL   08BE
.................... 			flag.setup_required =false; 
31F4:  BCF    1F.4
.................... 			break; 
31F6:  BRA    34AE
.................... 		} 
.................... 		case 'h' : { //return home 
.................... 			move_act(1000,9000,move_act_time_out*2,1,0); // move actuator to west 
31F8:  BCF    FD8.0
31FA:  RLCF   xC4,W
31FC:  MOVWF  xD2
31FE:  RLCF   xC5,W
3200:  MOVWF  xD3
3202:  MOVLW  03
3204:  MOVWF  xD7
3206:  MOVLW  E8
3208:  MOVWF  xD6
320A:  MOVLW  23
320C:  MOVWF  xD9
320E:  MOVLW  28
3210:  MOVWF  xD8
3212:  MOVFF  D3,DB
3216:  MOVFF  D2,DA
321A:  MOVLW  01
321C:  MOVWF  xDC
321E:  CLRF   xDD
3220:  CALL   214C
.................... 			FULL_STROKE_TICK= move_act(1000,9000,move_act_time_out*2,0,0); // move actuator to home position 
3224:  BCF    FD8.0
3226:  RLCF   xC4,W
3228:  MOVWF  xD2
322A:  RLCF   xC5,W
322C:  MOVWF  xD3
322E:  MOVLW  03
3230:  MOVWF  xD7
3232:  MOVLW  E8
3234:  MOVWF  xD6
3236:  MOVLW  23
3238:  MOVWF  xD9
323A:  MOVLW  28
323C:  MOVWF  xD8
323E:  MOVFF  D3,DB
3242:  MOVFF  D2,DA
3246:  CLRF   xDC
3248:  CLRF   xDD
324A:  CALL   214C
324E:  MOVFF  02,BF
3252:  MOVFF  01,BE
.................... 			write_eeprom_data(1); // save full_stroke_tick and current_position 
3256:  MOVLW  01
3258:  MOVWF  xD2
325A:  CALL   08BE
.................... 			break; 
325E:  BRA    34AE
.................... 		} 
.................... /* 
.................... 		case 'g': { 
.................... 			print_date_time(); 
.................... 		    break; 
.................... 		} 
.................... 		case 'a': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
.................... 			printf("\r\n   Sun angle %u, stroke length =%f",atoi(cmd_msg),actuator_length(atoi(cmd_msg))); 
.................... 			break; 
.................... 		} 
.................... */ 
.................... 		case 's': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
3260:  CLRF   FEA
3262:  MOVLW  58
3264:  MOVWF  FE9
3266:  CLRF   FE2
3268:  MOVLW  59
326A:  MOVWF  FE1
326C:  MOVLW  12
326E:  MOVWF  01
3270:  MOVFF  FE6,FEE
3274:  DECFSZ 01,F
3276:  BRA    3270
....................             if (atol(cmd_msg)!=22) break; 
3278:  CLRF   xD3
327A:  MOVLW  58
327C:  MOVWF  xD2
327E:  CALL   0B4C
3282:  MOVFF  02,D3
3286:  MOVF   01,W
3288:  MOVWF  xD2
328A:  SUBLW  16
328C:  BNZ   3292
328E:  MOVF   xD3,F
3290:  BZ    3294
3292:  BRA    34AE
.................... 			write_eeprom_data(1); 
3294:  MOVLW  01
3296:  MOVWF  xD2
3298:  CALL   08BE
.................... 			break; 
329C:  BRA    34AE
.................... 		} 
.................... 		case 'y': { //adc conversion 
.................... 			set_adc_channel( 0 ); 
329E:  MOVLW  00
32A0:  MOVWF  01
32A2:  MOVF   FC2,W
32A4:  ANDLW  C7
32A6:  IORWF  01,W
32A8:  MOVWF  FC2
.................... 			delay_us(20); 
32AA:  MOVLW  42
32AC:  MOVWF  00
32AE:  DECFSZ 00,F
32B0:  BRA    32AE
32B2:  NOP   
.................... 			current_measured = read_adc(); 
32B4:  BSF    FC2.2
32B6:  BTFSC  FC2.2
32B8:  BRA    32B6
32BA:  MOVFF  FC3,C6
32BE:  MOVFF  FC4,C7
.................... 			printf("\r\nADC= %lu",current_measured); 
32C2:  CLRF   xD2
32C4:  MOVF   xD2,W
32C6:  CALL   01E4
32CA:  INCF   xD2,F
32CC:  MOVWF  00
32CE:  MOVF   00,W
32D0:  BTFSS  F9E.4
32D2:  BRA    32D0
32D4:  MOVWF  FAD
32D6:  MOVLW  07
32D8:  SUBWF  xD2,W
32DA:  BNZ   32C4
32DC:  MOVLW  10
32DE:  MOVWF  FE9
32E0:  MOVFF  C7,D7
32E4:  MOVFF  C6,D6
32E8:  CALL   081A
.................... 			break; 
32EC:  BRA    34AE
.................... 		} 
.................... 		case 'w': { //buffer1 read 
.................... 			//ext_flash_buffer1_write(0x00,0x00, 1); 
.................... 			//ext_flash_buffer1_read(); 
.................... 			//ext_flash_buffer1_write(0x12,0xAA, 0); 
.................... 			disable_interrupts(GLOBAL); 
32EE:  BCF    FF2.6
32F0:  BCF    FF2.7
32F2:  BTFSC  FF2.7
32F4:  BRA    32F0
.................... 			restart_wdt(); 
32F6:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
32F8:  BCF    FD1.0
.................... 			ext_flash_buffer1_read(); 
32FA:  BRA    2C18
.................... 			enable_interrupts(GLOBAL); 
32FC:  MOVLW  C0
32FE:  IORWF  FF2,F
.................... 			restart_wdt(); 
3300:  CLRWDT
.................... 			setup_wdt(WDT_ON); 
3302:  BSF    FD1.0
....................  
.................... 			//ext_flash_write_buffer1_to_main_memory(1024); 
.................... 			break; 
3304:  BRA    34AE
.................... 		} 
.................... 		case 'i': { //adc conversion 
.................... 			printf("\r\nAct:%lu/%lu",current_act_position,FULL_STROKE_TICK); 
3306:  CLRF   xD2
3308:  MOVF   xD2,W
330A:  CALL   020A
330E:  INCF   xD2,F
3310:  MOVWF  00
3312:  MOVF   00,W
3314:  BTFSS  F9E.4
3316:  BRA    3314
3318:  MOVWF  FAD
331A:  MOVLW  06
331C:  SUBWF  xD2,W
331E:  BNZ   3308
3320:  MOVLW  10
3322:  MOVWF  FE9
3324:  MOVFF  73,D7
3328:  MOVFF  72,D6
332C:  CALL   081A
3330:  MOVLW  2F
3332:  BTFSS  F9E.4
3334:  BRA    3332
3336:  MOVWF  FAD
3338:  MOVLW  10
333A:  MOVWF  FE9
333C:  MOVFF  BF,D7
3340:  MOVFF  BE,D6
3344:  CALL   081A
.................... 			printf("\r\nRestart:%lu",startup_counter); 
3348:  CLRF   xD2
334A:  MOVF   xD2,W
334C:  CALL   0232
3350:  INCF   xD2,F
3352:  MOVWF  00
3354:  MOVF   00,W
3356:  BTFSS  F9E.4
3358:  BRA    3356
335A:  MOVWF  FAD
335C:  MOVLW  0A
335E:  SUBWF  xD2,W
3360:  BNZ   334A
3362:  MOVLW  10
3364:  MOVWF  FE9
3366:  MOVFF  CA,D7
336A:  MOVFF  C9,D6
336E:  CALL   081A
.................... 			printf("\r\nCurrent:%lu (%d)",current_measured/n_avg_current_measured, n_avg_current_measured); 
3372:  MOVFF  C7,D5
3376:  MOVFF  C6,D4
337A:  CLRF   xD7
337C:  MOVFF  C8,D6
3380:  RCALL  2C9E
3382:  MOVFF  02,D3
3386:  MOVFF  01,D2
338A:  CLRF   xD4
338C:  MOVF   xD4,W
338E:  CALL   025A
3392:  INCF   xD4,F
3394:  MOVWF  00
3396:  MOVF   00,W
3398:  BTFSS  F9E.4
339A:  BRA    3398
339C:  MOVWF  FAD
339E:  MOVLW  0A
33A0:  SUBWF  xD4,W
33A2:  BNZ   338C
33A4:  MOVLW  10
33A6:  MOVWF  FE9
33A8:  MOVFF  D3,D7
33AC:  MOVFF  D2,D6
33B0:  CALL   081A
33B4:  MOVLW  20
33B6:  BTFSS  F9E.4
33B8:  BRA    33B6
33BA:  MOVWF  FAD
33BC:  MOVLW  28
33BE:  BTFSS  F9E.4
33C0:  BRA    33BE
33C2:  MOVWF  FAD
33C4:  MOVFF  C8,D5
33C8:  MOVLW  1F
33CA:  MOVWF  xD6
33CC:  CALL   074A
33D0:  MOVLW  29
33D2:  BTFSS  F9E.4
33D4:  BRA    33D2
33D6:  MOVWF  FAD
.................... 			printf("\r\nTimer:%lu",timer_sec); 
33D8:  CLRF   xD2
33DA:  MOVF   xD2,W
33DC:  CALL   0288
33E0:  INCF   xD2,F
33E2:  MOVWF  00
33E4:  MOVF   00,W
33E6:  BTFSS  F9E.4
33E8:  BRA    33E6
33EA:  MOVWF  FAD
33EC:  MOVLW  08
33EE:  SUBWF  xD2,W
33F0:  BNZ   33DA
33F2:  MOVLW  41
33F4:  MOVWF  FE9
33F6:  MOVFF  27,D6
33FA:  MOVFF  26,D5
33FE:  MOVFF  25,D4
3402:  MOVFF  24,D3
3406:  BRA    2CE0
3408:  CLRF   18
340A:  BTFSC  FF2.7
340C:  BSF    18.7
340E:  BCF    FF2.7
.................... 			printf("\r\n#Day:%lu",find_day_number((timer_sec)%SEC_IN_4_YEARS)); 
3410:  MOVFF  27,F5
3414:  MOVFF  26,F4
3418:  MOVFF  25,F3
341C:  MOVFF  24,F2
3420:  MOVLW  07
3422:  MOVWF  xF9
3424:  MOVLW  86
3426:  MOVWF  xF8
3428:  MOVLW  1F
342A:  MOVWF  xF7
342C:  MOVLW  80
342E:  MOVWF  xF6
3430:  CALL   036A
3434:  BTFSC  18.7
3436:  BSF    FF2.7
3438:  MOVFF  FEF,D2
343C:  MOVFF  FEC,D3
3440:  MOVFF  FEC,D4
3444:  MOVFF  FEC,D5
3448:  MOVFF  D5,E5
344C:  MOVFF  D4,E4
3450:  MOVFF  D3,E3
3454:  MOVFF  D2,E2
3458:  CALL   2AF6
345C:  MOVFF  02,D4
3460:  MOVFF  01,D3
3464:  CLRF   xD5
3466:  MOVF   xD5,W
3468:  CALL   02AE
346C:  INCF   xD5,F
346E:  MOVWF  00
3470:  MOVF   00,W
3472:  BTFSS  F9E.4
3474:  BRA    3472
3476:  MOVWF  FAD
3478:  MOVLW  07
347A:  SUBWF  xD5,W
347C:  BNZ   3466
347E:  MOVLW  10
3480:  MOVWF  FE9
3482:  MOVFF  D4,D7
3486:  MOVFF  D3,D6
348A:  CALL   081A
....................  
.................... 			break; 
348E:  BRA    34AE
.................... 		} 
.................... 		case 'c': { //clear write buffer 
.................... 		    ext_flash_buffer1_write(0xAA,0,255); 
3490:  MOVLW  AA
3492:  MOVWF  xDD
3494:  CLRF   xDE
3496:  MOVLW  FF
3498:  MOVWF  xDF
349A:  RCALL  2DAA
.................... 			break; 
349C:  BRA    34AE
.................... 		} 
....................  
.................... 		case 'x': { //stop timer 
.................... 		    disable_interrupts(INT_TIMER1);  
349E:  BCF    F9D.0
.................... 			restart_wdt(); 
34A0:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
34A2:  BCF    FD1.0
.................... 			break; 
34A4:  BRA    34AE
.................... 		} 
....................  
.................... 		case 'o': { //start timer 
.................... 		    enable_interrupts(INT_TIMER1);  
34A6:  BSF    F9D.0
.................... 			setup_wdt(WDT_ON); 
34A8:  BSF    FD1.0
.................... 			restart_wdt(); 
34AA:  CLRWDT
.................... 			break; 
34AC:  BRA    34AE
.................... 		} 
....................  
....................  
.................... 		} 
.................... 		 
.................... 	} 
34AE:  RETLW  00
....................  
.................... void print_len_and_tick() 
.................... { 
.................... 	lcd_gotoxy(0,3); 
*
5A7E:  CLRF   xEF
5A80:  MOVLW  03
5A82:  MOVWF  xF0
5A84:  CALL   0D34
.................... 	itoa((int16)(al),10,tmp_str); 
5A88:  MOVFF  C3,14E
5A8C:  MOVFF  C2,14D
5A90:  MOVFF  C1,14C
5A94:  MOVFF  C0,14B
5A98:  CALL   4194
5A9C:  MOVFF  02,D3
5AA0:  MOVFF  01,D2
5AA4:  CLRF   xEE
5AA6:  CLRF   xED
5AA8:  MOVFF  02,EC
5AAC:  MOVFF  01,EB
5AB0:  MOVLW  0A
5AB2:  MOVWF  xEF
5AB4:  CLRF   xF1
5AB6:  MOVLW  30
5AB8:  MOVWF  xF0
5ABA:  CALL   14D6
....................     printf(lcd_putc,"L=%s.",tmp_str); 
5ABE:  MOVLW  4C
5AC0:  MOVWF  xEE
5AC2:  CALL   0D5A
5AC6:  MOVLW  3D
5AC8:  MOVWF  xEE
5ACA:  CALL   0D5A
5ACE:  CLRF   FEA
5AD0:  MOVLW  30
5AD2:  MOVWF  FE9
5AD4:  MOVLW  00
5AD6:  IORWF  FEF,W
5AD8:  BZ    5AFA
5ADA:  MOVFF  FEA,D3
5ADE:  MOVFF  FE9,D2
5AE2:  MOVFF  FEF,EE
5AE6:  CALL   0D5A
5AEA:  MOVFF  D3,FEA
5AEE:  MOVFF  D2,FE9
5AF2:  INCF   FE9,F
5AF4:  BTFSC  FD8.2
5AF6:  INCF   FEA,F
5AF8:  BRA    5AD4
5AFA:  MOVLW  2E
5AFC:  MOVWF  xEE
5AFE:  CALL   0D5A
.................... 	itoa((int16)(al*100.0)%100,10,tmp_str); 
5B02:  MOVFF  C3,152
5B06:  MOVFF  C2,151
5B0A:  MOVFF  C1,150
5B0E:  MOVFF  C0,14F
5B12:  MOVLB  1
5B14:  CLRF   x56
5B16:  CLRF   x55
5B18:  MOVLW  48
5B1A:  MOVWF  x54
5B1C:  MOVLW  85
5B1E:  MOVWF  x53
5B20:  MOVLB  0
5B22:  CALL   0E86
5B26:  MOVFF  03,14E
5B2A:  MOVFF  02,14D
5B2E:  MOVFF  01,14C
5B32:  MOVFF  00,14B
5B36:  CALL   4194
5B3A:  MOVFF  02,D3
5B3E:  MOVFF  01,D2
5B42:  MOVFF  02,D5
5B46:  MOVFF  01,D4
5B4A:  CLRF   xD7
5B4C:  MOVLW  64
5B4E:  MOVWF  xD6
5B50:  CALL   2C9E
5B54:  MOVFF  00,D3
5B58:  MOVFF  03,D4
5B5C:  CLRF   xEE
5B5E:  CLRF   xED
5B60:  MOVFF  03,EC
5B64:  MOVFF  00,EB
5B68:  MOVLW  0A
5B6A:  MOVWF  xEF
5B6C:  CLRF   xF1
5B6E:  MOVLW  30
5B70:  MOVWF  xF0
5B72:  CALL   14D6
....................     printf(lcd_putc,"%scm  ",tmp_str); 
5B76:  CLRF   FEA
5B78:  MOVLW  30
5B7A:  MOVWF  FE9
5B7C:  MOVLW  00
5B7E:  IORWF  FEF,W
5B80:  BZ    5BA2
5B82:  MOVFF  FEA,D3
5B86:  MOVFF  FE9,D2
5B8A:  MOVFF  FEF,EE
5B8E:  CALL   0D5A
5B92:  MOVFF  D3,FEA
5B96:  MOVFF  D2,FE9
5B9A:  INCF   FE9,F
5B9C:  BTFSC  FD8.2
5B9E:  INCF   FEA,F
5BA0:  BRA    5B7C
5BA2:  MOVLW  02
5BA4:  MOVWF  xD4
5BA6:  MOVF   xD4,W
5BA8:  CALL   02D4
5BAC:  INCF   xD4,F
5BAE:  MOVWF  00
5BB0:  MOVWF  xEE
5BB2:  CALL   0D5A
5BB6:  MOVLW  06
5BB8:  SUBWF  xD4,W
5BBA:  BNZ   5BA6
.................... 	lcd_gotoxy(12,3); 
5BBC:  MOVLW  0C
5BBE:  MOVWF  xEF
5BC0:  MOVLW  03
5BC2:  MOVWF  xF0
5BC4:  CALL   0D34
....................     printf(lcd_putc,"Tick=%03lu",target_act_position); 
5BC8:  CLRF   xD2
5BCA:  MOVF   xD2,W
5BCC:  CALL   02F6
5BD0:  INCF   xD2,F
5BD2:  MOVWF  00
5BD4:  MOVWF  xEE
5BD6:  CALL   0D5A
5BDA:  MOVLW  05
5BDC:  SUBWF  xD2,W
5BDE:  BNZ   5BCA
5BE0:  MOVLW  0A
5BE2:  MOVWF  FE9
5BE4:  MOVFF  75,E6
5BE8:  MOVFF  74,E5
5BEC:  CALL   0D9E
....................  
.................... } 
5BF0:  RETLW  00
....................  
....................  
.................... void main() { 
5BF2:  CLRF   FF8
5BF4:  BCF    FD0.7
5BF6:  BSF    0D.7
5BF8:  CLRF   FEA
5BFA:  CLRF   FE9
5BFC:  MOVLW  2A
5BFE:  MOVWF  FAF
5C00:  MOVLW  A6
5C02:  MOVWF  FAC
5C04:  MOVLW  90
5C06:  MOVWF  FAB
5C08:  BSF    FC1.0
5C0A:  BSF    FC1.1
5C0C:  BSF    FC1.2
5C0E:  BCF    FC1.3
5C10:  MOVLW  07
5C12:  MOVWF  FB4
5C14:  CLRF   19
5C16:  CLRF   1A
5C18:  CLRF   20
5C1A:  MOVLW  40
5C1C:  MOVWF  21
5C1E:  MOVLW  14
5C20:  MOVWF  22
5C22:  MOVLW  54
5C24:  MOVWF  23
5C26:  CLRF   24
5C28:  CLRF   25
5C2A:  CLRF   26
5C2C:  CLRF   27
5C2E:  CLRF   28
5C30:  CLRF   29
5C32:  CLRF   2A
5C34:  CLRF   2B
5C36:  CLRF   2C
5C38:  CLRF   2D
5C3A:  CLRF   2E
5C3C:  CLRF   2F
5C3E:  CLRF   x6C
5C40:  CLRF   x6D
5C42:  CLRF   x72
5C44:  CLRF   x73
5C46:  CLRF   x74
5C48:  CLRF   x75
5C4A:  CLRF   xBE
5C4C:  CLRF   xBF
5C4E:  MOVLW  04
5C50:  MOVWF  xC4
5C52:  CLRF   xC5
5C54:  CLRF   xC6
5C56:  CLRF   xC7
5C58:  CLRF   xC8
5C5A:  CLRF   xC9
5C5C:  CLRF   xCA
....................     unsigned int8 solar_angle; 
.................... 	int16 tick=0; 
5C5E:  CLRF   xCD
5C60:  CLRF   xCE
.................... 	int16 temp_mem; 
.................... 	int8 i; 
....................     set_tris_e(0x00); // all E are output 
5C62:  BCF    F96.0
5C64:  BCF    F96.1
5C66:  BCF    F96.2
.................... 	set_tris_d(0x00); // all D are output 
5C68:  MOVLW  00
5C6A:  MOVWF  F95
.................... 	set_tris_a(0xFF); // All is input 
5C6C:  MOVLW  FF
5C6E:  MOVWF  F92
.................... 	set_tris_b(0xA0); 
5C70:  MOVLW  A0
5C72:  MOVWF  F93
.................... 	set_tris_c(0b10010000); 
5C74:  MOVLW  90
5C76:  MOVWF  F94
.................... 	timer_sec=0; 
5C78:  CLRF   27
5C7A:  CLRF   26
5C7C:  CLRF   25
5C7E:  CLRF   24
.................... 	delay_ms(2000); 
5C80:  MOVLW  08
5C82:  MOVWF  xD2
5C84:  MOVLW  FA
5C86:  MOVWF  xEF
5C88:  CALL   05A2
5C8C:  DECFSZ xD2,F
5C8E:  BRA    5C84
.................... 	read_eeprom_data(); 
5C90:  GOTO   05E4
.................... 	restart_wdt(); 
5C94:  CLRWDT
.................... 	setup_wdt(WDT_OFF); 
5C96:  BCF    FD1.0
.................... 	setup_adc_ports(AN0); 
5C98:  BCF    FC1.0
5C9A:  BSF    FC1.1
5C9C:  BSF    FC1.2
5C9E:  BSF    FC1.3
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
5CA0:  BCF    FC1.6
5CA2:  BSF    FC2.6
5CA4:  BSF    FC2.7
5CA6:  BSF    FC1.7
5CA8:  BSF    FC2.0
.................... 	set_adc_channel( 0 ); 
5CAA:  MOVLW  00
5CAC:  MOVWF  01
5CAE:  MOVF   FC2,W
5CB0:  ANDLW  C7
5CB2:  IORWF  01,W
5CB4:  MOVWF  FC2
.................... 	current_measured =0; 
5CB6:  CLRF   xC7
5CB8:  CLRF   xC6
.................... 	startup_counter++; 
5CBA:  INCF   xC9,F
5CBC:  BTFSC  FD8.2
5CBE:  INCF   xCA,F
.................... 	printf("\r\nRestart Cause:%3d %lu",restart_cause(),startup_counter); 
5CC0:  MOVF   FD0,W
5CC2:  ANDLW  0F
5CC4:  BTFSS  FD0.4
5CC6:  MOVLW  00
5CC8:  BSF    FD0.0
5CCA:  BSF    FD0.1
5CCC:  BSF    FD0.4
5CCE:  BSF    FD8.3
5CD0:  BSF    FD8.4
5CD2:  MOVWF  xD2
5CD4:  CLRF   xD3
5CD6:  MOVF   xD3,W
5CD8:  CALL   031C
5CDC:  INCF   xD3,F
5CDE:  MOVWF  00
5CE0:  MOVF   00,W
5CE2:  BTFSS  F9E.4
5CE4:  BRA    5CE2
5CE6:  MOVWF  FAD
5CE8:  MOVLW  10
5CEA:  SUBWF  xD3,W
5CEC:  BNZ   5CD6
5CEE:  MOVFF  D2,D5
5CF2:  MOVLW  13
5CF4:  MOVWF  xD6
5CF6:  CALL   074A
5CFA:  MOVLW  20
5CFC:  BTFSS  F9E.4
5CFE:  BRA    5CFC
5D00:  MOVWF  FAD
5D02:  MOVLW  10
5D04:  MOVWF  FE9
5D06:  MOVFF  CA,D7
5D0A:  MOVFF  C9,D6
5D0E:  CALL   081A
.................... 	write_eeprom_data(0); 
5D12:  CLRF   xD2
5D14:  CALL   08BE
.................... 	output_low(CCW); 
5D18:  BCF    F93.4
5D1A:  BCF    F8A.4
.................... 	output_low(EN0); 
5D1C:  BCF    F93.0
5D1E:  BCF    F8A.0
.................... 	output_low(EN1); 
5D20:  BCF    F93.1
5D22:  BCF    F8A.1
.................... 	output_low(EN2); 
5D24:  BCF    F93.2
5D26:  BCF    F8A.2
.................... 	output_low(EN3); 
5D28:  BCF    F93.3
5D2A:  BCF    F8A.3
.................... 	output_low(PS_EN); 
5D2C:  BCF    F94.1
5D2E:  BCF    F8B.1
....................     output_low(LCD_EN); 
5D30:  BCF    F94.0
5D32:  BCF    F8B.0
....................     PORTE.rw=1; 
5D34:  BSF    F84.1
.................... 	lcd_init(); 
5D36:  CALL   0A90
.................... 	init_ext_flash(); 
5D3A:  GOTO   0B20
.................... 	restart_wdt(); 
5D3E:  CLRWDT
....................     output_high(FLASH_SELECT); 
5D40:  BCF    F92.1
5D42:  BSF    F89.1
....................     setup_timer_0(RTCC_DIV_32); 
5D44:  MOVLW  84
5D46:  MOVWF  FD5
.................... 	//setup_timer_0(RTCC_DIV_1); 
....................     disable_interrupts(INT_TIMER0);   // Setup interrupt on falling edge 
5D48:  BCF    FF2.5
....................     disable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
5D4A:  BCF    F9D.0
....................     disable_interrupts(GLOBAL); 
5D4C:  BCF    FF2.6
5D4E:  BCF    FF2.7
5D50:  BTFSC  FF2.7
5D52:  BRA    5D4E
.................... 	flag=0; 
5D54:  CLRF   1F
....................     strcpy(cmd_msg,""); 
5D56:  CLRF   FEA
5D58:  MOVLW  58
5D5A:  MOVWF  FE9
5D5C:  MOVFF  FF2,D2
5D60:  BCF    FF2.7
5D62:  MOVLW  00
5D64:  CALL   034E
5D68:  TBLRD*-
5D6A:  TBLRD*+
5D6C:  MOVF   FF5,W
5D6E:  MOVWF  FEE
5D70:  IORLW  00
5D72:  BNZ   5D6A
5D74:  BTFSC  xD2.7
5D76:  BSF    FF2.7
.................... 	if (timer_sec ==0x00000000) 
5D78:  MOVF   24,F
5D7A:  BNZ   5D8C
5D7C:  MOVF   25,F
5D7E:  BNZ   5D8C
5D80:  MOVF   26,F
5D82:  BNZ   5D8C
5D84:  MOVF   27,F
5D86:  BNZ   5D8C
.................... 		flag.setup_required = true; 
5D88:  BSF    1F.4
.................... 	else 
5D8A:  BRA    5D8E
.................... 		flag.setup_required = false; 
5D8C:  BCF    1F.4
....................  
.................... ///////////////// 
.................... 	enable_interrupts(INT_RDA); 
5D8E:  BSF    F9D.5
.................... 	enable_interrupts(INT_TIMER0);   
5D90:  BSF    FF2.5
.................... 	enable_interrupts(GLOBAL);  
5D92:  MOVLW  C0
5D94:  IORWF  FF2,F
.................... 	while(flag.setup_required)	if (flag.cmd_posted) process_cmd_msg(); 
5D96:  BTFSS  1F.4
5D98:  BRA    5DA4
5D9A:  BTFSS  1F.3
5D9C:  BRA    5DA2
5D9E:  CALL   2E08
5DA2:  BRA    5D96
.................... 	setup_wdt(WDT_ON); 
5DA4:  BSF    FD1.0
5DA6:  CLRF   18
5DA8:  BTFSC  FF2.7
5DAA:  BSF    18.7
5DAC:  BCF    FF2.7
.................... 	next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
5DAE:  MOVFF  27,F5
5DB2:  MOVFF  26,F4
5DB6:  MOVFF  25,F3
5DBA:  MOVFF  24,F2
5DBE:  MOVLW  07
5DC0:  MOVWF  xF9
5DC2:  MOVLW  86
5DC4:  MOVWF  xF8
5DC6:  MOVLW  1F
5DC8:  MOVWF  xF7
5DCA:  MOVLW  80
5DCC:  MOVWF  xF6
5DCE:  CALL   036A
5DD2:  BTFSC  18.7
5DD4:  BSF    FF2.7
5DD6:  MOVFF  FEF,D2
5DDA:  MOVFF  FEC,D3
5DDE:  MOVFF  FEC,D4
5DE2:  MOVFF  FEC,D5
5DE6:  MOVFF  D5,E5
5DEA:  MOVFF  D4,E4
5DEE:  MOVFF  D3,E3
5DF2:  MOVFF  D2,E2
5DF6:  CALL   2AF6
5DFA:  MOVFF  02,D4
5DFE:  MOVFF  01,D3
5E02:  MOVFF  02,E3
5E06:  MOVFF  01,E2
5E0A:  CALL   2B90
5E0E:  MOVFF  03,D7
5E12:  MOVFF  02,D6
5E16:  MOVFF  01,D5
5E1A:  MOVFF  00,D4
5E1E:  MOVFF  FEA,D9
5E22:  MOVFF  FE9,D8
5E26:  MOVFF  03,FD
5E2A:  MOVFF  02,FC
5E2E:  MOVFF  01,FB
5E32:  MOVFF  00,FA
5E36:  MOVLB  1
5E38:  CLRF   x01
5E3A:  CLRF   x00
5E3C:  MOVLW  01
5E3E:  MOVLB  0
5E40:  MOVWF  xFF
5E42:  MOVLW  C2
5E44:  MOVWF  xFE
5E46:  CALL   1392
5E4A:  MOVFF  D9,FEA
5E4E:  MOVFF  D8,FE9
5E52:  MOVFF  03,71
5E56:  MOVFF  02,70
5E5A:  MOVFF  01,6F
5E5E:  MOVFF  00,6E
....................  
.................... ////////////////// 
.................... 	// take sun angle and calculate the length of actuator needed to push 
.................... 	// also need counter of reed switch 
.................... 	flag.task1_armed =true; 
5E62:  BSF    1F.0
.................... 	while(1) { 
.................... 		if (flag.update_time) { 
5E64:  BTFSS  1F.1
5E66:  BRA    5E6E
.................... 			flag.update_time = false; 
5E68:  BCF    1F.1
.................... 			print_date_time(); 
5E6A:  CALL   1716
.................... 		} 
....................  
.................... 		if (flag.measured_current) {	 
5E6E:  BTFSS  1F.6
5E70:  BRA    5E84
.................... 		   flag.measured_current = false; 
5E72:  BCF    1F.6
.................... 		   current_measured += read_adc(); 
5E74:  BSF    FC2.2
5E76:  BTFSC  FC2.2
5E78:  BRA    5E76
5E7A:  MOVF   FC3,W
5E7C:  ADDWF  xC6,F
5E7E:  MOVF   FC4,W
5E80:  ADDWFC xC7,F
.................... 		   n_avg_current_measured++; 
5E82:  INCF   xC8,F
.................... 		} 
....................  
.................... 		if (flag.cmd_posted) { 
5E84:  BTFSS  1F.3
5E86:  BRA    5E8E
.................... 			flag.cmd_posted = false; 
5E88:  BCF    1F.3
.................... 			process_cmd_msg(); 
5E8A:  CALL   2E08
.................... 		} 
.................... 		if (flag.reset_rs232) { 
5E8E:  BTFSS  1F.5
5E90:  BRA    5E98
.................... 			flag.reset_rs232 =false; 
5E92:  BCF    1F.5
.................... 			 init_rs232(); 
5E94:  GOTO   3502
.................... 		} 
.................... 		if (flag.task1_armed) { 
5E98:  BTFSS  1F.0
5E9A:  BRA    61CA
.................... 			flag.task1_armed = false; 
5E9C:  BCF    1F.0
.................... 			solar_angle= task1(); 
5E9E:  CALL   376E
5EA2:  MOVFF  01,CC
.................... 			if ((solar_angle>0) && (solar_angle<180)) { 
5EA6:  MOVF   xCC,F
5EA8:  BZ    5EB0
5EAA:  MOVF   xCC,W
5EAC:  SUBLW  B3
5EAE:  BNC   5EB0
....................  
.................... 			} 
.................... 	 
.................... 			if ((solar_angle>30) && (solar_angle<150)) { 
5EB0:  MOVF   xCC,W
5EB2:  SUBLW  1E
5EB4:  BC    5EE0
5EB6:  MOVF   xCC,W
5EB8:  SUBLW  95
5EBA:  BNC   5EE0
.................... 				lcd_gotoxy(0,3); 
5EBC:  CLRF   xEF
5EBE:  MOVLW  03
5EC0:  MOVWF  xF0
5EC2:  CALL   0D34
.................... 				al=actuator_length(solar_angle); 
5EC6:  MOVFF  CC,D4
5ECA:  CALL   476E
5ECE:  MOVFF  03,C3
5ED2:  MOVFF  02,C2
5ED6:  MOVFF  01,C1
5EDA:  MOVFF  00,C0
.................... 			} else { 
5EDE:  BRA    5F52
.................... 				if ((solar_angle>0) && (solar_angle<=30)) { 
5EE0:  MOVF   xCC,F
5EE2:  BZ    5F16
5EE4:  MOVF   xCC,W
5EE6:  SUBLW  1E
5EE8:  BNC   5F16
.................... 					al=actuator_length(90-get_backtrack_angle(90-solar_angle)); 
5EEA:  MOVLW  5A
5EEC:  BSF    FD8.0
5EEE:  SUBFWB xCC,W
5EF0:  MOVWF  xD2
5EF2:  MOVWF  xD3
5EF4:  RCALL  576A
5EF6:  MOVLW  5A
5EF8:  BSF    FD8.0
5EFA:  SUBFWB 01,W
5EFC:  MOVWF  xD3
5EFE:  MOVWF  xD4
5F00:  CALL   476E
5F04:  MOVFF  03,C3
5F08:  MOVFF  02,C2
5F0C:  MOVFF  01,C1
5F10:  MOVFF  00,C0
.................... 				} else if ((solar_angle>=150) && (solar_angle<=180)) { 
5F14:  BRA    5F52
5F16:  MOVF   xCC,W
5F18:  SUBLW  95
5F1A:  BC    5F52
5F1C:  MOVF   xCC,W
5F1E:  SUBLW  B4
5F20:  BNC   5F52
.................... 					lcd_gotoxy(0,3); 
5F22:  CLRF   xEF
5F24:  MOVLW  03
5F26:  MOVWF  xF0
5F28:  CALL   0D34
.................... 					al=actuator_length(90+get_backtrack_angle(solar_angle-90)); 
5F2C:  MOVLW  5A
5F2E:  SUBWF  xCC,W
5F30:  MOVWF  xD2
5F32:  MOVWF  xD3
5F34:  RCALL  576A
5F36:  MOVLW  5A
5F38:  ADDWF  01,W
5F3A:  MOVWF  xD3
5F3C:  MOVWF  xD4
5F3E:  CALL   476E
5F42:  MOVFF  03,C3
5F46:  MOVFF  02,C2
5F4A:  MOVFF  01,C1
5F4E:  MOVFF  00,C0
.................... 				} 
.................... 			} 
.................... 			if((al >= MIN_STROKE) && (al <=MAX_STROKE)) { 
5F52:  MOVLW  9A
5F54:  MOVLB  1
5F56:  MOVWF  x4E
5F58:  MOVLW  99
5F5A:  MOVWF  x4D
5F5C:  MOVLW  0C
5F5E:  MOVWF  x4C
5F60:  MOVLW  85
5F62:  MOVWF  x4B
5F64:  MOVFF  C3,152
5F68:  MOVFF  C2,151
5F6C:  MOVFF  C1,150
5F70:  MOVFF  C0,14F
5F74:  MOVLB  0
5F76:  CALL   3BBA
5F7A:  BC    5F7E
5F7C:  BNZ   6062
5F7E:  MOVFF  C3,14E
5F82:  MOVFF  C2,14D
5F86:  MOVFF  C1,14C
5F8A:  MOVFF  C0,14B
5F8E:  MOVLB  1
5F90:  CLRF   x52
5F92:  CLRF   x51
5F94:  CLRF   x50
5F96:  MOVLW  86
5F98:  MOVWF  x4F
5F9A:  MOVLB  0
5F9C:  CALL   3BBA
5FA0:  BC    5FA4
5FA2:  BNZ   6062
.................... 				tick = ((al-MIN_STROKE)/(MAX_STROKE-MIN_STROKE))*FULL_STROKE_TICK; 
5FA4:  BSF    FD8.1
5FA6:  MOVFF  C3,154
5FAA:  MOVFF  C2,153
5FAE:  MOVFF  C1,152
5FB2:  MOVFF  C0,151
5FB6:  MOVLW  9A
5FB8:  MOVLB  1
5FBA:  MOVWF  x58
5FBC:  MOVLW  99
5FBE:  MOVWF  x57
5FC0:  MOVLW  0C
5FC2:  MOVWF  x56
5FC4:  MOVLW  85
5FC6:  MOVWF  x55
5FC8:  MOVLB  0
5FCA:  CALL   10DA
5FCE:  MOVFF  00,D2
5FD2:  MOVFF  01,D3
5FD6:  MOVFF  02,D4
5FDA:  MOVFF  03,D5
5FDE:  MOVFF  03,14E
5FE2:  MOVFF  02,14D
5FE6:  MOVFF  01,14C
5FEA:  MOVFF  00,14B
5FEE:  MOVLW  CC
5FF0:  MOVLB  1
5FF2:  MOVWF  x52
5FF4:  MOVWF  x51
5FF6:  MOVLW  66
5FF8:  MOVWF  x50
5FFA:  MOVLW  84
5FFC:  MOVWF  x4F
5FFE:  MOVLB  0
6000:  CALL   0F7C
6004:  MOVFF  00,D6
6008:  MOVFF  01,D7
600C:  MOVFF  02,D8
6010:  MOVFF  03,D9
6014:  MOVFF  BF,150
6018:  MOVFF  BE,14F
601C:  CALL   415E
6020:  MOVFF  D9,152
6024:  MOVFF  D8,151
6028:  MOVFF  D7,150
602C:  MOVFF  D6,14F
6030:  MOVFF  03,156
6034:  MOVFF  02,155
6038:  MOVFF  01,154
603C:  MOVFF  00,153
6040:  CALL   0E86
6044:  MOVFF  03,14E
6048:  MOVFF  02,14D
604C:  MOVFF  01,14C
6050:  MOVFF  00,14B
6054:  CALL   4194
6058:  MOVFF  02,CE
605C:  MOVFF  01,CD
.................... 			} else if (al<MIN_STROKE) { 
6060:  BRA    60BE
6062:  MOVFF  C3,14E
6066:  MOVFF  C2,14D
606A:  MOVFF  C1,14C
606E:  MOVFF  C0,14B
6072:  MOVLW  9A
6074:  MOVLB  1
6076:  MOVWF  x52
6078:  MOVLW  99
607A:  MOVWF  x51
607C:  MOVLW  0C
607E:  MOVWF  x50
6080:  MOVLW  85
6082:  MOVWF  x4F
6084:  MOVLB  0
6086:  CALL   3BBA
608A:  BNC   6092
.................... 				tick = 0; 
608C:  CLRF   xCE
608E:  CLRF   xCD
.................... 			} else if (al>MAX_STROKE) { 
6090:  BRA    60BE
6092:  MOVLB  1
6094:  CLRF   x4E
6096:  CLRF   x4D
6098:  CLRF   x4C
609A:  MOVLW  86
609C:  MOVWF  x4B
609E:  MOVFF  C3,152
60A2:  MOVFF  C2,151
60A6:  MOVFF  C1,150
60AA:  MOVFF  C0,14F
60AE:  MOVLB  0
60B0:  CALL   3BBA
60B4:  BNC   60BE
.................... 				tick = FULL_STROKE_TICK; 
60B6:  MOVFF  BF,CE
60BA:  MOVFF  BE,CD
.................... 			} 
.................... 			target_act_position = tick; 
60BE:  MOVFF  CE,75
60C2:  MOVFF  CD,74
.................... 			print_len_and_tick(); 
60C6:  RCALL  5A7E
....................  
.................... 			if(current_act_position > (target_act_position+5))// move east 
60C8:  MOVLW  05
60CA:  ADDWF  x74,W
60CC:  MOVWF  01
60CE:  MOVLW  00
60D0:  ADDWFC x75,W
60D2:  MOVWF  03
60D4:  MOVF   03,W
60D6:  SUBWF  x73,W
60D8:  BNC   6110
60DA:  BNZ   60E2
60DC:  MOVF   x72,W
60DE:  SUBWF  01,W
60E0:  BC    6110
.................... 			{ 
.................... 				move_act(current_act_position-target_act_position,4500,move_act_time_out,0,1); 
60E2:  MOVF   x74,W
60E4:  SUBWF  x72,W
60E6:  MOVWF  xD2
60E8:  MOVF   x75,W
60EA:  SUBWFB x73,W
60EC:  MOVWF  xD3
60EE:  MOVWF  xD7
60F0:  MOVFF  D2,D6
60F4:  MOVLW  11
60F6:  MOVWF  xD9
60F8:  MOVLW  94
60FA:  MOVWF  xD8
60FC:  MOVFF  C5,DB
6100:  MOVFF  C4,DA
6104:  CLRF   xDC
6106:  MOVLW  01
6108:  MOVWF  xDD
610A:  CALL   214C
.................... 			} else if((current_act_position+5) < target_act_position)// move west 
610E:  BRA    61B0
6110:  MOVLW  05
6112:  ADDWF  x72,W
6114:  MOVWF  xD2
6116:  MOVLW  00
6118:  ADDWFC x73,W
611A:  MOVWF  xD3
611C:  SUBWF  x75,W
611E:  BNC   6156
6120:  BNZ   6128
6122:  MOVF   x74,W
6124:  SUBWF  xD2,W
6126:  BC    6156
.................... 			{ 
.................... 				move_act(target_act_position-current_act_position,4500,move_act_time_out,1,1); 
6128:  MOVF   x72,W
612A:  SUBWF  x74,W
612C:  MOVWF  xD2
612E:  MOVF   x73,W
6130:  SUBWFB x75,W
6132:  MOVWF  xD3
6134:  MOVWF  xD7
6136:  MOVFF  D2,D6
613A:  MOVLW  11
613C:  MOVWF  xD9
613E:  MOVLW  94
6140:  MOVWF  xD8
6142:  MOVFF  C5,DB
6146:  MOVFF  C4,DA
614A:  MOVLW  01
614C:  MOVWF  xDC
614E:  MOVWF  xDD
6150:  CALL   214C
.................... 			} else if (target_act_position == 0x00)  // move east all the way 
6154:  BRA    61B0
6156:  MOVF   x74,F
6158:  BNZ   6182
615A:  MOVF   x75,F
615C:  BNZ   6182
.................... 				move_act(FULL_STROKE_TICK,4500,move_act_time_out,0,1); 
615E:  MOVFF  BF,D7
6162:  MOVFF  BE,D6
6166:  MOVLW  11
6168:  MOVWF  xD9
616A:  MOVLW  94
616C:  MOVWF  xD8
616E:  MOVFF  C5,DB
6172:  MOVFF  C4,DA
6176:  CLRF   xDC
6178:  MOVLW  01
617A:  MOVWF  xDD
617C:  CALL   214C
.................... 			else if (target_act_position == FULL_STROKE_TICK) // move west all the way 
6180:  BRA    61B0
6182:  MOVF   xBE,W
6184:  SUBWF  x74,W
6186:  BNZ   61B0
6188:  MOVF   xBF,W
618A:  SUBWF  x75,W
618C:  BNZ   61B0
.................... 				move_act(FULL_STROKE_TICK,4500,move_act_time_out,1,1); 
618E:  MOVFF  BF,D7
6192:  MOVFF  BE,D6
6196:  MOVLW  11
6198:  MOVWF  xD9
619A:  MOVLW  94
619C:  MOVWF  xD8
619E:  MOVFF  C5,DB
61A2:  MOVFF  C4,DA
61A6:  MOVLW  01
61A8:  MOVWF  xDC
61AA:  MOVWF  xDD
61AC:  CALL   214C
.................... 			task1(); 
61B0:  CALL   376E
.................... 			print_len_and_tick(); 
61B4:  RCALL  5A7E
.................... 			write_eeprom_data(0); 
61B6:  CLRF   xD2
61B8:  CALL   08BE
.................... 			current_measured=0; 
61BC:  CLRF   xC7
61BE:  CLRF   xC6
.................... 			n_avg_current_measured=0; 
61C0:  CLRF   xC8
.................... 			printf("."); 
61C2:  MOVLW  2E
61C4:  BTFSS  F9E.4
61C6:  BRA    61C4
61C8:  MOVWF  FAD
.................... 		} 
.................... 	} 
61CA:  BRA    5E64
....................  
.................... } 
.................... 	 
61CC:  SLEEP 

Configuration Fuses:
   Word  1: 2600   H4 NOOSCSEN
   Word  2: 0A0E   BROWNOUT WDT32 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: D8 02 00 00 00 00 00 00 00 00 
