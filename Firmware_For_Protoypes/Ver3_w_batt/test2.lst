CCS PCH C Compiler, Version 4.078, 37503               18-เม.ย.-10 11:44

               Filename: test2.lst

               ROM used: 25566 bytes (78%)
                         Largest free fragment is 7198
               RAM used: 215 (14%) at main() level
                         359 (23%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
0000:  GOTO   5DFC
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   03B2
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04DC
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1708:  MOVFF  E5,E7
170C:  MOVFF  E4,E6
1710:  MOVFF  E7,03
1714:  MOVFF  E6,FE9
1718:  MOVFF  E7,FEA
171C:  MOVF   FEF,F
171E:  BZ    1728
1720:  INCF   xE6,F
1722:  BTFSC  FD8.2
1724:  INCF   xE7,F
1726:  BRA    1710
....................    return(sc - s); 
1728:  MOVF   xE4,W
172A:  SUBWF  xE6,W
172C:  MOVWF  00
172E:  MOVF   xE5,W
1730:  SUBWFB xE7,W
1732:  MOVWF  03
1734:  MOVFF  00,01
.................... } 
1738:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AD2:  CLRF   xD5
....................    sign = 0; 
0AD4:  CLRF   xD3
....................    base = 10; 
0AD6:  MOVLW  0A
0AD8:  MOVWF  xD4
....................    result = 0; 
0ADA:  CLRF   xD2
0ADC:  CLRF   xD1
....................  
....................    if (!s) 
0ADE:  MOVF   xCF,W
0AE0:  IORWF  xD0,W
0AE2:  BNZ   0AEC
....................       return 0; 
0AE4:  MOVLW  00
0AE6:  MOVWF  01
0AE8:  MOVWF  02
0AEA:  BRA    0CB8
....................    c = s[index++]; 
0AEC:  MOVF   xD5,W
0AEE:  INCF   xD5,F
0AF0:  CLRF   03
0AF2:  ADDWF  xCF,W
0AF4:  MOVWF  FE9
0AF6:  MOVF   xD0,W
0AF8:  ADDWFC 03,W
0AFA:  MOVWF  FEA
0AFC:  MOVFF  FEF,D6
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B00:  MOVF   xD6,W
0B02:  SUBLW  2D
0B04:  BNZ   0B20
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B06:  MOVLW  01
0B08:  MOVWF  xD3
....................       c = s[index++]; 
0B0A:  MOVF   xD5,W
0B0C:  INCF   xD5,F
0B0E:  CLRF   03
0B10:  ADDWF  xCF,W
0B12:  MOVWF  FE9
0B14:  MOVF   xD0,W
0B16:  ADDWFC 03,W
0B18:  MOVWF  FEA
0B1A:  MOVFF  FEF,D6
....................    } 
....................    else if (c == '+') 
0B1E:  BRA    0B3A
0B20:  MOVF   xD6,W
0B22:  SUBLW  2B
0B24:  BNZ   0B3A
....................    { 
....................       c = s[index++]; 
0B26:  MOVF   xD5,W
0B28:  INCF   xD5,F
0B2A:  CLRF   03
0B2C:  ADDWF  xCF,W
0B2E:  MOVWF  FE9
0B30:  MOVF   xD0,W
0B32:  ADDWFC 03,W
0B34:  MOVWF  FEA
0B36:  MOVFF  FEF,D6
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B3A:  MOVF   xD6,W
0B3C:  SUBLW  2F
0B3E:  BTFSC  FD8.0
0B40:  BRA    0C9C
0B42:  MOVF   xD6,W
0B44:  SUBLW  39
0B46:  BTFSS  FD8.0
0B48:  BRA    0C9C
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B4A:  MOVF   xD6,W
0B4C:  SUBLW  30
0B4E:  BNZ   0B92
0B50:  CLRF   03
0B52:  MOVF   xD5,W
0B54:  ADDWF  xCF,W
0B56:  MOVWF  FE9
0B58:  MOVF   xD0,W
0B5A:  ADDWFC 03,W
0B5C:  MOVWF  FEA
0B5E:  MOVF   FEF,W
0B60:  SUBLW  78
0B62:  BZ    0B78
0B64:  CLRF   03
0B66:  MOVF   xD5,W
0B68:  ADDWF  xCF,W
0B6A:  MOVWF  FE9
0B6C:  MOVF   xD0,W
0B6E:  ADDWFC 03,W
0B70:  MOVWF  FEA
0B72:  MOVF   FEF,W
0B74:  SUBLW  58
0B76:  BNZ   0B92
....................       { 
....................          base = 16; 
0B78:  MOVLW  10
0B7A:  MOVWF  xD4
....................          index++; 
0B7C:  INCF   xD5,F
....................          c = s[index++]; 
0B7E:  MOVF   xD5,W
0B80:  INCF   xD5,F
0B82:  CLRF   03
0B84:  ADDWF  xCF,W
0B86:  MOVWF  FE9
0B88:  MOVF   xD0,W
0B8A:  ADDWFC 03,W
0B8C:  MOVWF  FEA
0B8E:  MOVFF  FEF,D6
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0B92:  MOVF   xD4,W
0B94:  SUBLW  0A
0B96:  BNZ   0BDA
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0B98:  MOVF   xD6,W
0B9A:  SUBLW  2F
0B9C:  BC    0BD8
0B9E:  MOVF   xD6,W
0BA0:  SUBLW  39
0BA2:  BNC   0BD8
....................             result = 10*result + (c - '0'); 
0BA4:  CLRF   xD8
0BA6:  MOVLW  0A
0BA8:  MOVWF  xD7
0BAA:  MOVFF  D2,DA
0BAE:  MOVFF  D1,D9
0BB2:  BRA    0AB2
0BB4:  MOVLW  30
0BB6:  SUBWF  xD6,W
0BB8:  ADDWF  01,W
0BBA:  MOVWF  xD1
0BBC:  MOVLW  00
0BBE:  ADDWFC 02,W
0BC0:  MOVWF  xD2
....................             c = s[index++]; 
0BC2:  MOVF   xD5,W
0BC4:  INCF   xD5,F
0BC6:  CLRF   03
0BC8:  ADDWF  xCF,W
0BCA:  MOVWF  FE9
0BCC:  MOVF   xD0,W
0BCE:  ADDWFC 03,W
0BD0:  MOVWF  FEA
0BD2:  MOVFF  FEF,D6
....................          } 
0BD6:  BRA    0B98
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0BD8:  BRA    0C9C
0BDA:  MOVF   xD4,W
0BDC:  SUBLW  10
0BDE:  BNZ   0C9C
....................       { 
....................          c = toupper(c); 
0BE0:  MOVF   xD6,W
0BE2:  SUBLW  60
0BE4:  BC    0BF2
0BE6:  MOVF   xD6,W
0BE8:  SUBLW  7A
0BEA:  BNC   0BF2
0BEC:  MOVF   xD6,W
0BEE:  ANDLW  DF
0BF0:  BRA    0BF4
0BF2:  MOVF   xD6,W
0BF4:  MOVWF  xD6
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0BF6:  MOVF   xD6,W
0BF8:  SUBLW  2F
0BFA:  BC    0C02
0BFC:  MOVF   xD6,W
0BFE:  SUBLW  39
0C00:  BC    0C0E
0C02:  MOVF   xD6,W
0C04:  SUBLW  40
0C06:  BC    0C9C
0C08:  MOVF   xD6,W
0C0A:  SUBLW  46
0C0C:  BNC   0C9C
....................             if (c >= '0' && c <= '9') 
0C0E:  MOVF   xD6,W
0C10:  SUBLW  2F
0C12:  BC    0C46
0C14:  MOVF   xD6,W
0C16:  SUBLW  39
0C18:  BNC   0C46
....................                result = (result << 4) + (c - '0'); 
0C1A:  RLCF   xD1,W
0C1C:  MOVWF  xD7
0C1E:  RLCF   xD2,W
0C20:  MOVWF  xD8
0C22:  RLCF   xD7,F
0C24:  RLCF   xD8,F
0C26:  RLCF   xD7,F
0C28:  RLCF   xD8,F
0C2A:  RLCF   xD7,F
0C2C:  RLCF   xD8,F
0C2E:  MOVLW  F0
0C30:  ANDWF  xD7,F
0C32:  MOVLW  30
0C34:  SUBWF  xD6,W
0C36:  ADDWF  xD7,W
0C38:  MOVWF  01
0C3A:  MOVLW  00
0C3C:  ADDWFC xD8,W
0C3E:  MOVFF  01,D1
0C42:  MOVWF  xD2
....................             else 
0C44:  BRA    0C72
....................                result = (result << 4) + (c - 'A' + 10); 
0C46:  RLCF   xD1,W
0C48:  MOVWF  xD7
0C4A:  RLCF   xD2,W
0C4C:  MOVWF  xD8
0C4E:  RLCF   xD7,F
0C50:  RLCF   xD8,F
0C52:  RLCF   xD7,F
0C54:  RLCF   xD8,F
0C56:  RLCF   xD7,F
0C58:  RLCF   xD8,F
0C5A:  MOVLW  F0
0C5C:  ANDWF  xD7,F
0C5E:  MOVLW  41
0C60:  SUBWF  xD6,W
0C62:  ADDLW  0A
0C64:  ADDWF  xD7,W
0C66:  MOVWF  01
0C68:  MOVLW  00
0C6A:  ADDWFC xD8,W
0C6C:  MOVFF  01,D1
0C70:  MOVWF  xD2
....................  
....................             c = s[index++];c = toupper(c); 
0C72:  MOVF   xD5,W
0C74:  INCF   xD5,F
0C76:  CLRF   03
0C78:  ADDWF  xCF,W
0C7A:  MOVWF  FE9
0C7C:  MOVF   xD0,W
0C7E:  ADDWFC 03,W
0C80:  MOVWF  FEA
0C82:  MOVF   FEF,W
0C84:  MOVWF  xD6
0C86:  SUBLW  60
0C88:  BC    0C96
0C8A:  MOVF   xD6,W
0C8C:  SUBLW  7A
0C8E:  BNC   0C96
0C90:  MOVF   xD6,W
0C92:  ANDLW  DF
0C94:  BRA    0C98
0C96:  MOVF   xD6,W
0C98:  MOVWF  xD6
....................          } 
0C9A:  BRA    0BF6
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0C9C:  MOVF   xD4,W
0C9E:  SUBLW  0A
0CA0:  BNZ   0CB0
0CA2:  DECFSZ xD3,W
0CA4:  BRA    0CB0
....................       result = -result; 
0CA6:  COMF   xD1,F
0CA8:  COMF   xD2,F
0CAA:  INCF   xD1,F
0CAC:  BTFSC  FD8.2
0CAE:  INCF   xD2,F
....................  
....................    return(result); 
0CB0:  MOVFF  D1,01
0CB4:  MOVFF  D2,02
.................... } 
0CB8:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
29B0:  CLRF   xD7
....................    sign = 0; 
29B2:  CLRF   xD5
....................    base = 10; 
29B4:  MOVLW  0A
29B6:  MOVWF  xD6
....................    result = 0; 
29B8:  CLRF   xD4
29BA:  CLRF   xD3
29BC:  CLRF   xD2
29BE:  CLRF   xD1
....................  
....................    if (!s) 
29C0:  MOVF   xCF,W
29C2:  IORWF  xD0,W
29C4:  BNZ   29D0
....................       return 0; 
29C6:  CLRF   00
29C8:  CLRF   01
29CA:  CLRF   02
29CC:  CLRF   03
29CE:  BRA    2C4A
....................    c = s[index++]; 
29D0:  MOVF   xD7,W
29D2:  INCF   xD7,F
29D4:  CLRF   03
29D6:  ADDWF  xCF,W
29D8:  MOVWF  FE9
29DA:  MOVF   xD0,W
29DC:  ADDWFC 03,W
29DE:  MOVWF  FEA
29E0:  MOVFF  FEF,D8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
29E4:  MOVF   xD8,W
29E6:  SUBLW  2D
29E8:  BNZ   2A04
....................    { 
....................       sign = 1;         // Set the sign to negative 
29EA:  MOVLW  01
29EC:  MOVWF  xD5
....................       c = s[index++]; 
29EE:  MOVF   xD7,W
29F0:  INCF   xD7,F
29F2:  CLRF   03
29F4:  ADDWF  xCF,W
29F6:  MOVWF  FE9
29F8:  MOVF   xD0,W
29FA:  ADDWFC 03,W
29FC:  MOVWF  FEA
29FE:  MOVFF  FEF,D8
....................    } 
....................    else if (c == '+') 
2A02:  BRA    2A1E
2A04:  MOVF   xD8,W
2A06:  SUBLW  2B
2A08:  BNZ   2A1E
....................    { 
....................       c = s[index++]; 
2A0A:  MOVF   xD7,W
2A0C:  INCF   xD7,F
2A0E:  CLRF   03
2A10:  ADDWF  xCF,W
2A12:  MOVWF  FE9
2A14:  MOVF   xD0,W
2A16:  ADDWFC 03,W
2A18:  MOVWF  FEA
2A1A:  MOVFF  FEF,D8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2A1E:  MOVF   xD8,W
2A20:  SUBLW  2F
2A22:  BTFSC  FD8.0
2A24:  BRA    2C1A
2A26:  MOVF   xD8,W
2A28:  SUBLW  39
2A2A:  BTFSS  FD8.0
2A2C:  BRA    2C1A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2A2E:  MOVF   xD8,W
2A30:  SUBLW  30
2A32:  BNZ   2A76
2A34:  CLRF   03
2A36:  MOVF   xD7,W
2A38:  ADDWF  xCF,W
2A3A:  MOVWF  FE9
2A3C:  MOVF   xD0,W
2A3E:  ADDWFC 03,W
2A40:  MOVWF  FEA
2A42:  MOVF   FEF,W
2A44:  SUBLW  78
2A46:  BZ    2A5C
2A48:  CLRF   03
2A4A:  MOVF   xD7,W
2A4C:  ADDWF  xCF,W
2A4E:  MOVWF  FE9
2A50:  MOVF   xD0,W
2A52:  ADDWFC 03,W
2A54:  MOVWF  FEA
2A56:  MOVF   FEF,W
2A58:  SUBLW  58
2A5A:  BNZ   2A76
....................       { 
....................          base = 16; 
2A5C:  MOVLW  10
2A5E:  MOVWF  xD6
....................          index++; 
2A60:  INCF   xD7,F
....................          c = s[index++]; 
2A62:  MOVF   xD7,W
2A64:  INCF   xD7,F
2A66:  CLRF   03
2A68:  ADDWF  xCF,W
2A6A:  MOVWF  FE9
2A6C:  MOVF   xD0,W
2A6E:  ADDWFC 03,W
2A70:  MOVWF  FEA
2A72:  MOVFF  FEF,D8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
2A76:  MOVF   xD6,W
2A78:  SUBLW  0A
2A7A:  BNZ   2B04
....................       { 
....................          while (c >= '0' && c <= '9') { 
2A7C:  MOVF   xD8,W
2A7E:  SUBLW  2F
2A80:  BC    2B02
2A82:  MOVF   xD8,W
2A84:  SUBLW  39
2A86:  BNC   2B02
....................             result = (result << 1) + (result << 3);  // result *= 10; 
2A88:  BCF    FD8.0
2A8A:  RLCF   xD1,W
2A8C:  MOVWF  xDA
2A8E:  RLCF   xD2,W
2A90:  MOVWF  xDB
2A92:  RLCF   xD3,W
2A94:  MOVWF  xDC
2A96:  RLCF   xD4,W
2A98:  MOVWF  xDD
2A9A:  RLCF   xD1,W
2A9C:  MOVWF  00
2A9E:  RLCF   xD2,W
2AA0:  MOVWF  01
2AA2:  RLCF   xD3,W
2AA4:  MOVWF  02
2AA6:  RLCF   xD4,W
2AA8:  MOVWF  03
2AAA:  RLCF   00,F
2AAC:  RLCF   01,F
2AAE:  RLCF   02,F
2AB0:  RLCF   03,F
2AB2:  RLCF   00,F
2AB4:  RLCF   01,F
2AB6:  RLCF   02,F
2AB8:  RLCF   03,F
2ABA:  MOVLW  F8
2ABC:  ANDWF  00,F
2ABE:  MOVF   xDA,W
2AC0:  ADDWF  00,F
2AC2:  MOVF   xDB,W
2AC4:  ADDWFC 01,F
2AC6:  MOVF   xDC,W
2AC8:  ADDWFC 02,F
2ACA:  MOVF   xDD,W
2ACC:  ADDWFC 03,F
2ACE:  MOVFF  03,D4
2AD2:  MOVFF  02,D3
2AD6:  MOVFF  01,D2
2ADA:  MOVFF  00,D1
....................             result += (c - '0'); 
2ADE:  MOVLW  30
2AE0:  SUBWF  xD8,W
2AE2:  ADDWF  xD1,F
2AE4:  MOVLW  00
2AE6:  ADDWFC xD2,F
2AE8:  ADDWFC xD3,F
2AEA:  ADDWFC xD4,F
....................             c = s[index++]; 
2AEC:  MOVF   xD7,W
2AEE:  INCF   xD7,F
2AF0:  CLRF   03
2AF2:  ADDWF  xCF,W
2AF4:  MOVWF  FE9
2AF6:  MOVF   xD0,W
2AF8:  ADDWFC 03,W
2AFA:  MOVWF  FEA
2AFC:  MOVFF  FEF,D8
....................          } 
2B00:  BRA    2A7C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2B02:  BRA    2C1A
2B04:  MOVF   xD6,W
2B06:  SUBLW  10
2B08:  BTFSS  FD8.2
2B0A:  BRA    2C1A
....................       { 
....................          c = toupper(c); 
2B0C:  MOVF   xD8,W
2B0E:  SUBLW  60
2B10:  BC    2B1E
2B12:  MOVF   xD8,W
2B14:  SUBLW  7A
2B16:  BNC   2B1E
2B18:  MOVF   xD8,W
2B1A:  ANDLW  DF
2B1C:  BRA    2B20
2B1E:  MOVF   xD8,W
2B20:  MOVWF  xD8
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2B22:  MOVF   xD8,W
2B24:  SUBLW  2F
2B26:  BC    2B2E
2B28:  MOVF   xD8,W
2B2A:  SUBLW  39
2B2C:  BC    2B3C
2B2E:  MOVF   xD8,W
2B30:  SUBLW  40
2B32:  BTFSC  FD8.0
2B34:  BRA    2C1A
2B36:  MOVF   xD8,W
2B38:  SUBLW  46
2B3A:  BNC   2C1A
....................             if (c >= '0' && c <= '9') 
2B3C:  MOVF   xD8,W
2B3E:  SUBLW  2F
2B40:  BC    2B9C
2B42:  MOVF   xD8,W
2B44:  SUBLW  39
2B46:  BNC   2B9C
....................                result = (result << 4) + (c - '0'); 
2B48:  RLCF   xD1,W
2B4A:  MOVWF  xDA
2B4C:  RLCF   xD2,W
2B4E:  MOVWF  xDB
2B50:  RLCF   xD3,W
2B52:  MOVWF  xDC
2B54:  RLCF   xD4,W
2B56:  MOVWF  xDD
2B58:  RLCF   xDA,F
2B5A:  RLCF   xDB,F
2B5C:  RLCF   xDC,F
2B5E:  RLCF   xDD,F
2B60:  RLCF   xDA,F
2B62:  RLCF   xDB,F
2B64:  RLCF   xDC,F
2B66:  RLCF   xDD,F
2B68:  RLCF   xDA,F
2B6A:  RLCF   xDB,F
2B6C:  RLCF   xDC,F
2B6E:  RLCF   xDD,F
2B70:  MOVLW  F0
2B72:  ANDWF  xDA,F
2B74:  MOVLW  30
2B76:  SUBWF  xD8,W
2B78:  ADDWF  xDA,W
2B7A:  MOVWF  00
2B7C:  MOVLW  00
2B7E:  ADDWFC xDB,W
2B80:  MOVWF  01
2B82:  MOVLW  00
2B84:  ADDWFC xDC,W
2B86:  MOVWF  02
2B88:  MOVLW  00
2B8A:  ADDWFC xDD,W
2B8C:  MOVWF  xD4
2B8E:  MOVFF  02,D3
2B92:  MOVFF  01,D2
2B96:  MOVFF  00,D1
....................             else 
2B9A:  BRA    2BF0
....................                result = (result << 4) + (c - 'A' + 10); 
2B9C:  RLCF   xD1,W
2B9E:  MOVWF  xDA
2BA0:  RLCF   xD2,W
2BA2:  MOVWF  xDB
2BA4:  RLCF   xD3,W
2BA6:  MOVWF  xDC
2BA8:  RLCF   xD4,W
2BAA:  MOVWF  xDD
2BAC:  RLCF   xDA,F
2BAE:  RLCF   xDB,F
2BB0:  RLCF   xDC,F
2BB2:  RLCF   xDD,F
2BB4:  RLCF   xDA,F
2BB6:  RLCF   xDB,F
2BB8:  RLCF   xDC,F
2BBA:  RLCF   xDD,F
2BBC:  RLCF   xDA,F
2BBE:  RLCF   xDB,F
2BC0:  RLCF   xDC,F
2BC2:  RLCF   xDD,F
2BC4:  MOVLW  F0
2BC6:  ANDWF  xDA,F
2BC8:  MOVLW  41
2BCA:  SUBWF  xD8,W
2BCC:  ADDLW  0A
2BCE:  ADDWF  xDA,W
2BD0:  MOVWF  00
2BD2:  MOVLW  00
2BD4:  ADDWFC xDB,W
2BD6:  MOVWF  01
2BD8:  MOVLW  00
2BDA:  ADDWFC xDC,W
2BDC:  MOVWF  02
2BDE:  MOVLW  00
2BE0:  ADDWFC xDD,W
2BE2:  MOVWF  xD4
2BE4:  MOVFF  02,D3
2BE8:  MOVFF  01,D2
2BEC:  MOVFF  00,D1
....................  
....................             c = s[index++];c = toupper(c); 
2BF0:  MOVF   xD7,W
2BF2:  INCF   xD7,F
2BF4:  CLRF   03
2BF6:  ADDWF  xCF,W
2BF8:  MOVWF  FE9
2BFA:  MOVF   xD0,W
2BFC:  ADDWFC 03,W
2BFE:  MOVWF  FEA
2C00:  MOVF   FEF,W
2C02:  MOVWF  xD8
2C04:  SUBLW  60
2C06:  BC    2C14
2C08:  MOVF   xD8,W
2C0A:  SUBLW  7A
2C0C:  BNC   2C14
2C0E:  MOVF   xD8,W
2C10:  ANDLW  DF
2C12:  BRA    2C16
2C14:  MOVF   xD8,W
2C16:  MOVWF  xD8
....................          } 
2C18:  BRA    2B22
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2C1A:  MOVF   xD6,W
2C1C:  SUBLW  0A
2C1E:  BNZ   2C3A
2C20:  DECFSZ xD5,W
2C22:  BRA    2C3A
....................       result = -result; 
2C24:  COMF   xD1,F
2C26:  COMF   xD2,F
2C28:  COMF   xD3,F
2C2A:  COMF   xD4,F
2C2C:  INCF   xD1,F
2C2E:  BTFSC  FD8.2
2C30:  INCF   xD2,F
2C32:  BTFSC  FD8.2
2C34:  INCF   xD3,F
2C36:  BTFSC  FD8.2
2C38:  INCF   xD4,F
....................  
....................    return(result); 
2C3A:  MOVFF  D1,00
2C3E:  MOVFF  D2,01
2C42:  MOVFF  D3,02
2C46:  MOVFF  D4,03
.................... } 
2C4A:  GOTO   3218 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
152C:  MOVLW  01
152E:  MOVWF  xEF
1530:  CLRF   xF0
1532:  CLRF   xF1
1534:  CLRF   xF2
....................      unsigned int8 i,sign=0,cnt=0; 
1536:  CLRF   xF4
1538:  CLRF   xF5
....................      char c; 
....................  
....................      if(num<0) { 
153A:  BTFSC  xEB.7
153C:  BRA    1540
153E:  BRA    1570
....................          sign=1;        // Check for negative number 
1540:  MOVLW  01
1542:  MOVWF  xF4
....................          num*=-1; 
1544:  MOVFF  EB,FA
1548:  MOVFF  EA,F9
154C:  MOVFF  E9,F8
1550:  MOVFF  E8,F7
1554:  MOVLW  FF
1556:  MOVWF  xFE
1558:  MOVWF  xFD
155A:  MOVWF  xFC
155C:  MOVWF  xFB
155E:  RCALL  13CC
1560:  MOVFF  03,EB
1564:  MOVFF  02,EA
1568:  MOVFF  01,E9
156C:  MOVFF  00,E8
....................      } 
....................  
....................      while(temp>0) { 
1570:  MOVF   xEF,F
1572:  BNZ   1580
1574:  MOVF   xF0,F
1576:  BNZ   1580
1578:  MOVF   xF1,F
157A:  BNZ   1580
157C:  MOVF   xF2,F
157E:  BZ    166E
....................          temp=(num/base); 
1580:  MOVFF  EB,FE
1584:  MOVFF  EA,FD
1588:  MOVFF  E9,FC
158C:  MOVFF  E8,FB
1590:  MOVLB  1
1592:  CLRF   x02
1594:  CLRF   x01
1596:  CLRF   x00
1598:  MOVFF  EC,FF
159C:  MOVLB  0
159E:  RCALL  1428
15A0:  MOVFF  03,F2
15A4:  MOVFF  02,F1
15A8:  MOVFF  01,F0
15AC:  MOVFF  00,EF
....................          s[cnt]=(num%base)+'0';    // Conversion 
15B0:  CLRF   03
15B2:  MOVF   xF5,W
15B4:  ADDWF  xED,W
15B6:  MOVWF  01
15B8:  MOVF   xEE,W
15BA:  ADDWFC 03,F
15BC:  MOVFF  01,F7
15C0:  MOVFF  03,F8
15C4:  MOVFF  FEA,FA
15C8:  MOVFF  FE9,F9
15CC:  MOVFF  EB,FE
15D0:  MOVFF  EA,FD
15D4:  MOVFF  E9,FC
15D8:  MOVFF  E8,FB
15DC:  MOVLB  1
15DE:  CLRF   x02
15E0:  CLRF   x01
15E2:  CLRF   x00
15E4:  MOVFF  EC,FF
15E8:  MOVLB  0
15EA:  RCALL  1428
15EC:  MOVFF  FEF,00
15F0:  MOVFF  FEC,01
15F4:  MOVFF  FEC,02
15F8:  MOVFF  FEC,03
15FC:  MOVFF  FA,FEA
1600:  MOVFF  F9,FE9
1604:  MOVFF  03,FE
1608:  MOVFF  02,FD
160C:  MOVFF  01,FC
1610:  MOVFF  00,FB
1614:  MOVLW  30
1616:  ADDWF  00,W
1618:  MOVWF  00
161A:  MOVLW  00
161C:  ADDWFC 01,W
161E:  MOVLW  00
1620:  ADDWFC 02,W
1622:  MOVLW  00
1624:  ADDWFC 03,W
1626:  MOVFF  F8,FEA
162A:  MOVFF  F7,FE9
162E:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
1632:  CLRF   03
1634:  MOVF   xF5,W
1636:  ADDWF  xED,W
1638:  MOVWF  FE9
163A:  MOVF   xEE,W
163C:  ADDWFC 03,W
163E:  MOVWF  FEA
1640:  MOVF   FEF,W
1642:  SUBLW  39
1644:  BC    165A
....................             s[cnt]+=0x7; 
1646:  CLRF   03
1648:  MOVF   xF5,W
164A:  ADDWF  xED,W
164C:  MOVWF  FE9
164E:  MOVF   xEE,W
1650:  ADDWFC 03,W
1652:  MOVWF  FEA
1654:  MOVLW  07
1656:  ADDWF  FEF,W
1658:  MOVWF  FEF
....................  
....................          cnt++; 
165A:  INCF   xF5,F
....................          num=temp; 
165C:  MOVFF  F2,EB
1660:  MOVFF  F1,EA
1664:  MOVFF  F0,E9
1668:  MOVFF  EF,E8
....................      } 
166C:  BRA    1570
....................  
....................      if(sign==1) { 
166E:  DECFSZ xF4,W
1670:  BRA    1686
....................          s[cnt]=0x2D;      // Negative sign 
1672:  CLRF   03
1674:  MOVF   xF5,W
1676:  ADDWF  xED,W
1678:  MOVWF  FE9
167A:  MOVF   xEE,W
167C:  ADDWFC 03,W
167E:  MOVWF  FEA
1680:  MOVLW  2D
1682:  MOVWF  FEF
....................          cnt++; 
1684:  INCF   xF5,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1686:  CLRF   xF3
1688:  BCF    FD8.0
168A:  RRCF   xF5,W
168C:  SUBWF  xF3,W
168E:  BC    16EE
....................  
....................          c=s[i]; 
1690:  CLRF   03
1692:  MOVF   xF3,W
1694:  ADDWF  xED,W
1696:  MOVWF  FE9
1698:  MOVF   xEE,W
169A:  ADDWFC 03,W
169C:  MOVWF  FEA
169E:  MOVFF  FEF,F6
....................          s[i]=s[cnt-i-1];        // Reverse the number 
16A2:  CLRF   03
16A4:  MOVF   xF3,W
16A6:  ADDWF  xED,W
16A8:  MOVWF  01
16AA:  MOVF   xEE,W
16AC:  ADDWFC 03,F
16AE:  MOVFF  03,F8
16B2:  MOVF   xF3,W
16B4:  SUBWF  xF5,W
16B6:  ADDLW  FF
16B8:  CLRF   03
16BA:  ADDWF  xED,W
16BC:  MOVWF  FE9
16BE:  MOVF   xEE,W
16C0:  ADDWFC 03,W
16C2:  MOVWF  FEA
16C4:  MOVFF  FEF,FB
16C8:  MOVFF  F8,FEA
16CC:  MOVFF  01,FE9
16D0:  MOVFF  FB,FEF
....................          s[cnt-i-1]=c; 
16D4:  MOVF   xF3,W
16D6:  SUBWF  xF5,W
16D8:  ADDLW  FF
16DA:  CLRF   03
16DC:  ADDWF  xED,W
16DE:  MOVWF  FE9
16E0:  MOVF   xEE,W
16E2:  ADDWFC 03,W
16E4:  MOVWF  FEA
16E6:  MOVFF  F6,FEF
....................      } 
16EA:  INCF   xF3,F
16EC:  BRA    1688
....................      s[cnt]='\0';     // End the string 
16EE:  CLRF   03
16F0:  MOVF   xF5,W
16F2:  ADDWF  xED,W
16F4:  MOVWF  FE9
16F6:  MOVF   xEE,W
16F8:  ADDWFC 03,W
16FA:  MOVWF  FEA
16FC:  CLRF   FEF
....................      return s; 
16FE:  MOVFF  ED,01
1702:  MOVFF  EE,02
.................... } 
1706:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
5468:  MOVLB  1
546A:  BCF    x09.0
....................    y = x; 
546C:  MOVFF  FD,102
5470:  MOVFF  FC,101
5474:  MOVFF  FB,100
5478:  MOVFF  FA,FF
....................  
....................    if (x < 0) 
547C:  MOVFF  FD,14B
5480:  MOVFF  FC,14A
5484:  MOVFF  FB,149
5488:  MOVFF  FA,148
548C:  CLRF   x4F
548E:  CLRF   x4E
5490:  CLRF   x4D
5492:  CLRF   x4C
5494:  MOVLB  0
5496:  CALL   3DD2
549A:  BNC   54A6
....................    { 
....................       s = 1; 
549C:  MOVLB  1
549E:  BSF    x09.0
....................       y = -y; 
54A0:  MOVF   x00,W
54A2:  XORLW  80
54A4:  MOVWF  x00
....................    } 
....................  
....................    if (y <= 32768.0) 
54A6:  MOVFF  102,14B
54AA:  MOVFF  101,14A
54AE:  MOVFF  100,149
54B2:  MOVFF  FF,148
54B6:  MOVLB  1
54B8:  CLRF   x4F
54BA:  CLRF   x4E
54BC:  CLRF   x4D
54BE:  MOVLW  8E
54C0:  MOVWF  x4C
54C2:  MOVLB  0
54C4:  CALL   3DD2
54C8:  BC    54CC
54CA:  BNZ   54FE
....................   res = (float32)(unsigned int16)y; 
54CC:  MOVFF  102,14B
54D0:  MOVFF  101,14A
54D4:  MOVFF  100,149
54D8:  MOVFF  FF,148
54DC:  CALL   43AC
54E0:  MOVFF  02,14D
54E4:  MOVFF  01,14C
54E8:  CALL   4376
54EC:  MOVFF  03,106
54F0:  MOVFF  02,105
54F4:  MOVFF  01,104
54F8:  MOVFF  00,103
....................  
....................  else if (y < 10000000.0) 
54FC:  BRA    56A4
54FE:  MOVFF  102,14B
5502:  MOVFF  101,14A
5506:  MOVFF  100,149
550A:  MOVFF  FF,148
550E:  MOVLW  80
5510:  MOVLB  1
5512:  MOVWF  x4F
5514:  MOVLW  96
5516:  MOVWF  x4E
5518:  MOVLW  18
551A:  MOVWF  x4D
551C:  MOVLW  96
551E:  MOVWF  x4C
5520:  MOVLB  0
5522:  CALL   3DD2
5526:  BTFSS  FD8.0
5528:  BRA    5694
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
552A:  MOVFF  102,14B
552E:  MOVFF  101,14A
5532:  MOVFF  100,149
5536:  MOVFF  FF,148
553A:  MOVLB  1
553C:  CLRF   x4F
553E:  CLRF   x4E
5540:  CLRF   x4D
5542:  MOVLW  8E
5544:  MOVWF  x4C
5546:  MOVLB  0
5548:  CALL   0FB6
554C:  MOVFF  03,14B
5550:  MOVFF  02,14A
5554:  MOVFF  01,149
5558:  MOVFF  00,148
555C:  CALL   43AC
5560:  MOVFF  02,108
5564:  MOVFF  01,107
....................       y = 32768.0*(y/32768.0 - (float32)l); 
5568:  MOVFF  102,14B
556C:  MOVFF  101,14A
5570:  MOVFF  100,149
5574:  MOVFF  FF,148
5578:  MOVLB  1
557A:  CLRF   x4F
557C:  CLRF   x4E
557E:  CLRF   x4D
5580:  MOVLW  8E
5582:  MOVWF  x4C
5584:  MOVLB  0
5586:  CALL   0FB6
558A:  MOVFF  00,10A
558E:  MOVFF  01,10B
5592:  MOVFF  02,10C
5596:  MOVFF  03,10D
559A:  MOVFF  108,14D
559E:  MOVFF  107,14C
55A2:  CALL   4376
55A6:  BSF    FD8.1
55A8:  MOVFF  10D,151
55AC:  MOVFF  10C,150
55B0:  MOVFF  10B,14F
55B4:  MOVFF  10A,14E
55B8:  MOVFF  03,155
55BC:  MOVFF  02,154
55C0:  MOVFF  01,153
55C4:  MOVFF  00,152
55C8:  CALL   1114
55CC:  MOVLB  1
55CE:  CLRF   x4F
55D0:  CLRF   x4E
55D2:  CLRF   x4D
55D4:  MOVLW  8E
55D6:  MOVWF  x4C
55D8:  MOVFF  03,153
55DC:  MOVFF  02,152
55E0:  MOVFF  01,151
55E4:  MOVFF  00,150
55E8:  MOVLB  0
55EA:  CALL   0EC0
55EE:  MOVFF  03,102
55F2:  MOVFF  02,101
55F6:  MOVFF  01,100
55FA:  MOVFF  00,FF
....................   res = 32768.0*(float32)l; 
55FE:  MOVFF  108,14D
5602:  MOVFF  107,14C
5606:  CALL   4376
560A:  MOVLB  1
560C:  CLRF   x4F
560E:  CLRF   x4E
5610:  CLRF   x4D
5612:  MOVLW  8E
5614:  MOVWF  x4C
5616:  MOVFF  03,153
561A:  MOVFF  02,152
561E:  MOVFF  01,151
5622:  MOVFF  00,150
5626:  MOVLB  0
5628:  CALL   0EC0
562C:  MOVFF  03,106
5630:  MOVFF  02,105
5634:  MOVFF  01,104
5638:  MOVFF  00,103
....................   res += (float32)(unsigned int16)y; 
563C:  MOVFF  102,14B
5640:  MOVFF  101,14A
5644:  MOVFF  100,149
5648:  MOVFF  FF,148
564C:  CALL   43AC
5650:  MOVFF  02,14D
5654:  MOVFF  01,14C
5658:  CALL   4376
565C:  BCF    FD8.1
565E:  MOVFF  106,151
5662:  MOVFF  105,150
5666:  MOVFF  104,14F
566A:  MOVFF  103,14E
566E:  MOVFF  03,155
5672:  MOVFF  02,154
5676:  MOVFF  01,153
567A:  MOVFF  00,152
567E:  CALL   1114
5682:  MOVFF  03,106
5686:  MOVFF  02,105
568A:  MOVFF  01,104
568E:  MOVFF  00,103
....................  } 
....................  
....................  else 
5692:  BRA    56A4
....................   res = y; 
5694:  MOVFF  102,106
5698:  MOVFF  101,105
569C:  MOVFF  100,104
56A0:  MOVFF  FF,103
....................  
....................  y = y - (float32)(unsigned int16)y; 
56A4:  MOVFF  102,14B
56A8:  MOVFF  101,14A
56AC:  MOVFF  100,149
56B0:  MOVFF  FF,148
56B4:  CALL   43AC
56B8:  MOVFF  02,14D
56BC:  MOVFF  01,14C
56C0:  CALL   4376
56C4:  BSF    FD8.1
56C6:  MOVFF  102,151
56CA:  MOVFF  101,150
56CE:  MOVFF  100,14F
56D2:  MOVFF  FF,14E
56D6:  MOVFF  03,155
56DA:  MOVFF  02,154
56DE:  MOVFF  01,153
56E2:  MOVFF  00,152
56E6:  CALL   1114
56EA:  MOVFF  03,102
56EE:  MOVFF  02,101
56F2:  MOVFF  01,100
56F6:  MOVFF  00,FF
....................  
....................  if (s) 
56FA:  MOVLB  1
56FC:  BTFSS  x09.0
56FE:  BRA    5706
....................   res = -res; 
5700:  MOVF   x04,W
5702:  XORLW  80
5704:  MOVWF  x04
....................  
....................  if (y != 0) 
5706:  MOVFF  102,14B
570A:  MOVFF  101,14A
570E:  MOVFF  100,149
5712:  MOVFF  FF,148
5716:  CLRF   x4F
5718:  CLRF   x4E
571A:  CLRF   x4D
571C:  CLRF   x4C
571E:  MOVLB  0
5720:  CALL   3DD2
5724:  BZ    57B2
....................  { 
....................   if (s == 1 && n == 0) 
5726:  MOVLB  1
5728:  BTFSS  x09.0
572A:  BRA    576E
572C:  MOVLB  0
572E:  MOVF   xFE,F
5730:  BTFSC  FD8.2
5732:  BRA    5738
5734:  MOVLB  1
5736:  BRA    576E
....................    res -= 1.0; 
5738:  BSF    FD8.1
573A:  MOVFF  106,151
573E:  MOVFF  105,150
5742:  MOVFF  104,14F
5746:  MOVFF  103,14E
574A:  MOVLB  1
574C:  CLRF   x55
574E:  CLRF   x54
5750:  CLRF   x53
5752:  MOVLW  7F
5754:  MOVWF  x52
5756:  MOVLB  0
5758:  CALL   1114
575C:  MOVFF  03,106
5760:  MOVFF  02,105
5764:  MOVFF  01,104
5768:  MOVFF  00,103
576C:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
576E:  BTFSC  x09.0
5770:  BRA    57B4
5772:  MOVLB  0
5774:  DECFSZ xFE,W
5776:  BRA    577A
5778:  BRA    577E
577A:  MOVLB  1
577C:  BRA    57B4
....................    res += 1.0; 
577E:  BCF    FD8.1
5780:  MOVFF  106,151
5784:  MOVFF  105,150
5788:  MOVFF  104,14F
578C:  MOVFF  103,14E
5790:  MOVLB  1
5792:  CLRF   x55
5794:  CLRF   x54
5796:  CLRF   x53
5798:  MOVLW  7F
579A:  MOVWF  x52
579C:  MOVLB  0
579E:  CALL   1114
57A2:  MOVFF  03,106
57A6:  MOVFF  02,105
57AA:  MOVFF  01,104
57AE:  MOVFF  00,103
57B2:  MOVLB  1
....................  } 
....................  if (x == 0) 
57B4:  MOVFF  FD,14B
57B8:  MOVFF  FC,14A
57BC:  MOVFF  FB,149
57C0:  MOVFF  FA,148
57C4:  CLRF   x4F
57C6:  CLRF   x4E
57C8:  CLRF   x4D
57CA:  CLRF   x4C
57CC:  MOVLB  0
57CE:  CALL   3DD2
57D2:  BNZ   57E0
....................     res = 0; 
57D4:  MOVLB  1
57D6:  CLRF   x06
57D8:  CLRF   x05
57DA:  CLRF   x04
57DC:  CLRF   x03
57DE:  MOVLB  0
....................  
....................  return (res); 
57E0:  MOVFF  103,00
57E4:  MOVFF  104,01
57E8:  MOVFF  105,02
57EC:  MOVFF  106,03
.................... } 
57F0:  RETLW  00
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
580C:  MOVFF  F9,FD
5810:  MOVFF  F8,FC
5814:  MOVFF  F7,FB
5818:  MOVFF  F6,FA
581C:  CLRF   xFE
581E:  RCALL  5468
.................... } 
5820:  GOTO   592C (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
57F2:  MOVFF  F8,FD
57F6:  MOVFF  F7,FC
57FA:  MOVFF  F6,FB
57FE:  MOVFF  F5,FA
5802:  MOVLW  01
5804:  MOVWF  xFE
5806:  RCALL  5468
.................... } 
5808:  GOTO   58E4 (RETURN)
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
5824:  MOVFF  E8,14B
5828:  MOVFF  E7,14A
582C:  MOVFF  E6,149
5830:  MOVFF  E5,148
5834:  MOVLB  1
5836:  CLRF   x4F
5838:  CLRF   x4E
583A:  CLRF   x4D
583C:  CLRF   x4C
583E:  MOVLB  0
5840:  CALL   3DD2
5844:  BTFSC  FD8.2
5846:  BRA    598A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
5848:  MOVFF  E4,14B
584C:  MOVFF  E3,14A
5850:  MOVFF  E2,149
5854:  MOVFF  E1,148
5858:  MOVFF  E8,14F
585C:  MOVFF  E7,14E
5860:  MOVFF  E6,14D
5864:  MOVFF  E5,14C
5868:  CALL   0FB6
586C:  MOVFF  00,ED
5870:  MOVFF  01,EE
5874:  MOVFF  02,EF
5878:  MOVFF  03,F0
587C:  MOVFF  03,14B
5880:  MOVFF  02,14A
5884:  MOVFF  01,149
5888:  MOVFF  00,148
588C:  MOVLB  1
588E:  CLRF   x4F
5890:  CLRF   x4E
5892:  CLRF   x4D
5894:  CLRF   x4C
5896:  MOVLB  0
5898:  CALL   3DD2
589C:  BNC   58E6
589E:  MOVFF  E4,14B
58A2:  MOVFF  E3,14A
58A6:  MOVFF  E2,149
58AA:  MOVFF  E1,148
58AE:  MOVFF  E8,14F
58B2:  MOVFF  E7,14E
58B6:  MOVFF  E6,14D
58BA:  MOVFF  E5,14C
58BE:  CALL   0FB6
58C2:  MOVFF  00,F1
58C6:  MOVFF  01,F2
58CA:  MOVFF  02,F3
58CE:  MOVFF  03,F4
58D2:  MOVFF  03,F8
58D6:  MOVFF  02,F7
58DA:  MOVFF  01,F6
58DE:  MOVFF  00,F5
58E2:  BRA    57F2
58E4:  BRA    592C
58E6:  MOVFF  E4,14B
58EA:  MOVFF  E3,14A
58EE:  MOVFF  E2,149
58F2:  MOVFF  E1,148
58F6:  MOVFF  E8,14F
58FA:  MOVFF  E7,14E
58FE:  MOVFF  E6,14D
5902:  MOVFF  E5,14C
5906:  CALL   0FB6
590A:  MOVFF  00,F2
590E:  MOVFF  01,F3
5912:  MOVFF  02,F4
5916:  MOVFF  03,F5
591A:  MOVFF  03,F9
591E:  MOVFF  02,F8
5922:  MOVFF  01,F7
5926:  MOVFF  00,F6
592A:  BRA    580C
592C:  MOVFF  03,EC
5930:  MOVFF  02,EB
5934:  MOVFF  01,EA
5938:  MOVFF  00,E9
....................       return(x-(i*y)); 
593C:  MOVFF  EC,14F
5940:  MOVFF  EB,14E
5944:  MOVFF  EA,14D
5948:  MOVFF  E9,14C
594C:  MOVFF  E8,153
5950:  MOVFF  E7,152
5954:  MOVFF  E6,151
5958:  MOVFF  E5,150
595C:  CALL   0EC0
5960:  BSF    FD8.1
5962:  MOVFF  E4,151
5966:  MOVFF  E3,150
596A:  MOVFF  E2,14F
596E:  MOVFF  E1,14E
5972:  MOVFF  03,155
5976:  MOVFF  02,154
597A:  MOVFF  01,153
597E:  MOVFF  00,152
5982:  CALL   1114
5986:  BRA    598A
....................    } 
....................    else 
5988:  BRA    598A
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
598A:  GOTO   5C1E (RETURN)
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
485C:  MOVFF  113,14B
4860:  MOVFF  112,14A
4864:  MOVFF  111,149
4868:  MOVFF  110,148
486C:  MOVLB  1
486E:  CLRF   x4F
4870:  CLRF   x4E
4872:  CLRF   x4D
4874:  CLRF   x4C
4876:  MOVLB  0
4878:  CALL   3DD2
487C:  BC    4880
487E:  BNZ   488A
....................       return(0.0); 
4880:  CLRF   00
4882:  CLRF   01
4884:  CLRF   02
4886:  CLRF   03
4888:  BRA    4984
....................  
....................    y=x; 
488A:  MOVFF  113,117
488E:  MOVFF  112,116
4892:  MOVFF  111,115
4896:  MOVFF  110,114
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
489A:  MOVLW  01
489C:  MOVLB  1
489E:  MOVWF  x1D
48A0:  MOVLW  14
48A2:  MOVWF  x1C
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
48A4:  MOVFF  11C,FE9
48A8:  MOVFF  11D,FEA
48AC:  MOVF   FEF,W
48AE:  CLRF   x21
48B0:  MOVWF  x20
48B2:  MOVLW  7F
48B4:  ADDWF  x20,W
48B6:  MOVWF  x22
48B8:  MOVLW  00
48BA:  ADDWFC x21,W
48BC:  MOVWF  x23
48BE:  BCF    FD8.0
48C0:  RRCF   x23,W
48C2:  RRCF   x22,W
48C4:  MOVFF  11D,FEA
48C8:  MOVFF  11C,FE9
48CC:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
48CE:  MOVFF  117,11B
48D2:  MOVFF  116,11A
48D6:  MOVFF  115,119
48DA:  MOVFF  114,118
....................       y+=(x/y); 
48DE:  MOVFF  113,14B
48E2:  MOVFF  112,14A
48E6:  MOVFF  111,149
48EA:  MOVFF  110,148
48EE:  MOVFF  117,14F
48F2:  MOVFF  116,14E
48F6:  MOVFF  115,14D
48FA:  MOVFF  114,14C
48FE:  MOVLB  0
4900:  CALL   0FB6
4904:  BCF    FD8.1
4906:  MOVFF  117,151
490A:  MOVFF  116,150
490E:  MOVFF  115,14F
4912:  MOVFF  114,14E
4916:  MOVFF  03,155
491A:  MOVFF  02,154
491E:  MOVFF  01,153
4922:  MOVFF  00,152
4926:  CALL   1114
492A:  MOVFF  03,117
492E:  MOVFF  02,116
4932:  MOVFF  01,115
4936:  MOVFF  00,114
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
493A:  MOVLB  1
493C:  MOVFF  11C,FE9
4940:  MOVFF  11D,FEA
4944:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
4946:  MOVFF  11B,14B
494A:  MOVFF  11A,14A
494E:  MOVFF  119,149
4952:  MOVFF  118,148
4956:  MOVFF  117,14F
495A:  MOVFF  116,14E
495E:  MOVFF  115,14D
4962:  MOVFF  114,14C
4966:  MOVLB  0
4968:  CALL   3DD2
496C:  BTFSC  FD8.2
496E:  BRA    4974
4970:  MOVLB  1
4972:  BRA    48CE
....................  
....................    return(res); 
4974:  MOVFF  118,00
4978:  MOVFF  119,01
497C:  MOVFF  11A,02
4980:  MOVFF  11B,03
.................... } 
4984:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
43E8:  MOVLW  7F
43EA:  MOVLB  1
43EC:  MOVWF  x2E
43EE:  CLRF   x2F
43F0:  CLRF   x30
43F2:  CLRF   x31
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
43F4:  MOVLW  7E
43F6:  MOVWF  x38
43F8:  MOVLW  80
43FA:  MOVWF  x39
43FC:  CLRF   x3A
43FE:  CLRF   x3B
4400:  MOVLW  7A
4402:  MOVWF  x3C
4404:  MOVLW  2A
4406:  MOVWF  x3D
4408:  MOVLW  AA
440A:  MOVWF  x3E
440C:  MOVLW  A3
440E:  MOVWF  x3F
4410:  MOVLW  75
4412:  MOVWF  x40
4414:  MOVLW  B6
4416:  MOVWF  x41
4418:  MOVLW  09
441A:  MOVWF  x42
441C:  MOVLW  9C
441E:  MOVWF  x43
4420:  MOVLW  6F
4422:  MOVWF  x44
4424:  MOVLW  4F
4426:  MOVWF  x45
4428:  MOVLW  B4
442A:  MOVWF  x46
442C:  MOVLW  0B
442E:  MOVWF  x47
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
4430:  MOVFF  125,14B
4434:  MOVFF  124,14A
4438:  MOVFF  123,149
443C:  MOVFF  122,148
4440:  CLRF   x4F
4442:  CLRF   x4E
4444:  CLRF   x4D
4446:  CLRF   x4C
4448:  MOVLB  0
444A:  RCALL  3DD2
444C:  BNC   4456
444E:  MOVLB  1
4450:  MOVF   x23,W
4452:  XORLW  80
4454:  MOVWF  x23
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
4456:  MOVFF  125,14B
445A:  MOVFF  124,14A
445E:  MOVFF  123,149
4462:  MOVFF  122,148
4466:  MOVLW  DB
4468:  MOVLB  1
446A:  MOVWF  x4F
446C:  MOVLW  0F
446E:  MOVWF  x4E
4470:  MOVLW  49
4472:  MOVWF  x4D
4474:  MOVLW  7F
4476:  MOVWF  x4C
4478:  MOVLB  0
447A:  CALL   0FB6
447E:  MOVFF  03,14B
4482:  MOVFF  02,14A
4486:  MOVFF  01,149
448A:  MOVFF  00,148
448E:  RCALL  43AC
4490:  MOVFF  01,132
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
4494:  MOVFF  125,14B
4498:  MOVFF  124,14A
449C:  MOVFF  123,149
44A0:  MOVFF  122,148
44A4:  MOVLW  DB
44A6:  MOVLB  1
44A8:  MOVWF  x4F
44AA:  MOVLW  0F
44AC:  MOVWF  x4E
44AE:  MOVLW  49
44B0:  MOVWF  x4D
44B2:  MOVLW  7F
44B4:  MOVWF  x4C
44B6:  MOVLB  0
44B8:  CALL   0FB6
44BC:  MOVFF  00,148
44C0:  MOVFF  01,149
44C4:  MOVFF  02,14A
44C8:  MOVFF  03,14B
44CC:  MOVLB  1
44CE:  CLRF   x4D
44D0:  MOVFF  132,14C
44D4:  MOVLB  0
44D6:  RCALL  4376
44D8:  BSF    FD8.1
44DA:  MOVFF  14B,151
44DE:  MOVFF  14A,150
44E2:  MOVFF  149,14F
44E6:  MOVFF  148,14E
44EA:  MOVFF  03,155
44EE:  MOVFF  02,154
44F2:  MOVFF  01,153
44F6:  MOVFF  00,152
44FA:  CALL   1114
44FE:  MOVFF  03,137
4502:  MOVFF  02,136
4506:  MOVFF  01,135
450A:  MOVFF  00,134
....................    quad = quad % 4;                    // quadrant (0 to 3) 
450E:  MOVLW  03
4510:  MOVLB  1
4512:  ANDWF  x32,F
....................  
....................    if (quad == 0 || quad == 2) 
4514:  MOVF   x32,F
4516:  BZ    451E
4518:  MOVF   x32,W
451A:  SUBLW  02
451C:  BNZ   4558
....................       t = frac * PI_DIV_BY_TWO; 
451E:  MOVFF  137,14F
4522:  MOVFF  136,14E
4526:  MOVFF  135,14D
452A:  MOVFF  134,14C
452E:  MOVLW  DB
4530:  MOVWF  x53
4532:  MOVLW  0F
4534:  MOVWF  x52
4536:  MOVLW  49
4538:  MOVWF  x51
453A:  MOVLW  7F
453C:  MOVWF  x50
453E:  MOVLB  0
4540:  CALL   0EC0
4544:  MOVFF  03,12D
4548:  MOVFF  02,12C
454C:  MOVFF  01,12B
4550:  MOVFF  00,12A
....................    else if (quad == 1) 
4554:  BRA    4634
4556:  MOVLB  1
4558:  DECFSZ x32,W
455A:  BRA    45CA
....................       t = (1-frac) * PI_DIV_BY_TWO; 
455C:  BSF    FD8.1
455E:  CLRF   x51
4560:  CLRF   x50
4562:  CLRF   x4F
4564:  MOVLW  7F
4566:  MOVWF  x4E
4568:  MOVFF  137,155
456C:  MOVFF  136,154
4570:  MOVFF  135,153
4574:  MOVFF  134,152
4578:  MOVLB  0
457A:  CALL   1114
457E:  MOVFF  00,148
4582:  MOVFF  01,149
4586:  MOVFF  02,14A
458A:  MOVFF  03,14B
458E:  MOVFF  03,14F
4592:  MOVFF  02,14E
4596:  MOVFF  01,14D
459A:  MOVFF  00,14C
459E:  MOVLW  DB
45A0:  MOVLB  1
45A2:  MOVWF  x53
45A4:  MOVLW  0F
45A6:  MOVWF  x52
45A8:  MOVLW  49
45AA:  MOVWF  x51
45AC:  MOVLW  7F
45AE:  MOVWF  x50
45B0:  MOVLB  0
45B2:  CALL   0EC0
45B6:  MOVFF  03,12D
45BA:  MOVFF  02,12C
45BE:  MOVFF  01,12B
45C2:  MOVFF  00,12A
....................    else // should be 3 
45C6:  BRA    4634
45C8:  MOVLB  1
....................       t = (frac-1) * PI_DIV_BY_TWO; 
45CA:  BSF    FD8.1
45CC:  MOVFF  137,151
45D0:  MOVFF  136,150
45D4:  MOVFF  135,14F
45D8:  MOVFF  134,14E
45DC:  CLRF   x55
45DE:  CLRF   x54
45E0:  CLRF   x53
45E2:  MOVLW  7F
45E4:  MOVWF  x52
45E6:  MOVLB  0
45E8:  CALL   1114
45EC:  MOVFF  00,148
45F0:  MOVFF  01,149
45F4:  MOVFF  02,14A
45F8:  MOVFF  03,14B
45FC:  MOVFF  03,14F
4600:  MOVFF  02,14E
4604:  MOVFF  01,14D
4608:  MOVFF  00,14C
460C:  MOVLW  DB
460E:  MOVLB  1
4610:  MOVWF  x53
4612:  MOVLW  0F
4614:  MOVWF  x52
4616:  MOVLW  49
4618:  MOVWF  x51
461A:  MOVLW  7F
461C:  MOVWF  x50
461E:  MOVLB  0
4620:  CALL   0EC0
4624:  MOVFF  03,12D
4628:  MOVFF  02,12C
462C:  MOVFF  01,12B
4630:  MOVFF  00,12A
....................  
....................    y = 0.999999999781; 
4634:  MOVLB  1
4636:  CLRF   x29
4638:  CLRF   x28
463A:  CLRF   x27
463C:  MOVLW  7F
463E:  MOVWF  x26
....................    t = t * t; 
4640:  MOVFF  12D,14F
4644:  MOVFF  12C,14E
4648:  MOVFF  12B,14D
464C:  MOVFF  12A,14C
4650:  MOVFF  12D,153
4654:  MOVFF  12C,152
4658:  MOVFF  12B,151
465C:  MOVFF  12A,150
4660:  MOVLB  0
4662:  CALL   0EC0
4666:  MOVFF  03,12D
466A:  MOVFF  02,12C
466E:  MOVFF  01,12B
4672:  MOVFF  00,12A
....................    for (i = 0; i <= 3; i++) 
4676:  MOVLB  1
4678:  CLRF   x33
467A:  MOVF   x33,W
467C:  SUBLW  03
467E:  BNC   474C
....................    { 
....................       t2 = t2 * t; 
4680:  MOVFF  131,14F
4684:  MOVFF  130,14E
4688:  MOVFF  12F,14D
468C:  MOVFF  12E,14C
4690:  MOVFF  12D,153
4694:  MOVFF  12C,152
4698:  MOVFF  12B,151
469C:  MOVFF  12A,150
46A0:  MOVLB  0
46A2:  CALL   0EC0
46A6:  MOVFF  03,131
46AA:  MOVFF  02,130
46AE:  MOVFF  01,12F
46B2:  MOVFF  00,12E
....................       y = y + p[i] * t2; 
46B6:  MOVLB  1
46B8:  MOVF   x33,W
46BA:  MULLW  04
46BC:  MOVF   FF3,W
46BE:  CLRF   03
46C0:  ADDLW  38
46C2:  MOVWF  FE9
46C4:  MOVLW  01
46C6:  ADDWFC 03,W
46C8:  MOVWF  FEA
46CA:  MOVFF  FEF,148
46CE:  MOVFF  FEC,149
46D2:  MOVFF  FEC,14A
46D6:  MOVFF  FEC,14B
46DA:  MOVFF  14B,14F
46DE:  MOVFF  14A,14E
46E2:  MOVFF  149,14D
46E6:  MOVFF  148,14C
46EA:  MOVFF  131,153
46EE:  MOVFF  130,152
46F2:  MOVFF  12F,151
46F6:  MOVFF  12E,150
46FA:  MOVLB  0
46FC:  CALL   0EC0
4700:  MOVFF  FEA,14D
4704:  MOVFF  FE9,14C
4708:  BCF    FD8.1
470A:  MOVFF  129,151
470E:  MOVFF  128,150
4712:  MOVFF  127,14F
4716:  MOVFF  126,14E
471A:  MOVFF  03,155
471E:  MOVFF  02,154
4722:  MOVFF  01,153
4726:  MOVFF  00,152
472A:  CALL   1114
472E:  MOVFF  14D,FEA
4732:  MOVFF  14C,FE9
4736:  MOVFF  03,129
473A:  MOVFF  02,128
473E:  MOVFF  01,127
4742:  MOVFF  00,126
....................    } 
4746:  MOVLB  1
4748:  INCF   x33,F
474A:  BRA    467A
....................  
....................    if (quad == 2 || quad == 1) 
474C:  MOVF   x32,W
474E:  SUBLW  02
4750:  BZ    4756
4752:  DECFSZ x32,W
4754:  BRA    475C
....................       y = -y;  // correct sign 
4756:  MOVF   x27,W
4758:  XORLW  80
475A:  MOVWF  x27
....................  
....................    return (y); 
475C:  MOVFF  126,00
4760:  MOVFF  127,01
4764:  MOVFF  128,02
4768:  MOVFF  129,03
.................... } 
476C:  MOVLB  0
476E:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
4770:  BSF    FD8.1
4772:  MOVFF  11D,151
4776:  MOVFF  11C,150
477A:  MOVFF  11B,14F
477E:  MOVFF  11A,14E
4782:  MOVLW  DB
4784:  MOVLB  1
4786:  MOVWF  x55
4788:  MOVLW  0F
478A:  MOVWF  x54
478C:  MOVLW  49
478E:  MOVWF  x53
4790:  MOVLW  7F
4792:  MOVWF  x52
4794:  MOVLB  0
4796:  CALL   1114
479A:  MOVFF  00,11E
479E:  MOVFF  01,11F
47A2:  MOVFF  02,120
47A6:  MOVFF  03,121
47AA:  MOVFF  03,125
47AE:  MOVFF  02,124
47B2:  MOVFF  01,123
47B6:  MOVFF  00,122
47BA:  RCALL  43E8
.................... } 
47BC:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
47BE:  MOVFF  111,125
47C2:  MOVFF  110,124
47C6:  MOVFF  10F,123
47CA:  MOVFF  10E,122
47CE:  RCALL  43E8
47D0:  MOVFF  03,115
47D4:  MOVFF  02,114
47D8:  MOVFF  01,113
47DC:  MOVFF  00,112
....................    if (c == 0.0) 
47E0:  MOVFF  115,14B
47E4:  MOVFF  114,14A
47E8:  MOVFF  113,149
47EC:  MOVFF  112,148
47F0:  MOVLB  1
47F2:  CLRF   x4F
47F4:  CLRF   x4E
47F6:  CLRF   x4D
47F8:  CLRF   x4C
47FA:  MOVLB  0
47FC:  CALL   3DD2
4800:  BNZ   4814
....................       return (1.0e+36); 
4802:  MOVLW  F6
4804:  MOVWF  00
4806:  MOVLW  40
4808:  MOVWF  01
480A:  MOVLW  97
480C:  MOVWF  02
480E:  MOVLW  CE
4810:  MOVWF  03
4812:  BRA    485A
....................  
....................    s = sin(x); 
4814:  MOVFF  111,11D
4818:  MOVFF  110,11C
481C:  MOVFF  10F,11B
4820:  MOVFF  10E,11A
4824:  RCALL  4770
4826:  MOVFF  03,119
482A:  MOVFF  02,118
482E:  MOVFF  01,117
4832:  MOVFF  00,116
....................    return(s/c); 
4836:  MOVFF  119,14B
483A:  MOVFF  118,14A
483E:  MOVFF  117,149
4842:  MOVFF  116,148
4846:  MOVFF  115,14F
484A:  MOVFF  114,14E
484E:  MOVFF  113,14D
4852:  MOVFF  112,14C
4856:  CALL   0FB6
.................... } 
485A:  RETLW  00
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
5026:  MOVLB  1
5028:  BCF    x07.0
....................    y = x; 
502A:  MOVFF  F5,FA
502E:  MOVFF  F4,F9
5032:  MOVFF  F3,F8
5036:  MOVFF  F2,F7
....................  
....................    if (x < 0) 
503A:  MOVFF  F5,14B
503E:  MOVFF  F4,14A
5042:  MOVFF  F3,149
5046:  MOVFF  F2,148
504A:  CLRF   x4F
504C:  CLRF   x4E
504E:  CLRF   x4D
5050:  CLRF   x4C
5052:  MOVLB  0
5054:  CALL   3DD2
5058:  BNC   5066
....................    { 
....................       s = 1; 
505A:  MOVLB  1
505C:  BSF    x07.0
....................       y = -y; 
505E:  MOVLB  0
5060:  MOVF   xF8,W
5062:  XORLW  80
5064:  MOVWF  xF8
....................    } 
....................  
....................    if (y > 0.5) 
5066:  MOVLB  1
5068:  CLRF   x4B
506A:  CLRF   x4A
506C:  CLRF   x49
506E:  MOVLW  7E
5070:  MOVWF  x48
5072:  MOVFF  FA,14F
5076:  MOVFF  F9,14E
507A:  MOVFF  F8,14D
507E:  MOVFF  F7,14C
5082:  MOVLB  0
5084:  CALL   3DD2
5088:  BNC   5118
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
508A:  BSF    FD8.1
508C:  MOVLB  1
508E:  CLRF   x51
5090:  CLRF   x50
5092:  CLRF   x4F
5094:  MOVLW  7F
5096:  MOVWF  x4E
5098:  MOVFF  FA,155
509C:  MOVFF  F9,154
50A0:  MOVFF  F8,153
50A4:  MOVFF  F7,152
50A8:  MOVLB  0
50AA:  CALL   1114
50AE:  MOVFF  00,108
50B2:  MOVFF  01,109
50B6:  MOVFF  02,10A
50BA:  MOVFF  03,10B
50BE:  MOVFF  03,14B
50C2:  MOVFF  02,14A
50C6:  MOVFF  01,149
50CA:  MOVFF  00,148
50CE:  MOVLB  1
50D0:  CLRF   x4F
50D2:  CLRF   x4E
50D4:  CLRF   x4D
50D6:  MOVLW  80
50D8:  MOVWF  x4C
50DA:  MOVLB  0
50DC:  CALL   0FB6
50E0:  MOVFF  00,10C
50E4:  MOVFF  01,10D
50E8:  MOVFF  02,10E
50EC:  MOVFF  03,10F
50F0:  MOVFF  03,113
50F4:  MOVFF  02,112
50F8:  MOVFF  01,111
50FC:  MOVFF  00,110
5100:  CALL   485C
5104:  MOVFF  03,FA
5108:  MOVFF  02,F9
510C:  MOVFF  01,F8
5110:  MOVFF  00,F7
....................       n += 2; 
5114:  MOVLW  02
5116:  ADDWF  xF6,F
....................    } 
....................  
....................    y2=y*y; 
5118:  MOVFF  FA,14F
511C:  MOVFF  F9,14E
5120:  MOVFF  F8,14D
5124:  MOVFF  F7,14C
5128:  MOVFF  FA,153
512C:  MOVFF  F9,152
5130:  MOVFF  F8,151
5134:  MOVFF  F7,150
5138:  CALL   0EC0
513C:  MOVFF  03,106
5140:  MOVFF  02,105
5144:  MOVFF  01,104
5148:  MOVFF  00,103
....................  
....................    res = pas[0]*y2 + pas[1]; 
514C:  MOVLW  37
514E:  MOVLB  1
5150:  MOVWF  x4F
5152:  MOVLW  BF
5154:  MOVWF  x4E
5156:  MOVLW  7D
5158:  MOVWF  x4D
515A:  MOVWF  x4C
515C:  MOVFF  106,153
5160:  MOVFF  105,152
5164:  MOVFF  104,151
5168:  MOVFF  103,150
516C:  MOVLB  0
516E:  CALL   0EC0
5172:  MOVFF  00,108
5176:  MOVFF  01,109
517A:  MOVFF  02,10A
517E:  MOVFF  03,10B
5182:  BCF    FD8.1
5184:  MOVFF  03,151
5188:  MOVFF  02,150
518C:  MOVFF  01,14F
5190:  MOVFF  00,14E
5194:  MOVLW  3D
5196:  MOVLB  1
5198:  MOVWF  x55
519A:  MOVLW  AA
519C:  MOVWF  x54
519E:  MOVLW  93
51A0:  MOVWF  x53
51A2:  MOVLW  81
51A4:  MOVWF  x52
51A6:  MOVLB  0
51A8:  CALL   1114
51AC:  MOVFF  03,FE
51B0:  MOVFF  02,FD
51B4:  MOVFF  01,FC
51B8:  MOVFF  00,FB
....................    res = res*y2 + pas[2]; 
51BC:  MOVFF  FE,14F
51C0:  MOVFF  FD,14E
51C4:  MOVFF  FC,14D
51C8:  MOVFF  FB,14C
51CC:  MOVFF  106,153
51D0:  MOVFF  105,152
51D4:  MOVFF  104,151
51D8:  MOVFF  103,150
51DC:  CALL   0EC0
51E0:  MOVFF  00,108
51E4:  MOVFF  01,109
51E8:  MOVFF  02,10A
51EC:  MOVFF  03,10B
51F0:  BCF    FD8.1
51F2:  MOVFF  03,151
51F6:  MOVFF  02,150
51FA:  MOVFF  01,14F
51FE:  MOVFF  00,14E
5202:  MOVLW  EE
5204:  MOVLB  1
5206:  MOVWF  x55
5208:  MOVLW  50
520A:  MOVWF  x54
520C:  MOVLW  33
520E:  MOVWF  x53
5210:  MOVLW  81
5212:  MOVWF  x52
5214:  MOVLB  0
5216:  CALL   1114
521A:  MOVFF  03,FE
521E:  MOVFF  02,FD
5222:  MOVFF  01,FC
5226:  MOVFF  00,FB
....................  
....................    r = qas[0]*y2 + qas[1]; 
522A:  MOVLB  1
522C:  CLRF   x4F
522E:  CLRF   x4E
5230:  CLRF   x4D
5232:  MOVLW  7F
5234:  MOVWF  x4C
5236:  MOVFF  106,153
523A:  MOVFF  105,152
523E:  MOVFF  104,151
5242:  MOVFF  103,150
5246:  MOVLB  0
5248:  CALL   0EC0
524C:  MOVFF  00,108
5250:  MOVFF  01,109
5254:  MOVFF  02,10A
5258:  MOVFF  03,10B
525C:  BCF    FD8.1
525E:  MOVFF  03,151
5262:  MOVFF  02,150
5266:  MOVFF  01,14F
526A:  MOVFF  00,14E
526E:  MOVLW  0A
5270:  MOVLB  1
5272:  MOVWF  x55
5274:  MOVLW  8D
5276:  MOVWF  x54
5278:  MOVLW  B1
527A:  MOVWF  x53
527C:  MOVLW  81
527E:  MOVWF  x52
5280:  MOVLB  0
5282:  CALL   1114
5286:  MOVFF  03,102
528A:  MOVFF  02,101
528E:  MOVFF  01,100
5292:  MOVFF  00,FF
....................    r = r*y2 + qas[2]; 
5296:  MOVFF  102,14F
529A:  MOVFF  101,14E
529E:  MOVFF  100,14D
52A2:  MOVFF  FF,14C
52A6:  MOVFF  106,153
52AA:  MOVFF  105,152
52AE:  MOVFF  104,151
52B2:  MOVFF  103,150
52B6:  CALL   0EC0
52BA:  MOVFF  00,108
52BE:  MOVFF  01,109
52C2:  MOVFF  02,10A
52C6:  MOVFF  03,10B
52CA:  BCF    FD8.1
52CC:  MOVFF  03,151
52D0:  MOVFF  02,150
52D4:  MOVFF  01,14F
52D8:  MOVFF  00,14E
52DC:  MOVLW  EE
52DE:  MOVLB  1
52E0:  MOVWF  x55
52E2:  MOVLW  50
52E4:  MOVWF  x54
52E6:  MOVLW  33
52E8:  MOVWF  x53
52EA:  MOVLW  81
52EC:  MOVWF  x52
52EE:  MOVLB  0
52F0:  CALL   1114
52F4:  MOVFF  03,102
52F8:  MOVFF  02,101
52FC:  MOVFF  01,100
5300:  MOVFF  00,FF
....................  
....................    res = y*res/r; 
5304:  MOVFF  FA,14F
5308:  MOVFF  F9,14E
530C:  MOVFF  F8,14D
5310:  MOVFF  F7,14C
5314:  MOVFF  FE,153
5318:  MOVFF  FD,152
531C:  MOVFF  FC,151
5320:  MOVFF  FB,150
5324:  CALL   0EC0
5328:  MOVFF  00,108
532C:  MOVFF  01,109
5330:  MOVFF  02,10A
5334:  MOVFF  03,10B
5338:  MOVFF  03,14B
533C:  MOVFF  02,14A
5340:  MOVFF  01,149
5344:  MOVFF  00,148
5348:  MOVFF  102,14F
534C:  MOVFF  101,14E
5350:  MOVFF  100,14D
5354:  MOVFF  FF,14C
5358:  CALL   0FB6
535C:  MOVFF  03,FE
5360:  MOVFF  02,FD
5364:  MOVFF  01,FC
5368:  MOVFF  00,FB
....................  
....................    if (n & 2)     // |x| > 0.5 
536C:  BTFSS  xF6.1
536E:  BRA    53CC
....................       res = PI_DIV_BY_TWO - 2.0*res; 
5370:  MOVLB  1
5372:  CLRF   x4F
5374:  CLRF   x4E
5376:  CLRF   x4D
5378:  MOVLW  80
537A:  MOVWF  x4C
537C:  MOVFF  FE,153
5380:  MOVFF  FD,152
5384:  MOVFF  FC,151
5388:  MOVFF  FB,150
538C:  MOVLB  0
538E:  CALL   0EC0
5392:  BSF    FD8.1
5394:  MOVLW  DB
5396:  MOVLB  1
5398:  MOVWF  x51
539A:  MOVLW  0F
539C:  MOVWF  x50
539E:  MOVLW  49
53A0:  MOVWF  x4F
53A2:  MOVLW  7F
53A4:  MOVWF  x4E
53A6:  MOVFF  03,155
53AA:  MOVFF  02,154
53AE:  MOVFF  01,153
53B2:  MOVFF  00,152
53B6:  MOVLB  0
53B8:  CALL   1114
53BC:  MOVFF  03,FE
53C0:  MOVFF  02,FD
53C4:  MOVFF  01,FC
53C8:  MOVFF  00,FB
....................    if (s) 
53CC:  MOVLB  1
53CE:  BTFSS  x07.0
53D0:  BRA    53DA
....................       res = -res; 
53D2:  MOVLB  0
53D4:  MOVF   xFC,W
53D6:  XORLW  80
53D8:  MOVWF  xFC
....................    if (n & 1)           // take arccos 
53DA:  MOVLB  0
53DC:  BTFSS  xF6.0
53DE:  BRA    541A
....................       res = PI_DIV_BY_TWO - res; 
53E0:  BSF    FD8.1
53E2:  MOVLW  DB
53E4:  MOVLB  1
53E6:  MOVWF  x51
53E8:  MOVLW  0F
53EA:  MOVWF  x50
53EC:  MOVLW  49
53EE:  MOVWF  x4F
53F0:  MOVLW  7F
53F2:  MOVWF  x4E
53F4:  MOVFF  FE,155
53F8:  MOVFF  FD,154
53FC:  MOVFF  FC,153
5400:  MOVFF  FB,152
5404:  MOVLB  0
5406:  CALL   1114
540A:  MOVFF  03,FE
540E:  MOVFF  02,FD
5412:  MOVFF  01,FC
5416:  MOVFF  00,FB
....................  
....................    return(res); 
541A:  MOVFF  FB,00
541E:  MOVFF  FC,01
5422:  MOVFF  FD,02
5426:  MOVFF  FE,03
.................... } 
542A:  GOTO   5444 (RETURN)
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
542E:  MOVFF  ED,F5
5432:  MOVFF  EC,F4
5436:  MOVFF  EB,F3
543A:  MOVFF  EA,F2
543E:  MOVLW  01
5440:  MOVWF  xF6
5442:  BRA    5026
5444:  MOVFF  03,F1
5448:  MOVFF  02,F0
544C:  MOVFF  01,EF
5450:  MOVFF  00,EE
....................    return(r); 
5454:  MOVFF  EE,00
5458:  MOVFF  EF,01
545C:  MOVFF  F0,02
5460:  MOVFF  F1,03
.................... } 
5464:  GOTO   5B5E (RETURN)
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
3E4C:  MOVLB  1
3E4E:  BCF    x16.0
....................    flag = 0; 
3E50:  BCF    x16.1
....................    y = x; 
3E52:  MOVFF  109,10D
3E56:  MOVFF  108,10C
3E5A:  MOVFF  107,10B
3E5E:  MOVFF  106,10A
....................  
....................    if (x < 0) 
3E62:  MOVFF  109,14B
3E66:  MOVFF  108,14A
3E6A:  MOVFF  107,149
3E6E:  MOVFF  106,148
3E72:  CLRF   x4F
3E74:  CLRF   x4E
3E76:  CLRF   x4D
3E78:  CLRF   x4C
3E7A:  MOVLB  0
3E7C:  RCALL  3DD2
3E7E:  BNC   3E8A
....................    { 
....................       s = 1; 
3E80:  MOVLB  1
3E82:  BSF    x16.0
....................       y = -y; 
3E84:  MOVF   x0B,W
3E86:  XORLW  80
3E88:  MOVWF  x0B
....................    } 
....................  
....................    if (y > 1.0) 
3E8A:  MOVLB  1
3E8C:  CLRF   x4B
3E8E:  CLRF   x4A
3E90:  CLRF   x49
3E92:  MOVLW  7F
3E94:  MOVWF  x48
3E96:  MOVFF  10D,14F
3E9A:  MOVFF  10C,14E
3E9E:  MOVFF  10B,14D
3EA2:  MOVFF  10A,14C
3EA6:  MOVLB  0
3EA8:  RCALL  3DD2
3EAA:  BNC   3EE2
....................    { 
....................       y = 1.0/y; 
3EAC:  MOVLB  1
3EAE:  CLRF   x4B
3EB0:  CLRF   x4A
3EB2:  CLRF   x49
3EB4:  MOVLW  7F
3EB6:  MOVWF  x48
3EB8:  MOVFF  10D,14F
3EBC:  MOVFF  10C,14E
3EC0:  MOVFF  10B,14D
3EC4:  MOVFF  10A,14C
3EC8:  MOVLB  0
3ECA:  CALL   0FB6
3ECE:  MOVFF  03,10D
3ED2:  MOVFF  02,10C
3ED6:  MOVFF  01,10B
3EDA:  MOVFF  00,10A
....................       flag = 1; 
3EDE:  MOVLB  1
3EE0:  BSF    x16.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
3EE2:  MOVLW  0A
3EE4:  MOVLB  1
3EE6:  MOVWF  x4F
3EE8:  MOVLW  89
3EEA:  MOVWF  x4E
3EEC:  MOVLW  34
3EEE:  MOVWF  x4D
3EF0:  MOVLW  7C
3EF2:  MOVWF  x4C
3EF4:  MOVFF  10D,153
3EF8:  MOVFF  10C,152
3EFC:  MOVFF  10B,151
3F00:  MOVFF  10A,150
3F04:  MOVLB  0
3F06:  CALL   0EC0
3F0A:  MOVFF  00,117
3F0E:  MOVFF  01,118
3F12:  MOVFF  02,119
3F16:  MOVFF  03,11A
3F1A:  MOVFF  03,14F
3F1E:  MOVFF  02,14E
3F22:  MOVFF  01,14D
3F26:  MOVFF  00,14C
3F2A:  MOVFF  10D,153
3F2E:  MOVFF  10C,152
3F32:  MOVFF  10B,151
3F36:  MOVFF  10A,150
3F3A:  CALL   0EC0
3F3E:  MOVFF  00,11B
3F42:  MOVFF  01,11C
3F46:  MOVFF  02,11D
3F4A:  MOVFF  03,11E
3F4E:  BCF    FD8.1
3F50:  MOVFF  03,151
3F54:  MOVFF  02,150
3F58:  MOVFF  01,14F
3F5C:  MOVFF  00,14E
3F60:  MOVLW  7C
3F62:  MOVLB  1
3F64:  MOVWF  x55
3F66:  MOVLW  79
3F68:  MOVWF  x54
3F6A:  MOVLW  35
3F6C:  MOVWF  x53
3F6E:  MOVLW  81
3F70:  MOVWF  x52
3F72:  MOVLB  0
3F74:  CALL   1114
3F78:  MOVFF  03,111
3F7C:  MOVFF  02,110
3F80:  MOVFF  01,10F
3F84:  MOVFF  00,10E
....................    res = res*y*y + pat[2]; 
3F88:  MOVFF  111,14F
3F8C:  MOVFF  110,14E
3F90:  MOVFF  10F,14D
3F94:  MOVFF  10E,14C
3F98:  MOVFF  10D,153
3F9C:  MOVFF  10C,152
3FA0:  MOVFF  10B,151
3FA4:  MOVFF  10A,150
3FA8:  CALL   0EC0
3FAC:  MOVFF  00,117
3FB0:  MOVFF  01,118
3FB4:  MOVFF  02,119
3FB8:  MOVFF  03,11A
3FBC:  MOVFF  03,14F
3FC0:  MOVFF  02,14E
3FC4:  MOVFF  01,14D
3FC8:  MOVFF  00,14C
3FCC:  MOVFF  10D,153
3FD0:  MOVFF  10C,152
3FD4:  MOVFF  10B,151
3FD8:  MOVFF  10A,150
3FDC:  CALL   0EC0
3FE0:  MOVFF  00,11B
3FE4:  MOVFF  01,11C
3FE8:  MOVFF  02,11D
3FEC:  MOVFF  03,11E
3FF0:  BCF    FD8.1
3FF2:  MOVFF  03,151
3FF6:  MOVFF  02,150
3FFA:  MOVFF  01,14F
3FFE:  MOVFF  00,14E
4002:  MOVLW  3F
4004:  MOVLB  1
4006:  MOVWF  x55
4008:  MOVLW  02
400A:  MOVWF  x54
400C:  MOVLW  33
400E:  MOVWF  x53
4010:  MOVLW  83
4012:  MOVWF  x52
4014:  MOVLB  0
4016:  CALL   1114
401A:  MOVFF  03,111
401E:  MOVFF  02,110
4022:  MOVFF  01,10F
4026:  MOVFF  00,10E
....................    res = res*y*y + pat[3]; 
402A:  MOVFF  111,14F
402E:  MOVFF  110,14E
4032:  MOVFF  10F,14D
4036:  MOVFF  10E,14C
403A:  MOVFF  10D,153
403E:  MOVFF  10C,152
4042:  MOVFF  10B,151
4046:  MOVFF  10A,150
404A:  CALL   0EC0
404E:  MOVFF  00,117
4052:  MOVFF  01,118
4056:  MOVFF  02,119
405A:  MOVFF  03,11A
405E:  MOVFF  03,14F
4062:  MOVFF  02,14E
4066:  MOVFF  01,14D
406A:  MOVFF  00,14C
406E:  MOVFF  10D,153
4072:  MOVFF  10C,152
4076:  MOVFF  10B,151
407A:  MOVFF  10A,150
407E:  CALL   0EC0
4082:  MOVFF  00,11B
4086:  MOVFF  01,11C
408A:  MOVFF  02,11D
408E:  MOVFF  03,11E
4092:  BCF    FD8.1
4094:  MOVFF  03,151
4098:  MOVFF  02,150
409C:  MOVFF  01,14F
40A0:  MOVFF  00,14E
40A4:  MOVLW  33
40A6:  MOVLB  1
40A8:  MOVWF  x55
40AA:  MOVLW  8C
40AC:  MOVWF  x54
40AE:  MOVLW  1E
40B0:  MOVWF  x53
40B2:  MOVLW  83
40B4:  MOVWF  x52
40B6:  MOVLB  0
40B8:  CALL   1114
40BC:  MOVFF  03,111
40C0:  MOVFF  02,110
40C4:  MOVFF  01,10F
40C8:  MOVFF  00,10E
....................  
....................    r = qat[0]*y*y + qat[1]; 
40CC:  MOVLB  1
40CE:  CLRF   x4F
40D0:  CLRF   x4E
40D2:  CLRF   x4D
40D4:  MOVLW  7F
40D6:  MOVWF  x4C
40D8:  MOVFF  10D,153
40DC:  MOVFF  10C,152
40E0:  MOVFF  10B,151
40E4:  MOVFF  10A,150
40E8:  MOVLB  0
40EA:  CALL   0EC0
40EE:  MOVFF  00,117
40F2:  MOVFF  01,118
40F6:  MOVFF  02,119
40FA:  MOVFF  03,11A
40FE:  MOVFF  03,14F
4102:  MOVFF  02,14E
4106:  MOVFF  01,14D
410A:  MOVFF  00,14C
410E:  MOVFF  10D,153
4112:  MOVFF  10C,152
4116:  MOVFF  10B,151
411A:  MOVFF  10A,150
411E:  CALL   0EC0
4122:  MOVFF  00,11B
4126:  MOVFF  01,11C
412A:  MOVFF  02,11D
412E:  MOVFF  03,11E
4132:  BCF    FD8.1
4134:  MOVFF  03,151
4138:  MOVFF  02,150
413C:  MOVFF  01,14F
4140:  MOVFF  00,14E
4144:  MOVLW  1B
4146:  MOVLB  1
4148:  MOVWF  x55
414A:  MOVLW  E4
414C:  MOVWF  x54
414E:  MOVLW  35
4150:  MOVWF  x53
4152:  MOVLW  82
4154:  MOVWF  x52
4156:  MOVLB  0
4158:  CALL   1114
415C:  MOVFF  03,115
4160:  MOVFF  02,114
4164:  MOVFF  01,113
4168:  MOVFF  00,112
....................    r = r*y*y + qat[2]; 
416C:  MOVFF  115,14F
4170:  MOVFF  114,14E
4174:  MOVFF  113,14D
4178:  MOVFF  112,14C
417C:  MOVFF  10D,153
4180:  MOVFF  10C,152
4184:  MOVFF  10B,151
4188:  MOVFF  10A,150
418C:  CALL   0EC0
4190:  MOVFF  00,117
4194:  MOVFF  01,118
4198:  MOVFF  02,119
419C:  MOVFF  03,11A
41A0:  MOVFF  03,14F
41A4:  MOVFF  02,14E
41A8:  MOVFF  01,14D
41AC:  MOVFF  00,14C
41B0:  MOVFF  10D,153
41B4:  MOVFF  10C,152
41B8:  MOVFF  10B,151
41BC:  MOVFF  10A,150
41C0:  CALL   0EC0
41C4:  MOVFF  00,11B
41C8:  MOVFF  01,11C
41CC:  MOVFF  02,11D
41D0:  MOVFF  03,11E
41D4:  BCF    FD8.1
41D6:  MOVFF  03,151
41DA:  MOVFF  02,150
41DE:  MOVFF  01,14F
41E2:  MOVFF  00,14E
41E6:  MOVLW  A4
41E8:  MOVLB  1
41EA:  MOVWF  x55
41EC:  MOVLW  DB
41EE:  MOVWF  x54
41F0:  MOVLW  67
41F2:  MOVWF  x53
41F4:  MOVLW  83
41F6:  MOVWF  x52
41F8:  MOVLB  0
41FA:  CALL   1114
41FE:  MOVFF  03,115
4202:  MOVFF  02,114
4206:  MOVFF  01,113
420A:  MOVFF  00,112
....................    r = r*y*y + qat[3]; 
420E:  MOVFF  115,14F
4212:  MOVFF  114,14E
4216:  MOVFF  113,14D
421A:  MOVFF  112,14C
421E:  MOVFF  10D,153
4222:  MOVFF  10C,152
4226:  MOVFF  10B,151
422A:  MOVFF  10A,150
422E:  CALL   0EC0
4232:  MOVFF  00,117
4236:  MOVFF  01,118
423A:  MOVFF  02,119
423E:  MOVFF  03,11A
4242:  MOVFF  03,14F
4246:  MOVFF  02,14E
424A:  MOVFF  01,14D
424E:  MOVFF  00,14C
4252:  MOVFF  10D,153
4256:  MOVFF  10C,152
425A:  MOVFF  10B,151
425E:  MOVFF  10A,150
4262:  CALL   0EC0
4266:  MOVFF  00,11B
426A:  MOVFF  01,11C
426E:  MOVFF  02,11D
4272:  MOVFF  03,11E
4276:  BCF    FD8.1
4278:  MOVFF  03,151
427C:  MOVFF  02,150
4280:  MOVFF  01,14F
4284:  MOVFF  00,14E
4288:  MOVLW  33
428A:  MOVLB  1
428C:  MOVWF  x55
428E:  MOVLW  8C
4290:  MOVWF  x54
4292:  MOVLW  1E
4294:  MOVWF  x53
4296:  MOVLW  83
4298:  MOVWF  x52
429A:  MOVLB  0
429C:  CALL   1114
42A0:  MOVFF  03,115
42A4:  MOVFF  02,114
42A8:  MOVFF  01,113
42AC:  MOVFF  00,112
....................  
....................    res = y*res/r; 
42B0:  MOVFF  10D,14F
42B4:  MOVFF  10C,14E
42B8:  MOVFF  10B,14D
42BC:  MOVFF  10A,14C
42C0:  MOVFF  111,153
42C4:  MOVFF  110,152
42C8:  MOVFF  10F,151
42CC:  MOVFF  10E,150
42D0:  CALL   0EC0
42D4:  MOVFF  00,117
42D8:  MOVFF  01,118
42DC:  MOVFF  02,119
42E0:  MOVFF  03,11A
42E4:  MOVFF  03,14B
42E8:  MOVFF  02,14A
42EC:  MOVFF  01,149
42F0:  MOVFF  00,148
42F4:  MOVFF  115,14F
42F8:  MOVFF  114,14E
42FC:  MOVFF  113,14D
4300:  MOVFF  112,14C
4304:  CALL   0FB6
4308:  MOVFF  03,111
430C:  MOVFF  02,110
4310:  MOVFF  01,10F
4314:  MOVFF  00,10E
....................  
....................  
....................    if (flag)                              // for |x| > 1 
4318:  MOVLB  1
431A:  BTFSS  x16.1
431C:  BRA    4358
....................       res = PI_DIV_BY_TWO - res; 
431E:  BSF    FD8.1
4320:  MOVLW  DB
4322:  MOVWF  x51
4324:  MOVLW  0F
4326:  MOVWF  x50
4328:  MOVLW  49
432A:  MOVWF  x4F
432C:  MOVLW  7F
432E:  MOVWF  x4E
4330:  MOVFF  111,155
4334:  MOVFF  110,154
4338:  MOVFF  10F,153
433C:  MOVFF  10E,152
4340:  MOVLB  0
4342:  CALL   1114
4346:  MOVFF  03,111
434A:  MOVFF  02,110
434E:  MOVFF  01,10F
4352:  MOVFF  00,10E
4356:  MOVLB  1
....................    if (s) 
4358:  BTFSS  x16.0
435A:  BRA    4362
....................       res = -res; 
435C:  MOVF   x0F,W
435E:  XORLW  80
4360:  MOVWF  x0F
....................  
....................    return(res); 
4362:  MOVFF  10E,00
4366:  MOVFF  10F,01
436A:  MOVFF  110,02
436E:  MOVFF  111,03
.................... } 
4372:  MOVLB  0
4374:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
04B4:  CLRF   FEA
04B6:  MOVLW  F1
04B8:  MOVWF  FE9
04BA:  MOVF   FEF,W
04BC:  BZ    04DA
04BE:  MOVLW  03
04C0:  MOVWF  01
04C2:  CLRF   00
04C4:  DECFSZ 00,F
04C6:  BRA    04C4
04C8:  DECFSZ 01,F
04CA:  BRA    04C2
04CC:  MOVLW  3C
04CE:  MOVWF  00
04D0:  DECFSZ 00,F
04D2:  BRA    04D0
04D4:  BRA    04D6
04D6:  DECFSZ FEF,F
04D8:  BRA    04BE
04DA:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N) 
....................  
....................  
....................  
....................  
....................  
.................... struct flag { 
.................... 	boolean task1_armed; 
.................... 	boolean update_time; 
.................... 	boolean prev_pulse_state; 
.................... 	boolean cmd_posted; 
.................... 	boolean setup_required; 
.................... 	boolean reset_rs232; 
.................... 	boolean pwr_state; 
.................... 	boolean measured_current; 
.................... } flag; 
....................  
.................... struct port_d_map{ 
.................... 	int8 lcd_nibble:4; //0:3 
.................... 	boolean ps_en;     //4 
.................... 	boolean meas_rly;  //5 
.................... 	boolean pwr_ctrl;  //6 
.................... 	boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... struct port_e_map{ 
.................... 	boolean rs; //0 
.................... 	boolean emgcy; //1 
.................... 	boolean tx_en; //2 
....................     int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
.................... #byte PORTA =0xF80 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... ////////////// actuator parameter ///////// 
.................... #define DIM_A 107.5 
.................... #define DIM_P 9.3 
.................... #define DIM_M 5.5 
.................... #define DIM_K 36.0 
.................... #define DIM_B 15.8 
.................... #define MIN_STROKE 70.3  
.................... #define MAX_STROKE 128.0 
.................... #define ROW_SPACING 320.00 
.................... #define PANEL_WIDTH 160.00 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1	PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3	PIN_B3 
.................... #define CCW PIN_B4 
.................... #define FLASH_SELECT PIN_C2 // output 
.................... #define FLASH_CLOCK  PIN_C3 // output 
.................... #define FLASH_DI     PIN_C5 // output 
.................... #define FLASH_DO     PIN_C4 // input 
.................... #define SENSE_0		 PIN_A1 
.................... #define SENSE_1		 PIN_A2 
.................... #define SENSE_2		 PIN_A3 
.................... #define SENSE_3		 PIN_A4 
.................... #define WALL_PWR	 PIN_A5 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00002 
.................... #define ADDR_TIME           0xf00004 
.................... #define ADDR_START_COUNTER  0xf00008 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x05B1} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000} 
.................... #rom ADDR_TIME={0x0000,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... //#rom ADDR_TIME={0x1C20,0x0000} 
....................  
.................... const int8 line[4] = {0,0x40,0x10,0x50}; 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... char tmp_str[20],tmp_str2[20]; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... unsigned int8 timer_ms=0; 
.................... unsigned int32 next_sun_rise; 
.................... unsigned int16 current_act_position=0; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int32 JDN,jj,g; 
.................... unsigned int32 dg,c,dc,b,db,a,da,y,m,d; 
.................... unsigned int32 YY,MM,DD,time_of_day; 
.................... unsigned int32 sec_until_sun_rise; 
.................... int16 FULL_STROKE_TICK=0; 
.................... float al; 
.................... int16 move_act_time_out=4; 
.................... int8 tx_delay=0; 
.................... int16 current_measured=0; 
.................... int8 n_avg_current_measured=0; 
.................... int16 startup_counter=0; 
.................... unsigned int8 index_in_page; 
....................  
.................... void init_ext_flash(void); 
.................... void ext_flash_startContinuousRead(int pageAddress); 
.................... void ext_flash_sendData(int data, int size); 
.................... void ext_flash_send16Data(int16 data, int size); 
.................... void ext_flash_sendBytes(char* data, int size); 
.................... void ext_flash_getBytes(char* data, int16 size); 
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size); 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size); 
.................... int ext_flash_getByte(void); 
.................... void ext_flash_waitUntilReady(void); 
....................  
.................... void init_rs232() { 
.................... 	bit_clear(PIR1,4);  //TXIF=0 
*
3606:  BCF    F9E.4
.................... 	bit_clear(PIR1,5);  //RCIF=0 
3608:  BCF    F9E.5
.................... 	bit_clear(PIE1,5);  //RCIE=0 
360A:  BCF    F9D.5
.................... 	bit_clear(RCSTA,7); //SPEN=0 
360C:  BCF    FAB.7
.................... 	bit_clear(RCSTA,4); //CREN=0 
360E:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
3610:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
3612:  BCF    FAC.5
.................... 	delay_cycles(10); 
3614:  MOVLW  03
3616:  MOVWF  00
3618:  DECFSZ 00,F
361A:  BRA    3618
.................... 	bit_set(RCSTA,4); //CREN=1 
361C:  BSF    FAB.4
.................... 	bit_set(RCSTA,7); //SPEN=1 
361E:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
3620:  BSF    FAC.5
.................... 	bit_set(PIE1,5); //RCIE=1 
3622:  BSF    F9D.5
....................  
.................... } 
3624:  GOTO   6080 (RETURN)
....................  
....................  
.................... void read_eeprom_data() 
.................... { 
.................... 	int i; 
.................... 	int16 temp_mem;	 
.................... 	temp_mem= &timer_sec; 
*
05B4:  CLRF   xD1
05B6:  MOVLW  20
05B8:  MOVWF  xD0
.................... 	for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
05BA:  CLRF   xCF
05BC:  MOVF   xCF,W
05BE:  SUBLW  03
05C0:  BNC   0604
05C2:  MOVF   xCF,W
05C4:  ADDWF  xD0,W
05C6:  MOVWF  xD2
05C8:  MOVLW  00
05CA:  ADDWFC xD1,W
05CC:  MOVWF  xD3
05CE:  MOVLW  04
05D0:  ADDWF  xCF,W
05D2:  MOVWF  xD4
05D4:  MOVFF  FF2,D5
05D8:  BCF    FF2.7
05DA:  MOVFF  D4,FA9
05DE:  BCF    FA6.6
05E0:  BCF    FA6.7
05E2:  BSF    FA6.0
05E4:  MOVF   FA8,W
05E6:  BTFSC  xD5.7
05E8:  BSF    FF2.7
05EA:  MOVWF  xD5
05EC:  MOVFF  D3,FEA
05F0:  MOVFF  D2,FE9
05F4:  MOVFF  D5,D6
05F8:  CLRF   xD8
05FA:  MOVLW  01
05FC:  MOVWF  xD7
05FE:  RCALL  059A
0600:  INCF   xCF,F
0602:  BRA    05BC
.................... 	temp_mem= &FULL_STROKE_TICK; 
0604:  CLRF   xD1
0606:  MOVLW  BA
0608:  MOVWF  xD0
.................... 	if (FULL_STROKE_TICK > MAX_FULL_STROKE) FULL_STROKE_TICK = MAX_FULL_STROKE; 
060A:  MOVF   xBB,W
060C:  SUBLW  06
060E:  BC    0622
0610:  XORLW  FF
0612:  BNZ   061A
0614:  MOVF   xBA,W
0616:  SUBLW  D0
0618:  BC    0622
061A:  MOVLW  07
061C:  MOVWF  xBB
061E:  MOVLW  D0
0620:  MOVWF  xBA
.................... 	if (FULL_STROKE_TICK <0) FULL_STROKE_TICK = 0; 
....................  
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i),1); 
0622:  CLRF   xCF
0624:  MOVF   xCF,W
0626:  SUBLW  01
0628:  BNC   0666
062A:  MOVF   xCF,W
062C:  ADDWF  xD0,W
062E:  MOVWF  xD2
0630:  MOVLW  00
0632:  ADDWFC xD1,W
0634:  MOVWF  xD3
0636:  MOVFF  FF2,D4
063A:  BCF    FF2.7
063C:  MOVFF  CF,FA9
0640:  BCF    FA6.6
0642:  BCF    FA6.7
0644:  BSF    FA6.0
0646:  MOVF   FA8,W
0648:  BTFSC  xD4.7
064A:  BSF    FF2.7
064C:  MOVWF  xD5
064E:  MOVFF  D3,FEA
0652:  MOVFF  D2,FE9
0656:  MOVFF  D5,D6
065A:  CLRF   xD8
065C:  MOVLW  01
065E:  MOVWF  xD7
0660:  RCALL  059A
0662:  INCF   xCF,F
0664:  BRA    0624
.................... 	temp_mem= &current_act_position; 
0666:  CLRF   xD1
0668:  MOVLW  6E
066A:  MOVWF  xD0
.................... 	if (current_act_position > FULL_STROKE_TICK) current_act_position = FULL_STROKE_TICK; 
066C:  MOVF   xBB,W
066E:  SUBWF  x6F,W
0670:  BNC   0682
0672:  BNZ   067A
0674:  MOVF   x6E,W
0676:  SUBWF  xBA,W
0678:  BC    0682
067A:  MOVFF  BB,6F
067E:  MOVFF  BA,6E
.................... 	if (current_act_position < 0) current_act_position =0; 
....................  
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i),1); 
0682:  CLRF   xCF
0684:  MOVF   xCF,W
0686:  SUBLW  01
0688:  BNC   06CC
068A:  MOVF   xCF,W
068C:  ADDWF  xD0,W
068E:  MOVWF  xD2
0690:  MOVLW  00
0692:  ADDWFC xD1,W
0694:  MOVWF  xD3
0696:  MOVLW  02
0698:  ADDWF  xCF,W
069A:  MOVWF  xD4
069C:  MOVFF  FF2,D5
06A0:  BCF    FF2.7
06A2:  MOVFF  D4,FA9
06A6:  BCF    FA6.6
06A8:  BCF    FA6.7
06AA:  BSF    FA6.0
06AC:  MOVF   FA8,W
06AE:  BTFSC  xD5.7
06B0:  BSF    FF2.7
06B2:  MOVWF  xD5
06B4:  MOVFF  D3,FEA
06B8:  MOVFF  D2,FE9
06BC:  MOVFF  D5,D6
06C0:  CLRF   xD8
06C2:  MOVLW  01
06C4:  MOVWF  xD7
06C6:  RCALL  059A
06C8:  INCF   xCF,F
06CA:  BRA    0684
.................... 	temp_mem= &startup_counter; 
06CC:  CLRF   xD1
06CE:  MOVLW  C6
06D0:  MOVWF  xD0
.................... 	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
06D2:  CLRF   xCF
06D4:  MOVF   xCF,W
06D6:  SUBLW  01
06D8:  BNC   071C
06DA:  MOVF   xCF,W
06DC:  ADDWF  xD0,W
06DE:  MOVWF  xD2
06E0:  MOVLW  00
06E2:  ADDWFC xD1,W
06E4:  MOVWF  xD3
06E6:  MOVLW  08
06E8:  ADDWF  xCF,W
06EA:  MOVWF  xD4
06EC:  MOVFF  FF2,D5
06F0:  BCF    FF2.7
06F2:  MOVFF  D4,FA9
06F6:  BCF    FA6.6
06F8:  BCF    FA6.7
06FA:  BSF    FA6.0
06FC:  MOVF   FA8,W
06FE:  BTFSC  xD5.7
0700:  BSF    FF2.7
0702:  MOVWF  xD5
0704:  MOVFF  D3,FEA
0708:  MOVFF  D2,FE9
070C:  MOVFF  D5,D6
0710:  CLRF   xD8
0712:  MOVLW  01
0714:  MOVWF  xD7
0716:  RCALL  059A
0718:  INCF   xCF,F
071A:  BRA    06D4
.................... } 
071C:  GOTO   5E96 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
.................... 	int8 i; 
.................... 	for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0818:  CLRF   xD0
081A:  MOVF   xD0,W
081C:  SUBLW  03
081E:  BNC   0880
0820:  MOVLW  04
0822:  ADDWF  xD0,W
0824:  MOVWF  xD1
0826:  MOVF   xD0,W
0828:  MULLW  08
082A:  MOVFF  FF3,D2
082E:  MOVFF  23,D6
0832:  MOVFF  22,D5
0836:  MOVFF  21,D4
083A:  MOVFF  20,D3
083E:  MOVF   xD2,F
0840:  BZ    0850
0842:  BCF    FD8.0
0844:  RRCF   xD6,F
0846:  RRCF   xD5,F
0848:  RRCF   xD4,F
084A:  RRCF   xD3,F
084C:  DECFSZ xD2,F
084E:  BRA    0842
0850:  MOVFF  D1,FA9
0854:  MOVFF  D3,FA8
0858:  BCF    FA6.6
085A:  BCF    FA6.7
085C:  BSF    FA6.2
085E:  MOVFF  FF2,00
0862:  BCF    FF2.7
0864:  MOVLB  F
0866:  MOVLW  55
0868:  MOVWF  FA7
086A:  MOVLW  AA
086C:  MOVWF  FA7
086E:  BSF    FA6.1
0870:  BTFSC  FA6.1
0872:  BRA    0870
0874:  BCF    FA6.2
0876:  MOVF   00,W
0878:  IORWF  FF2,F
087A:  MOVLB  0
087C:  INCF   xD0,F
087E:  BRA    081A
.................... 	for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i,current_act_position>>(i*8)); 
0880:  CLRF   xD0
0882:  MOVF   xD0,W
0884:  SUBLW  01
0886:  BNC   08DC
0888:  MOVLW  02
088A:  ADDWF  xD0,W
088C:  MOVWF  xD1
088E:  MOVF   xD0,W
0890:  MULLW  08
0892:  MOVFF  FF3,00
0896:  MOVFF  6F,D3
089A:  MOVFF  6E,D2
089E:  MOVF   00,F
08A0:  BZ    08AC
08A2:  BCF    FD8.0
08A4:  RRCF   xD3,F
08A6:  RRCF   xD2,F
08A8:  DECFSZ 00,F
08AA:  BRA    08A2
08AC:  MOVFF  D1,FA9
08B0:  MOVFF  D2,FA8
08B4:  BCF    FA6.6
08B6:  BCF    FA6.7
08B8:  BSF    FA6.2
08BA:  MOVFF  FF2,00
08BE:  BCF    FF2.7
08C0:  MOVLB  F
08C2:  MOVLW  55
08C4:  MOVWF  FA7
08C6:  MOVLW  AA
08C8:  MOVWF  FA7
08CA:  BSF    FA6.1
08CC:  BTFSC  FA6.1
08CE:  BRA    08CC
08D0:  BCF    FA6.2
08D2:  MOVF   00,W
08D4:  IORWF  FF2,F
08D6:  MOVLB  0
08D8:  INCF   xD0,F
08DA:  BRA    0882
.................... 	for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
08DC:  CLRF   xD0
08DE:  MOVF   xD0,W
08E0:  SUBLW  01
08E2:  BNC   0938
08E4:  MOVLW  08
08E6:  ADDWF  xD0,W
08E8:  MOVWF  xD1
08EA:  MOVF   xD0,W
08EC:  MULLW  08
08EE:  MOVFF  FF3,00
08F2:  MOVFF  C7,D3
08F6:  MOVFF  C6,D2
08FA:  MOVF   00,F
08FC:  BZ    0908
08FE:  BCF    FD8.0
0900:  RRCF   xD3,F
0902:  RRCF   xD2,F
0904:  DECFSZ 00,F
0906:  BRA    08FE
0908:  MOVFF  D1,FA9
090C:  MOVFF  D2,FA8
0910:  BCF    FA6.6
0912:  BCF    FA6.7
0914:  BSF    FA6.2
0916:  MOVFF  FF2,00
091A:  BCF    FF2.7
091C:  MOVLB  F
091E:  MOVLW  55
0920:  MOVWF  FA7
0922:  MOVLW  AA
0924:  MOVWF  FA7
0926:  BSF    FA6.1
0928:  BTFSC  FA6.1
092A:  BRA    0928
092C:  BCF    FA6.2
092E:  MOVF   00,W
0930:  IORWF  FF2,F
0932:  MOVLB  0
0934:  INCF   xD0,F
0936:  BRA    08DE
.................... 	if (write_cal ==1) 
0938:  DECFSZ xCF,W
093A:  BRA    0992
.................... 		for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i,FULL_STROKE_TICK>>(i*8)); 
093C:  CLRF   xD0
093E:  MOVF   xD0,W
0940:  SUBLW  01
0942:  BNC   0992
0944:  MOVF   xD0,W
0946:  MULLW  08
0948:  MOVFF  FF3,00
094C:  MOVFF  BB,D2
0950:  MOVFF  BA,D1
0954:  MOVF   00,F
0956:  BZ    0962
0958:  BCF    FD8.0
095A:  RRCF   xD2,F
095C:  RRCF   xD1,F
095E:  DECFSZ 00,F
0960:  BRA    0958
0962:  MOVFF  D0,FA9
0966:  MOVFF  D1,FA8
096A:  BCF    FA6.6
096C:  BCF    FA6.7
096E:  BSF    FA6.2
0970:  MOVFF  FF2,00
0974:  BCF    FF2.7
0976:  MOVLB  F
0978:  MOVLW  55
097A:  MOVWF  FA7
097C:  MOVLW  AA
097E:  MOVWF  FA7
0980:  BSF    FA6.1
0982:  BTFSC  FA6.1
0984:  BRA    0982
0986:  BCF    FA6.2
0988:  MOVF   00,W
098A:  IORWF  FF2,F
098C:  MOVLB  0
098E:  INCF   xD0,F
0990:  BRA    093E
.................... } 
0992:  RETLW  00
....................  
....................  
.................... void init_ext_flash(void) { 
....................   output_low(FLASH_CLOCK); 
*
0AA6:  BCF    F94.3
0AA8:  BCF    F8B.3
....................   output_high(FLASH_SELECT); 
0AAA:  BCF    F94.2
0AAC:  BSF    F8B.2
.................... } 
0AAE:  GOTO   5F24 (RETURN)
....................  
.................... /* 
.................... void ext_flash_startContinuousRead(int pageAddress) { 
....................   ext_flash_waitUntilReady(); 
....................   output_low(FLASH_SELECT); 
....................   ext_flash_sendData(0xE8, 8); 
....................   ext_flash_sendData(pageAddress, 14); 
....................   ext_flash_sendData(0, 10); 
....................   ext_flash_sendData(0, 16); 
....................   ext_flash_sendData(0, 16); 
.................... } 
....................  
.................... */ 
....................  
.................... int ext_flash_getByte(void) { 
....................   int flashData = 0; 
....................   output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   return(flashData); 
.................... } 
....................  
.................... void ext_flash_getBytes(char* data, int16 size) { 
....................    int16 i, j; 
....................    for(i = 0; i < size; i++) { 
*
281A:  CLRF   xFD
281C:  CLRF   xFC
281E:  MOVF   xFD,W
2820:  SUBWF  xFB,W
2822:  BNC   287C
2824:  BNZ   282C
2826:  MOVF   xFA,W
2828:  SUBWF  xFC,W
282A:  BC    287C
....................       for(j = 0; j < 8; j++) { 
282C:  CLRF   xFF
282E:  CLRF   xFE
2830:  MOVF   xFF,F
2832:  BNZ   2874
2834:  MOVF   xFE,W
2836:  SUBLW  07
2838:  BNC   2874
....................          output_high(FLASH_CLOCK); 
283A:  BCF    F94.3
283C:  BSF    F8B.3
....................          shift_left(data + i, 1, input(FLASH_DO)); 
283E:  MOVF   xFC,W
2840:  ADDWF  xF8,W
2842:  MOVLB  1
2844:  MOVWF  x00
2846:  MOVLB  0
2848:  MOVF   xFD,W
284A:  ADDWFC xF9,W
284C:  MOVLB  1
284E:  MOVWF  x01
2850:  BSF    F94.4
2852:  BTFSC  F82.4
2854:  BRA    285A
2856:  BCF    FD8.0
2858:  BRA    285C
285A:  BSF    FD8.0
285C:  MOVFF  101,FEA
2860:  MOVFF  100,FE9
2864:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
2866:  BCF    F94.3
2868:  BCF    F8B.3
....................       } 
286A:  MOVLB  0
286C:  INCF   xFE,F
286E:  BTFSC  FD8.2
2870:  INCF   xFF,F
2872:  BRA    2830
....................    } 
2874:  INCF   xFC,F
2876:  BTFSC  FD8.2
2878:  INCF   xFD,F
287A:  BRA    281E
.................... } 
287C:  RETLW  00
....................  
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size) { 
....................    ext_flash_waitUntilReady(); 
287E:  RCALL  2552
....................    output_low(FLASH_SELECT); 
2880:  BCF    F94.2
2882:  BCF    F8B.2
....................    ext_flash_sendData(0xD2, 8); 
2884:  MOVLW  D2
2886:  MOVWF  xF8
2888:  MOVLW  08
288A:  MOVWF  xF9
288C:  RCALL  2688
....................    ext_flash_send16Data(pageAddress, 15); 
288E:  MOVFF  F2,F9
2892:  MOVFF  F1,F8
2896:  MOVLW  0F
2898:  MOVWF  xFA
289A:  RCALL  26B8
....................    ext_flash_sendData(0, 1); 
289C:  CLRF   xF8
289E:  MOVLW  01
28A0:  MOVWF  xF9
28A2:  RCALL  2688
....................    ext_flash_sendData(pageIndex, 8); 
28A4:  MOVFF  F3,F8
28A8:  MOVLW  08
28AA:  MOVWF  xF9
28AC:  RCALL  2688
....................    ext_flash_sendData(0, 16); 
28AE:  CLRF   xF8
28B0:  MOVLW  10
28B2:  MOVWF  xF9
28B4:  RCALL  2688
....................    ext_flash_sendData(0, 16); 
28B6:  CLRF   xF8
28B8:  MOVLW  10
28BA:  MOVWF  xF9
28BC:  RCALL  2688
....................    ext_flash_getBytes(data, size); 
28BE:  MOVFF  F5,F9
28C2:  MOVFF  F4,F8
28C6:  MOVFF  F7,FB
28CA:  MOVFF  F6,FA
28CE:  RCALL  281A
....................    output_high(FLASH_SELECT); 
28D0:  BCF    F94.2
28D2:  BSF    F8B.2
.................... } 
28D4:  RETLW  00
....................  
.................... /* 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
....................    output_low(FLASH_SELECT); 
....................    ext_flash_sendData(0x82, 8); 
....................    ext_flash_sendData(pageAddress, 14); 
....................    ext_flash_sendData(0, 10); 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
....................    output_high(FLASH_SELECT); 
.................... } 
.................... */ 
....................  
....................  
.................... void ext_flash_sendData(int data, int size) { 
....................    do { 
....................       size--; 
*
2688:  DECF   xF9,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
268A:  MOVFF  F8,00
268E:  MOVF   xF9,W
2690:  MOVWF  01
2692:  BZ    269C
2694:  BCF    FD8.0
2696:  RRCF   00,F
2698:  DECFSZ 01,F
269A:  BRA    2694
269C:  MOVF   00,W
269E:  ANDLW  01
26A0:  BNZ   26A6
26A2:  BCF    F8B.5
26A4:  BRA    26A8
26A6:  BSF    F8B.5
26A8:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
26AA:  BCF    F94.3
26AC:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
26AE:  BCF    F94.3
26B0:  BCF    F8B.3
....................    } while(size > 0); 
26B2:  MOVF   xF9,F
26B4:  BNZ   2688
.................... } 
26B6:  RETLW  00
....................  
.................... void ext_flash_send16Data(int16 data, int size) { 
....................    do { 
....................       size--; 
26B8:  DECF   xFA,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
26BA:  MOVFF  F9,FC
26BE:  MOVFF  F8,FB
26C2:  MOVF   xFA,W
26C4:  MOVWF  00
26C6:  BZ    26D2
26C8:  BCF    FD8.0
26CA:  RRCF   xFC,F
26CC:  RRCF   xFB,F
26CE:  DECFSZ 00,F
26D0:  BRA    26C8
26D2:  MOVF   xFB,W
26D4:  ANDLW  01
26D6:  MOVWF  00
26D8:  CLRF   03
26DA:  MOVF   00,W
26DC:  IORWF  03,W
26DE:  BNZ   26E4
26E0:  BCF    F8B.5
26E2:  BRA    26E6
26E4:  BSF    F8B.5
26E6:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
26E8:  BCF    F94.3
26EA:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
26EC:  BCF    F94.3
26EE:  BCF    F8B.3
....................    } while(size > 0); 
26F0:  MOVF   xFA,F
26F2:  BNZ   26B8
.................... } 
26F4:  RETLW  00
....................  
.................... void ext_flash_sendBytes(char* data, int size) { 
....................    int i; 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
.................... } 
....................  
.................... void ext_flash_waitUntilReady(void) { 
.................... // this function read status register 
.................... // Bit7 : 1=RDY, 0=BUSY 
.................... // Bit6 : COMP, 1=Recent Main memory page compare, 0 == match 
.................... // Bit 5-2 : 0b0111 , density code for 4MBit 
.................... // Bit 1: Protect 
.................... // Bit 0: Page size. 0= 264 byte, 1=256 byte 
....................  
....................   int flashData; 
....................   int i; 
....................   output_low(FLASH_SELECT); 
*
2552:  BCF    F94.2
2554:  BCF    F8B.2
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2556:  BSF    F8B.5
2558:  BCF    F94.5
255A:  BCF    F94.3
255C:  BSF    F8B.3
255E:  BCF    F94.3
2560:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2562:  BSF    F8B.5
2564:  BCF    F94.5
2566:  BCF    F94.3
2568:  BSF    F8B.3
256A:  BCF    F94.3
256C:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
256E:  BCF    F8B.5
2570:  BCF    F94.5
2572:  BCF    F94.3
2574:  BSF    F8B.3
2576:  BCF    F94.3
2578:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
257A:  BSF    F8B.5
257C:  BCF    F94.5
257E:  BCF    F94.3
2580:  BSF    F8B.3
2582:  BCF    F94.3
2584:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2586:  BCF    F8B.5
2588:  BCF    F94.5
258A:  BCF    F94.3
258C:  BSF    F8B.3
258E:  BCF    F94.3
2590:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2592:  BSF    F8B.5
2594:  BCF    F94.5
2596:  BCF    F94.3
2598:  BSF    F8B.3
259A:  BCF    F94.3
259C:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
259E:  BSF    F8B.5
25A0:  BCF    F94.5
25A2:  BCF    F94.3
25A4:  BSF    F8B.3
25A6:  BCF    F94.3
25A8:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
25AA:  BSF    F8B.5
25AC:  BCF    F94.5
25AE:  BCF    F94.3
25B0:  BSF    F8B.3
25B2:  BCF    F94.3
25B4:  BCF    F8B.3
....................   for(i=0;i<255;i++) { 
25B6:  CLRF   xF9
25B8:  INCFSZ xF9,W
25BA:  BRA    25BE
25BC:  BRA    2682
....................     flashData = 0; 
25BE:  CLRF   xF8
....................     output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25C0:  BCF    F94.3
25C2:  BSF    F8B.3
25C4:  BSF    F94.4
25C6:  MOVLW  00
25C8:  BTFSC  F82.4
25CA:  MOVLW  01
25CC:  ADDWF  xF8,F
25CE:  BCF    F94.3
25D0:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25D2:  BCF    F94.3
25D4:  BSF    F8B.3
25D6:  BCF    FD8.0
25D8:  RLCF   xF8,F
25DA:  BSF    F94.4
25DC:  MOVLW  00
25DE:  BTFSC  F82.4
25E0:  MOVLW  01
25E2:  ADDWF  xF8,F
25E4:  BCF    F94.3
25E6:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25E8:  BCF    F94.3
25EA:  BSF    F8B.3
25EC:  BCF    FD8.0
25EE:  RLCF   xF8,F
25F0:  BSF    F94.4
25F2:  MOVLW  00
25F4:  BTFSC  F82.4
25F6:  MOVLW  01
25F8:  ADDWF  xF8,F
25FA:  BCF    F94.3
25FC:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25FE:  BCF    F94.3
2600:  BSF    F8B.3
2602:  BCF    FD8.0
2604:  RLCF   xF8,F
2606:  BSF    F94.4
2608:  MOVLW  00
260A:  BTFSC  F82.4
260C:  MOVLW  01
260E:  ADDWF  xF8,F
2610:  BCF    F94.3
2612:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2614:  BCF    F94.3
2616:  BSF    F8B.3
2618:  BCF    FD8.0
261A:  RLCF   xF8,F
261C:  BSF    F94.4
261E:  MOVLW  00
2620:  BTFSC  F82.4
2622:  MOVLW  01
2624:  ADDWF  xF8,F
2626:  BCF    F94.3
2628:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
262A:  BCF    F94.3
262C:  BSF    F8B.3
262E:  BCF    FD8.0
2630:  RLCF   xF8,F
2632:  BSF    F94.4
2634:  MOVLW  00
2636:  BTFSC  F82.4
2638:  MOVLW  01
263A:  ADDWF  xF8,F
263C:  BCF    F94.3
263E:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2640:  BCF    F94.3
2642:  BSF    F8B.3
2644:  BCF    FD8.0
2646:  RLCF   xF8,F
2648:  BSF    F94.4
264A:  MOVLW  00
264C:  BTFSC  F82.4
264E:  MOVLW  01
2650:  ADDWF  xF8,F
2652:  BCF    F94.3
2654:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2656:  BCF    F94.3
2658:  BSF    F8B.3
265A:  BCF    FD8.0
265C:  RLCF   xF8,F
265E:  BSF    F94.4
2660:  MOVLW  00
2662:  BTFSC  F82.4
2664:  MOVLW  01
2666:  ADDWF  xF8,F
2668:  BCF    F94.3
266A:  BCF    F8B.3
....................     if (bit_test(flashData,7) == 1) break; // device is not busy 
266C:  BTFSS  xF8.7
266E:  BRA    2672
2670:  BRA    2682
.................... 	delay_cycles(50); 
2672:  MOVLW  10
2674:  MOVWF  00
2676:  DECFSZ 00,F
2678:  BRA    2676
267A:  NOP   
.................... 	restart_wdt(); 
267C:  CLRWDT
....................   } 
267E:  INCF   xF9,F
2680:  BRA    25B8
....................   output_high(FLASH_SELECT); 
2682:  BCF    F94.2
2684:  BSF    F8B.2
.................... } 
2686:  RETLW  00
....................  
.................... void ext_flash_block_erase() { 
....................    int i; 
....................    for(i=0;i<0xFF;i++) { 
*
2970:  CLRF   xCF
2972:  INCFSZ xCF,W
2974:  BRA    2978
2976:  BRA    29AA
....................    ext_flash_waitUntilReady(); 
2978:  RCALL  2552
....................    output_low(FLASH_SELECT); 
297A:  BCF    F94.2
297C:  BCF    F8B.2
....................    ext_flash_sendData(0x50, 8); 
297E:  MOVLW  50
2980:  MOVWF  xF8
2982:  MOVLW  08
2984:  MOVWF  xF9
2986:  RCALL  2688
....................    ext_flash_sendData(0, 4); 
2988:  CLRF   xF8
298A:  MOVLW  04
298C:  MOVWF  xF9
298E:  RCALL  2688
....................    ext_flash_sendData(i, 8); 
2990:  MOVFF  CF,F8
2994:  MOVLW  08
2996:  MOVWF  xF9
2998:  RCALL  2688
....................    ext_flash_sendData(0, 12); 
299A:  CLRF   xF8
299C:  MOVLW  0C
299E:  MOVWF  xF9
29A0:  RCALL  2688
....................    output_high(FLASH_SELECT); 
29A2:  BCF    F94.2
29A4:  BSF    F8B.2
....................    } 
29A6:  INCF   xCF,F
29A8:  BRA    2972
....................    ext_flash_waitUntilReady(); 
29AA:  RCALL  2552
.................... } 
29AC:  GOTO   35B2 (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_read() { 
....................    char data; 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2D70:  CALL   2552
....................    output_low(FLASH_SELECT); 
2D74:  BCF    F94.2
2D76:  BCF    F8B.2
....................    ext_flash_sendData(0xD1, 8); 
2D78:  MOVLW  D1
2D7A:  MOVWF  xF8
2D7C:  MOVLW  08
2D7E:  MOVWF  xF9
2D80:  RCALL  2688
....................    ext_flash_send16Data(0, 16); 
2D82:  CLRF   xF9
2D84:  CLRF   xF8
2D86:  MOVLW  10
2D88:  MOVWF  xFA
2D8A:  RCALL  26B8
....................    ext_flash_sendData(0, 8); 
2D8C:  CLRF   xF8
2D8E:  MOVLW  08
2D90:  MOVWF  xF9
2D92:  RCALL  2688
....................    i=255; 
2D94:  MOVLW  FF
2D96:  MOVWF  xD0
....................    do { 
.................... 	  ext_flash_getBytes(&data,1); 
2D98:  CLRF   xF9
2D9A:  MOVLW  CF
2D9C:  MOVWF  xF8
2D9E:  CLRF   xFB
2DA0:  MOVLW  01
2DA2:  MOVWF  xFA
2DA4:  RCALL  281A
.................... 	  i++; 
2DA6:  INCF   xD0,F
.................... 	  if (i%16==0) printf("\r\n %02X:", i); 
2DA8:  MOVF   xD0,W
2DAA:  ANDLW  0F
2DAC:  BNZ   2DD8
2DAE:  MOVLW  0D
2DB0:  BTFSS  F9E.4
2DB2:  BRA    2DB0
2DB4:  MOVWF  FAD
2DB6:  MOVLW  0A
2DB8:  BTFSS  F9E.4
2DBA:  BRA    2DB8
2DBC:  MOVWF  FAD
2DBE:  MOVLW  20
2DC0:  BTFSS  F9E.4
2DC2:  BRA    2DC0
2DC4:  MOVWF  FAD
2DC6:  MOVFF  D0,E7
2DCA:  MOVLW  37
2DCC:  MOVWF  xE8
2DCE:  RCALL  27D8
2DD0:  MOVLW  3A
2DD2:  BTFSS  F9E.4
2DD4:  BRA    2DD2
2DD6:  MOVWF  FAD
....................       printf("%02X ",data); 
2DD8:  MOVFF  CF,E7
2DDC:  MOVLW  37
2DDE:  MOVWF  xE8
2DE0:  RCALL  27D8
2DE2:  MOVLW  20
2DE4:  BTFSS  F9E.4
2DE6:  BRA    2DE4
2DE8:  MOVWF  FAD
....................  
....................    } while (i<255); 
2DEA:  INCFSZ xD0,W
2DEC:  BRA    2D98
....................    output_high(FLASH_SELECT);	 
2DEE:  BCF    F94.2
2DF0:  BSF    F8B.2
.................... } 
2DF2:  GOTO   3400 (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2F02:  CALL   2552
....................    output_low(FLASH_SELECT); 
2F06:  BCF    F94.2
2F08:  BCF    F8B.2
....................    ext_flash_sendData(0x84, 8); 
2F0A:  MOVLW  84
2F0C:  MOVWF  xF8
2F0E:  MOVLW  08
2F10:  MOVWF  xF9
2F12:  CALL   2688
....................    ext_flash_send16Data(0, 16); 
2F16:  CLRF   xF9
2F18:  CLRF   xF8
2F1A:  MOVLW  10
2F1C:  MOVWF  xFA
2F1E:  CALL   26B8
....................    ext_flash_sendData(PageIndex, 8); 
2F22:  MOVFF  DB,F8
2F26:  MOVLW  08
2F28:  MOVWF  xF9
2F2A:  CALL   2688
....................    if (nData>1) { 
2F2E:  MOVF   xDC,W
2F30:  SUBLW  01
2F32:  BC    2F4E
.................... 	i=255; 
2F34:  MOVLW  FF
2F36:  MOVWF  xDD
.................... 	do { 
.................... 	   ext_flash_sendData(data,8); 
2F38:  MOVFF  DA,F8
2F3C:  MOVLW  08
2F3E:  MOVWF  xF9
2F40:  CALL   2688
.................... 	   i++; 
2F44:  INCF   xDD,F
.................... 	} while(i<nData); 
2F46:  MOVF   xDC,W
2F48:  SUBWF  xDD,W
2F4A:  BNC   2F38
....................    } else 
2F4C:  BRA    2F5A
....................    		ext_flash_sendData(data,8); 
2F4E:  MOVFF  DA,F8
2F52:  MOVLW  08
2F54:  MOVWF  xF9
2F56:  CALL   2688
....................    output_high(FLASH_SELECT); 
2F5A:  BCF    F94.2
2F5C:  BSF    F8B.2
.................... } 
2F5E:  RETLW  00
....................  
.................... void ext_flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
3836:  CALL   2552
....................    output_low(FLASH_SELECT); 
383A:  BCF    F94.2
383C:  BCF    F8B.2
....................    ext_flash_sendData(0x83, 8); 
383E:  MOVLW  83
3840:  MOVWF  xF8
3842:  MOVLW  08
3844:  MOVWF  xF9
3846:  CALL   2688
....................    ext_flash_send16Data(pageAddress, 15); 
384A:  MOVFF  D6,F9
384E:  MOVFF  D5,F8
3852:  MOVLW  0F
3854:  MOVWF  xFA
3856:  CALL   26B8
....................    ext_flash_send16Data(0, 9); 
385A:  CLRF   xF9
385C:  CLRF   xF8
385E:  MOVLW  09
3860:  MOVWF  xFA
3862:  CALL   26B8
....................    output_high(FLASH_SELECT); 
3866:  BCF    F94.2
3868:  BSF    F8B.2
.................... } 
386A:  GOTO   3BFC (RETURN)
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD.lcd_nibble=n>>4; 
*
0994:  SWAPF  xF4,W
0996:  MOVWF  00
0998:  MOVLW  0F
099A:  ANDWF  00,F
099C:  MOVF   00,W
099E:  ANDLW  0F
09A0:  MOVWF  00
09A2:  MOVLW  F0
09A4:  ANDWF  F83,W
09A6:  IORWF  00,W
09A8:  MOVWF  F83
....................       delay_us(50); 
09AA:  MOVLW  29
09AC:  MOVWF  00
09AE:  DECFSZ 00,F
09B0:  BRA    09AE
09B2:  NOP   
....................       PORTD.disp_en=1; 
09B4:  BSF    F83.7
....................       delay_us(50); 
09B6:  MOVLW  29
09B8:  MOVWF  00
09BA:  DECFSZ 00,F
09BC:  BRA    09BA
09BE:  NOP   
....................       PORTD.disp_en=0; 
09C0:  BCF    F83.7
.................... 	  delay_us(50); 
09C2:  MOVLW  29
09C4:  MOVWF  00
09C6:  DECFSZ 00,F
09C8:  BRA    09C6
09CA:  NOP   
.................... } 
09CC:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
.................... 	PORTE.rs=rs; 
09CE:  BTFSS  xF0.0
09D0:  BCF    F84.0
09D2:  BTFSC  xF0.0
09D4:  BSF    F84.0
.................... 	lcd_send_nibble(dat&0xF0); 
09D6:  MOVF   xF1,W
09D8:  ANDLW  F0
09DA:  MOVWF  xF2
09DC:  MOVWF  xF4
09DE:  RCALL  0994
.................... 	lcd_send_nibble((dat<<4)&0xF0); 
09E0:  SWAPF  xF1,W
09E2:  MOVWF  00
09E4:  MOVLW  F0
09E6:  ANDWF  00,F
09E8:  MOVF   00,W
09EA:  ANDLW  F0
09EC:  MOVWF  xF3
09EE:  MOVWF  xF4
09F0:  RCALL  0994
.................... 	PORTE.rs=1; 
09F2:  BSF    F84.0
.................... } 
09F4:  RETLW  00
....................  
.................... void lcd_init() { 
.................... 	int8 i; 
....................     PORTE.rs = 0; 
09F6:  BCF    F84.0
....................     PORTD.disp_en=0; 
09F8:  BCF    F83.7
09FA:  CLRF   18
09FC:  BTFSC  FF2.7
09FE:  BSF    18.7
0A00:  BCF    FF2.7
.................... 	delay_ms(15); 
0A02:  MOVLW  0F
0A04:  MOVWF  xF1
0A06:  RCALL  04B4
0A08:  BTFSC  18.7
0A0A:  BSF    FF2.7
....................     for(i=1;i<=3;++i) { 
0A0C:  MOVLW  01
0A0E:  MOVWF  xD0
0A10:  MOVF   xD0,W
0A12:  SUBLW  03
0A14:  BNC   0A32
....................        lcd_send_nibble(0x30);  
0A16:  MOVLW  30
0A18:  MOVWF  xF4
0A1A:  RCALL  0994
0A1C:  CLRF   18
0A1E:  BTFSC  FF2.7
0A20:  BSF    18.7
0A22:  BCF    FF2.7
....................        delay_ms(15); 
0A24:  MOVLW  0F
0A26:  MOVWF  xF1
0A28:  RCALL  04B4
0A2A:  BTFSC  18.7
0A2C:  BSF    FF2.7
....................     } 
0A2E:  INCF   xD0,F
0A30:  BRA    0A10
....................     lcd_send_nibble(0x20);  
0A32:  MOVLW  20
0A34:  MOVWF  xF4
0A36:  RCALL  0994
0A38:  CLRF   18
0A3A:  BTFSC  FF2.7
0A3C:  BSF    18.7
0A3E:  BCF    FF2.7
....................     delay_ms(15); 
0A40:  MOVLW  0F
0A42:  MOVWF  xF1
0A44:  RCALL  04B4
0A46:  BTFSC  18.7
0A48:  BSF    FF2.7
....................     lcd_send_cmd(0,0x06); 
0A4A:  CLRF   xF0
0A4C:  MOVLW  06
0A4E:  MOVWF  xF1
0A50:  RCALL  09CE
....................     delay_us(50); 
0A52:  MOVLW  29
0A54:  MOVWF  00
0A56:  DECFSZ 00,F
0A58:  BRA    0A56
0A5A:  NOP   
....................     lcd_send_cmd(0,0x0c); 
0A5C:  CLRF   xF0
0A5E:  MOVLW  0C
0A60:  MOVWF  xF1
0A62:  RCALL  09CE
....................     delay_us(50); 
0A64:  MOVLW  29
0A66:  MOVWF  00
0A68:  DECFSZ 00,F
0A6A:  BRA    0A68
0A6C:  NOP   
....................     lcd_send_cmd(0,0x10); 
0A6E:  CLRF   xF0
0A70:  MOVLW  10
0A72:  MOVWF  xF1
0A74:  RCALL  09CE
....................     delay_us(50); 
0A76:  MOVLW  29
0A78:  MOVWF  00
0A7A:  DECFSZ 00,F
0A7C:  BRA    0A7A
0A7E:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
0A80:  CLRF   xF0
0A82:  MOVLW  2C
0A84:  MOVWF  xF1
0A86:  RCALL  09CE
....................     delay_us(50); 
0A88:  MOVLW  29
0A8A:  MOVWF  00
0A8C:  DECFSZ 00,F
0A8E:  BRA    0A8C
0A90:  NOP   
....................     lcd_send_cmd(0,0x01); 
0A92:  CLRF   xF0
0A94:  MOVLW  01
0A96:  MOVWF  xF1
0A98:  RCALL  09CE
....................     delay_us(50); 
0A9A:  MOVLW  29
0A9C:  MOVWF  00
0A9E:  DECFSZ 00,F
0AA0:  BRA    0A9E
0AA2:  NOP   
....................  
.................... } 
0AA4:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
0CBA:  MOVF   xED,W
0CBC:  ANDLW  03
0CBE:  CLRF   03
0CC0:  MOVFF  FF2,F0
0CC4:  BCF    FF2.7
0CC6:  CALL   00AA
0CCA:  BTFSC  xF0.7
0CCC:  BSF    FF2.7
0CCE:  MOVWF  xEE
....................    address+=x; 
0CD0:  MOVF   xEC,W
0CD2:  ADDWF  xEE,F
....................    lcd_send_cmd(0,0x80|address); 
0CD4:  MOVF   xEE,W
0CD6:  IORLW  80
0CD8:  MOVWF  xEF
0CDA:  CLRF   xF0
0CDC:  MOVWF  xF1
0CDE:  RCALL  09CE
.................... } 
0CE0:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0CE2:  MOVF   xEB,W
0CE4:  XORLW  0C
0CE6:  BZ    0CF2
0CE8:  XORLW  06
0CEA:  BZ    0D10
0CEC:  XORLW  02
0CEE:  BZ    0D1C
0CF0:  BRA    0D26
....................      case '\f'   : lcd_send_cmd(0,1); 
0CF2:  CLRF   xF0
0CF4:  MOVLW  01
0CF6:  MOVWF  xF1
0CF8:  RCALL  09CE
0CFA:  CLRF   18
0CFC:  BTFSC  FF2.7
0CFE:  BSF    18.7
0D00:  BCF    FF2.7
....................                    delay_ms(2); 
0D02:  MOVLW  02
0D04:  MOVWF  xF1
0D06:  CALL   04B4
0D0A:  BTFSC  18.7
0D0C:  BSF    FF2.7
....................                                            break; 
0D0E:  BRA    0D32
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0D10:  MOVLW  01
0D12:  MOVWF  xEC
0D14:  MOVLW  02
0D16:  MOVWF  xED
0D18:  RCALL  0CBA
0D1A:  BRA    0D32
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
0D1C:  CLRF   xF0
0D1E:  MOVLW  10
0D20:  MOVWF  xF1
0D22:  RCALL  09CE
0D24:  BRA    0D32
....................      default     : lcd_send_cmd(1,c);     break; 
0D26:  MOVLW  01
0D28:  MOVWF  xF0
0D2A:  MOVFF  EB,F1
0D2E:  RCALL  09CE
0D30:  BRA    0D32
....................    } 
.................... } 
0D32:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
.................... 	int8 i; 
.................... 	for(i=0;i<size;i++)	lcd_putc(c[i]); 
*
173A:  CLRF   xE6
173C:  MOVF   xE5,W
173E:  SUBWF  xE6,W
1740:  BC    1760
1742:  CLRF   03
1744:  MOVF   xE6,W
1746:  ADDWF  xE3,W
1748:  MOVWF  FE9
174A:  MOVF   xE4,W
174C:  ADDWFC 03,W
174E:  MOVWF  FEA
1750:  MOVFF  FEF,E7
1754:  MOVFF  E7,EB
1758:  CALL   0CE2
175C:  INCF   xE6,F
175E:  BRA    173C
.................... } 
1760:  RETLW  00
.................... 	 
....................  
.................... void print_date_time() { 
....................  
.................... 		JDN = (unsigned int32)((float) (Y2010_JDN*1.0+ 0.5+ (float)(UTC*1.0)/24.0 + (timer_sec)*1.0/86400.0)); 
1762:  MOVFF  23,E5
1766:  MOVFF  22,E4
176A:  MOVFF  21,E3
176E:  MOVFF  20,E2
1772:  GOTO   0E8A
1776:  MOVFF  03,14F
177A:  MOVFF  02,14E
177E:  MOVFF  01,14D
1782:  MOVFF  00,14C
1786:  MOVLB  1
1788:  CLRF   x53
178A:  CLRF   x52
178C:  CLRF   x51
178E:  MOVLW  7F
1790:  MOVWF  x50
1792:  MOVLB  0
1794:  CALL   0EC0
1798:  MOVFF  00,E2
179C:  MOVFF  01,E3
17A0:  MOVFF  02,E4
17A4:  MOVFF  03,E5
17A8:  MOVFF  03,14B
17AC:  MOVFF  02,14A
17B0:  MOVFF  01,149
17B4:  MOVFF  00,148
17B8:  MOVLB  1
17BA:  CLRF   x4F
17BC:  MOVLW  C0
17BE:  MOVWF  x4E
17C0:  MOVLW  28
17C2:  MOVWF  x4D
17C4:  MOVLW  8F
17C6:  MOVWF  x4C
17C8:  MOVLB  0
17CA:  CALL   0FB6
17CE:  BCF    FD8.1
17D0:  MOVLW  79
17D2:  MOVLB  1
17D4:  MOVWF  x51
17D6:  MOVLW  DA
17D8:  MOVWF  x50
17DA:  MOVLW  15
17DC:  MOVWF  x4F
17DE:  MOVLW  94
17E0:  MOVWF  x4E
17E2:  MOVFF  03,155
17E6:  MOVFF  02,154
17EA:  MOVFF  01,153
17EE:  MOVFF  00,152
17F2:  MOVLB  0
17F4:  RCALL  1114
17F6:  MOVFF  03,E9
17FA:  MOVFF  02,E8
17FE:  MOVFF  01,E7
1802:  MOVFF  00,E6
1806:  BRA    138C
1808:  MOVFF  03,75
180C:  MOVFF  02,74
1810:  MOVFF  01,73
1814:  MOVFF  00,72
.................... 		jj = JDN +32044; 
1818:  MOVLW  2C
181A:  ADDWF  x72,W
181C:  MOVWF  x76
181E:  MOVLW  7D
1820:  ADDWFC x73,W
1822:  MOVWF  x77
1824:  MOVLW  00
1826:  ADDWFC x74,W
1828:  MOVWF  x78
182A:  MOVLW  00
182C:  ADDWFC x75,W
182E:  MOVWF  x79
1830:  CLRF   18
1832:  BTFSC  FF2.7
1834:  BSF    18.7
1836:  BCF    FF2.7
.................... 		g=jj/146097; 
1838:  MOVFF  79,F2
183C:  MOVFF  78,F1
1840:  MOVFF  77,F0
1844:  MOVFF  76,EF
1848:  CLRF   xF6
184A:  MOVLW  02
184C:  MOVWF  xF5
184E:  MOVLW  3A
1850:  MOVWF  xF4
1852:  MOVLW  B1
1854:  MOVWF  xF3
1856:  CALL   0338
185A:  BTFSC  18.7
185C:  BSF    FF2.7
185E:  MOVFF  03,7D
1862:  MOVFF  02,7C
1866:  MOVFF  01,7B
186A:  MOVFF  00,7A
186E:  CLRF   18
1870:  BTFSC  FF2.7
1872:  BSF    18.7
1874:  BCF    FF2.7
.................... 		dg=jj%146097; 
1876:  MOVFF  79,F2
187A:  MOVFF  78,F1
187E:  MOVFF  77,F0
1882:  MOVFF  76,EF
1886:  CLRF   xF6
1888:  MOVLW  02
188A:  MOVWF  xF5
188C:  MOVLW  3A
188E:  MOVWF  xF4
1890:  MOVLW  B1
1892:  MOVWF  xF3
1894:  CALL   0338
1898:  BTFSC  18.7
189A:  BSF    FF2.7
189C:  MOVFF  FEF,7E
18A0:  MOVFF  FEC,7F
18A4:  MOVFF  FEC,80
18A8:  MOVFF  FEC,81
18AC:  CLRF   18
18AE:  BTFSC  FF2.7
18B0:  BSF    18.7
18B2:  BCF    FF2.7
.................... 		c=(dg/36524+1)*3/4; 
18B4:  MOVFF  81,F2
18B8:  MOVFF  80,F1
18BC:  MOVFF  7F,F0
18C0:  MOVFF  7E,EF
18C4:  CLRF   xF6
18C6:  CLRF   xF5
18C8:  MOVLW  8E
18CA:  MOVWF  xF4
18CC:  MOVLW  AC
18CE:  MOVWF  xF3
18D0:  CALL   0338
18D4:  BTFSC  18.7
18D6:  BSF    FF2.7
18D8:  MOVFF  03,E5
18DC:  MOVFF  02,E4
18E0:  MOVFF  01,E3
18E4:  MOVFF  00,E2
18E8:  MOVLW  01
18EA:  ADDWF  00,W
18EC:  MOVWF  xE6
18EE:  MOVLW  00
18F0:  ADDWFC 01,W
18F2:  MOVWF  xE7
18F4:  MOVLW  00
18F6:  ADDWFC 02,W
18F8:  MOVWF  xE8
18FA:  MOVLW  00
18FC:  ADDWFC 03,W
18FE:  MOVWF  xE9
1900:  MOVWF  xFA
1902:  MOVFF  E8,F9
1906:  MOVFF  E7,F8
190A:  MOVFF  E6,F7
190E:  CLRF   xFE
1910:  CLRF   xFD
1912:  CLRF   xFC
1914:  MOVLW  03
1916:  MOVWF  xFB
1918:  RCALL  13CC
191A:  RRCF   03,W
191C:  MOVWF  x85
191E:  RRCF   02,W
1920:  MOVWF  x84
1922:  RRCF   01,W
1924:  MOVWF  x83
1926:  RRCF   00,W
1928:  MOVWF  x82
192A:  RRCF   x85,F
192C:  RRCF   x84,F
192E:  RRCF   x83,F
1930:  RRCF   x82,F
1932:  MOVLW  3F
1934:  ANDWF  x85,F
.................... 		dc=dg-c*36524; 
1936:  MOVFF  85,FA
193A:  MOVFF  84,F9
193E:  MOVFF  83,F8
1942:  MOVFF  82,F7
1946:  CLRF   xFE
1948:  CLRF   xFD
194A:  MOVLW  8E
194C:  MOVWF  xFC
194E:  MOVLW  AC
1950:  MOVWF  xFB
1952:  RCALL  13CC
1954:  MOVF   00,W
1956:  SUBWF  x7E,W
1958:  MOVWF  x86
195A:  MOVF   01,W
195C:  SUBWFB x7F,W
195E:  MOVWF  x87
1960:  MOVF   02,W
1962:  SUBWFB x80,W
1964:  MOVWF  x88
1966:  MOVF   03,W
1968:  SUBWFB x81,W
196A:  MOVWF  x89
196C:  CLRF   18
196E:  BTFSC  FF2.7
1970:  BSF    18.7
1972:  BCF    FF2.7
.................... 		b=dc/1461; 
1974:  MOVFF  89,F2
1978:  MOVFF  88,F1
197C:  MOVFF  87,F0
1980:  MOVFF  86,EF
1984:  CLRF   xF6
1986:  CLRF   xF5
1988:  MOVLW  05
198A:  MOVWF  xF4
198C:  MOVLW  B5
198E:  MOVWF  xF3
1990:  CALL   0338
1994:  BTFSC  18.7
1996:  BSF    FF2.7
1998:  MOVFF  03,8D
199C:  MOVFF  02,8C
19A0:  MOVFF  01,8B
19A4:  MOVFF  00,8A
19A8:  CLRF   18
19AA:  BTFSC  FF2.7
19AC:  BSF    18.7
19AE:  BCF    FF2.7
.................... 		db=dc%1461; 
19B0:  MOVFF  89,F2
19B4:  MOVFF  88,F1
19B8:  MOVFF  87,F0
19BC:  MOVFF  86,EF
19C0:  CLRF   xF6
19C2:  CLRF   xF5
19C4:  MOVLW  05
19C6:  MOVWF  xF4
19C8:  MOVLW  B5
19CA:  MOVWF  xF3
19CC:  CALL   0338
19D0:  BTFSC  18.7
19D2:  BSF    FF2.7
19D4:  MOVFF  FEF,8E
19D8:  MOVFF  FEC,8F
19DC:  MOVFF  FEC,90
19E0:  MOVFF  FEC,91
19E4:  CLRF   18
19E6:  BTFSC  FF2.7
19E8:  BSF    18.7
19EA:  BCF    FF2.7
.................... 		a=(db/365+1)*3/4; 
19EC:  MOVFF  91,F2
19F0:  MOVFF  90,F1
19F4:  MOVFF  8F,F0
19F8:  MOVFF  8E,EF
19FC:  CLRF   xF6
19FE:  CLRF   xF5
1A00:  MOVLW  01
1A02:  MOVWF  xF4
1A04:  MOVLW  6D
1A06:  MOVWF  xF3
1A08:  CALL   0338
1A0C:  BTFSC  18.7
1A0E:  BSF    FF2.7
1A10:  MOVFF  03,E5
1A14:  MOVFF  02,E4
1A18:  MOVFF  01,E3
1A1C:  MOVFF  00,E2
1A20:  MOVLW  01
1A22:  ADDWF  00,W
1A24:  MOVWF  xE6
1A26:  MOVLW  00
1A28:  ADDWFC 01,W
1A2A:  MOVWF  xE7
1A2C:  MOVLW  00
1A2E:  ADDWFC 02,W
1A30:  MOVWF  xE8
1A32:  MOVLW  00
1A34:  ADDWFC 03,W
1A36:  MOVWF  xE9
1A38:  MOVWF  xFA
1A3A:  MOVFF  E8,F9
1A3E:  MOVFF  E7,F8
1A42:  MOVFF  E6,F7
1A46:  CLRF   xFE
1A48:  CLRF   xFD
1A4A:  CLRF   xFC
1A4C:  MOVLW  03
1A4E:  MOVWF  xFB
1A50:  RCALL  13CC
1A52:  RRCF   03,W
1A54:  MOVWF  x95
1A56:  RRCF   02,W
1A58:  MOVWF  x94
1A5A:  RRCF   01,W
1A5C:  MOVWF  x93
1A5E:  RRCF   00,W
1A60:  MOVWF  x92
1A62:  RRCF   x95,F
1A64:  RRCF   x94,F
1A66:  RRCF   x93,F
1A68:  RRCF   x92,F
1A6A:  MOVLW  3F
1A6C:  ANDWF  x95,F
.................... 		da=db-a*365; 
1A6E:  MOVFF  95,FA
1A72:  MOVFF  94,F9
1A76:  MOVFF  93,F8
1A7A:  MOVFF  92,F7
1A7E:  CLRF   xFE
1A80:  CLRF   xFD
1A82:  MOVLW  01
1A84:  MOVWF  xFC
1A86:  MOVLW  6D
1A88:  MOVWF  xFB
1A8A:  RCALL  13CC
1A8C:  MOVF   00,W
1A8E:  SUBWF  x8E,W
1A90:  MOVWF  x96
1A92:  MOVF   01,W
1A94:  SUBWFB x8F,W
1A96:  MOVWF  x97
1A98:  MOVF   02,W
1A9A:  SUBWFB x90,W
1A9C:  MOVWF  x98
1A9E:  MOVF   03,W
1AA0:  SUBWFB x91,W
1AA2:  MOVWF  x99
.................... 		y=g*400+c*100+b*4+a; 
1AA4:  MOVFF  7D,FA
1AA8:  MOVFF  7C,F9
1AAC:  MOVFF  7B,F8
1AB0:  MOVFF  7A,F7
1AB4:  CLRF   xFE
1AB6:  CLRF   xFD
1AB8:  MOVLW  01
1ABA:  MOVWF  xFC
1ABC:  MOVLW  90
1ABE:  MOVWF  xFB
1AC0:  RCALL  13CC
1AC2:  MOVFF  03,E5
1AC6:  MOVFF  02,E4
1ACA:  MOVFF  01,E3
1ACE:  MOVFF  00,E2
1AD2:  MOVFF  85,FA
1AD6:  MOVFF  84,F9
1ADA:  MOVFF  83,F8
1ADE:  MOVFF  82,F7
1AE2:  CLRF   xFE
1AE4:  CLRF   xFD
1AE6:  CLRF   xFC
1AE8:  MOVLW  64
1AEA:  MOVWF  xFB
1AEC:  RCALL  13CC
1AEE:  MOVF   00,W
1AF0:  ADDWF  xE2,W
1AF2:  MOVWF  xE6
1AF4:  MOVF   01,W
1AF6:  ADDWFC xE3,W
1AF8:  MOVWF  xE7
1AFA:  MOVF   02,W
1AFC:  ADDWFC xE4,W
1AFE:  MOVWF  xE8
1B00:  MOVF   03,W
1B02:  ADDWFC xE5,W
1B04:  MOVWF  xE9
1B06:  RLCF   x8A,W
1B08:  MOVWF  00
1B0A:  RLCF   x8B,W
1B0C:  MOVWF  01
1B0E:  RLCF   x8C,W
1B10:  MOVWF  02
1B12:  RLCF   x8D,W
1B14:  MOVWF  03
1B16:  RLCF   00,F
1B18:  RLCF   01,F
1B1A:  RLCF   02,F
1B1C:  RLCF   03,F
1B1E:  MOVLW  FC
1B20:  ANDWF  00,F
1B22:  MOVF   00,W
1B24:  ADDWF  xE6,W
1B26:  MOVWF  xEA
1B28:  MOVF   01,W
1B2A:  ADDWFC xE7,W
1B2C:  MOVWF  xEB
1B2E:  MOVF   02,W
1B30:  ADDWFC xE8,W
1B32:  MOVWF  xEC
1B34:  MOVF   03,W
1B36:  ADDWFC xE9,W
1B38:  MOVWF  xED
1B3A:  MOVF   x92,W
1B3C:  ADDWF  xEA,W
1B3E:  MOVWF  x9A
1B40:  MOVF   x93,W
1B42:  ADDWFC xEB,W
1B44:  MOVWF  x9B
1B46:  MOVF   x94,W
1B48:  ADDWFC xEC,W
1B4A:  MOVWF  x9C
1B4C:  MOVF   x95,W
1B4E:  ADDWFC xED,W
1B50:  MOVWF  x9D
.................... 		m=(da*5+308)/153-2; 
1B52:  MOVFF  99,FA
1B56:  MOVFF  98,F9
1B5A:  MOVFF  97,F8
1B5E:  MOVFF  96,F7
1B62:  CLRF   xFE
1B64:  CLRF   xFD
1B66:  CLRF   xFC
1B68:  MOVLW  05
1B6A:  MOVWF  xFB
1B6C:  RCALL  13CC
1B6E:  MOVFF  03,E5
1B72:  MOVFF  02,E4
1B76:  MOVFF  01,E3
1B7A:  MOVFF  00,E2
1B7E:  MOVLW  34
1B80:  ADDWF  00,W
1B82:  MOVWF  xE6
1B84:  MOVLW  01
1B86:  ADDWFC 01,W
1B88:  MOVWF  xE7
1B8A:  MOVLW  00
1B8C:  ADDWFC 02,W
1B8E:  MOVWF  xE8
1B90:  MOVLW  00
1B92:  ADDWFC 03,W
1B94:  MOVWF  xE9
1B96:  CLRF   18
1B98:  BTFSC  FF2.7
1B9A:  BSF    18.7
1B9C:  BCF    FF2.7
1B9E:  MOVWF  xF2
1BA0:  MOVFF  E8,F1
1BA4:  MOVFF  E7,F0
1BA8:  MOVFF  E6,EF
1BAC:  CLRF   xF6
1BAE:  CLRF   xF5
1BB0:  CLRF   xF4
1BB2:  MOVLW  99
1BB4:  MOVWF  xF3
1BB6:  CALL   0338
1BBA:  BTFSC  18.7
1BBC:  BSF    FF2.7
1BBE:  MOVLW  02
1BC0:  SUBWF  00,W
1BC2:  MOVWF  x9E
1BC4:  MOVLW  00
1BC6:  SUBWFB 01,W
1BC8:  MOVWF  x9F
1BCA:  MOVLW  00
1BCC:  SUBWFB 02,W
1BCE:  MOVWF  xA0
1BD0:  MOVLW  00
1BD2:  SUBWFB 03,W
1BD4:  MOVWF  xA1
.................... 		d=da-(m+4)*153/5+122; 
1BD6:  MOVLW  04
1BD8:  ADDWF  x9E,W
1BDA:  MOVWF  xE2
1BDC:  MOVLW  00
1BDE:  ADDWFC x9F,W
1BE0:  MOVWF  xE3
1BE2:  MOVLW  00
1BE4:  ADDWFC xA0,W
1BE6:  MOVWF  xE4
1BE8:  MOVLW  00
1BEA:  ADDWFC xA1,W
1BEC:  MOVWF  xE5
1BEE:  MOVWF  xFA
1BF0:  MOVFF  E4,F9
1BF4:  MOVFF  E3,F8
1BF8:  MOVFF  E2,F7
1BFC:  CLRF   xFE
1BFE:  CLRF   xFD
1C00:  CLRF   xFC
1C02:  MOVLW  99
1C04:  MOVWF  xFB
1C06:  CALL   13CC
1C0A:  MOVFF  03,E6
1C0E:  MOVFF  02,E5
1C12:  MOVFF  01,E4
1C16:  MOVFF  00,E3
1C1A:  CLRF   18
1C1C:  BTFSC  FF2.7
1C1E:  BSF    18.7
1C20:  BCF    FF2.7
1C22:  MOVFF  03,F2
1C26:  MOVFF  02,F1
1C2A:  MOVFF  01,F0
1C2E:  MOVFF  00,EF
1C32:  CLRF   xF6
1C34:  CLRF   xF5
1C36:  CLRF   xF4
1C38:  MOVLW  05
1C3A:  MOVWF  xF3
1C3C:  CALL   0338
1C40:  BTFSC  18.7
1C42:  BSF    FF2.7
1C44:  MOVF   00,W
1C46:  SUBWF  x96,W
1C48:  MOVWF  xE4
1C4A:  MOVF   01,W
1C4C:  SUBWFB x97,W
1C4E:  MOVWF  xE5
1C50:  MOVF   02,W
1C52:  SUBWFB x98,W
1C54:  MOVWF  xE6
1C56:  MOVF   03,W
1C58:  SUBWFB x99,W
1C5A:  MOVWF  xE7
1C5C:  MOVLW  7A
1C5E:  ADDWF  xE4,W
1C60:  MOVWF  xA2
1C62:  MOVLW  00
1C64:  ADDWFC xE5,W
1C66:  MOVWF  xA3
1C68:  MOVLW  00
1C6A:  ADDWFC xE6,W
1C6C:  MOVWF  xA4
1C6E:  MOVLW  00
1C70:  ADDWFC xE7,W
1C72:  MOVWF  xA5
.................... 		YY=y-4800+(m+2)/12; 
1C74:  MOVLW  C0
1C76:  SUBWF  x9A,W
1C78:  MOVWF  xE2
1C7A:  MOVLW  12
1C7C:  SUBWFB x9B,W
1C7E:  MOVWF  xE3
1C80:  MOVLW  00
1C82:  SUBWFB x9C,W
1C84:  MOVWF  xE4
1C86:  MOVLW  00
1C88:  SUBWFB x9D,W
1C8A:  MOVWF  xE5
1C8C:  MOVLW  02
1C8E:  ADDWF  x9E,W
1C90:  MOVWF  xE6
1C92:  MOVLW  00
1C94:  ADDWFC x9F,W
1C96:  MOVWF  xE7
1C98:  MOVLW  00
1C9A:  ADDWFC xA0,W
1C9C:  MOVWF  xE8
1C9E:  MOVLW  00
1CA0:  ADDWFC xA1,W
1CA2:  MOVWF  xE9
1CA4:  CLRF   18
1CA6:  BTFSC  FF2.7
1CA8:  BSF    18.7
1CAA:  BCF    FF2.7
1CAC:  MOVWF  xF2
1CAE:  MOVFF  E8,F1
1CB2:  MOVFF  E7,F0
1CB6:  MOVFF  E6,EF
1CBA:  CLRF   xF6
1CBC:  CLRF   xF5
1CBE:  CLRF   xF4
1CC0:  MOVLW  0C
1CC2:  MOVWF  xF3
1CC4:  CALL   0338
1CC8:  BTFSC  18.7
1CCA:  BSF    FF2.7
1CCC:  MOVF   00,W
1CCE:  ADDWF  xE2,W
1CD0:  MOVWF  xA6
1CD2:  MOVF   01,W
1CD4:  ADDWFC xE3,W
1CD6:  MOVWF  xA7
1CD8:  MOVF   02,W
1CDA:  ADDWFC xE4,W
1CDC:  MOVWF  xA8
1CDE:  MOVF   03,W
1CE0:  ADDWFC xE5,W
1CE2:  MOVWF  xA9
.................... 		MM=(m+2)%12+1; 
1CE4:  MOVLW  02
1CE6:  ADDWF  x9E,W
1CE8:  MOVWF  xE2
1CEA:  MOVLW  00
1CEC:  ADDWFC x9F,W
1CEE:  MOVWF  xE3
1CF0:  MOVLW  00
1CF2:  ADDWFC xA0,W
1CF4:  MOVWF  xE4
1CF6:  MOVLW  00
1CF8:  ADDWFC xA1,W
1CFA:  MOVWF  xE5
1CFC:  CLRF   18
1CFE:  BTFSC  FF2.7
1D00:  BSF    18.7
1D02:  BCF    FF2.7
1D04:  MOVWF  xF2
1D06:  MOVFF  E4,F1
1D0A:  MOVFF  E3,F0
1D0E:  MOVFF  E2,EF
1D12:  CLRF   xF6
1D14:  CLRF   xF5
1D16:  CLRF   xF4
1D18:  MOVLW  0C
1D1A:  MOVWF  xF3
1D1C:  CALL   0338
1D20:  BTFSC  18.7
1D22:  BSF    FF2.7
1D24:  MOVFF  FEF,E3
1D28:  MOVFF  FEC,E4
1D2C:  MOVFF  FEC,E5
1D30:  MOVFF  FEC,E6
1D34:  MOVLW  01
1D36:  ADDWF  xE3,W
1D38:  MOVWF  xAA
1D3A:  MOVLW  00
1D3C:  ADDWFC xE4,W
1D3E:  MOVWF  xAB
1D40:  MOVLW  00
1D42:  ADDWFC xE5,W
1D44:  MOVWF  xAC
1D46:  MOVLW  00
1D48:  ADDWFC xE6,W
1D4A:  MOVWF  xAD
.................... 		DD=d+1; 
1D4C:  MOVLW  01
1D4E:  ADDWF  xA2,W
1D50:  MOVWF  xAE
1D52:  MOVLW  00
1D54:  ADDWFC xA3,W
1D56:  MOVWF  xAF
1D58:  MOVLW  00
1D5A:  ADDWFC xA4,W
1D5C:  MOVWF  xB0
1D5E:  MOVLW  00
1D60:  ADDWFC xA5,W
1D62:  MOVWF  xB1
.................... 		time_of_day = (timer_sec+((int8)UTC)*3600)%86400; 
1D64:  MOVLW  70
1D66:  ADDWF  20,W
1D68:  MOVWF  xE2
1D6A:  MOVLW  62
1D6C:  ADDWFC 21,W
1D6E:  MOVWF  xE3
1D70:  MOVLW  00
1D72:  ADDWFC 22,W
1D74:  MOVWF  xE4
1D76:  MOVLW  00
1D78:  ADDWFC 23,W
1D7A:  MOVWF  xE5
1D7C:  CLRF   18
1D7E:  BTFSC  FF2.7
1D80:  BSF    18.7
1D82:  BCF    FF2.7
1D84:  MOVWF  xF2
1D86:  MOVFF  E4,F1
1D8A:  MOVFF  E3,F0
1D8E:  MOVFF  E2,EF
1D92:  CLRF   xF6
1D94:  MOVLW  01
1D96:  MOVWF  xF5
1D98:  MOVLW  51
1D9A:  MOVWF  xF4
1D9C:  MOVLW  80
1D9E:  MOVWF  xF3
1DA0:  CALL   0338
1DA4:  BTFSC  18.7
1DA6:  BSF    FF2.7
1DA8:  MOVFF  FEF,B2
1DAC:  MOVFF  FEC,B3
1DB0:  MOVFF  FEC,B4
1DB4:  MOVFF  FEC,B5
....................  
.................... 		strcpy(tmp_str,"00/00/00"); 
1DB8:  CLRF   FEA
1DBA:  MOVLW  2C
1DBC:  MOVWF  FE9
1DBE:  MOVFF  FF2,E2
1DC2:  BCF    FF2.7
1DC4:  MOVLW  00
1DC6:  CALL   00C8
1DCA:  TBLRD*-
1DCC:  TBLRD*+
1DCE:  MOVF   FF5,W
1DD0:  MOVWF  FEE
1DD2:  IORLW  00
1DD4:  BNZ   1DCC
1DD6:  BTFSC  xE2.7
1DD8:  BSF    FF2.7
.................... 		itoa((int8)DD,10,tmp_str2); 
1DDA:  CLRF   xEB
1DDC:  CLRF   xEA
1DDE:  CLRF   xE9
1DE0:  MOVFF  AE,E8
1DE4:  MOVLW  0A
1DE6:  MOVWF  xEC
1DE8:  CLRF   xEE
1DEA:  MOVLW  40
1DEC:  MOVWF  xED
1DEE:  CALL   152C
.................... 		if (strlen(tmp_str2)==1) tmp_str[1]=tmp_str2[0]; else memcpy(tmp_str,tmp_str2,2); 
1DF2:  CLRF   xE5
1DF4:  MOVLW  40
1DF6:  MOVWF  xE4
1DF8:  RCALL  1708
1DFA:  DECFSZ 01,W
1DFC:  BRA    1E04
1DFE:  MOVFF  40,2D
1E02:  BRA    1E1C
1E04:  CLRF   FEA
1E06:  MOVLW  2C
1E08:  MOVWF  FE9
1E0A:  CLRF   FE2
1E0C:  MOVLW  40
1E0E:  MOVWF  FE1
1E10:  MOVLW  02
1E12:  MOVWF  01
1E14:  MOVFF  FE6,FEE
1E18:  DECFSZ 01,F
1E1A:  BRA    1E14
.................... 		itoa((int8)MM,10,tmp_str2); 
1E1C:  CLRF   xEB
1E1E:  CLRF   xEA
1E20:  CLRF   xE9
1E22:  MOVFF  AA,E8
1E26:  MOVLW  0A
1E28:  MOVWF  xEC
1E2A:  CLRF   xEE
1E2C:  MOVLW  40
1E2E:  MOVWF  xED
1E30:  CALL   152C
.................... 		if (strlen(tmp_str2)==1) tmp_str[4]=tmp_str2[0]; else memcpy(tmp_str+3,tmp_str2,2); 
1E34:  CLRF   xE5
1E36:  MOVLW  40
1E38:  MOVWF  xE4
1E3A:  RCALL  1708
1E3C:  DECFSZ 01,W
1E3E:  BRA    1E46
1E40:  MOVFF  40,30
1E44:  BRA    1E5E
1E46:  CLRF   FEA
1E48:  MOVLW  2F
1E4A:  MOVWF  FE9
1E4C:  CLRF   FE2
1E4E:  MOVLW  40
1E50:  MOVWF  FE1
1E52:  MOVLW  02
1E54:  MOVWF  01
1E56:  MOVFF  FE6,FEE
1E5A:  DECFSZ 01,F
1E5C:  BRA    1E56
1E5E:  CLRF   18
1E60:  BTFSC  FF2.7
1E62:  BSF    18.7
1E64:  BCF    FF2.7
.................... 		itoa((int8)(YY%2000),10,tmp_str2); 
1E66:  MOVFF  A9,F2
1E6A:  MOVFF  A8,F1
1E6E:  MOVFF  A7,F0
1E72:  MOVFF  A6,EF
1E76:  CLRF   xF6
1E78:  CLRF   xF5
1E7A:  MOVLW  07
1E7C:  MOVWF  xF4
1E7E:  MOVLW  D0
1E80:  MOVWF  xF3
1E82:  CALL   0338
1E86:  BTFSC  18.7
1E88:  BSF    FF2.7
1E8A:  MOVFF  FEF,00
1E8E:  MOVFF  FEC,01
1E92:  MOVFF  FEC,02
1E96:  MOVFF  FEC,03
1E9A:  MOVFF  00,E2
1E9E:  CLRF   xEB
1EA0:  CLRF   xEA
1EA2:  CLRF   xE9
1EA4:  MOVFF  00,E8
1EA8:  MOVLW  0A
1EAA:  MOVWF  xEC
1EAC:  CLRF   xEE
1EAE:  MOVLW  40
1EB0:  MOVWF  xED
1EB2:  CALL   152C
.................... 		if (strlen(tmp_str2)==1) tmp_str[7]=tmp_str2[0]; else memcpy(tmp_str+6,tmp_str2,2); 
1EB6:  CLRF   xE5
1EB8:  MOVLW  40
1EBA:  MOVWF  xE4
1EBC:  RCALL  1708
1EBE:  DECFSZ 01,W
1EC0:  BRA    1EC8
1EC2:  MOVFF  40,33
1EC6:  BRA    1EE0
1EC8:  CLRF   FEA
1ECA:  MOVLW  32
1ECC:  MOVWF  FE9
1ECE:  CLRF   FE2
1ED0:  MOVLW  40
1ED2:  MOVWF  FE1
1ED4:  MOVLW  02
1ED6:  MOVWF  01
1ED8:  MOVFF  FE6,FEE
1EDC:  DECFSZ 01,F
1EDE:  BRA    1ED8
.................... 		lcd_gotoxy(0,0); 
1EE0:  CLRF   xEC
1EE2:  CLRF   xED
1EE4:  CALL   0CBA
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
1EE8:  CLRF   xE5
1EEA:  MOVLW  2C
1EEC:  MOVWF  xE4
1EEE:  RCALL  1708
1EF0:  MOVFF  01,E2
1EF4:  CLRF   xE4
1EF6:  MOVLW  2C
1EF8:  MOVWF  xE3
1EFA:  MOVFF  01,E5
1EFE:  RCALL  173A
.................... 		strcpy(tmp_str,"00:00:00"); 
1F00:  CLRF   FEA
1F02:  MOVLW  2C
1F04:  MOVWF  FE9
1F06:  MOVFF  FF2,E2
1F0A:  BCF    FF2.7
1F0C:  MOVLW  00
1F0E:  CALL   00EC
1F12:  TBLRD*-
1F14:  TBLRD*+
1F16:  MOVF   FF5,W
1F18:  MOVWF  FEE
1F1A:  IORLW  00
1F1C:  BNZ   1F14
1F1E:  BTFSC  xE2.7
1F20:  BSF    FF2.7
1F22:  CLRF   18
1F24:  BTFSC  FF2.7
1F26:  BSF    18.7
1F28:  BCF    FF2.7
.................... 		itoa((int8) (time_of_day/3600),10,tmp_str2); 
1F2A:  MOVFF  B5,F2
1F2E:  MOVFF  B4,F1
1F32:  MOVFF  B3,F0
1F36:  MOVFF  B2,EF
1F3A:  CLRF   xF6
1F3C:  CLRF   xF5
1F3E:  MOVLW  0E
1F40:  MOVWF  xF4
1F42:  MOVLW  10
1F44:  MOVWF  xF3
1F46:  CALL   0338
1F4A:  BTFSC  18.7
1F4C:  BSF    FF2.7
1F4E:  MOVFF  00,E2
1F52:  CLRF   xEB
1F54:  CLRF   xEA
1F56:  CLRF   xE9
1F58:  MOVFF  00,E8
1F5C:  MOVLW  0A
1F5E:  MOVWF  xEC
1F60:  CLRF   xEE
1F62:  MOVLW  40
1F64:  MOVWF  xED
1F66:  CALL   152C
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1F6A:  CLRF   xE5
1F6C:  MOVLW  40
1F6E:  MOVWF  xE4
1F70:  CALL   1708
1F74:  MOVF   01,W
1F76:  SUBLW  02
1F78:  BNC   1FBE
1F7A:  CLRF   xE5
1F7C:  MOVLW  40
1F7E:  MOVWF  xE4
1F80:  CALL   1708
1F84:  MOVLW  2E
1F86:  BSF    FD8.0
1F88:  SUBFWB 01,W
1F8A:  MOVWF  xE2
1F8C:  MOVLW  00
1F8E:  BTFSS  FD8.0
1F90:  DECF   FE8,F
1F92:  MOVWF  xE3
1F94:  CLRF   xE5
1F96:  MOVLW  40
1F98:  MOVWF  xE4
1F9A:  CALL   1708
1F9E:  MOVFF  01,E4
1FA2:  MOVFF  E3,FEA
1FA6:  MOVFF  E2,FE9
1FAA:  CLRF   FE2
1FAC:  MOVLW  40
1FAE:  MOVWF  FE1
1FB0:  MOVF   01,W
1FB2:  MOVWF  01
1FB4:  BZ    1FBE
1FB6:  MOVFF  FE6,FEE
1FBA:  DECFSZ 01,F
1FBC:  BRA    1FB6
1FBE:  CLRF   18
1FC0:  BTFSC  FF2.7
1FC2:  BSF    18.7
1FC4:  BCF    FF2.7
.................... 		itoa((int8) ((time_of_day%3600)/60),10,tmp_str2); 
1FC6:  MOVFF  B5,F2
1FCA:  MOVFF  B4,F1
1FCE:  MOVFF  B3,F0
1FD2:  MOVFF  B2,EF
1FD6:  CLRF   xF6
1FD8:  CLRF   xF5
1FDA:  MOVLW  0E
1FDC:  MOVWF  xF4
1FDE:  MOVLW  10
1FE0:  MOVWF  xF3
1FE2:  CALL   0338
1FE6:  BTFSC  18.7
1FE8:  BSF    FF2.7
1FEA:  MOVFF  FEF,E2
1FEE:  MOVFF  FEC,E3
1FF2:  MOVFF  FEC,E4
1FF6:  MOVFF  FEC,E5
1FFA:  MOVFF  FEA,E7
1FFE:  MOVFF  FE9,E6
2002:  CLRF   18
2004:  BTFSC  FF2.7
2006:  BSF    18.7
2008:  BCF    FF2.7
200A:  MOVFF  E5,F2
200E:  MOVFF  E4,F1
2012:  MOVFF  E3,F0
2016:  MOVFF  E2,EF
201A:  CLRF   xF6
201C:  CLRF   xF5
201E:  CLRF   xF4
2020:  MOVLW  3C
2022:  MOVWF  xF3
2024:  CALL   0338
2028:  BTFSC  18.7
202A:  BSF    FF2.7
202C:  MOVFF  E7,FEA
2030:  MOVFF  E6,FE9
2034:  MOVFF  00,E3
2038:  CLRF   xEB
203A:  CLRF   xEA
203C:  CLRF   xE9
203E:  MOVFF  00,E8
2042:  MOVLW  0A
2044:  MOVWF  xEC
2046:  CLRF   xEE
2048:  MOVLW  40
204A:  MOVWF  xED
204C:  CALL   152C
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2050:  CLRF   xE5
2052:  MOVLW  40
2054:  MOVWF  xE4
2056:  CALL   1708
205A:  MOVF   01,W
205C:  SUBLW  02
205E:  BNC   20A4
2060:  CLRF   xE5
2062:  MOVLW  40
2064:  MOVWF  xE4
2066:  CALL   1708
206A:  MOVLW  31
206C:  BSF    FD8.0
206E:  SUBFWB 01,W
2070:  MOVWF  xE2
2072:  MOVLW  00
2074:  BTFSS  FD8.0
2076:  DECF   FE8,F
2078:  MOVWF  xE3
207A:  CLRF   xE5
207C:  MOVLW  40
207E:  MOVWF  xE4
2080:  CALL   1708
2084:  MOVFF  01,E4
2088:  MOVFF  E3,FEA
208C:  MOVFF  E2,FE9
2090:  CLRF   FE2
2092:  MOVLW  40
2094:  MOVWF  FE1
2096:  MOVF   01,W
2098:  MOVWF  01
209A:  BZ    20A4
209C:  MOVFF  FE6,FEE
20A0:  DECFSZ 01,F
20A2:  BRA    209C
20A4:  CLRF   18
20A6:  BTFSC  FF2.7
20A8:  BSF    18.7
20AA:  BCF    FF2.7
.................... 		itoa((int8) (time_of_day%60),10,tmp_str2); 
20AC:  MOVFF  B5,F2
20B0:  MOVFF  B4,F1
20B4:  MOVFF  B3,F0
20B8:  MOVFF  B2,EF
20BC:  CLRF   xF6
20BE:  CLRF   xF5
20C0:  CLRF   xF4
20C2:  MOVLW  3C
20C4:  MOVWF  xF3
20C6:  CALL   0338
20CA:  BTFSC  18.7
20CC:  BSF    FF2.7
20CE:  MOVFF  FEF,00
20D2:  MOVFF  FEC,01
20D6:  MOVFF  FEC,02
20DA:  MOVFF  FEC,03
20DE:  MOVFF  00,E2
20E2:  CLRF   xEB
20E4:  CLRF   xEA
20E6:  CLRF   xE9
20E8:  MOVFF  00,E8
20EC:  MOVLW  0A
20EE:  MOVWF  xEC
20F0:  CLRF   xEE
20F2:  MOVLW  40
20F4:  MOVWF  xED
20F6:  CALL   152C
.................... 		if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
20FA:  CLRF   xE5
20FC:  MOVLW  40
20FE:  MOVWF  xE4
2100:  CALL   1708
2104:  MOVF   01,W
2106:  SUBLW  02
2108:  BNC   214E
210A:  CLRF   xE5
210C:  MOVLW  40
210E:  MOVWF  xE4
2110:  CALL   1708
2114:  MOVLW  34
2116:  BSF    FD8.0
2118:  SUBFWB 01,W
211A:  MOVWF  xE2
211C:  MOVLW  00
211E:  BTFSS  FD8.0
2120:  DECF   FE8,F
2122:  MOVWF  xE3
2124:  CLRF   xE5
2126:  MOVLW  40
2128:  MOVWF  xE4
212A:  CALL   1708
212E:  MOVFF  01,E4
2132:  MOVFF  E3,FEA
2136:  MOVFF  E2,FE9
213A:  CLRF   FE2
213C:  MOVLW  40
213E:  MOVWF  FE1
2140:  MOVF   01,W
2142:  MOVWF  01
2144:  BZ    214E
2146:  MOVFF  FE6,FEE
214A:  DECFSZ 01,F
214C:  BRA    2146
.................... 		lcd_gotoxy(0,1); 
214E:  CLRF   xEC
2150:  MOVLW  01
2152:  MOVWF  xED
2154:  CALL   0CBA
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
2158:  CLRF   xE5
215A:  MOVLW  2C
215C:  MOVWF  xE4
215E:  CALL   1708
2162:  MOVFF  01,E2
2166:  CLRF   xE4
2168:  MOVLW  2C
216A:  MOVWF  xE3
216C:  MOVFF  01,E5
2170:  CALL   173A
....................  
.................... 		strcpy(tmp_str,"   "); 
2174:  CLRF   FEA
2176:  MOVLW  2C
2178:  MOVWF  FE9
217A:  MOVFF  FF2,E2
217E:  BCF    FF2.7
2180:  MOVLW  00
2182:  CALL   0110
2186:  TBLRD*-
2188:  TBLRD*+
218A:  MOVF   FF5,W
218C:  MOVWF  FEE
218E:  IORLW  00
2190:  BNZ   2188
2192:  BTFSC  xE2.7
2194:  BSF    FF2.7
.................... 		itoa((int8)startup_counter,10,tmp_str2); 
2196:  CLRF   xEB
2198:  CLRF   xEA
219A:  CLRF   xE9
219C:  MOVFF  C6,E8
21A0:  MOVLW  0A
21A2:  MOVWF  xEC
21A4:  CLRF   xEE
21A6:  MOVLW  40
21A8:  MOVWF  xED
21AA:  CALL   152C
.................... 		if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
21AE:  CLRF   xE5
21B0:  MOVLW  40
21B2:  MOVWF  xE4
21B4:  CALL   1708
21B8:  MOVF   01,W
21BA:  SUBLW  03
21BC:  BNC   2202
21BE:  CLRF   xE5
21C0:  MOVLW  40
21C2:  MOVWF  xE4
21C4:  CALL   1708
21C8:  MOVLW  2F
21CA:  BSF    FD8.0
21CC:  SUBFWB 01,W
21CE:  MOVWF  xE2
21D0:  MOVLW  00
21D2:  BTFSS  FD8.0
21D4:  DECF   FE8,F
21D6:  MOVWF  xE3
21D8:  CLRF   xE5
21DA:  MOVLW  40
21DC:  MOVWF  xE4
21DE:  CALL   1708
21E2:  MOVFF  01,E4
21E6:  MOVFF  E3,FEA
21EA:  MOVFF  E2,FE9
21EE:  CLRF   FE2
21F0:  MOVLW  40
21F2:  MOVWF  FE1
21F4:  MOVF   01,W
21F6:  MOVWF  01
21F8:  BZ    2202
21FA:  MOVFF  FE6,FEE
21FE:  DECFSZ 01,F
2200:  BRA    21FA
.................... 	    lcd_gotoxy(0,2); 
2202:  CLRF   xEC
2204:  MOVLW  02
2206:  MOVWF  xED
2208:  CALL   0CBA
.................... 		lcd_put_str(tmp_str,strlen(tmp_str));			 
220C:  CLRF   xE5
220E:  MOVLW  2C
2210:  MOVWF  xE4
2212:  CALL   1708
2216:  MOVFF  01,E2
221A:  CLRF   xE4
221C:  MOVLW  2C
221E:  MOVWF  xE3
2220:  MOVFF  01,E5
2224:  CALL   173A
....................  
....................  
.................... } 
2228:  RETLW  00
....................  
.................... void download_sun_table(int16 nPage) { 
....................     int16 i,j; 
.................... 	disable_interrupts(GLOBAL); 
*
26F6:  BCF    FF2.6
26F8:  BCF    FF2.7
26FA:  BTFSC  FF2.7
26FC:  BRA    26F8
.................... 	restart_wdt(); 
26FE:  CLRWDT
.................... 	setup_wdt(WDT_OFF); 
2700:  BCF    FD1.0
....................     output_high(FLASH_SELECT); 
2702:  BCF    F94.2
2704:  BSF    F8B.2
....................     while(kbhit()) getc(); 
2706:  BTFSS  F9E.5
2708:  BRA    2712
270A:  BTFSS  F9E.5
270C:  BRA    270A
270E:  MOVF   FAE,W
2710:  BRA    2706
....................     for (j=0;j<nPage+1;j++) { 
2712:  CLRF   xD6
2714:  CLRF   xD5
2716:  MOVLW  01
2718:  ADDWF  xD1,W
271A:  MOVWF  01
271C:  MOVLW  00
271E:  ADDWFC xD2,W
2720:  MOVWF  03
2722:  MOVF   xD6,W
2724:  SUBWF  03,W
2726:  BNC   27CC
2728:  BNZ   2730
272A:  MOVF   01,W
272C:  SUBWF  xD5,W
272E:  BC    27CC
....................      	ext_flash_waitUntilReady(); 
2730:  RCALL  2552
.................... 		PORTE.tx_en=1; 
2732:  BSF    F84.2
....................         printf("OK\r\n"); 
2734:  CLRF   xD7
2736:  MOVF   xD7,W
2738:  CALL   012E
273C:  INCF   xD7,F
273E:  MOVWF  00
2740:  MOVF   00,W
2742:  BTFSS  F9E.4
2744:  BRA    2742
2746:  MOVWF  FAD
2748:  MOVLW  04
274A:  SUBWF  xD7,W
274C:  BNZ   2736
.................... 		tx_delay=TX_DLY_TIME; 
274E:  MOVLW  01
2750:  MOVWF  xC2
.................... 		//PORTE.tx_en=0; 
....................    		output_low(FLASH_SELECT); 
2752:  BCF    F94.2
2754:  BCF    F8B.2
....................         if (j%2) ext_flash_sendData(0x82, 8); else ext_flash_sendData(0x85, 8); 
2756:  MOVF   xD5,W
2758:  ANDLW  01
275A:  MOVWF  00
275C:  CLRF   03
275E:  MOVF   00,W
2760:  IORWF  03,W
2762:  BZ    2770
2764:  MOVLW  82
2766:  MOVWF  xF8
2768:  MOVLW  08
276A:  MOVWF  xF9
276C:  RCALL  2688
276E:  BRA    277A
2770:  MOVLW  85
2772:  MOVWF  xF8
2774:  MOVLW  08
2776:  MOVWF  xF9
2778:  RCALL  2688
....................    		ext_flash_send16Data(j+10, 15); // page address 
277A:  MOVLW  0A
277C:  ADDWF  xD5,W
277E:  MOVWF  xD7
2780:  MOVLW  00
2782:  ADDWFC xD6,W
2784:  MOVWF  xD8
2786:  MOVWF  xF9
2788:  MOVFF  D7,F8
278C:  MOVLW  0F
278E:  MOVWF  xFA
2790:  RCALL  26B8
.................... 		ext_flash_send16Data(0, 9); 
2792:  CLRF   xF9
2794:  CLRF   xF8
2796:  MOVLW  09
2798:  MOVWF  xFA
279A:  RCALL  26B8
.................... 		for (i=0;i<256;i++) { 
279C:  CLRF   xD4
279E:  CLRF   xD3
27A0:  MOVF   xD4,W
27A2:  SUBLW  00
27A4:  BNC   27C0
....................             ext_flash_sendData(getc(), 8); 
27A6:  BTFSS  F9E.5
27A8:  BRA    27A6
27AA:  MOVFF  FAE,D7
27AE:  MOVFF  D7,F8
27B2:  MOVLW  08
27B4:  MOVWF  xF9
27B6:  RCALL  2688
.................... 		} 
27B8:  INCF   xD3,F
27BA:  BTFSC  FD8.2
27BC:  INCF   xD4,F
27BE:  BRA    27A0
....................        output_high(FLASH_SELECT); 
27C0:  BCF    F94.2
27C2:  BSF    F8B.2
.................... 	} 
27C4:  INCF   xD5,F
27C6:  BTFSC  FD8.2
27C8:  INCF   xD6,F
27CA:  BRA    2716
.................... 	enable_interrupts(GLOBAL); 
27CC:  MOVLW  C0
27CE:  IORWF  FF2,F
.................... 	restart_wdt(); 
27D0:  CLRWDT
.................... 	setup_wdt(WDT_ON); 
27D2:  BSF    FD1.0
....................  
.................... } 
27D4:  GOTO   35B2 (RETURN)
....................  
.................... /* 
.................... void print_page_data(int16 nPage) { 
....................     char temp[256]; 
....................     int16 i; 
....................     int32 time_index; 
....................  
.................... 	ext_flash_readPage(nPage,0,temp,264); 
....................     for(i=0;i<264;i++) { 
.................... 		PORTE.tx_en=1; 
.................... 		if((i%16) ==0) printf("\r\n%02X : ",i); 
.................... 		printf("%02X ",temp[i]); 
.................... 	} 
.................... 	memcpy(&time_index,temp,4); 
....................     printf("\r\n Timer Index: %Lu",time_index);	 
.................... 	 
....................  
....................  
.................... } 
.................... */ 
.................... void print_page_data(int16 nPage) { 
....................     char temp[17]; 
....................     int8 i; 
.................... 	int8 j; 
....................     PORTE.tx_en=1; 
*
28D6:  BSF    F84.2
....................     for(i=0;i<16;i++) { 
28D8:  CLRF   xE4
28DA:  MOVF   xE4,W
28DC:  SUBLW  0F
28DE:  BNC   2968
.................... 		printf("\r\n%02X : ",i); 
28E0:  MOVLW  0D
28E2:  BTFSS  F9E.4
28E4:  BRA    28E2
28E6:  MOVWF  FAD
28E8:  MOVLW  0A
28EA:  BTFSS  F9E.4
28EC:  BRA    28EA
28EE:  MOVWF  FAD
28F0:  MOVFF  E4,E7
28F4:  MOVLW  37
28F6:  MOVWF  xE8
28F8:  RCALL  27D8
28FA:  MOVLW  20
28FC:  BTFSS  F9E.4
28FE:  BRA    28FC
2900:  MOVWF  FAD
2902:  MOVLW  3A
2904:  BTFSS  F9E.4
2906:  BRA    2904
2908:  MOVWF  FAD
290A:  MOVLW  20
290C:  BTFSS  F9E.4
290E:  BRA    290C
2910:  MOVWF  FAD
.................... 		ext_flash_readPage(nPage,i*16,temp,16); 
2912:  MOVF   xE4,W
2914:  MULLW  10
2916:  MOVFF  FF3,E6
291A:  MOVFF  D2,F2
291E:  MOVFF  D1,F1
2922:  MOVFF  E6,F3
2926:  CLRF   xF5
2928:  MOVLW  D3
292A:  MOVWF  xF4
292C:  CLRF   xF7
292E:  MOVLW  10
2930:  MOVWF  xF6
2932:  RCALL  287E
.................... 		for (j=0;j<16;j++) printf("%02X ",temp[j]); 
2934:  CLRF   xE5
2936:  MOVF   xE5,W
2938:  SUBLW  0F
293A:  BNC   2964
293C:  CLRF   03
293E:  MOVF   xE5,W
2940:  ADDLW  D3
2942:  MOVWF  FE9
2944:  MOVLW  00
2946:  ADDWFC 03,W
2948:  MOVWF  FEA
294A:  MOVFF  FEF,E6
294E:  MOVFF  E6,E7
2952:  MOVLW  37
2954:  MOVWF  xE8
2956:  RCALL  27D8
2958:  MOVLW  20
295A:  BTFSS  F9E.4
295C:  BRA    295A
295E:  MOVWF  FAD
2960:  INCF   xE5,F
2962:  BRA    2936
.................... 	} 
2964:  INCF   xE4,F
2966:  BRA    28DA
.................... 	tx_delay=TX_DLY_TIME; 
2968:  MOVLW  01
296A:  MOVWF  xC2
.................... } 
296C:  GOTO   3194 (RETURN)
....................  
.................... int32 get_timer_index(int16 nDay) { // 1 page contain 2 subpage 
....................     char temp[6]; 
....................     int32 time_index; 
.................... 	ext_flash_readPage((nDay/2)+10,128*(nDay%2),temp,4); 
*
2CE8:  BCF    FD8.0
2CEA:  RRCF   xE0,W
2CEC:  MOVWF  xEC
2CEE:  RRCF   xDF,W
2CF0:  MOVWF  xEB
2CF2:  MOVLW  0A
2CF4:  ADDWF  xEB,W
2CF6:  MOVWF  xED
2CF8:  MOVLW  00
2CFA:  ADDWFC xEC,W
2CFC:  MOVWF  xEE
2CFE:  MOVF   xDF,W
2D00:  ANDLW  01
2D02:  MOVWF  00
2D04:  CLRF   03
2D06:  MOVWF  02
2D08:  RLCF   00,W
2D0A:  MOVWF  xEF
2D0C:  RLCF   03,W
2D0E:  MOVWF  xF0
2D10:  RLCF   xEF,F
2D12:  RLCF   xF0,F
2D14:  RLCF   xEF,F
2D16:  RLCF   xF0,F
2D18:  RLCF   xEF,F
2D1A:  RLCF   xF0,F
2D1C:  RLCF   xEF,F
2D1E:  RLCF   xF0,F
2D20:  RLCF   xEF,F
2D22:  RLCF   xF0,F
2D24:  RLCF   xEF,F
2D26:  RLCF   xF0,F
2D28:  MOVLW  80
2D2A:  ANDWF  xEF,F
2D2C:  MOVFF  EE,F2
2D30:  MOVFF  ED,F1
2D34:  MOVFF  EF,F3
2D38:  CLRF   xF5
2D3A:  MOVLW  E1
2D3C:  MOVWF  xF4
2D3E:  CLRF   xF7
2D40:  MOVLW  04
2D42:  MOVWF  xF6
2D44:  RCALL  287E
.................... 	memcpy(&time_index,temp,4); 
2D46:  CLRF   FEA
2D48:  MOVLW  E7
2D4A:  MOVWF  FE9
2D4C:  CLRF   FE2
2D4E:  MOVLW  E1
2D50:  MOVWF  FE1
2D52:  MOVLW  04
2D54:  MOVWF  01
2D56:  MOVFF  FE6,FEE
2D5A:  DECFSZ 01,F
2D5C:  BRA    2D56
.................... 	return time_index; 
2D5E:  MOVFF  E7,00
2D62:  MOVFF  E8,01
2D66:  MOVFF  E9,02
2D6A:  MOVFF  EA,03
.................... } 
2D6E:  RETLW  00
....................  
.................... int16 find_day_number(int32 tsec) // return day number after 1-jan-2010, we use this to search for sun angle in flash memory page 
.................... { 
.................... 	return (((tsec+((int8)UTC)*3600)/86400)%1461); 
*
2C4E:  MOVLW  70
2C50:  ADDWF  xDF,W
2C52:  MOVWF  xE3
2C54:  MOVLW  62
2C56:  ADDWFC xE0,W
2C58:  MOVWF  xE4
2C5A:  MOVLW  00
2C5C:  ADDWFC xE1,W
2C5E:  MOVWF  xE5
2C60:  MOVLW  00
2C62:  ADDWFC xE2,W
2C64:  MOVWF  xE6
2C66:  CLRF   18
2C68:  BTFSC  FF2.7
2C6A:  BSF    18.7
2C6C:  BCF    FF2.7
2C6E:  MOVWF  xF2
2C70:  MOVFF  E5,F1
2C74:  MOVFF  E4,F0
2C78:  MOVFF  E3,EF
2C7C:  CLRF   xF6
2C7E:  MOVLW  01
2C80:  MOVWF  xF5
2C82:  MOVLW  51
2C84:  MOVWF  xF4
2C86:  MOVLW  80
2C88:  MOVWF  xF3
2C8A:  CALL   0338
2C8E:  BTFSC  18.7
2C90:  BSF    FF2.7
2C92:  MOVFF  03,E7
2C96:  MOVFF  02,E6
2C9A:  MOVFF  01,E5
2C9E:  MOVFF  00,E4
2CA2:  CLRF   18
2CA4:  BTFSC  FF2.7
2CA6:  BSF    18.7
2CA8:  BCF    FF2.7
2CAA:  MOVFF  03,F2
2CAE:  MOVFF  02,F1
2CB2:  MOVFF  01,F0
2CB6:  MOVFF  00,EF
2CBA:  CLRF   xF6
2CBC:  CLRF   xF5
2CBE:  MOVLW  05
2CC0:  MOVWF  xF4
2CC2:  MOVLW  B5
2CC4:  MOVWF  xF3
2CC6:  CALL   0338
2CCA:  BTFSC  18.7
2CCC:  BSF    FF2.7
2CCE:  MOVFF  FEF,00
2CD2:  MOVFF  FEC,01
2CD6:  MOVFF  FEC,02
2CDA:  MOVFF  FEC,03
2CDE:  MOVFF  01,02
2CE2:  MOVFF  00,01
.................... } 
2CE6:  RETLW  00
....................  
.................... unsigned int8 current_sun_angle(unsigned int32 t_sec) { 
.................... 	unsigned int16 today;  // current day (count after epoch) 
.................... 	unsigned int32 sun_rise_t_sec; // time of day . compensated for time zone 
.................... 	unsigned int8 sun_data; 
.................... 	today = find_day_number(t_sec); // day after epoch 
*
3628:  MOVFF  D7,E2
362C:  MOVFF  D6,E1
3630:  MOVFF  D5,E0
3634:  MOVFF  D4,DF
3638:  CALL   2C4E
363C:  MOVFF  02,D9
3640:  MOVFF  01,D8
....................     sun_rise_t_sec = get_timer_index(today)*450; 
3644:  MOVFF  D9,E0
3648:  MOVFF  D8,DF
364C:  CALL   2CE8
3650:  MOVFF  03,E2
3654:  MOVFF  02,E1
3658:  MOVFF  01,E0
365C:  MOVFF  00,DF
3660:  MOVFF  FEA,E4
3664:  MOVFF  FE9,E3
3668:  MOVFF  03,FA
366C:  MOVFF  02,F9
3670:  MOVFF  01,F8
3674:  MOVFF  00,F7
3678:  CLRF   xFE
367A:  CLRF   xFD
367C:  MOVLW  01
367E:  MOVWF  xFC
3680:  MOVLW  C2
3682:  MOVWF  xFB
3684:  CALL   13CC
3688:  MOVFF  E4,FEA
368C:  MOVFF  E3,FE9
3690:  MOVFF  03,DD
3694:  MOVFF  02,DC
3698:  MOVFF  01,DB
369C:  MOVFF  00,DA
36A0:  CLRF   18
36A2:  BTFSC  FF2.7
36A4:  BSF    18.7
36A6:  BCF    FF2.7
....................     if (sun_rise_t_sec > t_sec%SEC_IN_4_YEARS) return 0x0; // sun havent up yet, angle is 0 
36A8:  MOVFF  D7,F2
36AC:  MOVFF  D6,F1
36B0:  MOVFF  D5,F0
36B4:  MOVFF  D4,EF
36B8:  MOVLW  07
36BA:  MOVWF  xF6
36BC:  MOVLW  86
36BE:  MOVWF  xF5
36C0:  MOVLW  1F
36C2:  MOVWF  xF4
36C4:  MOVLW  80
36C6:  MOVWF  xF3
36C8:  CALL   0338
36CC:  BTFSC  18.7
36CE:  BSF    FF2.7
36D0:  MOVFF  FEF,00
36D4:  MOVFF  FEC,01
36D8:  MOVFF  FEC,02
36DC:  MOVFF  FEC,03
36E0:  MOVF   03,W
36E2:  SUBWF  xDD,W
36E4:  BNC   3704
36E6:  BNZ   36FE
36E8:  MOVF   02,W
36EA:  SUBWF  xDC,W
36EC:  BNC   3704
36EE:  BNZ   36FE
36F0:  MOVF   01,W
36F2:  SUBWF  xDB,W
36F4:  BNC   3704
36F6:  BNZ   36FE
36F8:  MOVF   xDA,W
36FA:  SUBWF  00,W
36FC:  BC    3704
36FE:  MOVLW  00
3700:  MOVWF  01
3702:  BRA    3832
3704:  CLRF   18
3706:  BTFSC  FF2.7
3708:  BSF    18.7
370A:  BCF    FF2.7
.................... 	index_in_page = (t_sec%SEC_IN_4_YEARS-sun_rise_t_sec)/450; 
370C:  MOVFF  D7,F2
3710:  MOVFF  D6,F1
3714:  MOVFF  D5,F0
3718:  MOVFF  D4,EF
371C:  MOVLW  07
371E:  MOVWF  xF6
3720:  MOVLW  86
3722:  MOVWF  xF5
3724:  MOVLW  1F
3726:  MOVWF  xF4
3728:  MOVLW  80
372A:  MOVWF  xF3
372C:  CALL   0338
3730:  BTFSC  18.7
3732:  BSF    FF2.7
3734:  MOVFF  FEF,DF
3738:  MOVFF  FEC,E0
373C:  MOVFF  FEC,E1
3740:  MOVFF  FEC,E2
3744:  MOVF   xDA,W
3746:  SUBWF  xDF,W
3748:  MOVWF  xE3
374A:  MOVF   xDB,W
374C:  SUBWFB xE0,W
374E:  MOVWF  xE4
3750:  MOVF   xDC,W
3752:  SUBWFB xE1,W
3754:  MOVWF  xE5
3756:  MOVF   xDD,W
3758:  SUBWFB xE2,W
375A:  MOVWF  xE6
375C:  MOVFF  FEA,E8
3760:  MOVFF  FE9,E7
3764:  CLRF   18
3766:  BTFSC  FF2.7
3768:  BSF    18.7
376A:  BCF    FF2.7
376C:  MOVWF  xF2
376E:  MOVFF  E5,F1
3772:  MOVFF  E4,F0
3776:  MOVFF  E3,EF
377A:  CLRF   xF6
377C:  CLRF   xF5
377E:  MOVLW  01
3780:  MOVWF  xF4
3782:  MOVLW  C2
3784:  MOVWF  xF3
3786:  CALL   0338
378A:  BTFSC  18.7
378C:  BSF    FF2.7
378E:  MOVFF  E8,FEA
3792:  MOVFF  E7,FE9
3796:  MOVFF  00,C8
....................     if (index_in_page>=124) return 0xFF; // exceed page size , sun went down 
379A:  MOVF   xC8,W
379C:  SUBLW  7B
379E:  BC    37A6
37A0:  MOVLW  FF
37A2:  MOVWF  01
37A4:  BRA    3832
....................     ext_flash_readPage((today/2)+10,128*(today%2)+4+index_in_page,&sun_data,1); 
37A6:  BCF    FD8.0
37A8:  RRCF   xD9,W
37AA:  MOVWF  xE0
37AC:  RRCF   xD8,W
37AE:  MOVWF  xDF
37B0:  MOVLW  0A
37B2:  ADDWF  xDF,W
37B4:  MOVWF  xE1
37B6:  MOVLW  00
37B8:  ADDWFC xE0,W
37BA:  MOVWF  xE2
37BC:  MOVF   xD8,W
37BE:  ANDLW  01
37C0:  MOVWF  00
37C2:  CLRF   03
37C4:  MOVWF  02
37C6:  RLCF   00,W
37C8:  MOVWF  xE3
37CA:  RLCF   03,W
37CC:  MOVWF  xE4
37CE:  RLCF   xE3,F
37D0:  RLCF   xE4,F
37D2:  RLCF   xE3,F
37D4:  RLCF   xE4,F
37D6:  RLCF   xE3,F
37D8:  RLCF   xE4,F
37DA:  RLCF   xE3,F
37DC:  RLCF   xE4,F
37DE:  RLCF   xE3,F
37E0:  RLCF   xE4,F
37E2:  RLCF   xE3,F
37E4:  RLCF   xE4,F
37E6:  MOVLW  80
37E8:  ANDWF  xE3,F
37EA:  MOVLW  04
37EC:  ADDWF  xE3,W
37EE:  MOVWF  xE5
37F0:  MOVLW  00
37F2:  ADDWFC xE4,W
37F4:  MOVWF  xE6
37F6:  MOVF   xC8,W
37F8:  ADDWF  xE5,W
37FA:  MOVWF  xE7
37FC:  MOVLW  00
37FE:  ADDWFC xE6,W
3800:  MOVWF  xE8
3802:  MOVFF  E2,F2
3806:  MOVFF  E1,F1
380A:  MOVFF  E7,F3
380E:  CLRF   xF5
3810:  MOVLW  DE
3812:  MOVWF  xF4
3814:  CLRF   xF7
3816:  MOVLW  01
3818:  MOVWF  xF6
381A:  CALL   287E
.................... 	if ((index_in_page>5) && (sun_data==0)) return 0xFF; // sun went down 
381E:  MOVF   xC8,W
3820:  SUBLW  05
3822:  BC    382E
3824:  MOVF   xDE,F
3826:  BNZ   382E
3828:  MOVLW  FF
382A:  MOVWF  01
382C:  BRA    3832
.................... 	return sun_data; 
382E:  MOVFF  DE,01
.................... 	 
.................... } 
3832:  GOTO   3A16 (RETURN)
....................  
....................  
.................... int16 move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,boolean direction,boolean abort_when_task_armed) { 
.................... 	// direction 0 = east, 1=west 
.................... 	unsigned int16 xxx=0; 
*
222A:  CLRF   xDB
222C:  CLRF   xDC
.................... 	unsigned int16 yyy=0; 
222E:  CLRF   xDD
2230:  CLRF   xDE
.................... 	int16 actuator_pulse=0; 
2232:  CLRF   xDF
2234:  CLRF   xE0
.................... 	int8 rt=5; 
2236:  MOVLW  05
2238:  MOVWF  xE1
.................... 	output_low(CCW); 
223A:  BCF    F93.4
223C:  BCF    F8A.4
.................... 	output_low(EN0); 
223E:  BCF    F93.0
2240:  BCF    F8A.0
.................... 	output_low(EN1); 
2242:  BCF    F93.1
2244:  BCF    F8A.1
.................... 	output_low(EN2); 
2246:  BCF    F93.2
2248:  BCF    F8A.2
.................... 	output_low(EN3); 
224A:  BCF    F93.3
224C:  BCF    F8A.3
.................... 	PORTD.ps_en=0; 
224E:  BCF    F83.4
2250:  CLRF   18
2252:  BTFSC  FF2.7
2254:  BSF    18.7
2256:  BCF    FF2.7
....................     delay_ms(20); 
2258:  MOVLW  14
225A:  MOVWF  xF1
225C:  CALL   04B4
2260:  BTFSC  18.7
2262:  BSF    FF2.7
....................  
.................... 	if (!direction)	{ 
2264:  MOVF   xD9,F
2266:  BNZ   226C
.................... 		output_high(CCW); 
2268:  BCF    F93.4
226A:  BSF    F8A.4
.................... 	} 
....................  
.................... 	PORTD.ps_en=1; 
226C:  BSF    F83.4
226E:  CLRF   18
2270:  BTFSC  FF2.7
2272:  BSF    18.7
2274:  BCF    FF2.7
....................     delay_ms(20); 
2276:  MOVLW  14
2278:  MOVWF  xF1
227A:  CALL   04B4
227E:  BTFSC  18.7
2280:  BSF    FF2.7
.................... 	output_high(EN0); 
2282:  BCF    F93.0
2284:  BSF    F8A.0
2286:  CLRF   18
2288:  BTFSC  FF2.7
228A:  BSF    18.7
228C:  BCF    FF2.7
....................     delay_ms(10); 
228E:  MOVLW  0A
2290:  MOVWF  xF1
2292:  CALL   04B4
2296:  BTFSC  18.7
2298:  BSF    FF2.7
....................  
.................... 	flag.prev_pulse_state = input(PIN_A2); //A2 = sensor wire for actuator 1 
229A:  BSF    F92.2
229C:  BCF    1F.2
229E:  BTFSC  F80.2
22A0:  BSF    1F.2
.................... 	tick = timer_sec; 
22A2:  MOVFF  23,27
22A6:  MOVFF  22,26
22AA:  MOVFF  21,25
22AE:  MOVFF  20,24
.................... 	tick2 = timer_sec; 
22B2:  MOVFF  23,2B
22B6:  MOVFF  22,2A
22BA:  MOVFF  21,29
22BE:  MOVFF  20,28
.................... 	actuator_pulse =0; 
22C2:  CLRF   xE0
22C4:  CLRF   xDF
.................... 	while(1) { 
.................... 		xxx = (int16) (timer_sec-tick); 
22C6:  MOVF   24,W
22C8:  SUBWF  20,W
22CA:  MOVWF  00
22CC:  MOVF   25,W
22CE:  SUBWFB 21,W
22D0:  MOVWF  01
22D2:  MOVF   26,W
22D4:  SUBWFB 22,W
22D6:  MOVF   27,W
22D8:  SUBWFB 23,W
22DA:  MOVFF  01,DC
22DE:  MOVFF  00,DB
.................... 		yyy = (int16) (timer_sec-tick2); 
22E2:  MOVF   28,W
22E4:  SUBWF  20,W
22E6:  MOVWF  00
22E8:  MOVF   29,W
22EA:  SUBWFB 21,W
22EC:  MOVWF  01
22EE:  MOVF   2A,W
22F0:  SUBWFB 22,W
22F2:  MOVF   2B,W
22F4:  SUBWFB 23,W
22F6:  MOVFF  01,DE
22FA:  MOVFF  00,DD
.................... 		if ( xxx>= time_out_sec)  
22FE:  MOVF   xD6,W
2300:  SUBWF  xDC,W
2302:  BNC   230E
2304:  BNZ   230C
2306:  MOVF   xD5,W
2308:  SUBWF  xDB,W
230A:  BNC   230E
.................... 			break; 
230C:  BRA    2412
....................  		if (actuator_pulse >= nPulse) 
230E:  MOVF   xD4,W
2310:  SUBWF  xE0,W
2312:  BNC   2320
2314:  BNZ   231C
2316:  MOVF   xD3,W
2318:  SUBWF  xDF,W
231A:  BNC   2320
.................... 			output_low(EN0); 
231C:  BCF    F93.0
231E:  BCF    F8A.0
.................... 		if ( yyy >=stuck_sec) 
2320:  MOVF   xD8,W
2322:  SUBWF  xDE,W
2324:  BNC   2330
2326:  BNZ   232E
2328:  MOVF   xD7,W
232A:  SUBWF  xDD,W
232C:  BNC   2330
.................... 			break; 
232E:  BRA    2412
.................... 		if (abort_when_task_armed && (flag.task1_armed||flag.cmd_posted)) 
2330:  MOVF   xDA,F
2332:  BZ    233E
2334:  BTFSC  1F.0
2336:  BRA    233C
2338:  BTFSS  1F.3
233A:  BRA    233E
.................... 			break; 
233C:  BRA    2412
.................... 		if (flag.prev_pulse_state != input(SENSE_0)) { 
233E:  MOVLW  00
2340:  BTFSC  1F.2
2342:  MOVLW  01
2344:  MOVWF  xE2
2346:  BSF    F92.1
2348:  MOVLW  00
234A:  BTFSC  F80.1
234C:  MOVLW  01
234E:  SUBWF  xE2,W
2350:  BZ    2406
.................... 			tick2 = timer_sec; 
2352:  MOVFF  23,2B
2356:  MOVFF  22,2A
235A:  MOVFF  21,29
235E:  MOVFF  20,28
.................... 			flag.prev_pulse_state = input(SENSE_0); 
2362:  BSF    F92.1
2364:  BCF    1F.2
2366:  BTFSC  F80.1
2368:  BSF    1F.2
.................... 			if (!direction && (current_act_position >0)) current_act_position--; 
236A:  MOVF   xD9,F
236C:  BNZ   237E
236E:  MOVF   x6E,F
2370:  BNZ   2376
2372:  MOVF   x6F,F
2374:  BZ    237E
2376:  MOVF   x6E,W
2378:  BTFSC  FD8.2
237A:  DECF   x6F,F
237C:  DECF   x6E,F
.................... 			if (direction && (current_act_position < FULL_STROKE_TICK)) current_act_position++; 
237E:  MOVF   xD9,F
2380:  BZ    2396
2382:  MOVF   x6F,W
2384:  SUBWF  xBB,W
2386:  BNC   2396
2388:  BNZ   2390
238A:  MOVF   xBA,W
238C:  SUBWF  x6E,W
238E:  BC    2396
2390:  INCF   x6E,F
2392:  BTFSC  FD8.2
2394:  INCF   x6F,F
.................... 			actuator_pulse=actuator_pulse+1; 
2396:  MOVLW  01
2398:  ADDWF  xDF,F
239A:  MOVLW  00
239C:  ADDWFC xE0,F
.................... 			lcd_gotoxy(11,2); 
239E:  MOVLW  0B
23A0:  MOVWF  xEC
23A2:  MOVLW  02
23A4:  MOVWF  xED
23A6:  CALL   0CBA
.................... 			if (actuator_pulse%2==0)	lcd_putc('*'); else  lcd_putc('.'); 
23AA:  MOVF   xDF,W
23AC:  ANDLW  01
23AE:  MOVWF  xE2
23B0:  CLRF   xE3
23B2:  MOVF   xE2,F
23B4:  BNZ   23C4
23B6:  MOVF   xE3,F
23B8:  BNZ   23C4
23BA:  MOVLW  2A
23BC:  MOVWF  xEB
23BE:  CALL   0CE2
23C2:  BRA    23CC
23C4:  MOVLW  2E
23C6:  MOVWF  xEB
23C8:  CALL   0CE2
.................... 			lcd_gotoxy(12,2); 
23CC:  MOVLW  0C
23CE:  MOVWF  xEC
23D0:  MOVLW  02
23D2:  MOVWF  xED
23D4:  CALL   0CBA
.................... 			printf(lcd_putc,"%4lu",current_act_position); 
23D8:  MOVLW  01
23DA:  MOVWF  FE9
23DC:  MOVFF  6F,E3
23E0:  MOVFF  6E,E2
23E4:  CALL   0D34
.................... 			PORTE.tx_en=1; 
23E8:  BSF    F84.2
.................... 			printf("\r%4lu",actuator_pulse); 
23EA:  MOVLW  0D
23EC:  BTFSS  F9E.4
23EE:  BRA    23EC
23F0:  MOVWF  FAD
23F2:  MOVLW  01
23F4:  MOVWF  FE9
23F6:  MOVFF  E0,E3
23FA:  MOVFF  DF,E2
23FE:  CALL   0DE6
.................... 			tx_delay=TX_DLY_TIME; 
2402:  MOVLW  01
2404:  MOVWF  xC2
....................  
.................... 		} 
.................... 		if (flag.update_time) { 
2406:  BTFSS  1F.1
2408:  BRA    2410
.................... 			flag.update_time = false; 
240A:  BCF    1F.1
.................... 			print_date_time(); 
240C:  CALL   1762
.................... 		} 
.................... 	} 
2410:  BRA    22C6
.................... 	lcd_gotoxy(12,2); 
2412:  MOVLW  0C
2414:  MOVWF  xEC
2416:  MOVLW  02
2418:  MOVWF  xED
241A:  CALL   0CBA
....................     printf(lcd_putc,"%4lu",current_act_position); 
241E:  MOVLW  01
2420:  MOVWF  FE9
2422:  MOVFF  6F,E3
2426:  MOVFF  6E,E2
242A:  CALL   0D34
.................... 	output_low(EN0); 
242E:  BCF    F93.0
2430:  BCF    F8A.0
.................... 	output_low(EN1); 
2432:  BCF    F93.1
2434:  BCF    F8A.1
.................... 	output_low(EN2); 
2436:  BCF    F93.2
2438:  BCF    F8A.2
.................... 	output_low(EN3); 
243A:  BCF    F93.3
243C:  BCF    F8A.3
.................... 	PORTD.ps_en=0; 
243E:  BCF    F83.4
2440:  CLRF   18
2442:  BTFSC  FF2.7
2444:  BSF    18.7
2446:  BCF    FF2.7
....................     delay_ms(50); 
2448:  MOVLW  32
244A:  MOVWF  xF1
244C:  CALL   04B4
2450:  BTFSC  18.7
2452:  BSF    FF2.7
.................... 	output_low(CCW); 
2454:  BCF    F93.4
2456:  BCF    F8A.4
2458:  CLRF   18
245A:  BTFSC  FF2.7
245C:  BSF    18.7
245E:  BCF    FF2.7
....................     delay_ms(50); 
2460:  MOVLW  32
2462:  MOVWF  xF1
2464:  CALL   04B4
2468:  BTFSC  18.7
246A:  BSF    FF2.7
.................... 	return actuator_pulse; 
246C:  MOVFF  DF,01
2470:  MOVFF  E0,02
.................... } 
2474:  RETLW  00
....................  
.................... int8 task1() { 
.................... 		int8 sun_angle; 
.................... 		lcd_init(); 
*
386E:  CALL   09F6
3872:  CLRF   18
3874:  BTFSC  FF2.7
3876:  BSF    18.7
3878:  BCF    FF2.7
.................... 		if (timer_sec%SEC_IN_4_YEARS >= next_sun_rise) { 
387A:  MOVFF  23,F2
387E:  MOVFF  22,F1
3882:  MOVFF  21,F0
3886:  MOVFF  20,EF
388A:  MOVLW  07
388C:  MOVWF  xF6
388E:  MOVLW  86
3890:  MOVWF  xF5
3892:  MOVLW  1F
3894:  MOVWF  xF4
3896:  MOVLW  80
3898:  MOVWF  xF3
389A:  CALL   0338
389E:  BTFSC  18.7
38A0:  BSF    FF2.7
38A2:  MOVFF  FEF,D0
38A6:  MOVFF  FEC,D1
38AA:  MOVFF  FEC,D2
38AE:  MOVFF  FEC,D3
38B2:  MOVF   x6D,W
38B4:  SUBWF  xD3,W
38B6:  BTFSS  FD8.0
38B8:  BRA    39A0
38BA:  BNZ   38D2
38BC:  MOVF   x6C,W
38BE:  SUBWF  xD2,W
38C0:  BNC   39A0
38C2:  BNZ   38D2
38C4:  MOVF   x6B,W
38C6:  SUBWF  xD1,W
38C8:  BNC   39A0
38CA:  BNZ   38D2
38CC:  MOVF   x6A,W
38CE:  SUBWF  xD0,W
38D0:  BNC   39A0
.................... 	    	next_sun_rise=get_timer_index(find_day_number((next_sun_rise+86400)%SEC_IN_4_YEARS))*450; 
38D2:  MOVLW  80
38D4:  ADDWF  x6A,W
38D6:  MOVWF  xD0
38D8:  MOVLW  51
38DA:  ADDWFC x6B,W
38DC:  MOVWF  xD1
38DE:  MOVLW  01
38E0:  ADDWFC x6C,W
38E2:  MOVWF  xD2
38E4:  MOVLW  00
38E6:  ADDWFC x6D,W
38E8:  MOVWF  xD3
38EA:  CLRF   18
38EC:  BTFSC  FF2.7
38EE:  BSF    18.7
38F0:  BCF    FF2.7
38F2:  MOVWF  xF2
38F4:  MOVFF  D2,F1
38F8:  MOVFF  D1,F0
38FC:  MOVFF  D0,EF
3900:  MOVLW  07
3902:  MOVWF  xF6
3904:  MOVLW  86
3906:  MOVWF  xF5
3908:  MOVLW  1F
390A:  MOVWF  xF4
390C:  MOVLW  80
390E:  MOVWF  xF3
3910:  CALL   0338
3914:  BTFSC  18.7
3916:  BSF    FF2.7
3918:  MOVFF  FEF,D1
391C:  MOVFF  FEC,D2
3920:  MOVFF  FEC,D3
3924:  MOVFF  FEC,D4
3928:  MOVFF  D4,E2
392C:  MOVFF  D3,E1
3930:  MOVFF  D2,E0
3934:  MOVFF  D1,DF
3938:  CALL   2C4E
393C:  MOVFF  02,D3
3940:  MOVFF  01,D2
3944:  MOVFF  02,E0
3948:  MOVFF  01,DF
394C:  CALL   2CE8
3950:  MOVFF  03,D6
3954:  MOVFF  02,D5
3958:  MOVFF  01,D4
395C:  MOVFF  00,D3
3960:  MOVFF  FEA,D8
3964:  MOVFF  FE9,D7
3968:  MOVFF  03,FA
396C:  MOVFF  02,F9
3970:  MOVFF  01,F8
3974:  MOVFF  00,F7
3978:  CLRF   xFE
397A:  CLRF   xFD
397C:  MOVLW  01
397E:  MOVWF  xFC
3980:  MOVLW  C2
3982:  MOVWF  xFB
3984:  CALL   13CC
3988:  MOVFF  D8,FEA
398C:  MOVFF  D7,FE9
3990:  MOVFF  03,6D
3994:  MOVFF  02,6C
3998:  MOVFF  01,6B
399C:  MOVFF  00,6A
.................... 		} 
....................         sec_until_sun_rise = (int32) (next_sun_rise-timer_sec); 
39A0:  MOVF   20,W
39A2:  SUBWF  x6A,W
39A4:  MOVWF  00
39A6:  MOVF   21,W
39A8:  SUBWFB x6B,W
39AA:  MOVWF  01
39AC:  MOVF   22,W
39AE:  SUBWFB x6C,W
39B0:  MOVWF  02
39B2:  MOVF   23,W
39B4:  SUBWFB x6D,W
39B6:  MOVWF  xB9
39B8:  MOVFF  02,B8
39BC:  MOVFF  01,B7
39C0:  MOVFF  00,B6
39C4:  CLRF   18
39C6:  BTFSC  FF2.7
39C8:  BSF    18.7
39CA:  BCF    FF2.7
.................... 		sun_angle=current_sun_angle(timer_sec%SEC_IN_4_YEARS); 
39CC:  MOVFF  23,F2
39D0:  MOVFF  22,F1
39D4:  MOVFF  21,F0
39D8:  MOVFF  20,EF
39DC:  MOVLW  07
39DE:  MOVWF  xF6
39E0:  MOVLW  86
39E2:  MOVWF  xF5
39E4:  MOVLW  1F
39E6:  MOVWF  xF4
39E8:  MOVLW  80
39EA:  MOVWF  xF3
39EC:  CALL   0338
39F0:  BTFSC  18.7
39F2:  BSF    FF2.7
39F4:  MOVFF  FEF,D0
39F8:  MOVFF  FEC,D1
39FC:  MOVFF  FEC,D2
3A00:  MOVFF  FEC,D3
3A04:  MOVFF  D3,D7
3A08:  MOVFF  D2,D6
3A0C:  MOVFF  D1,D5
3A10:  MOVFF  D0,D4
3A14:  BRA    3628
3A16:  MOVFF  01,CF
....................  
.................... 		// prepare buffer1 
.................... 		if (sun_angle==0x00) // sun havent' come up yet, clear buffer1 
3A1A:  MOVF   xCF,F
3A1C:  BNZ   3AA8
3A1E:  CLRF   18
3A20:  BTFSC  FF2.7
3A22:  BSF    18.7
3A24:  BCF    FF2.7
.................... 		{ 
.................... 			if(find_day_number(timer_sec%SEC_IN_4_YEARS)%2==0)  
3A26:  MOVFF  23,F2
3A2A:  MOVFF  22,F1
3A2E:  MOVFF  21,F0
3A32:  MOVFF  20,EF
3A36:  MOVLW  07
3A38:  MOVWF  xF6
3A3A:  MOVLW  86
3A3C:  MOVWF  xF5
3A3E:  MOVLW  1F
3A40:  MOVWF  xF4
3A42:  MOVLW  80
3A44:  MOVWF  xF3
3A46:  CALL   0338
3A4A:  BTFSC  18.7
3A4C:  BSF    FF2.7
3A4E:  MOVFF  FEF,D0
3A52:  MOVFF  FEC,D1
3A56:  MOVFF  FEC,D2
3A5A:  MOVFF  FEC,D3
3A5E:  MOVFF  D3,E2
3A62:  MOVFF  D2,E1
3A66:  MOVFF  D1,E0
3A6A:  MOVFF  D0,DF
3A6E:  CALL   2C4E
3A72:  MOVFF  02,D2
3A76:  MOVF   01,W
3A78:  MOVWF  xD1
3A7A:  ANDLW  01
3A7C:  MOVWF  xD3
3A7E:  CLRF   xD4
3A80:  MOVF   xD3,F
3A82:  BNZ   3A98
3A84:  MOVF   xD4,F
3A86:  BNZ   3A98
.................... 				ext_flash_buffer1_write(0xAA,0,255); 
3A88:  MOVLW  AA
3A8A:  MOVWF  xDA
3A8C:  CLRF   xDB
3A8E:  MOVLW  FF
3A90:  MOVWF  xDC
3A92:  CALL   2F02
.................... 			else 
3A96:  BRA    3AA8
.................... 				ext_flash_buffer1_write(0xAA,128,127); 
3A98:  MOVLW  AA
3A9A:  MOVWF  xDA
3A9C:  MOVLW  80
3A9E:  MOVWF  xDB
3AA0:  MOVLW  7F
3AA2:  MOVWF  xDC
3AA4:  CALL   2F02
.................... 		} 
....................  
.................... 		if ((sun_angle == 0xFF) || (sun_angle == 0x00)) // sundown 
3AA8:  INCFSZ xCF,W
3AAA:  BRA    3AAE
3AAC:  BRA    3AB2
3AAE:  MOVF   xCF,F
3AB0:  BNZ   3AB6
.................... 			sun_angle = 180; 
3AB2:  MOVLW  B4
3AB4:  MOVWF  xCF
....................  
.................... 		if (sun_angle != 180) { 
3AB6:  MOVF   xCF,W
3AB8:  SUBLW  B4
3ABA:  BTFSC  FD8.2
3ABC:  BRA    3BFC
.................... 			ext_flash_buffer1_write((int8)(current_measured/n_avg_current_measured),128*(find_day_number(timer_sec%SEC_IN_4_YEARS)%2)+4+index_in_page,1); 
3ABE:  MOVFF  C4,D2
3AC2:  MOVFF  C3,D1
3AC6:  CLRF   xD4
3AC8:  MOVFF  C5,D3
3ACC:  CALL   2DF6
3AD0:  MOVFF  01,D0
3AD4:  CLRF   18
3AD6:  BTFSC  FF2.7
3AD8:  BSF    18.7
3ADA:  BCF    FF2.7
3ADC:  MOVFF  23,F2
3AE0:  MOVFF  22,F1
3AE4:  MOVFF  21,F0
3AE8:  MOVFF  20,EF
3AEC:  MOVLW  07
3AEE:  MOVWF  xF6
3AF0:  MOVLW  86
3AF2:  MOVWF  xF5
3AF4:  MOVLW  1F
3AF6:  MOVWF  xF4
3AF8:  MOVLW  80
3AFA:  MOVWF  xF3
3AFC:  CALL   0338
3B00:  BTFSC  18.7
3B02:  BSF    FF2.7
3B04:  MOVFF  FEF,D1
3B08:  MOVFF  FEC,D2
3B0C:  MOVFF  FEC,D3
3B10:  MOVFF  FEC,D4
3B14:  MOVFF  D4,E2
3B18:  MOVFF  D3,E1
3B1C:  MOVFF  D2,E0
3B20:  MOVFF  D1,DF
3B24:  CALL   2C4E
3B28:  MOVFF  02,D3
3B2C:  MOVF   01,W
3B2E:  MOVWF  xD2
3B30:  ANDLW  01
3B32:  MOVWF  00
3B34:  CLRF   03
3B36:  MOVWF  02
3B38:  RLCF   00,W
3B3A:  MOVWF  xD4
3B3C:  RLCF   03,W
3B3E:  MOVWF  xD5
3B40:  RLCF   xD4,F
3B42:  RLCF   xD5,F
3B44:  RLCF   xD4,F
3B46:  RLCF   xD5,F
3B48:  RLCF   xD4,F
3B4A:  RLCF   xD5,F
3B4C:  RLCF   xD4,F
3B4E:  RLCF   xD5,F
3B50:  RLCF   xD4,F
3B52:  RLCF   xD5,F
3B54:  RLCF   xD4,F
3B56:  RLCF   xD5,F
3B58:  MOVLW  80
3B5A:  ANDWF  xD4,F
3B5C:  MOVLW  04
3B5E:  ADDWF  xD4,W
3B60:  MOVWF  xD6
3B62:  MOVLW  00
3B64:  ADDWFC xD5,W
3B66:  MOVWF  xD7
3B68:  MOVF   xC8,W
3B6A:  ADDWF  xD6,W
3B6C:  MOVWF  xD8
3B6E:  MOVLW  00
3B70:  ADDWFC xD7,W
3B72:  MOVWF  xD9
3B74:  MOVFF  D0,DA
3B78:  MOVFF  D8,DB
3B7C:  MOVLW  01
3B7E:  MOVWF  xDC
3B80:  CALL   2F02
3B84:  CLRF   18
3B86:  BTFSC  FF2.7
3B88:  BSF    18.7
3B8A:  BCF    FF2.7
.................... 			ext_flash_write_buffer1_to_main_memory(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
3B8C:  MOVFF  23,F2
3B90:  MOVFF  22,F1
3B94:  MOVFF  21,F0
3B98:  MOVFF  20,EF
3B9C:  MOVLW  07
3B9E:  MOVWF  xF6
3BA0:  MOVLW  86
3BA2:  MOVWF  xF5
3BA4:  MOVLW  1F
3BA6:  MOVWF  xF4
3BA8:  MOVLW  80
3BAA:  MOVWF  xF3
3BAC:  CALL   0338
3BB0:  BTFSC  18.7
3BB2:  BSF    FF2.7
3BB4:  MOVFF  FEF,D0
3BB8:  MOVFF  FEC,D1
3BBC:  MOVFF  FEC,D2
3BC0:  MOVFF  FEC,D3
3BC4:  MOVFF  D3,E2
3BC8:  MOVFF  D2,E1
3BCC:  MOVFF  D1,E0
3BD0:  MOVFF  D0,DF
3BD4:  CALL   2C4E
3BD8:  MOVFF  02,D2
3BDC:  MOVFF  01,D1
3BE0:  BCF    FD8.0
3BE2:  RRCF   02,W
3BE4:  MOVWF  03
3BE6:  RRCF   01,W
3BE8:  MOVWF  02
3BEA:  ADDLW  F2
3BEC:  MOVWF  xD3
3BEE:  MOVLW  03
3BF0:  ADDWFC 03,W
3BF2:  MOVWF  xD4
3BF4:  MOVWF  xD6
3BF6:  MOVFF  D3,D5
3BFA:  BRA    3836
.................... 		} 
.................... 		strcpy(tmp_str,"#     "); 
3BFC:  CLRF   FEA
3BFE:  MOVLW  2C
3C00:  MOVWF  FE9
3C02:  MOVFF  FF2,D0
3C06:  BCF    FF2.7
3C08:  MOVLW  00
3C0A:  CALL   014E
3C0E:  TBLRD*-
3C10:  TBLRD*+
3C12:  MOVF   FF5,W
3C14:  MOVWF  FEE
3C16:  IORLW  00
3C18:  BNZ   3C10
3C1A:  BTFSC  xD0.7
3C1C:  BSF    FF2.7
3C1E:  CLRF   18
3C20:  BTFSC  FF2.7
3C22:  BSF    18.7
3C24:  BCF    FF2.7
.................... 		itoa((int16)find_day_number(timer_sec%SEC_IN_4_YEARS),10,tmp_str2); 
3C26:  MOVFF  23,F2
3C2A:  MOVFF  22,F1
3C2E:  MOVFF  21,F0
3C32:  MOVFF  20,EF
3C36:  MOVLW  07
3C38:  MOVWF  xF6
3C3A:  MOVLW  86
3C3C:  MOVWF  xF5
3C3E:  MOVLW  1F
3C40:  MOVWF  xF4
3C42:  MOVLW  80
3C44:  MOVWF  xF3
3C46:  CALL   0338
3C4A:  BTFSC  18.7
3C4C:  BSF    FF2.7
3C4E:  MOVFF  FEF,D0
3C52:  MOVFF  FEC,D1
3C56:  MOVFF  FEC,D2
3C5A:  MOVFF  FEC,D3
3C5E:  MOVFF  D3,E2
3C62:  MOVFF  D2,E1
3C66:  MOVFF  D1,E0
3C6A:  MOVFF  D0,DF
3C6E:  CALL   2C4E
3C72:  MOVFF  02,D2
3C76:  MOVFF  01,D1
3C7A:  CLRF   xEB
3C7C:  CLRF   xEA
3C7E:  MOVFF  02,E9
3C82:  MOVFF  01,E8
3C86:  MOVLW  0A
3C88:  MOVWF  xEC
3C8A:  CLRF   xEE
3C8C:  MOVLW  40
3C8E:  MOVWF  xED
3C90:  CALL   152C
.................... 		memcpy(tmp_str+4-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3C94:  CLRF   xE5
3C96:  MOVLW  40
3C98:  MOVWF  xE4
3C9A:  CALL   1708
3C9E:  MOVLW  30
3CA0:  BSF    FD8.0
3CA2:  SUBFWB 01,W
3CA4:  MOVWF  xD0
3CA6:  MOVLW  00
3CA8:  BTFSS  FD8.0
3CAA:  DECF   FE8,F
3CAC:  MOVWF  xD1
3CAE:  CLRF   xE5
3CB0:  MOVLW  40
3CB2:  MOVWF  xE4
3CB4:  CALL   1708
3CB8:  MOVFF  01,D2
3CBC:  MOVFF  D1,FEA
3CC0:  MOVFF  D0,FE9
3CC4:  CLRF   FE2
3CC6:  MOVLW  40
3CC8:  MOVWF  FE1
3CCA:  MOVF   01,W
3CCC:  MOVWF  01
3CCE:  BZ    3CD8
3CD0:  MOVFF  FE6,FEE
3CD4:  DECFSZ 01,F
3CD6:  BRA    3CD0
.................... 		lcd_gotoxy(10,0); 
3CD8:  MOVLW  0A
3CDA:  MOVWF  xEC
3CDC:  CLRF   xED
3CDE:  CALL   0CBA
.................... 		lcd_gotoxy(10,0);		 
3CE2:  MOVLW  0A
3CE4:  MOVWF  xEC
3CE6:  CLRF   xED
3CE8:  CALL   0CBA
.................... 		lcd_gotoxy(10,0); 
3CEC:  MOVLW  0A
3CEE:  MOVWF  xEC
3CF0:  CLRF   xED
3CF2:  CALL   0CBA
.................... 		lcd_put_str(tmp_str,strlen(tmp_str)); 
3CF6:  CLRF   xE5
3CF8:  MOVLW  2C
3CFA:  MOVWF  xE4
3CFC:  CALL   1708
3D00:  MOVFF  01,D0
3D04:  CLRF   xE4
3D06:  MOVLW  2C
3D08:  MOVWF  xE3
3D0A:  MOVFF  01,E5
3D0E:  CALL   173A
....................  
.................... 		strcpy(tmp_str,"   "); 
3D12:  CLRF   FEA
3D14:  MOVLW  2C
3D16:  MOVWF  FE9
3D18:  MOVFF  FF2,D0
3D1C:  BCF    FF2.7
3D1E:  MOVLW  00
3D20:  CALL   0110
3D24:  TBLRD*-
3D26:  TBLRD*+
3D28:  MOVF   FF5,W
3D2A:  MOVWF  FEE
3D2C:  IORLW  00
3D2E:  BNZ   3D26
3D30:  BTFSC  xD0.7
3D32:  BSF    FF2.7
.................... 		tmp_str[3]=0xDF; 
3D34:  MOVLW  DF
3D36:  MOVWF  2F
.................... 		itoa((int8)sun_angle,10,tmp_str2); 
3D38:  CLRF   xEB
3D3A:  CLRF   xEA
3D3C:  CLRF   xE9
3D3E:  MOVFF  CF,E8
3D42:  MOVLW  0A
3D44:  MOVWF  xEC
3D46:  CLRF   xEE
3D48:  MOVLW  40
3D4A:  MOVWF  xED
3D4C:  CALL   152C
.................... 		if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3D50:  CLRF   xE5
3D52:  MOVLW  40
3D54:  MOVWF  xE4
3D56:  CALL   1708
3D5A:  MOVF   01,W
3D5C:  SUBLW  03
3D5E:  BNC   3DA4
3D60:  CLRF   xE5
3D62:  MOVLW  40
3D64:  MOVWF  xE4
3D66:  CALL   1708
3D6A:  MOVLW  2F
3D6C:  BSF    FD8.0
3D6E:  SUBFWB 01,W
3D70:  MOVWF  xD0
3D72:  MOVLW  00
3D74:  BTFSS  FD8.0
3D76:  DECF   FE8,F
3D78:  MOVWF  xD1
3D7A:  CLRF   xE5
3D7C:  MOVLW  40
3D7E:  MOVWF  xE4
3D80:  CALL   1708
3D84:  MOVFF  01,D2
3D88:  MOVFF  D1,FEA
3D8C:  MOVFF  D0,FE9
3D90:  CLRF   FE2
3D92:  MOVLW  40
3D94:  MOVWF  FE1
3D96:  MOVF   01,W
3D98:  MOVWF  01
3D9A:  BZ    3DA4
3D9C:  MOVFF  FE6,FEE
3DA0:  DECFSZ 01,F
3DA2:  BRA    3D9C
.................... 	    lcd_gotoxy(10,1); 
3DA4:  MOVLW  0A
3DA6:  MOVWF  xEC
3DA8:  MOVLW  01
3DAA:  MOVWF  xED
3DAC:  CALL   0CBA
.................... 		lcd_put_str(tmp_str,strlen(tmp_str));			 
3DB0:  CLRF   xE5
3DB2:  MOVLW  2C
3DB4:  MOVWF  xE4
3DB6:  CALL   1708
3DBA:  MOVFF  01,D0
3DBE:  CLRF   xE4
3DC0:  MOVLW  2C
3DC2:  MOVWF  xE3
3DC4:  MOVFF  01,E5
3DC8:  CALL   173A
....................  
.................... 		return sun_angle; 
3DCC:  MOVFF  CF,01
....................  
.................... } 
3DD0:  RETLW  00
....................  
.................... unsigned int8 get_backtrack_angle(unsigned int8 alpha) { 
....................  
.................... 	float tan_alpha,ll,dd; 
.................... 	float beta; 
.................... 	ll = PANEL_WIDTH; 
*
598E:  CLRF   xD8
5990:  CLRF   xD7
5992:  MOVLW  20
5994:  MOVWF  xD6
5996:  MOVLW  86
5998:  MOVWF  xD5
.................... 	dd = ROW_SPACING; 
599A:  CLRF   xDC
599C:  CLRF   xDB
599E:  MOVLW  20
59A0:  MOVWF  xDA
59A2:  MOVLW  87
59A4:  MOVWF  xD9
.................... 	tan_alpha = tan( (float) (alpha) *PI/180.0); 
59A6:  MOVLB  1
59A8:  CLRF   x4D
59AA:  MOVFF  D0,14C
59AE:  MOVLB  0
59B0:  CALL   4376
59B4:  MOVFF  00,E1
59B8:  MOVFF  01,E2
59BC:  MOVFF  02,E3
59C0:  MOVFF  03,E4
59C4:  MOVFF  03,14F
59C8:  MOVFF  02,14E
59CC:  MOVFF  01,14D
59D0:  MOVFF  00,14C
59D4:  MOVLW  DB
59D6:  MOVLB  1
59D8:  MOVWF  x53
59DA:  MOVLW  0F
59DC:  MOVWF  x52
59DE:  MOVLW  49
59E0:  MOVWF  x51
59E2:  MOVLW  80
59E4:  MOVWF  x50
59E6:  MOVLB  0
59E8:  CALL   0EC0
59EC:  MOVFF  00,E5
59F0:  MOVFF  01,E6
59F4:  MOVFF  02,E7
59F8:  MOVFF  03,E8
59FC:  MOVFF  03,14B
5A00:  MOVFF  02,14A
5A04:  MOVFF  01,149
5A08:  MOVFF  00,148
5A0C:  MOVLB  1
5A0E:  CLRF   x4F
5A10:  CLRF   x4E
5A12:  MOVLW  34
5A14:  MOVWF  x4D
5A16:  MOVLW  86
5A18:  MOVWF  x4C
5A1A:  MOVLB  0
5A1C:  CALL   0FB6
5A20:  MOVFF  00,E9
5A24:  MOVFF  01,EA
5A28:  MOVFF  02,EB
5A2C:  MOVFF  03,EC
5A30:  MOVFF  03,111
5A34:  MOVFF  02,110
5A38:  MOVFF  01,10F
5A3C:  MOVFF  00,10E
5A40:  CALL   47BE
5A44:  MOVFF  03,D4
5A48:  MOVFF  02,D3
5A4C:  MOVFF  01,D2
5A50:  MOVFF  00,D1
....................  
.................... 	beta = acos(-1*dd/(ll*sqrt(1.0+tan_alpha*tan_alpha))) -atan(-1.0*tan_alpha); 
5A54:  MOVLB  1
5A56:  CLRF   x4F
5A58:  CLRF   x4E
5A5A:  MOVLW  80
5A5C:  MOVWF  x4D
5A5E:  MOVLW  7F
5A60:  MOVWF  x4C
5A62:  MOVFF  DC,153
5A66:  MOVFF  DB,152
5A6A:  MOVFF  DA,151
5A6E:  MOVFF  D9,150
5A72:  MOVLB  0
5A74:  CALL   0EC0
5A78:  MOVFF  00,E1
5A7C:  MOVFF  01,E2
5A80:  MOVFF  02,E3
5A84:  MOVFF  03,E4
5A88:  MOVFF  D4,14F
5A8C:  MOVFF  D3,14E
5A90:  MOVFF  D2,14D
5A94:  MOVFF  D1,14C
5A98:  MOVFF  D4,153
5A9C:  MOVFF  D3,152
5AA0:  MOVFF  D2,151
5AA4:  MOVFF  D1,150
5AA8:  CALL   0EC0
5AAC:  BCF    FD8.1
5AAE:  MOVLB  1
5AB0:  CLRF   x51
5AB2:  CLRF   x50
5AB4:  CLRF   x4F
5AB6:  MOVLW  7F
5AB8:  MOVWF  x4E
5ABA:  MOVFF  03,155
5ABE:  MOVFF  02,154
5AC2:  MOVFF  01,153
5AC6:  MOVFF  00,152
5ACA:  MOVLB  0
5ACC:  CALL   1114
5AD0:  MOVFF  00,E5
5AD4:  MOVFF  01,E6
5AD8:  MOVFF  02,E7
5ADC:  MOVFF  03,E8
5AE0:  MOVFF  03,113
5AE4:  MOVFF  02,112
5AE8:  MOVFF  01,111
5AEC:  MOVFF  00,110
5AF0:  CALL   485C
5AF4:  MOVFF  D8,14F
5AF8:  MOVFF  D7,14E
5AFC:  MOVFF  D6,14D
5B00:  MOVFF  D5,14C
5B04:  MOVFF  03,153
5B08:  MOVFF  02,152
5B0C:  MOVFF  01,151
5B10:  MOVFF  00,150
5B14:  CALL   0EC0
5B18:  MOVFF  E4,14B
5B1C:  MOVFF  E3,14A
5B20:  MOVFF  E2,149
5B24:  MOVFF  E1,148
5B28:  MOVFF  03,14F
5B2C:  MOVFF  02,14E
5B30:  MOVFF  01,14D
5B34:  MOVFF  00,14C
5B38:  CALL   0FB6
5B3C:  MOVFF  00,E6
5B40:  MOVFF  01,E7
5B44:  MOVFF  02,E8
5B48:  MOVFF  03,E9
5B4C:  MOVFF  03,ED
5B50:  MOVFF  02,EC
5B54:  MOVFF  01,EB
5B58:  MOVFF  00,EA
5B5C:  BRA    542E
5B5E:  MOVFF  00,E7
5B62:  MOVFF  01,E8
5B66:  MOVFF  02,E9
5B6A:  MOVFF  03,EA
5B6E:  MOVLB  1
5B70:  CLRF   x4F
5B72:  CLRF   x4E
5B74:  MOVLW  80
5B76:  MOVWF  x4D
5B78:  MOVLW  7F
5B7A:  MOVWF  x4C
5B7C:  MOVFF  D4,153
5B80:  MOVFF  D3,152
5B84:  MOVFF  D2,151
5B88:  MOVFF  D1,150
5B8C:  MOVLB  0
5B8E:  CALL   0EC0
5B92:  MOVFF  00,EB
5B96:  MOVFF  01,EC
5B9A:  MOVFF  02,ED
5B9E:  MOVFF  03,EE
5BA2:  MOVFF  03,109
5BA6:  MOVFF  02,108
5BAA:  MOVFF  01,107
5BAE:  MOVFF  00,106
5BB2:  CALL   3E4C
5BB6:  MOVFF  FEA,ED
5BBA:  MOVFF  FE9,EC
5BBE:  BSF    FD8.1
5BC0:  MOVFF  EA,151
5BC4:  MOVFF  E9,150
5BC8:  MOVFF  E8,14F
5BCC:  MOVFF  E7,14E
5BD0:  MOVFF  03,155
5BD4:  MOVFF  02,154
5BD8:  MOVFF  01,153
5BDC:  MOVFF  00,152
5BE0:  CALL   1114
5BE4:  MOVFF  ED,FEA
5BE8:  MOVFF  EC,FE9
5BEC:  MOVFF  03,E0
5BF0:  MOVFF  02,DF
5BF4:  MOVFF  01,DE
5BF8:  MOVFF  00,DD
.................... 	return fmod(beta,PI)*180.0/PI; 
5BFC:  MOVFF  E0,E4
5C00:  MOVFF  DF,E3
5C04:  MOVFF  DE,E2
5C08:  MOVFF  DD,E1
5C0C:  MOVLW  DB
5C0E:  MOVWF  xE8
5C10:  MOVLW  0F
5C12:  MOVWF  xE7
5C14:  MOVLW  49
5C16:  MOVWF  xE6
5C18:  MOVLW  80
5C1A:  MOVWF  xE5
5C1C:  BRA    5824
5C1E:  MOVFF  00,E1
5C22:  MOVFF  01,E2
5C26:  MOVFF  02,E3
5C2A:  MOVFF  03,E4
5C2E:  MOVFF  03,14F
5C32:  MOVFF  02,14E
5C36:  MOVFF  01,14D
5C3A:  MOVFF  00,14C
5C3E:  MOVLB  1
5C40:  CLRF   x53
5C42:  CLRF   x52
5C44:  MOVLW  34
5C46:  MOVWF  x51
5C48:  MOVLW  86
5C4A:  MOVWF  x50
5C4C:  MOVLB  0
5C4E:  CALL   0EC0
5C52:  MOVFF  00,E5
5C56:  MOVFF  01,E6
5C5A:  MOVFF  02,E7
5C5E:  MOVFF  03,E8
5C62:  MOVFF  03,14B
5C66:  MOVFF  02,14A
5C6A:  MOVFF  01,149
5C6E:  MOVFF  00,148
5C72:  MOVLW  DB
5C74:  MOVLB  1
5C76:  MOVWF  x4F
5C78:  MOVLW  0F
5C7A:  MOVWF  x4E
5C7C:  MOVLW  49
5C7E:  MOVWF  x4D
5C80:  MOVLW  80
5C82:  MOVWF  x4C
5C84:  MOVLB  0
5C86:  CALL   0FB6
5C8A:  MOVFF  03,14B
5C8E:  MOVFF  02,14A
5C92:  MOVFF  01,149
5C96:  MOVFF  00,148
5C9A:  CALL   43AC
5C9E:  MOVF   01,W
.................... } 
5CA0:  RETLW  00
....................  
....................  
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
.................... 		set_timer1(get_timer1()+0x8000); 
*
03B2:  MOVF   FCE,W
03B4:  MOVFF  FCF,03
03B8:  MOVLB  1
03BA:  MOVWF  x63
03BC:  MOVFF  FCF,164
03C0:  MOVLW  80
03C2:  ADDWF  FCF,W
03C4:  MOVWF  FCF
03C6:  MOVFF  163,FCE
.................... 		timer_sec+=1;  
03CA:  MOVLW  01
03CC:  ADDWF  20,F
03CE:  MOVLW  00
03D0:  ADDWFC 21,F
03D2:  ADDWFC 22,F
03D4:  ADDWFC 23,F
.................... 		flag.update_time = true; 
03D6:  BSF    1F.1
.................... 		restart_wdt(); 
03D8:  CLRWDT
.................... 		if ((timer_sec%15) ==0) 
03DA:  MOVFF  23,F2
03DE:  MOVFF  22,F1
03E2:  MOVFF  21,F0
03E6:  MOVFF  20,EF
03EA:  MOVLB  0
03EC:  CLRF   xF6
03EE:  CLRF   xF5
03F0:  CLRF   xF4
03F2:  MOVLW  0F
03F4:  MOVWF  xF3
03F6:  RCALL  0338
03F8:  MOVFF  FEF,163
03FC:  MOVFF  FEC,164
0400:  MOVFF  FEC,165
0404:  MOVFF  FEC,166
0408:  MOVLB  1
040A:  MOVF   x63,F
040C:  BNZ   041C
040E:  MOVF   x64,F
0410:  BNZ   041C
0412:  MOVF   x65,F
0414:  BNZ   041C
0416:  MOVF   x66,F
0418:  BNZ   041C
.................... 			flag.measured_current=true; 
041A:  BSF    1F.7
.................... 		if ((timer_sec%450) ==0) 
041C:  MOVFF  23,F2
0420:  MOVFF  22,F1
0424:  MOVFF  21,F0
0428:  MOVFF  20,EF
042C:  MOVLB  0
042E:  CLRF   xF6
0430:  CLRF   xF5
0432:  MOVLW  01
0434:  MOVWF  xF4
0436:  MOVLW  C2
0438:  MOVWF  xF3
043A:  RCALL  0338
043C:  MOVFF  FEF,163
0440:  MOVFF  FEC,164
0444:  MOVFF  FEC,165
0448:  MOVFF  FEC,166
044C:  MOVLB  1
044E:  MOVF   x63,F
0450:  BNZ   0460
0452:  MOVF   x64,F
0454:  BNZ   0460
0456:  MOVF   x65,F
0458:  BNZ   0460
045A:  MOVF   x66,F
045C:  BNZ   0460
.................... 			flag.task1_armed=true; 
045E:  BSF    1F.0
.................... 		if (timer_sec%300==30) flag.reset_rs232=true; 
0460:  MOVFF  23,F2
0464:  MOVFF  22,F1
0468:  MOVFF  21,F0
046C:  MOVFF  20,EF
0470:  MOVLB  0
0472:  CLRF   xF6
0474:  CLRF   xF5
0476:  MOVLW  01
0478:  MOVWF  xF4
047A:  MOVLW  2C
047C:  MOVWF  xF3
047E:  RCALL  0338
0480:  MOVFF  FEF,163
0484:  MOVFF  FEC,164
0488:  MOVFF  FEC,165
048C:  MOVFF  FEC,166
0490:  MOVLB  1
0492:  MOVF   x63,W
0494:  SUBLW  1E
0496:  BNZ   04A6
0498:  MOVF   x64,F
049A:  BNZ   04A6
049C:  MOVF   x65,F
049E:  BNZ   04A6
04A0:  MOVF   x66,F
04A2:  BTFSC  FD8.2
04A4:  BSF    1F.5
.................... 		if (tx_delay>0) tx_delay--; 
04A6:  MOVLB  0
04A8:  MOVF   xC2,F
04AA:  BTFSS  FD8.2
04AC:  DECF   xC2,F
.................... //		 
.................... } 
....................  
....................  
04AE:  BCF    F9E.0
04B0:  GOTO   0064
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
.................... 	char c; 
....................     c=getc(); 
*
04DC:  BTFSS  F9E.5
04DE:  BRA    04DC
04E0:  MOVFF  FAE,163
04E4:  MOVLB  1
....................     PORTE.tx_en=1; 
04E6:  BSF    F84.2
.................... 	delay_ms(2); 
04E8:  MOVLW  02
04EA:  MOVLB  0
04EC:  MOVWF  xF1
04EE:  RCALL  04B4
....................      if(c==8) {  // Backspace 
04F0:  MOVLB  1
04F2:  MOVF   x63,W
04F4:  SUBLW  08
04F6:  BNZ   0520
....................         if(cmd_len>0) { 
04F8:  MOVLB  0
04FA:  MOVF   x68,F
04FC:  BZ    051C
....................           cmd_len--; 
04FE:  DECF   x68,F
....................           printf("%c",c); 
0500:  MOVLB  1
0502:  MOVF   x63,W
0504:  BTFSS  F9E.4
0506:  BRA    0504
0508:  MOVWF  FAD
....................           printf(" "); 
050A:  MOVLW  20
050C:  BTFSS  F9E.4
050E:  BRA    050C
0510:  MOVWF  FAD
....................           printf("%c",c); 
0512:  MOVF   x63,W
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
051A:  MOVLB  0
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
051C:  BRA    0552
051E:  MOVLB  1
0520:  MOVF   x63,W
0522:  SUBLW  1F
0524:  BC    0552
0526:  MOVF   x63,W
0528:  SUBLW  7E
052A:  BNC   0552
....................        if(cmd_len<=MAX_CMD_LEN) { 
052C:  MOVLB  0
052E:  MOVF   x68,W
0530:  SUBLW  12
0532:  BNC   0552
....................          cmd_msg[cmd_len++]=c; 
0534:  MOVF   x68,W
0536:  INCF   x68,F
0538:  CLRF   03
053A:  ADDLW  54
053C:  MOVWF  FE9
053E:  MOVLW  00
0540:  ADDWFC 03,W
0542:  MOVWF  FEA
0544:  MOVFF  163,FEF
....................          printf("%c",c); 
0548:  MOVLB  1
054A:  MOVF   x63,W
054C:  BTFSS  F9E.4
054E:  BRA    054C
0550:  MOVWF  FAD
....................        }  
....................     if (c==13) {  
0552:  MOVLB  1
0554:  MOVF   x63,W
0556:  SUBLW  0D
0558:  BNZ   058E
.................... 	printf("\r\n>"); 
055A:  MOVLW  0D
055C:  BTFSS  F9E.4
055E:  BRA    055C
0560:  MOVWF  FAD
0562:  MOVLW  0A
0564:  BTFSS  F9E.4
0566:  BRA    0564
0568:  MOVWF  FAD
056A:  MOVLW  3E
056C:  BTFSS  F9E.4
056E:  BRA    056C
0570:  MOVWF  FAD
....................     //PORTE.tx_en=0; 
.................... 	cmd_msg[cmd_len]=0; 
0572:  CLRF   03
0574:  MOVLB  0
0576:  MOVF   x68,W
0578:  ADDLW  54
057A:  MOVWF  FE9
057C:  MOVLW  00
057E:  ADDWFC 03,W
0580:  MOVWF  FEA
0582:  CLRF   FEF
.................... 	if(cmd_len>1)flag.cmd_posted=true; 
0584:  MOVF   x68,W
0586:  SUBLW  01
0588:  BTFSS  FD8.0
058A:  BSF    1F.3
.................... 	cmd_len =0; 
058C:  CLRF   x68
....................   } 
.................... 	tx_delay=TX_DLY_TIME; 
058E:  MOVLW  01
0590:  MOVLB  0
0592:  MOVWF  xC2
....................  
.................... } 
....................  
0594:  BCF    F9E.5
0596:  GOTO   0064
.................... float actuator_length(int8 sun_angle) { 
.................... // return actuator length in cm at given sun_angle 
.................... float len_a,len_b,len_c,len_p,len_m,len_k,len_l; 
.................... float sin_beta,cos_beta,tan_beta; 
.................... float temp1; 
.................... float alpha; 
.................... //if (sun_angle < 30) return; 
.................... //if (sun_angle > 150) return; 
.................... len_a = DIM_A; 
*
4986:  CLRF   xD5
4988:  CLRF   xD4
498A:  MOVLW  57
498C:  MOVWF  xD3
498E:  MOVLW  85
4990:  MOVWF  xD2
.................... len_b = DIM_B; 
4992:  MOVLW  CD
4994:  MOVWF  xD9
4996:  MOVLW  CC
4998:  MOVWF  xD8
499A:  MOVLW  7C
499C:  MOVWF  xD7
499E:  MOVLW  82
49A0:  MOVWF  xD6
.................... len_p = DIM_P; 
49A2:  MOVLW  CD
49A4:  MOVWF  xE1
49A6:  MOVLW  CC
49A8:  MOVWF  xE0
49AA:  MOVLW  14
49AC:  MOVWF  xDF
49AE:  MOVLW  82
49B0:  MOVWF  xDE
.................... len_k = DIM_K; 
49B2:  CLRF   xE9
49B4:  CLRF   xE8
49B6:  MOVLW  10
49B8:  MOVWF  xE7
49BA:  MOVLW  84
49BC:  MOVWF  xE6
.................... len_m = DIM_M; 
49BE:  CLRF   xE5
49C0:  CLRF   xE4
49C2:  MOVLW  30
49C4:  MOVWF  xE3
49C6:  MOVLW  81
49C8:  MOVWF  xE2
.................... len_p = DIM_P; 
49CA:  MOVLW  CD
49CC:  MOVWF  xE1
49CE:  MOVLW  CC
49D0:  MOVWF  xE0
49D2:  MOVLW  14
49D4:  MOVWF  xDF
49D6:  MOVLW  82
49D8:  MOVWF  xDE
.................... alpha = atan(len_b/len_k); 
49DA:  MOVFF  D9,14B
49DE:  MOVFF  D8,14A
49E2:  MOVFF  D7,149
49E6:  MOVFF  D6,148
49EA:  MOVFF  E9,14F
49EE:  MOVFF  E8,14E
49F2:  MOVFF  E7,14D
49F6:  MOVFF  E6,14C
49FA:  CALL   0FB6
49FE:  MOVFF  00,102
4A02:  MOVFF  01,103
4A06:  MOVFF  02,104
4A0A:  MOVFF  03,105
4A0E:  MOVFF  03,109
4A12:  MOVFF  02,108
4A16:  MOVFF  01,107
4A1A:  MOVFF  00,106
4A1E:  CALL   3E4C
4A22:  MOVFF  03,101
4A26:  MOVFF  02,100
4A2A:  MOVFF  01,FF
4A2E:  MOVFF  00,FE
.................... sin_beta = sin((sun_angle*PI/180.0)-alpha); 
4A32:  MOVLB  1
4A34:  CLRF   x4D
4A36:  MOVFF  D1,14C
4A3A:  MOVLB  0
4A3C:  RCALL  4376
4A3E:  MOVFF  03,14F
4A42:  MOVFF  02,14E
4A46:  MOVFF  01,14D
4A4A:  MOVFF  00,14C
4A4E:  MOVLW  DB
4A50:  MOVLB  1
4A52:  MOVWF  x53
4A54:  MOVLW  0F
4A56:  MOVWF  x52
4A58:  MOVLW  49
4A5A:  MOVWF  x51
4A5C:  MOVLW  80
4A5E:  MOVWF  x50
4A60:  MOVLB  0
4A62:  CALL   0EC0
4A66:  MOVFF  00,102
4A6A:  MOVFF  01,103
4A6E:  MOVFF  02,104
4A72:  MOVFF  03,105
4A76:  MOVFF  03,14B
4A7A:  MOVFF  02,14A
4A7E:  MOVFF  01,149
4A82:  MOVFF  00,148
4A86:  MOVLB  1
4A88:  CLRF   x4F
4A8A:  CLRF   x4E
4A8C:  MOVLW  34
4A8E:  MOVWF  x4D
4A90:  MOVLW  86
4A92:  MOVWF  x4C
4A94:  MOVLB  0
4A96:  CALL   0FB6
4A9A:  MOVFF  00,106
4A9E:  MOVFF  01,107
4AA2:  MOVFF  02,108
4AA6:  MOVFF  03,109
4AAA:  BSF    FD8.1
4AAC:  MOVFF  03,151
4AB0:  MOVFF  02,150
4AB4:  MOVFF  01,14F
4AB8:  MOVFF  00,14E
4ABC:  MOVFF  101,155
4AC0:  MOVFF  100,154
4AC4:  MOVFF  FF,153
4AC8:  MOVFF  FE,152
4ACC:  CALL   1114
4AD0:  MOVFF  00,10A
4AD4:  MOVFF  01,10B
4AD8:  MOVFF  02,10C
4ADC:  MOVFF  03,10D
4AE0:  MOVFF  03,11D
4AE4:  MOVFF  02,11C
4AE8:  MOVFF  01,11B
4AEC:  MOVFF  00,11A
4AF0:  RCALL  4770
4AF2:  MOVFF  03,F1
4AF6:  MOVFF  02,F0
4AFA:  MOVFF  01,EF
4AFE:  MOVFF  00,EE
.................... cos_beta = cos((sun_angle*PI/180.0)-alpha); 
4B02:  MOVLB  1
4B04:  CLRF   x4D
4B06:  MOVFF  D1,14C
4B0A:  MOVLB  0
4B0C:  RCALL  4376
4B0E:  MOVFF  03,14F
4B12:  MOVFF  02,14E
4B16:  MOVFF  01,14D
4B1A:  MOVFF  00,14C
4B1E:  MOVLW  DB
4B20:  MOVLB  1
4B22:  MOVWF  x53
4B24:  MOVLW  0F
4B26:  MOVWF  x52
4B28:  MOVLW  49
4B2A:  MOVWF  x51
4B2C:  MOVLW  80
4B2E:  MOVWF  x50
4B30:  MOVLB  0
4B32:  CALL   0EC0
4B36:  MOVFF  00,102
4B3A:  MOVFF  01,103
4B3E:  MOVFF  02,104
4B42:  MOVFF  03,105
4B46:  MOVFF  03,14B
4B4A:  MOVFF  02,14A
4B4E:  MOVFF  01,149
4B52:  MOVFF  00,148
4B56:  MOVLB  1
4B58:  CLRF   x4F
4B5A:  CLRF   x4E
4B5C:  MOVLW  34
4B5E:  MOVWF  x4D
4B60:  MOVLW  86
4B62:  MOVWF  x4C
4B64:  MOVLB  0
4B66:  CALL   0FB6
4B6A:  MOVFF  00,106
4B6E:  MOVFF  01,107
4B72:  MOVFF  02,108
4B76:  MOVFF  03,109
4B7A:  BSF    FD8.1
4B7C:  MOVFF  03,151
4B80:  MOVFF  02,150
4B84:  MOVFF  01,14F
4B88:  MOVFF  00,14E
4B8C:  MOVFF  101,155
4B90:  MOVFF  100,154
4B94:  MOVFF  FF,153
4B98:  MOVFF  FE,152
4B9C:  CALL   1114
4BA0:  MOVFF  00,10A
4BA4:  MOVFF  01,10B
4BA8:  MOVFF  02,10C
4BAC:  MOVFF  03,10D
4BB0:  MOVFF  03,125
4BB4:  MOVFF  02,124
4BB8:  MOVFF  01,123
4BBC:  MOVFF  00,122
4BC0:  RCALL  43E8
4BC2:  MOVFF  03,F5
4BC6:  MOVFF  02,F4
4BCA:  MOVFF  01,F3
4BCE:  MOVFF  00,F2
.................... tan_beta = tan((sun_angle*PI/180.0)-alpha); 
4BD2:  MOVLB  1
4BD4:  CLRF   x4D
4BD6:  MOVFF  D1,14C
4BDA:  MOVLB  0
4BDC:  CALL   4376
4BE0:  MOVFF  03,14F
4BE4:  MOVFF  02,14E
4BE8:  MOVFF  01,14D
4BEC:  MOVFF  00,14C
4BF0:  MOVLW  DB
4BF2:  MOVLB  1
4BF4:  MOVWF  x53
4BF6:  MOVLW  0F
4BF8:  MOVWF  x52
4BFA:  MOVLW  49
4BFC:  MOVWF  x51
4BFE:  MOVLW  80
4C00:  MOVWF  x50
4C02:  MOVLB  0
4C04:  CALL   0EC0
4C08:  MOVFF  00,102
4C0C:  MOVFF  01,103
4C10:  MOVFF  02,104
4C14:  MOVFF  03,105
4C18:  MOVFF  03,14B
4C1C:  MOVFF  02,14A
4C20:  MOVFF  01,149
4C24:  MOVFF  00,148
4C28:  MOVLB  1
4C2A:  CLRF   x4F
4C2C:  CLRF   x4E
4C2E:  MOVLW  34
4C30:  MOVWF  x4D
4C32:  MOVLW  86
4C34:  MOVWF  x4C
4C36:  MOVLB  0
4C38:  CALL   0FB6
4C3C:  MOVFF  00,106
4C40:  MOVFF  01,107
4C44:  MOVFF  02,108
4C48:  MOVFF  03,109
4C4C:  BSF    FD8.1
4C4E:  MOVFF  03,151
4C52:  MOVFF  02,150
4C56:  MOVFF  01,14F
4C5A:  MOVFF  00,14E
4C5E:  MOVFF  101,155
4C62:  MOVFF  100,154
4C66:  MOVFF  FF,153
4C6A:  MOVFF  FE,152
4C6E:  CALL   1114
4C72:  MOVFF  00,10A
4C76:  MOVFF  01,10B
4C7A:  MOVFF  02,10C
4C7E:  MOVFF  03,10D
4C82:  MOVFF  03,111
4C86:  MOVFF  02,110
4C8A:  MOVFF  01,10F
4C8E:  MOVFF  00,10E
4C92:  RCALL  47BE
4C94:  MOVFF  03,F9
4C98:  MOVFF  02,F8
4C9C:  MOVFF  01,F7
4CA0:  MOVFF  00,F6
....................  
....................  
.................... len_c = sqrt(len_k*len_k+len_b*len_b)-len_p/sin_beta; 
4CA4:  MOVFF  E9,14F
4CA8:  MOVFF  E8,14E
4CAC:  MOVFF  E7,14D
4CB0:  MOVFF  E6,14C
4CB4:  MOVFF  E9,153
4CB8:  MOVFF  E8,152
4CBC:  MOVFF  E7,151
4CC0:  MOVFF  E6,150
4CC4:  CALL   0EC0
4CC8:  MOVFF  00,102
4CCC:  MOVFF  01,103
4CD0:  MOVFF  02,104
4CD4:  MOVFF  03,105
4CD8:  MOVFF  D9,14F
4CDC:  MOVFF  D8,14E
4CE0:  MOVFF  D7,14D
4CE4:  MOVFF  D6,14C
4CE8:  MOVFF  D9,153
4CEC:  MOVFF  D8,152
4CF0:  MOVFF  D7,151
4CF4:  MOVFF  D6,150
4CF8:  CALL   0EC0
4CFC:  BCF    FD8.1
4CFE:  MOVFF  105,151
4D02:  MOVFF  104,150
4D06:  MOVFF  103,14F
4D0A:  MOVFF  102,14E
4D0E:  MOVFF  03,155
4D12:  MOVFF  02,154
4D16:  MOVFF  01,153
4D1A:  MOVFF  00,152
4D1E:  CALL   1114
4D22:  MOVFF  00,106
4D26:  MOVFF  01,107
4D2A:  MOVFF  02,108
4D2E:  MOVFF  03,109
4D32:  MOVFF  03,113
4D36:  MOVFF  02,112
4D3A:  MOVFF  01,111
4D3E:  MOVFF  00,110
4D42:  RCALL  485C
4D44:  MOVFF  00,107
4D48:  MOVFF  01,108
4D4C:  MOVFF  02,109
4D50:  MOVFF  03,10A
4D54:  MOVFF  E1,14B
4D58:  MOVFF  E0,14A
4D5C:  MOVFF  DF,149
4D60:  MOVFF  DE,148
4D64:  MOVFF  F1,14F
4D68:  MOVFF  F0,14E
4D6C:  MOVFF  EF,14D
4D70:  MOVFF  EE,14C
4D74:  CALL   0FB6
4D78:  MOVFF  FEA,10C
4D7C:  MOVFF  FE9,10B
4D80:  BSF    FD8.1
4D82:  MOVFF  10A,151
4D86:  MOVFF  109,150
4D8A:  MOVFF  108,14F
4D8E:  MOVFF  107,14E
4D92:  MOVFF  03,155
4D96:  MOVFF  02,154
4D9A:  MOVFF  01,153
4D9E:  MOVFF  00,152
4DA2:  CALL   1114
4DA6:  MOVFF  10C,FEA
4DAA:  MOVFF  10B,FE9
4DAE:  MOVFF  03,DD
4DB2:  MOVFF  02,DC
4DB6:  MOVFF  01,DB
4DBA:  MOVFF  00,DA
.................... temp1 = len_a - (len_p/tan_beta)-len_c*cos_beta; 
4DBE:  MOVFF  E1,14B
4DC2:  MOVFF  E0,14A
4DC6:  MOVFF  DF,149
4DCA:  MOVFF  DE,148
4DCE:  MOVFF  F9,14F
4DD2:  MOVFF  F8,14E
4DD6:  MOVFF  F7,14D
4DDA:  MOVFF  F6,14C
4DDE:  CALL   0FB6
4DE2:  BSF    FD8.1
4DE4:  MOVFF  D5,151
4DE8:  MOVFF  D4,150
4DEC:  MOVFF  D3,14F
4DF0:  MOVFF  D2,14E
4DF4:  MOVFF  03,155
4DF8:  MOVFF  02,154
4DFC:  MOVFF  01,153
4E00:  MOVFF  00,152
4E04:  CALL   1114
4E08:  MOVFF  00,102
4E0C:  MOVFF  01,103
4E10:  MOVFF  02,104
4E14:  MOVFF  03,105
4E18:  MOVFF  DD,14F
4E1C:  MOVFF  DC,14E
4E20:  MOVFF  DB,14D
4E24:  MOVFF  DA,14C
4E28:  MOVFF  F5,153
4E2C:  MOVFF  F4,152
4E30:  MOVFF  F3,151
4E34:  MOVFF  F2,150
4E38:  CALL   0EC0
4E3C:  BSF    FD8.1
4E3E:  MOVFF  105,151
4E42:  MOVFF  104,150
4E46:  MOVFF  103,14F
4E4A:  MOVFF  102,14E
4E4E:  MOVFF  03,155
4E52:  MOVFF  02,154
4E56:  MOVFF  01,153
4E5A:  MOVFF  00,152
4E5E:  CALL   1114
4E62:  MOVFF  03,FD
4E66:  MOVFF  02,FC
4E6A:  MOVFF  01,FB
4E6E:  MOVFF  00,FA
.................... len_l = len_c*sin_beta*len_c*sin_beta+temp1*temp1-len_m*len_m; 
4E72:  MOVFF  DD,14F
4E76:  MOVFF  DC,14E
4E7A:  MOVFF  DB,14D
4E7E:  MOVFF  DA,14C
4E82:  MOVFF  F1,153
4E86:  MOVFF  F0,152
4E8A:  MOVFF  EF,151
4E8E:  MOVFF  EE,150
4E92:  CALL   0EC0
4E96:  MOVFF  00,102
4E9A:  MOVFF  01,103
4E9E:  MOVFF  02,104
4EA2:  MOVFF  03,105
4EA6:  MOVFF  03,14F
4EAA:  MOVFF  02,14E
4EAE:  MOVFF  01,14D
4EB2:  MOVFF  00,14C
4EB6:  MOVFF  DD,153
4EBA:  MOVFF  DC,152
4EBE:  MOVFF  DB,151
4EC2:  MOVFF  DA,150
4EC6:  CALL   0EC0
4ECA:  MOVFF  00,106
4ECE:  MOVFF  01,107
4ED2:  MOVFF  02,108
4ED6:  MOVFF  03,109
4EDA:  MOVFF  03,14F
4EDE:  MOVFF  02,14E
4EE2:  MOVFF  01,14D
4EE6:  MOVFF  00,14C
4EEA:  MOVFF  F1,153
4EEE:  MOVFF  F0,152
4EF2:  MOVFF  EF,151
4EF6:  MOVFF  EE,150
4EFA:  CALL   0EC0
4EFE:  MOVFF  00,10A
4F02:  MOVFF  01,10B
4F06:  MOVFF  02,10C
4F0A:  MOVFF  03,10D
4F0E:  MOVFF  FD,14F
4F12:  MOVFF  FC,14E
4F16:  MOVFF  FB,14D
4F1A:  MOVFF  FA,14C
4F1E:  MOVFF  FD,153
4F22:  MOVFF  FC,152
4F26:  MOVFF  FB,151
4F2A:  MOVFF  FA,150
4F2E:  CALL   0EC0
4F32:  BCF    FD8.1
4F34:  MOVFF  10D,151
4F38:  MOVFF  10C,150
4F3C:  MOVFF  10B,14F
4F40:  MOVFF  10A,14E
4F44:  MOVFF  03,155
4F48:  MOVFF  02,154
4F4C:  MOVFF  01,153
4F50:  MOVFF  00,152
4F54:  CALL   1114
4F58:  MOVFF  00,10E
4F5C:  MOVFF  01,10F
4F60:  MOVFF  02,110
4F64:  MOVFF  03,111
4F68:  MOVFF  E5,14F
4F6C:  MOVFF  E4,14E
4F70:  MOVFF  E3,14D
4F74:  MOVFF  E2,14C
4F78:  MOVFF  E5,153
4F7C:  MOVFF  E4,152
4F80:  MOVFF  E3,151
4F84:  MOVFF  E2,150
4F88:  CALL   0EC0
4F8C:  BSF    FD8.1
4F8E:  MOVFF  111,151
4F92:  MOVFF  110,150
4F96:  MOVFF  10F,14F
4F9A:  MOVFF  10E,14E
4F9E:  MOVFF  03,155
4FA2:  MOVFF  02,154
4FA6:  MOVFF  01,153
4FAA:  MOVFF  00,152
4FAE:  CALL   1114
4FB2:  MOVFF  03,ED
4FB6:  MOVFF  02,EC
4FBA:  MOVFF  01,EB
4FBE:  MOVFF  00,EA
.................... len_l = sqrt(len_l); 
4FC2:  MOVFF  ED,113
4FC6:  MOVFF  EC,112
4FCA:  MOVFF  EB,111
4FCE:  MOVFF  EA,110
4FD2:  RCALL  485C
4FD4:  MOVFF  03,ED
4FD8:  MOVFF  02,EC
4FDC:  MOVFF  01,EB
4FE0:  MOVFF  00,EA
....................  
.................... if (len_l<50.0) 
4FE4:  MOVFF  ED,14B
4FE8:  MOVFF  EC,14A
4FEC:  MOVFF  EB,149
4FF0:  MOVFF  EA,148
4FF4:  MOVLB  1
4FF6:  CLRF   x4F
4FF8:  CLRF   x4E
4FFA:  MOVLW  48
4FFC:  MOVWF  x4D
4FFE:  MOVLW  84
5000:  MOVWF  x4C
5002:  MOVLB  0
5004:  CALL   3DD2
5008:  BNC   5014
.................... 	return 0.0; 
500A:  CLRF   00
500C:  CLRF   01
500E:  CLRF   02
5010:  CLRF   03
5012:  BRA    5024
....................  
.................... return len_l; 
5014:  MOVFF  EA,00
5018:  MOVFF  EB,01
501C:  MOVFF  EC,02
5020:  MOVFF  ED,03
.................... } 
5024:  RETLW  00
....................  
.................... void process_cmd_msg(){ 
....................     flag.cmd_posted =false; 
*
2F60:  BCF    1F.3
.................... 	switch (cmd_msg[0]) { 
2F62:  MOVLW  63
2F64:  SUBWF  54,W
2F66:  ADDLW  E9
2F68:  BTFSC  FD8.0
2F6A:  BRA    35B2
2F6C:  ADDLW  17
2F6E:  GOTO   35B4
.................... 		case 'm':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2F72:  CLRF   FEA
2F74:  MOVLW  54
2F76:  MOVWF  FE9
2F78:  CLRF   FE2
2F7A:  MOVLW  55
2F7C:  MOVWF  FE1
2F7E:  MOVLW  12
2F80:  MOVWF  01
2F82:  MOVFF  FE6,FEE
2F86:  DECFSZ 01,F
2F88:  BRA    2F82
....................         	if (atol(cmd_msg)==0) break; 
2F8A:  CLRF   xD0
2F8C:  MOVLW  54
2F8E:  MOVWF  xCF
2F90:  CALL   0AD2
2F94:  MOVFF  02,D0
2F98:  MOVFF  01,CF
2F9C:  MOVF   xCF,F
2F9E:  BNZ   2FA6
2FA0:  MOVF   xD0,F
2FA2:  BNZ   2FA6
2FA4:  BRA    35B2
.................... 			move_act(atol(cmd_msg),9000,move_act_time_out*2,1,0); 
2FA6:  CLRF   xD0
2FA8:  MOVLW  54
2FAA:  MOVWF  xCF
2FAC:  CALL   0AD2
2FB0:  MOVFF  02,D0
2FB4:  MOVFF  01,CF
2FB8:  BCF    FD8.0
2FBA:  RLCF   xC0,W
2FBC:  MOVWF  xD1
2FBE:  RLCF   xC1,W
2FC0:  MOVWF  xD2
2FC2:  MOVFF  02,D4
2FC6:  MOVFF  01,D3
2FCA:  MOVLW  23
2FCC:  MOVWF  xD6
2FCE:  MOVLW  28
2FD0:  MOVWF  xD5
2FD2:  MOVFF  D2,D8
2FD6:  MOVFF  D1,D7
2FDA:  MOVLW  01
2FDC:  MOVWF  xD9
2FDE:  CLRF   xDA
2FE0:  CALL   222A
.................... 			break; 	} 
2FE4:  BRA    35B2
....................  
.................... 		case 'n':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
2FE6:  CLRF   FEA
2FE8:  MOVLW  54
2FEA:  MOVWF  FE9
2FEC:  CLRF   FE2
2FEE:  MOVLW  55
2FF0:  MOVWF  FE1
2FF2:  MOVLW  12
2FF4:  MOVWF  01
2FF6:  MOVFF  FE6,FEE
2FFA:  DECFSZ 01,F
2FFC:  BRA    2FF6
....................         	if (atol(cmd_msg)==0) break; 
2FFE:  CLRF   xD0
3000:  MOVLW  54
3002:  MOVWF  xCF
3004:  CALL   0AD2
3008:  MOVFF  02,D0
300C:  MOVFF  01,CF
3010:  MOVF   xCF,F
3012:  BNZ   301A
3014:  MOVF   xD0,F
3016:  BNZ   301A
3018:  BRA    35B2
.................... 			move_act(atol(cmd_msg),9000,move_act_time_out*2,0,0); 
301A:  CLRF   xD0
301C:  MOVLW  54
301E:  MOVWF  xCF
3020:  CALL   0AD2
3024:  MOVFF  02,D0
3028:  MOVFF  01,CF
302C:  BCF    FD8.0
302E:  RLCF   xC0,W
3030:  MOVWF  xD1
3032:  RLCF   xC1,W
3034:  MOVWF  xD2
3036:  MOVFF  02,D4
303A:  MOVFF  01,D3
303E:  MOVLW  23
3040:  MOVWF  xD6
3042:  MOVLW  28
3044:  MOVWF  xD5
3046:  MOVFF  D2,D8
304A:  MOVFF  D1,D7
304E:  CLRF   xD9
3050:  CLRF   xDA
3052:  CALL   222A
.................... 			break; 	} 
3056:  BRA    35B2
.................... /* 
.................... 		case 'x':{ 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
....................         	if (atol(cmd_msg)==1) { 
.................... 				setup_timer_0(RTCC_DIV_32); 
.................... 				move_act_time_out =4; 
.................... 			} else if(atol(cmd_msg)==2) { 
.................... 				setup_timer_0(RTCC_DIV_1); 
.................... 				move_act_time_out =128; 
.................... 			} 
.................... 			break; 	}	 
.................... */	 
.................... 		case 'd':{  
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
3058:  CLRF   FEA
305A:  MOVLW  54
305C:  MOVWF  FE9
305E:  CLRF   FE2
3060:  MOVLW  55
3062:  MOVWF  FE1
3064:  MOVLW  12
3066:  MOVWF  01
3068:  MOVFF  FE6,FEE
306C:  DECFSZ 01,F
306E:  BRA    3068
....................         	if (atol(cmd_msg)==0) break; 
3070:  CLRF   xD0
3072:  MOVLW  54
3074:  MOVWF  xCF
3076:  CALL   0AD2
307A:  MOVFF  02,D0
307E:  MOVFF  01,CF
3082:  MOVF   xCF,F
3084:  BNZ   308C
3086:  MOVF   xD0,F
3088:  BNZ   308C
308A:  BRA    35B2
.................... 			PORTE.tx_en=1; 
308C:  BSF    F84.2
.................... 			printf("\r\n DL %ld pages ..",atol(cmd_msg)); 
308E:  CLRF   xD0
3090:  MOVLW  54
3092:  MOVWF  xCF
3094:  CALL   0AD2
3098:  MOVFF  02,D0
309C:  MOVFF  01,CF
30A0:  CLRF   xD1
30A2:  MOVF   xD1,W
30A4:  CALL   0170
30A8:  INCF   xD1,F
30AA:  MOVWF  00
30AC:  MOVF   00,W
30AE:  BTFSS  F9E.4
30B0:  BRA    30AE
30B2:  MOVWF  FAD
30B4:  MOVLW  06
30B6:  SUBWF  xD1,W
30B8:  BNZ   30A2
30BA:  MOVLW  10
30BC:  MOVWF  FE9
30BE:  MOVFF  D0,D3
30C2:  MOVFF  CF,D2
30C6:  CALL   2476
30CA:  MOVLW  09
30CC:  MOVWF  xD2
30CE:  MOVF   xD2,W
30D0:  CALL   0170
30D4:  INCF   xD2,F
30D6:  MOVWF  00
30D8:  MOVF   00,W
30DA:  BTFSS  F9E.4
30DC:  BRA    30DA
30DE:  MOVWF  FAD
30E0:  MOVLW  12
30E2:  SUBWF  xD2,W
30E4:  BNZ   30CE
.................... 			tx_delay=TX_DLY_TIME; 
30E6:  MOVLW  01
30E8:  MOVWF  xC2
....................         	download_sun_table(atol(cmd_msg)); 
30EA:  CLRF   xD0
30EC:  MOVLW  54
30EE:  MOVWF  xCF
30F0:  CALL   0AD2
30F4:  MOVFF  02,D0
30F8:  MOVFF  01,CF
30FC:  MOVFF  02,D2
3100:  MOVFF  01,D1
3104:  GOTO   26F6
.................... 			break; 	} 
.................... 		case 'r': { 
.................... 			disable_interrupts(GLOBAL); 
3108:  BCF    FF2.6
310A:  BCF    FF2.7
310C:  BTFSC  FF2.7
310E:  BRA    310A
.................... 			restart_wdt(); 
3110:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
3112:  BCF    FD1.0
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
3114:  CLRF   FEA
3116:  MOVLW  54
3118:  MOVWF  FE9
311A:  CLRF   FE2
311C:  MOVLW  55
311E:  MOVWF  FE1
3120:  MOVLW  12
3122:  MOVWF  01
3124:  MOVFF  FE6,FEE
3128:  DECFSZ 01,F
312A:  BRA    3124
.................... 			PORTE.tx_en=1; 
312C:  BSF    F84.2
.................... 			printf("\r\n PAGE %ld:",atol(cmd_msg)); 
312E:  CLRF   xD0
3130:  MOVLW  54
3132:  MOVWF  xCF
3134:  CALL   0AD2
3138:  MOVFF  02,D0
313C:  MOVFF  01,CF
3140:  CLRF   xD1
3142:  MOVF   xD1,W
3144:  CALL   019E
3148:  INCF   xD1,F
314A:  MOVWF  00
314C:  MOVF   00,W
314E:  BTFSS  F9E.4
3150:  BRA    314E
3152:  MOVWF  FAD
3154:  MOVLW  08
3156:  SUBWF  xD1,W
3158:  BNZ   3142
315A:  MOVLW  10
315C:  MOVWF  FE9
315E:  MOVFF  D0,D3
3162:  MOVFF  CF,D2
3166:  CALL   2476
316A:  MOVLW  3A
316C:  BTFSS  F9E.4
316E:  BRA    316C
3170:  MOVWF  FAD
.................... 			tx_delay=TX_DLY_TIME; 
3172:  MOVLW  01
3174:  MOVWF  xC2
.................... 			print_page_data(atol(cmd_msg)); 
3176:  CLRF   xD0
3178:  MOVLW  54
317A:  MOVWF  xCF
317C:  CALL   0AD2
3180:  MOVFF  02,D0
3184:  MOVFF  01,CF
3188:  MOVFF  02,D2
318C:  MOVFF  01,D1
3190:  GOTO   28D6
.................... 			enable_interrupts(GLOBAL); 
3194:  MOVLW  C0
3196:  IORWF  FF2,F
.................... 			restart_wdt(); 
3198:  CLRWDT
.................... 			setup_wdt(WDT_ON); 
319A:  BSF    FD1.0
....................             break; } 
319C:  BRA    35B2
....................         case 'e': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
319E:  CLRF   FEA
31A0:  MOVLW  54
31A2:  MOVWF  FE9
31A4:  CLRF   FE2
31A6:  MOVLW  55
31A8:  MOVWF  FE1
31AA:  MOVLW  12
31AC:  MOVWF  01
31AE:  MOVFF  FE6,FEE
31B2:  DECFSZ 01,F
31B4:  BRA    31AE
....................             if (atol(cmd_msg)!=22) break; 
31B6:  CLRF   xD0
31B8:  MOVLW  54
31BA:  MOVWF  xCF
31BC:  CALL   0AD2
31C0:  MOVFF  02,D0
31C4:  MOVF   01,W
31C6:  MOVWF  xCF
31C8:  SUBLW  16
31CA:  BNZ   31D0
31CC:  MOVF   xD0,F
31CE:  BZ    31D2
31D0:  BRA    35B2
.................... 			PORTE.tx_en=1; 
31D2:  BSF    F84.2
.................... 			printf("\r\ndeleting entire flash data "); 
31D4:  CLRF   xCF
31D6:  MOVF   xCF,W
31D8:  CALL   01C6
31DC:  INCF   xCF,F
31DE:  MOVWF  00
31E0:  MOVF   00,W
31E2:  BTFSS  F9E.4
31E4:  BRA    31E2
31E6:  MOVWF  FAD
31E8:  MOVLW  1D
31EA:  SUBWF  xCF,W
31EC:  BNZ   31D6
.................... 			tx_delay=TX_DLY_TIME; 
31EE:  MOVLW  01
31F0:  MOVWF  xC2
.................... 			ext_flash_block_erase(); 
31F2:  GOTO   2970
....................             break; } 
.................... 		case 't': { // timer set 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
31F6:  CLRF   FEA
31F8:  MOVLW  54
31FA:  MOVWF  FE9
31FC:  CLRF   FE2
31FE:  MOVLW  55
3200:  MOVWF  FE1
3202:  MOVLW  12
3204:  MOVWF  01
3206:  MOVFF  FE6,FEE
320A:  DECFSZ 01,F
320C:  BRA    3206
.................... 			timer_sec=atoi32(cmd_msg); 
320E:  CLRF   xD0
3210:  MOVLW  54
3212:  MOVWF  xCF
3214:  GOTO   29B0
3218:  MOVFF  03,23
321C:  MOVFF  02,22
3220:  MOVFF  01,21
3224:  MOVFF  00,20
.................... 			lcd_send_cmd(0,0x02); 
3228:  CLRF   xF0
322A:  MOVLW  02
322C:  MOVWF  xF1
322E:  CALL   09CE
3232:  CLRF   18
3234:  BTFSC  FF2.7
3236:  BSF    18.7
3238:  BCF    FF2.7
.................... 			next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
323A:  MOVFF  23,F2
323E:  MOVFF  22,F1
3242:  MOVFF  21,F0
3246:  MOVFF  20,EF
324A:  MOVLW  07
324C:  MOVWF  xF6
324E:  MOVLW  86
3250:  MOVWF  xF5
3252:  MOVLW  1F
3254:  MOVWF  xF4
3256:  MOVLW  80
3258:  MOVWF  xF3
325A:  CALL   0338
325E:  BTFSC  18.7
3260:  BSF    FF2.7
3262:  MOVFF  FEF,CF
3266:  MOVFF  FEC,D0
326A:  MOVFF  FEC,D1
326E:  MOVFF  FEC,D2
3272:  MOVFF  D2,E2
3276:  MOVFF  D1,E1
327A:  MOVFF  D0,E0
327E:  MOVFF  CF,DF
3282:  RCALL  2C4E
3284:  MOVFF  02,D1
3288:  MOVFF  01,D0
328C:  MOVFF  02,E0
3290:  MOVFF  01,DF
3294:  RCALL  2CE8
3296:  MOVFF  03,D4
329A:  MOVFF  02,D3
329E:  MOVFF  01,D2
32A2:  MOVFF  00,D1
32A6:  MOVFF  FEA,D6
32AA:  MOVFF  FE9,D5
32AE:  MOVFF  03,FA
32B2:  MOVFF  02,F9
32B6:  MOVFF  01,F8
32BA:  MOVFF  00,F7
32BE:  CLRF   xFE
32C0:  CLRF   xFD
32C2:  MOVLW  01
32C4:  MOVWF  xFC
32C6:  MOVLW  C2
32C8:  MOVWF  xFB
32CA:  CALL   13CC
32CE:  MOVFF  D6,FEA
32D2:  MOVFF  D5,FE9
32D6:  MOVFF  03,6D
32DA:  MOVFF  02,6C
32DE:  MOVFF  01,6B
32E2:  MOVFF  00,6A
.................... 			enable_interrupts(INT_TIMER1);    
32E6:  BSF    F9D.0
.................... 			enable_interrupts(GLOBAL);  
32E8:  MOVLW  C0
32EA:  IORWF  FF2,F
.................... 			flag.task1_armed=true; 
32EC:  BSF    1F.0
.................... 			write_eeprom_data(0); // save full_stroke_tick and current_position 
32EE:  CLRF   xCF
32F0:  CALL   0818
.................... 			flag.setup_required =false; 
32F4:  BCF    1F.4
.................... 			break; 
32F6:  BRA    35B2
.................... 		} 
.................... 		case 'h' : { //return home 
.................... 			move_act(2000,9000,move_act_time_out*2,1,0); // move actuator to west 
32F8:  BCF    FD8.0
32FA:  RLCF   xC0,W
32FC:  MOVWF  xCF
32FE:  RLCF   xC1,W
3300:  MOVWF  xD0
3302:  MOVLW  07
3304:  MOVWF  xD4
3306:  MOVLW  D0
3308:  MOVWF  xD3
330A:  MOVLW  23
330C:  MOVWF  xD6
330E:  MOVLW  28
3310:  MOVWF  xD5
3312:  MOVFF  D0,D8
3316:  MOVFF  CF,D7
331A:  MOVLW  01
331C:  MOVWF  xD9
331E:  CLRF   xDA
3320:  CALL   222A
.................... 			FULL_STROKE_TICK= move_act(2000,9000,move_act_time_out*2,0,0); // move actuator to home position 
3324:  BCF    FD8.0
3326:  RLCF   xC0,W
3328:  MOVWF  xCF
332A:  RLCF   xC1,W
332C:  MOVWF  xD0
332E:  MOVLW  07
3330:  MOVWF  xD4
3332:  MOVLW  D0
3334:  MOVWF  xD3
3336:  MOVLW  23
3338:  MOVWF  xD6
333A:  MOVLW  28
333C:  MOVWF  xD5
333E:  MOVFF  D0,D8
3342:  MOVFF  CF,D7
3346:  CLRF   xD9
3348:  CLRF   xDA
334A:  CALL   222A
334E:  MOVFF  02,BB
3352:  MOVFF  01,BA
.................... 			current_act_position =0; 
3356:  CLRF   x6F
3358:  CLRF   x6E
.................... 			write_eeprom_data(1); // save full_stroke_tick and current_position 
335A:  MOVLW  01
335C:  MOVWF  xCF
335E:  CALL   0818
.................... 			break; 
3362:  BRA    35B2
.................... 		} 
.................... /* 
.................... 		case 'g': { 
.................... 			print_date_time(); 
.................... 		    break; 
.................... 		} 
.................... 		case 'a': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
.................... 			PORTE.tx_en=1; 
.................... 			printf("\r\n   Sun angle %u, stroke length =%f",atoi(cmd_msg),actuator_length(atoi(cmd_msg))); 
.................... 			tx_delay=TX_DLY_TIME; 
.................... 			break; 
.................... 		} 
.................... */ 
.................... 		case 's': { 
.................... 			memcpy(cmd_msg,cmd_msg+1,18); 
3364:  CLRF   FEA
3366:  MOVLW  54
3368:  MOVWF  FE9
336A:  CLRF   FE2
336C:  MOVLW  55
336E:  MOVWF  FE1
3370:  MOVLW  12
3372:  MOVWF  01
3374:  MOVFF  FE6,FEE
3378:  DECFSZ 01,F
337A:  BRA    3374
....................             if (atol(cmd_msg)!=22) break; 
337C:  CLRF   xD0
337E:  MOVLW  54
3380:  MOVWF  xCF
3382:  CALL   0AD2
3386:  MOVFF  02,D0
338A:  MOVF   01,W
338C:  MOVWF  xCF
338E:  SUBLW  16
3390:  BNZ   3396
3392:  MOVF   xD0,F
3394:  BZ    3398
3396:  BRA    35B2
.................... 			write_eeprom_data(1); 
3398:  MOVLW  01
339A:  MOVWF  xCF
339C:  CALL   0818
.................... 			break; 
33A0:  BRA    35B2
.................... 		} 
.................... 		case 'y': { //adc conversion 
.................... 			set_adc_channel( 0 ); 
33A2:  MOVLW  00
33A4:  MOVWF  01
33A6:  MOVF   FC2,W
33A8:  ANDLW  C7
33AA:  IORWF  01,W
33AC:  MOVWF  FC2
.................... 			delay_us(20); 
33AE:  MOVLW  10
33B0:  MOVWF  00
33B2:  DECFSZ 00,F
33B4:  BRA    33B2
33B6:  NOP   
.................... 			current_measured = (read_adc()); 
33B8:  BSF    FC2.2
33BA:  BTFSC  FC2.2
33BC:  BRA    33BA
33BE:  MOVFF  FC3,C3
33C2:  MOVFF  FC4,C4
.................... 			printf("\r\nADC= %lu",current_measured); 
33C6:  CLRF   xCF
33C8:  MOVF   xCF,W
33CA:  CALL   01FE
33CE:  INCF   xCF,F
33D0:  MOVWF  00
33D2:  MOVF   00,W
33D4:  BTFSS  F9E.4
33D6:  BRA    33D4
33D8:  MOVWF  FAD
33DA:  MOVLW  07
33DC:  SUBWF  xCF,W
33DE:  BNZ   33C8
33E0:  MOVLW  10
33E2:  MOVWF  FE9
33E4:  MOVFF  C4,E3
33E8:  MOVFF  C3,E2
33EC:  CALL   0DE6
.................... 			break; 
33F0:  BRA    35B2
.................... 		} 
.................... 		case 'w': { //buffer1 read 
.................... 			//ext_flash_buffer1_write(0x00,0x00, 1); 
.................... 			//ext_flash_buffer1_read(); 
.................... 			//ext_flash_buffer1_write(0x12,0xAA, 0); 
.................... 			disable_interrupts(GLOBAL); 
33F2:  BCF    FF2.6
33F4:  BCF    FF2.7
33F6:  BTFSC  FF2.7
33F8:  BRA    33F4
.................... 			restart_wdt(); 
33FA:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
33FC:  BCF    FD1.0
.................... 			ext_flash_buffer1_read(); 
33FE:  BRA    2D70
.................... 			enable_interrupts(GLOBAL); 
3400:  MOVLW  C0
3402:  IORWF  FF2,F
.................... 			restart_wdt(); 
3404:  CLRWDT
.................... 			setup_wdt(WDT_ON); 
3406:  BSF    FD1.0
....................  
.................... 			//ext_flash_write_buffer1_to_main_memory(1024); 
.................... 			break; 
3408:  BRA    35B2
.................... 		} 
.................... 		case 'i': { //adc conversion 
.................... 			printf("\r\nAct:%lu/%lu",current_act_position,FULL_STROKE_TICK); 
340A:  CLRF   xCF
340C:  MOVF   xCF,W
340E:  CALL   0224
3412:  INCF   xCF,F
3414:  MOVWF  00
3416:  MOVF   00,W
3418:  BTFSS  F9E.4
341A:  BRA    3418
341C:  MOVWF  FAD
341E:  MOVLW  06
3420:  SUBWF  xCF,W
3422:  BNZ   340C
3424:  MOVLW  10
3426:  MOVWF  FE9
3428:  MOVFF  6F,E3
342C:  MOVFF  6E,E2
3430:  CALL   0DE6
3434:  MOVLW  2F
3436:  BTFSS  F9E.4
3438:  BRA    3436
343A:  MOVWF  FAD
343C:  MOVLW  10
343E:  MOVWF  FE9
3440:  MOVFF  BB,E3
3444:  MOVFF  BA,E2
3448:  CALL   0DE6
.................... 			printf("\r\nRestart:%lu",startup_counter); 
344C:  CLRF   xCF
344E:  MOVF   xCF,W
3450:  CALL   024C
3454:  INCF   xCF,F
3456:  MOVWF  00
3458:  MOVF   00,W
345A:  BTFSS  F9E.4
345C:  BRA    345A
345E:  MOVWF  FAD
3460:  MOVLW  0A
3462:  SUBWF  xCF,W
3464:  BNZ   344E
3466:  MOVLW  10
3468:  MOVWF  FE9
346A:  MOVFF  C7,E3
346E:  MOVFF  C6,E2
3472:  CALL   0DE6
.................... 			printf("\r\nCurrent:%lu (%d)",current_measured/n_avg_current_measured, n_avg_current_measured); 
3476:  MOVFF  C4,D2
347A:  MOVFF  C3,D1
347E:  CLRF   xD4
3480:  MOVFF  C5,D3
3484:  RCALL  2DF6
3486:  MOVFF  02,D0
348A:  MOVFF  01,CF
348E:  CLRF   xD1
3490:  MOVF   xD1,W
3492:  CALL   0274
3496:  INCF   xD1,F
3498:  MOVWF  00
349A:  MOVF   00,W
349C:  BTFSS  F9E.4
349E:  BRA    349C
34A0:  MOVWF  FAD
34A2:  MOVLW  0A
34A4:  SUBWF  xD1,W
34A6:  BNZ   3490
34A8:  MOVLW  10
34AA:  MOVWF  FE9
34AC:  MOVFF  D0,E3
34B0:  MOVFF  CF,E2
34B4:  CALL   0DE6
34B8:  MOVLW  20
34BA:  BTFSS  F9E.4
34BC:  BRA    34BA
34BE:  MOVWF  FAD
34C0:  MOVLW  28
34C2:  BTFSS  F9E.4
34C4:  BRA    34C2
34C6:  MOVWF  FAD
34C8:  MOVFF  C5,D2
34CC:  MOVLW  1F
34CE:  MOVWF  xD3
34D0:  CALL   0748
34D4:  MOVLW  29
34D6:  BTFSS  F9E.4
34D8:  BRA    34D6
34DA:  MOVWF  FAD
.................... 			printf("\r\nTimer:%lu",timer_sec); 
34DC:  CLRF   xCF
34DE:  MOVF   xCF,W
34E0:  CALL   02A2
34E4:  INCF   xCF,F
34E6:  MOVWF  00
34E8:  MOVF   00,W
34EA:  BTFSS  F9E.4
34EC:  BRA    34EA
34EE:  MOVWF  FAD
34F0:  MOVLW  08
34F2:  SUBWF  xCF,W
34F4:  BNZ   34DE
34F6:  MOVLW  41
34F8:  MOVWF  FE9
34FA:  MOVFF  23,D3
34FE:  MOVFF  22,D2
3502:  MOVFF  21,D1
3506:  MOVFF  20,D0
350A:  BRA    2E38
350C:  CLRF   18
350E:  BTFSC  FF2.7
3510:  BSF    18.7
3512:  BCF    FF2.7
.................... 			printf("\r\n#Day:%lu",find_day_number((timer_sec)%SEC_IN_4_YEARS)); 
3514:  MOVFF  23,F2
3518:  MOVFF  22,F1
351C:  MOVFF  21,F0
3520:  MOVFF  20,EF
3524:  MOVLW  07
3526:  MOVWF  xF6
3528:  MOVLW  86
352A:  MOVWF  xF5
352C:  MOVLW  1F
352E:  MOVWF  xF4
3530:  MOVLW  80
3532:  MOVWF  xF3
3534:  CALL   0338
3538:  BTFSC  18.7
353A:  BSF    FF2.7
353C:  MOVFF  FEF,CF
3540:  MOVFF  FEC,D0
3544:  MOVFF  FEC,D1
3548:  MOVFF  FEC,D2
354C:  MOVFF  D2,E2
3550:  MOVFF  D1,E1
3554:  MOVFF  D0,E0
3558:  MOVFF  CF,DF
355C:  CALL   2C4E
3560:  MOVFF  02,D1
3564:  MOVFF  01,D0
3568:  CLRF   xD2
356A:  MOVF   xD2,W
356C:  CALL   02C8
3570:  INCF   xD2,F
3572:  MOVWF  00
3574:  MOVF   00,W
3576:  BTFSS  F9E.4
3578:  BRA    3576
357A:  MOVWF  FAD
357C:  MOVLW  07
357E:  SUBWF  xD2,W
3580:  BNZ   356A
3582:  MOVLW  10
3584:  MOVWF  FE9
3586:  MOVFF  D1,E3
358A:  MOVFF  D0,E2
358E:  CALL   0DE6
....................  
.................... 			break; 
3592:  BRA    35B2
.................... 		} 
.................... 		case 'c': { //clear write buffer 
.................... 		    ext_flash_buffer1_write(0xAA,0,255); 
3594:  MOVLW  AA
3596:  MOVWF  xDA
3598:  CLRF   xDB
359A:  MOVLW  FF
359C:  MOVWF  xDC
359E:  RCALL  2F02
.................... 			break; 
35A0:  BRA    35B2
.................... 		} 
....................  
.................... 		case 'x': { //stop timer 
.................... 		    disable_interrupts(INT_TIMER1);  
35A2:  BCF    F9D.0
.................... 			restart_wdt(); 
35A4:  CLRWDT
.................... 			setup_wdt(WDT_OFF); 
35A6:  BCF    FD1.0
.................... 			break; 
35A8:  BRA    35B2
.................... 		} 
....................  
.................... 		case 'o': { //start timer 
.................... 		    enable_interrupts(INT_TIMER1);  
35AA:  BSF    F9D.0
.................... 			setup_wdt(WDT_ON); 
35AC:  BSF    FD1.0
.................... 			restart_wdt(); 
35AE:  CLRWDT
.................... 			break; 
35B0:  BRA    35B2
.................... 		} 
....................  
....................  
.................... 		} 
.................... 		 
.................... 	} 
35B2:  RETLW  00
....................  
.................... void print_len_and_tick() 
.................... { 
.................... 	lcd_gotoxy(0,3); 
*
5CA2:  CLRF   xEC
5CA4:  MOVLW  03
5CA6:  MOVWF  xED
5CA8:  CALL   0CBA
.................... 	itoa((int16)(al),10,tmp_str); 
5CAC:  MOVFF  BF,14B
5CB0:  MOVFF  BE,14A
5CB4:  MOVFF  BD,149
5CB8:  MOVFF  BC,148
5CBC:  CALL   43AC
5CC0:  MOVFF  02,D0
5CC4:  MOVFF  01,CF
5CC8:  CLRF   xEB
5CCA:  CLRF   xEA
5CCC:  MOVFF  02,E9
5CD0:  MOVFF  01,E8
5CD4:  MOVLW  0A
5CD6:  MOVWF  xEC
5CD8:  CLRF   xEE
5CDA:  MOVLW  2C
5CDC:  MOVWF  xED
5CDE:  CALL   152C
....................     printf(lcd_putc,"L=%s.",tmp_str); 
5CE2:  MOVLW  4C
5CE4:  MOVWF  xEB
5CE6:  CALL   0CE2
5CEA:  MOVLW  3D
5CEC:  MOVWF  xEB
5CEE:  CALL   0CE2
5CF2:  CLRF   FEA
5CF4:  MOVLW  2C
5CF6:  MOVWF  FE9
5CF8:  MOVLW  00
5CFA:  IORWF  FEF,W
5CFC:  BZ    5D1E
5CFE:  MOVFF  FEA,D0
5D02:  MOVFF  FE9,CF
5D06:  MOVFF  FEF,EB
5D0A:  CALL   0CE2
5D0E:  MOVFF  D0,FEA
5D12:  MOVFF  CF,FE9
5D16:  INCF   FE9,F
5D18:  BTFSC  FD8.2
5D1A:  INCF   FEA,F
5D1C:  BRA    5CF8
5D1E:  MOVLW  2E
5D20:  MOVWF  xEB
5D22:  CALL   0CE2
.................... 	itoa((int16)(al*100.0)%100,10,tmp_str); 
5D26:  MOVFF  BF,14F
5D2A:  MOVFF  BE,14E
5D2E:  MOVFF  BD,14D
5D32:  MOVFF  BC,14C
5D36:  MOVLB  1
5D38:  CLRF   x53
5D3A:  CLRF   x52
5D3C:  MOVLW  48
5D3E:  MOVWF  x51
5D40:  MOVLW  85
5D42:  MOVWF  x50
5D44:  MOVLB  0
5D46:  CALL   0EC0
5D4A:  MOVFF  03,14B
5D4E:  MOVFF  02,14A
5D52:  MOVFF  01,149
5D56:  MOVFF  00,148
5D5A:  CALL   43AC
5D5E:  MOVFF  02,D0
5D62:  MOVFF  01,CF
5D66:  MOVFF  02,D2
5D6A:  MOVFF  01,D1
5D6E:  CLRF   xD4
5D70:  MOVLW  64
5D72:  MOVWF  xD3
5D74:  CALL   2DF6
5D78:  MOVFF  00,D0
5D7C:  MOVFF  03,D1
5D80:  CLRF   xEB
5D82:  CLRF   xEA
5D84:  MOVFF  03,E9
5D88:  MOVFF  00,E8
5D8C:  MOVLW  0A
5D8E:  MOVWF  xEC
5D90:  CLRF   xEE
5D92:  MOVLW  2C
5D94:  MOVWF  xED
5D96:  CALL   152C
....................     printf(lcd_putc,"%scm",tmp_str); 
5D9A:  CLRF   FEA
5D9C:  MOVLW  2C
5D9E:  MOVWF  FE9
5DA0:  MOVLW  00
5DA2:  IORWF  FEF,W
5DA4:  BZ    5DC6
5DA6:  MOVFF  FEA,D0
5DAA:  MOVFF  FE9,CF
5DAE:  MOVFF  FEF,EB
5DB2:  CALL   0CE2
5DB6:  MOVFF  D0,FEA
5DBA:  MOVFF  CF,FE9
5DBE:  INCF   FE9,F
5DC0:  BTFSC  FD8.2
5DC2:  INCF   FEA,F
5DC4:  BRA    5DA0
5DC6:  MOVLW  63
5DC8:  MOVWF  xEB
5DCA:  CALL   0CE2
5DCE:  MOVLW  6D
5DD0:  MOVWF  xEB
5DD2:  CALL   0CE2
.................... 	lcd_gotoxy(11,3); 
5DD6:  MOVLW  0B
5DD8:  MOVWF  xEC
5DDA:  MOVLW  03
5DDC:  MOVWF  xED
5DDE:  CALL   0CBA
....................     printf(lcd_putc,"*%4lu",target_act_position); 
5DE2:  MOVLW  2A
5DE4:  MOVWF  xEB
5DE6:  CALL   0CE2
5DEA:  MOVLW  01
5DEC:  MOVWF  FE9
5DEE:  MOVFF  71,E3
5DF2:  MOVFF  70,E2
5DF6:  CALL   0D34
....................  
.................... } 
5DFA:  RETLW  00
....................  
....................  
.................... void main() { 
5DFC:  CLRF   FF8
5DFE:  BCF    FD0.7
5E00:  BSF    0D.7
5E02:  CLRF   FEA
5E04:  CLRF   FE9
5E06:  MOVLW  0A
5E08:  MOVWF  FAF
5E0A:  MOVLW  A6
5E0C:  MOVWF  FAC
5E0E:  MOVLW  90
5E10:  MOVWF  FAB
5E12:  BSF    FC1.0
5E14:  BSF    FC1.1
5E16:  BSF    FC1.2
5E18:  BCF    FC1.3
5E1A:  MOVLW  07
5E1C:  MOVWF  FB4
5E1E:  CLRF   19
5E20:  CLRF   1A
5E22:  CLRF   20
5E24:  CLRF   21
5E26:  CLRF   22
5E28:  CLRF   23
5E2A:  CLRF   24
5E2C:  CLRF   25
5E2E:  CLRF   26
5E30:  CLRF   27
5E32:  CLRF   28
5E34:  CLRF   29
5E36:  CLRF   2A
5E38:  CLRF   2B
5E3A:  CLRF   x68
5E3C:  CLRF   x69
5E3E:  CLRF   x6E
5E40:  CLRF   x6F
5E42:  CLRF   x70
5E44:  CLRF   x71
5E46:  CLRF   xBA
5E48:  CLRF   xBB
5E4A:  MOVLW  04
5E4C:  MOVWF  xC0
5E4E:  CLRF   xC1
5E50:  CLRF   xC2
5E52:  CLRF   xC3
5E54:  CLRF   xC4
5E56:  CLRF   xC5
5E58:  CLRF   xC6
5E5A:  CLRF   xC7
....................     unsigned int8 solar_angle; 
.................... 	int16 tick=0; 
5E5C:  CLRF   xCA
5E5E:  CLRF   xCB
.................... 	int16 temp_mem; 
.................... 	int8 i; 
....................     set_tris_d(0x00); // all D are output 
5E60:  MOVLW  00
5E62:  MOVWF  F95
.................... 	set_tris_e(0b00000010); // RE1 = emergnecy input 
5E64:  BCF    F96.0
5E66:  BSF    F96.1
5E68:  BCF    F96.2
.................... 	set_tris_a(0b11111111); // A0 -1 is output 
5E6A:  MOVLW  FF
5E6C:  MOVWF  F92
.................... 	set_tris_b(0xA0); 
5E6E:  MOVLW  A0
5E70:  MOVWF  F93
.................... 	set_tris_c(0b10010000); 
5E72:  MOVLW  90
5E74:  MOVWF  F94
.................... 	timer_sec=0; 
5E76:  CLRF   23
5E78:  CLRF   22
5E7A:  CLRF   21
5E7C:  CLRF   20
5E7E:  CLRF   18
5E80:  BTFSC  FF2.7
5E82:  BSF    18.7
5E84:  BCF    FF2.7
.................... 	delay_ms(200); 
5E86:  MOVLW  C8
5E88:  MOVWF  xF1
5E8A:  CALL   04B4
5E8E:  BTFSC  18.7
5E90:  BSF    FF2.7
.................... 	read_eeprom_data(); 
5E92:  GOTO   05B4
.................... 	restart_wdt(); 
5E96:  CLRWDT
.................... 	setup_wdt(WDT_OFF); 
5E98:  BCF    FD1.0
.................... 	setup_adc_ports(AN0); 
5E9A:  BCF    FC1.0
5E9C:  BSF    FC1.1
5E9E:  BSF    FC1.2
5EA0:  BSF    FC1.3
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
5EA2:  BCF    FC1.6
5EA4:  BSF    FC2.6
5EA6:  BSF    FC2.7
5EA8:  BSF    FC1.7
5EAA:  BSF    FC2.0
.................... 	set_adc_channel( 0 ); 
5EAC:  MOVLW  00
5EAE:  MOVWF  01
5EB0:  MOVF   FC2,W
5EB2:  ANDLW  C7
5EB4:  IORWF  01,W
5EB6:  MOVWF  FC2
.................... 	current_measured =0; 
5EB8:  CLRF   xC4
5EBA:  CLRF   xC3
.................... 	startup_counter++; 
5EBC:  INCF   xC6,F
5EBE:  BTFSC  FD8.2
5EC0:  INCF   xC7,F
.................... 	printf("\r\nRestart Cause:%3d",restart_cause()); 
5EC2:  MOVF   FD0,W
5EC4:  ANDLW  0F
5EC6:  BTFSS  FD0.4
5EC8:  MOVLW  00
5ECA:  BSF    FD0.0
5ECC:  BSF    FD0.1
5ECE:  BSF    FD0.4
5ED0:  BSF    FD8.3
5ED2:  BSF    FD8.4
5ED4:  MOVWF  xCF
5ED6:  CLRF   xD0
5ED8:  MOVF   xD0,W
5EDA:  CALL   02EE
5EDE:  INCF   xD0,F
5EE0:  MOVWF  00
5EE2:  MOVF   00,W
5EE4:  BTFSS  F9E.4
5EE6:  BRA    5EE4
5EE8:  MOVWF  FAD
5EEA:  MOVLW  10
5EEC:  SUBWF  xD0,W
5EEE:  BNZ   5ED8
5EF0:  MOVFF  CF,D2
5EF4:  MOVLW  13
5EF6:  MOVWF  xD3
5EF8:  CALL   0748
.................... 	write_eeprom_data(0); 
5EFC:  CLRF   xCF
5EFE:  CALL   0818
.................... 	output_low(CCW); 
5F02:  BCF    F93.4
5F04:  BCF    F8A.4
.................... 	output_low(EN0); 
5F06:  BCF    F93.0
5F08:  BCF    F8A.0
.................... 	output_low(EN1); 
5F0A:  BCF    F93.1
5F0C:  BCF    F8A.1
.................... 	output_low(EN2); 
5F0E:  BCF    F93.2
5F10:  BCF    F8A.2
.................... 	output_low(EN3); 
5F12:  BCF    F93.3
5F14:  BCF    F8A.3
.................... 	PORTD.ps_en=0; 
5F16:  BCF    F83.4
.................... 	PORTD.disp_en=0;  
5F18:  BCF    F83.7
.................... 	PORTE.tx_en=1; 
5F1A:  BSF    F84.2
.................... 	lcd_init(); 
5F1C:  CALL   09F6
.................... 	init_ext_flash(); 
5F20:  GOTO   0AA6
.................... 	restart_wdt(); 
5F24:  CLRWDT
.................... 	portd.pwr_ctrl=0; 
5F26:  BCF    F83.6
....................     output_high(FLASH_SELECT); 
5F28:  BCF    F94.2
5F2A:  BSF    F8B.2
....................     setup_timer_0(RTCC_DIV_32); 
5F2C:  MOVLW  84
5F2E:  MOVWF  FD5
.................... 	T1CON = 0x8F; 
5F30:  MOVLW  8F
5F32:  MOVWF  FCD
.................... 	//setup_timer_0(RTCC_DIV_1); 
....................     disable_interrupts(INT_TIMER0);   // Setup interrupt on falling edge 
5F34:  BCF    FF2.5
....................     disable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
5F36:  BCF    F9D.0
....................     disable_interrupts(GLOBAL); 
5F38:  BCF    FF2.6
5F3A:  BCF    FF2.7
5F3C:  BTFSC  FF2.7
5F3E:  BRA    5F3A
.................... 	flag=0; 
5F40:  CLRF   1F
....................     strcpy(cmd_msg,""); 
5F42:  CLRF   FEA
5F44:  MOVLW  54
5F46:  MOVWF  FE9
5F48:  MOVFF  FF2,CF
5F4C:  BCF    FF2.7
5F4E:  MOVLW  00
5F50:  CALL   031C
5F54:  TBLRD*-
5F56:  TBLRD*+
5F58:  MOVF   FF5,W
5F5A:  MOVWF  FEE
5F5C:  IORLW  00
5F5E:  BNZ   5F56
5F60:  BTFSC  xCF.7
5F62:  BSF    FF2.7
.................... 	if (timer_sec ==0x00000000) 
5F64:  MOVF   20,F
5F66:  BNZ   5F78
5F68:  MOVF   21,F
5F6A:  BNZ   5F78
5F6C:  MOVF   22,F
5F6E:  BNZ   5F78
5F70:  MOVF   23,F
5F72:  BNZ   5F78
.................... 		flag.setup_required = true; 
5F74:  BSF    1F.4
.................... 	else 
5F76:  BRA    5F7A
.................... 		flag.setup_required = false; 
5F78:  BCF    1F.4
....................  
.................... ///////////////// 
.................... 	enable_interrupts(INT_RDA); 
5F7A:  BSF    F9D.5
.................... 	enable_interrupts(INT_TIMER1);   
5F7C:  BSF    F9D.0
.................... 	enable_interrupts(GLOBAL);  
5F7E:  MOVLW  C0
5F80:  IORWF  FF2,F
.................... 	while(flag.setup_required)	if (flag.cmd_posted) process_cmd_msg(); 
5F82:  BTFSS  1F.4
5F84:  BRA    5F90
5F86:  BTFSS  1F.3
5F88:  BRA    5F8E
5F8A:  CALL   2F60
5F8E:  BRA    5F82
.................... 	setup_wdt(WDT_ON); 
5F90:  BSF    FD1.0
5F92:  CLRF   18
5F94:  BTFSC  FF2.7
5F96:  BSF    18.7
5F98:  BCF    FF2.7
.................... 	next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
5F9A:  MOVFF  23,F2
5F9E:  MOVFF  22,F1
5FA2:  MOVFF  21,F0
5FA6:  MOVFF  20,EF
5FAA:  MOVLW  07
5FAC:  MOVWF  xF6
5FAE:  MOVLW  86
5FB0:  MOVWF  xF5
5FB2:  MOVLW  1F
5FB4:  MOVWF  xF4
5FB6:  MOVLW  80
5FB8:  MOVWF  xF3
5FBA:  CALL   0338
5FBE:  BTFSC  18.7
5FC0:  BSF    FF2.7
5FC2:  MOVFF  FEF,CF
5FC6:  MOVFF  FEC,D0
5FCA:  MOVFF  FEC,D1
5FCE:  MOVFF  FEC,D2
5FD2:  MOVFF  D2,E2
5FD6:  MOVFF  D1,E1
5FDA:  MOVFF  D0,E0
5FDE:  MOVFF  CF,DF
5FE2:  CALL   2C4E
5FE6:  MOVFF  02,D1
5FEA:  MOVFF  01,D0
5FEE:  MOVFF  02,E0
5FF2:  MOVFF  01,DF
5FF6:  CALL   2CE8
5FFA:  MOVFF  03,D4
5FFE:  MOVFF  02,D3
6002:  MOVFF  01,D2
6006:  MOVFF  00,D1
600A:  MOVFF  FEA,D6
600E:  MOVFF  FE9,D5
6012:  MOVFF  03,FA
6016:  MOVFF  02,F9
601A:  MOVFF  01,F8
601E:  MOVFF  00,F7
6022:  CLRF   xFE
6024:  CLRF   xFD
6026:  MOVLW  01
6028:  MOVWF  xFC
602A:  MOVLW  C2
602C:  MOVWF  xFB
602E:  CALL   13CC
6032:  MOVFF  D6,FEA
6036:  MOVFF  D5,FE9
603A:  MOVFF  03,6D
603E:  MOVFF  02,6C
6042:  MOVFF  01,6B
6046:  MOVFF  00,6A
....................  
.................... ////////////////// 
.................... 	// take sun angle and calculate the length of actuator needed to push 
.................... 	// also need counter of reed switch 
.................... 	flag.task1_armed =true; 
604A:  BSF    1F.0
.................... 	while(1) { 
.................... 		if (flag.update_time) { 
604C:  BTFSS  1F.1
604E:  BRA    6056
.................... 			flag.update_time = false; 
6050:  BCF    1F.1
.................... 			print_date_time(); 
6052:  CALL   1762
.................... 		} 
....................  
.................... 		if (flag.measured_current) {	 
6056:  BTFSS  1F.7
6058:  BRA    606C
.................... 		   flag.measured_current = false; 
605A:  BCF    1F.7
.................... 		   current_measured += (read_adc()); 
605C:  BSF    FC2.2
605E:  BTFSC  FC2.2
6060:  BRA    605E
6062:  MOVF   FC3,W
6064:  ADDWF  xC3,F
6066:  MOVF   FC4,W
6068:  ADDWFC xC4,F
.................... 		   n_avg_current_measured++; 
606A:  INCF   xC5,F
.................... 		} 
....................  
.................... 		if (flag.cmd_posted) { 
606C:  BTFSS  1F.3
606E:  BRA    6076
.................... 			flag.cmd_posted = false; 
6070:  BCF    1F.3
.................... 			process_cmd_msg(); 
6072:  CALL   2F60
.................... 		} 
.................... 		if (flag.reset_rs232) { 
6076:  BTFSS  1F.5
6078:  BRA    6080
.................... 			flag.reset_rs232 =false; 
607A:  BCF    1F.5
.................... 			 init_rs232(); 
607C:  GOTO   3606
.................... 		} 
.................... 		if (input(WALL_PWR)==false) { 
6080:  BSF    F92.5
6082:  BTFSC  F80.5
6084:  BRA    608A
.................... 			flag.pwr_state = false; 
6086:  BCF    1F.6
.................... 		} else { 
6088:  BRA    6094
.................... 			if (flag.pwr_state==false) 
608A:  BTFSC  1F.6
608C:  BRA    6092
.................... 				lcd_init(); 
608E:  CALL   09F6
.................... 			flag.pwr_state=true; 
6092:  BSF    1F.6
.................... 		} 
.................... 		if (tx_delay==0) PORTE.tx_en=0; 
6094:  MOVF   xC2,F
6096:  BTFSC  FD8.2
6098:  BCF    F84.2
.................... 		if (flag.task1_armed) { 
609A:  BTFSS  1F.0
609C:  BRA    63DE
.................... 			flag.task1_armed = false; 
609E:  BCF    1F.0
.................... 			solar_angle= task1(); 
60A0:  CALL   386E
60A4:  MOVFF  01,C9
....................  
.................... 			if ((solar_angle>30) && (solar_angle<150)) { 
60A8:  MOVF   xC9,W
60AA:  SUBLW  1E
60AC:  BC    60D8
60AE:  MOVF   xC9,W
60B0:  SUBLW  95
60B2:  BNC   60D8
.................... 				lcd_gotoxy(0,3); 
60B4:  CLRF   xEC
60B6:  MOVLW  03
60B8:  MOVWF  xED
60BA:  CALL   0CBA
.................... 				al=actuator_length(solar_angle); 
60BE:  MOVFF  C9,D1
60C2:  CALL   4986
60C6:  MOVFF  03,BF
60CA:  MOVFF  02,BE
60CE:  MOVFF  01,BD
60D2:  MOVFF  00,BC
.................... 			} else { 
60D6:  BRA    614A
.................... 				if ((solar_angle>0) && (solar_angle<=30)) { 
60D8:  MOVF   xC9,F
60DA:  BZ    610E
60DC:  MOVF   xC9,W
60DE:  SUBLW  1E
60E0:  BNC   610E
.................... 					al=actuator_length(90-get_backtrack_angle(90-solar_angle)); 
60E2:  MOVLW  5A
60E4:  BSF    FD8.0
60E6:  SUBFWB xC9,W
60E8:  MOVWF  xCF
60EA:  MOVWF  xD0
60EC:  RCALL  598E
60EE:  MOVLW  5A
60F0:  BSF    FD8.0
60F2:  SUBFWB 01,W
60F4:  MOVWF  xD0
60F6:  MOVWF  xD1
60F8:  CALL   4986
60FC:  MOVFF  03,BF
6100:  MOVFF  02,BE
6104:  MOVFF  01,BD
6108:  MOVFF  00,BC
.................... 				} else if ((solar_angle>=150) && (solar_angle<=180)) { 
610C:  BRA    614A
610E:  MOVF   xC9,W
6110:  SUBLW  95
6112:  BC    614A
6114:  MOVF   xC9,W
6116:  SUBLW  B4
6118:  BNC   614A
.................... 					lcd_gotoxy(0,3); 
611A:  CLRF   xEC
611C:  MOVLW  03
611E:  MOVWF  xED
6120:  CALL   0CBA
.................... 					al=actuator_length(90+get_backtrack_angle(solar_angle-90)); 
6124:  MOVLW  5A
6126:  SUBWF  xC9,W
6128:  MOVWF  xCF
612A:  MOVWF  xD0
612C:  RCALL  598E
612E:  MOVLW  5A
6130:  ADDWF  01,W
6132:  MOVWF  xD0
6134:  MOVWF  xD1
6136:  CALL   4986
613A:  MOVFF  03,BF
613E:  MOVFF  02,BE
6142:  MOVFF  01,BD
6146:  MOVFF  00,BC
.................... 				} 
.................... 			} 
.................... 			if((al >= MIN_STROKE) && (al <=MAX_STROKE)) { 
614A:  MOVLW  9A
614C:  MOVLB  1
614E:  MOVWF  x4B
6150:  MOVLW  99
6152:  MOVWF  x4A
6154:  MOVLW  0C
6156:  MOVWF  x49
6158:  MOVLW  85
615A:  MOVWF  x48
615C:  MOVFF  BF,14F
6160:  MOVFF  BE,14E
6164:  MOVFF  BD,14D
6168:  MOVFF  BC,14C
616C:  MOVLB  0
616E:  CALL   3DD2
6172:  BC    6176
6174:  BNZ   625A
6176:  MOVFF  BF,14B
617A:  MOVFF  BE,14A
617E:  MOVFF  BD,149
6182:  MOVFF  BC,148
6186:  MOVLB  1
6188:  CLRF   x4F
618A:  CLRF   x4E
618C:  CLRF   x4D
618E:  MOVLW  86
6190:  MOVWF  x4C
6192:  MOVLB  0
6194:  CALL   3DD2
6198:  BC    619C
619A:  BNZ   625A
.................... 				tick = ((al-MIN_STROKE)/(MAX_STROKE-MIN_STROKE))*FULL_STROKE_TICK; 
619C:  BSF    FD8.1
619E:  MOVFF  BF,151
61A2:  MOVFF  BE,150
61A6:  MOVFF  BD,14F
61AA:  MOVFF  BC,14E
61AE:  MOVLW  9A
61B0:  MOVLB  1
61B2:  MOVWF  x55
61B4:  MOVLW  99
61B6:  MOVWF  x54
61B8:  MOVLW  0C
61BA:  MOVWF  x53
61BC:  MOVLW  85
61BE:  MOVWF  x52
61C0:  MOVLB  0
61C2:  CALL   1114
61C6:  MOVFF  00,CF
61CA:  MOVFF  01,D0
61CE:  MOVFF  02,D1
61D2:  MOVFF  03,D2
61D6:  MOVFF  03,14B
61DA:  MOVFF  02,14A
61DE:  MOVFF  01,149
61E2:  MOVFF  00,148
61E6:  MOVLW  CC
61E8:  MOVLB  1
61EA:  MOVWF  x4F
61EC:  MOVWF  x4E
61EE:  MOVLW  66
61F0:  MOVWF  x4D
61F2:  MOVLW  84
61F4:  MOVWF  x4C
61F6:  MOVLB  0
61F8:  CALL   0FB6
61FC:  MOVFF  00,D3
6200:  MOVFF  01,D4
6204:  MOVFF  02,D5
6208:  MOVFF  03,D6
620C:  MOVFF  BB,14D
6210:  MOVFF  BA,14C
6214:  CALL   4376
6218:  MOVFF  D6,14F
621C:  MOVFF  D5,14E
6220:  MOVFF  D4,14D
6224:  MOVFF  D3,14C
6228:  MOVFF  03,153
622C:  MOVFF  02,152
6230:  MOVFF  01,151
6234:  MOVFF  00,150
6238:  CALL   0EC0
623C:  MOVFF  03,14B
6240:  MOVFF  02,14A
6244:  MOVFF  01,149
6248:  MOVFF  00,148
624C:  CALL   43AC
6250:  MOVFF  02,CB
6254:  MOVFF  01,CA
.................... 			} else if (al<MIN_STROKE) { 
6258:  BRA    62B6
625A:  MOVFF  BF,14B
625E:  MOVFF  BE,14A
6262:  MOVFF  BD,149
6266:  MOVFF  BC,148
626A:  MOVLW  9A
626C:  MOVLB  1
626E:  MOVWF  x4F
6270:  MOVLW  99
6272:  MOVWF  x4E
6274:  MOVLW  0C
6276:  MOVWF  x4D
6278:  MOVLW  85
627A:  MOVWF  x4C
627C:  MOVLB  0
627E:  CALL   3DD2
6282:  BNC   628A
.................... 				tick = 0; 
6284:  CLRF   xCB
6286:  CLRF   xCA
.................... 			} else if (al>MAX_STROKE) { 
6288:  BRA    62B6
628A:  MOVLB  1
628C:  CLRF   x4B
628E:  CLRF   x4A
6290:  CLRF   x49
6292:  MOVLW  86
6294:  MOVWF  x48
6296:  MOVFF  BF,14F
629A:  MOVFF  BE,14E
629E:  MOVFF  BD,14D
62A2:  MOVFF  BC,14C
62A6:  MOVLB  0
62A8:  CALL   3DD2
62AC:  BNC   62B6
.................... 				tick = FULL_STROKE_TICK; 
62AE:  MOVFF  BB,CB
62B2:  MOVFF  BA,CA
.................... 			} 
.................... 			target_act_position = tick; 
62B6:  MOVFF  CB,71
62BA:  MOVFF  CA,70
.................... 			print_len_and_tick(); 
62BE:  RCALL  5CA2
....................  
.................... 			if(current_act_position > (target_act_position+5))// move east 
62C0:  MOVLW  05
62C2:  ADDWF  x70,W
62C4:  MOVWF  01
62C6:  MOVLW  00
62C8:  ADDWFC x71,W
62CA:  MOVWF  03
62CC:  MOVF   03,W
62CE:  SUBWF  x6F,W
62D0:  BNC   6308
62D2:  BNZ   62DA
62D4:  MOVF   x6E,W
62D6:  SUBWF  01,W
62D8:  BC    6308
.................... 			{ 
.................... 				move_act(current_act_position-target_act_position,4500,move_act_time_out,0,1); 
62DA:  MOVF   x70,W
62DC:  SUBWF  x6E,W
62DE:  MOVWF  xCF
62E0:  MOVF   x71,W
62E2:  SUBWFB x6F,W
62E4:  MOVWF  xD0
62E6:  MOVWF  xD4
62E8:  MOVFF  CF,D3
62EC:  MOVLW  11
62EE:  MOVWF  xD6
62F0:  MOVLW  94
62F2:  MOVWF  xD5
62F4:  MOVFF  C1,D8
62F8:  MOVFF  C0,D7
62FC:  CLRF   xD9
62FE:  MOVLW  01
6300:  MOVWF  xDA
6302:  CALL   222A
.................... 			} else if((current_act_position+5) < target_act_position)// move west 
6306:  BRA    63A8
6308:  MOVLW  05
630A:  ADDWF  x6E,W
630C:  MOVWF  xCF
630E:  MOVLW  00
6310:  ADDWFC x6F,W
6312:  MOVWF  xD0
6314:  SUBWF  x71,W
6316:  BNC   634E
6318:  BNZ   6320
631A:  MOVF   x70,W
631C:  SUBWF  xCF,W
631E:  BC    634E
.................... 			{ 
.................... 				move_act(target_act_position-current_act_position,4500,move_act_time_out,1,1); 
6320:  MOVF   x6E,W
6322:  SUBWF  x70,W
6324:  MOVWF  xCF
6326:  MOVF   x6F,W
6328:  SUBWFB x71,W
632A:  MOVWF  xD0
632C:  MOVWF  xD4
632E:  MOVFF  CF,D3
6332:  MOVLW  11
6334:  MOVWF  xD6
6336:  MOVLW  94
6338:  MOVWF  xD5
633A:  MOVFF  C1,D8
633E:  MOVFF  C0,D7
6342:  MOVLW  01
6344:  MOVWF  xD9
6346:  MOVWF  xDA
6348:  CALL   222A
.................... 			} else if (target_act_position == 0x00)  // move east all the way 
634C:  BRA    63A8
634E:  MOVF   x70,F
6350:  BNZ   637A
6352:  MOVF   x71,F
6354:  BNZ   637A
.................... 				move_act(FULL_STROKE_TICK,4500,move_act_time_out,0,1); 
6356:  MOVFF  BB,D4
635A:  MOVFF  BA,D3
635E:  MOVLW  11
6360:  MOVWF  xD6
6362:  MOVLW  94
6364:  MOVWF  xD5
6366:  MOVFF  C1,D8
636A:  MOVFF  C0,D7
636E:  CLRF   xD9
6370:  MOVLW  01
6372:  MOVWF  xDA
6374:  CALL   222A
.................... 			else if (target_act_position == FULL_STROKE_TICK) // move west all the way 
6378:  BRA    63A8
637A:  MOVF   xBA,W
637C:  SUBWF  x70,W
637E:  BNZ   63A8
6380:  MOVF   xBB,W
6382:  SUBWF  x71,W
6384:  BNZ   63A8
.................... 				move_act(FULL_STROKE_TICK,4500,move_act_time_out,1,1); 
6386:  MOVFF  BB,D4
638A:  MOVFF  BA,D3
638E:  MOVLW  11
6390:  MOVWF  xD6
6392:  MOVLW  94
6394:  MOVWF  xD5
6396:  MOVFF  C1,D8
639A:  MOVFF  C0,D7
639E:  MOVLW  01
63A0:  MOVWF  xD9
63A2:  MOVWF  xDA
63A4:  CALL   222A
63A8:  CLRF   18
63AA:  BTFSC  FF2.7
63AC:  BSF    18.7
63AE:  BCF    FF2.7
.................... 			delay_ms(20); 
63B0:  MOVLW  14
63B2:  MOVWF  xF1
63B4:  CALL   04B4
63B8:  BTFSC  18.7
63BA:  BSF    FF2.7
.................... 			task1(); 
63BC:  CALL   386E
.................... 			print_len_and_tick(); 
63C0:  RCALL  5CA2
.................... 			write_eeprom_data(0); 
63C2:  CLRF   xCF
63C4:  CALL   0818
.................... 			PORTE.tx_en=1; 
63C8:  BSF    F84.2
.................... 			current_measured=0; 
63CA:  CLRF   xC4
63CC:  CLRF   xC3
.................... 			n_avg_current_measured=0; 
63CE:  CLRF   xC5
.................... 			printf("."); 
63D0:  MOVLW  2E
63D2:  BTFSS  F9E.4
63D4:  BRA    63D2
63D6:  MOVWF  FAD
.................... 			tx_delay=TX_DLY_TIME; 
63D8:  MOVLW  01
63DA:  MOVWF  xC2
.................... 			sleep(); 
63DC:  SLEEP 
.................... 		} 
.................... 	} 
63DE:  BRA    604C
....................  
.................... } 
63E0:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: B1 05 00 00 00 00 00 00 00 00 
