CCS PCH C Compiler, Version 4.078, 37503               22-¾.¤.-10 12:42

               Filename: G:\Solar_Tracker_Final\Code\Ver2_w_batt\tracker2.lst

               ROM used: 25800 bytes (79%)
                         Largest free fragment is 6964
               RAM used: 217 (14%) at main() level
                         356 (23%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
0000:  GOTO   5E5C
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   03BA
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04E4
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... // 22-may-2010  power supply always on to fix restart problem, change move_Act_timeout = 3 seconds 
....................  
....................  
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1682:  MOVFF  E3,E5
1686:  MOVFF  E2,E4
168A:  MOVFF  E5,03
168E:  MOVFF  E4,FE9
1692:  MOVFF  E5,FEA
1696:  MOVF   FEF,F
1698:  BZ    16A2
169A:  INCF   xE4,F
169C:  BTFSC  FD8.2
169E:  INCF   xE5,F
16A0:  BRA    168A
....................    return(sc - s); 
16A2:  MOVF   xE2,W
16A4:  SUBWF  xE4,W
16A6:  MOVWF  00
16A8:  MOVF   xE3,W
16AA:  SUBWFB xE5,W
16AC:  MOVWF  03
16AE:  MOVFF  00,01
.................... } 
16B2:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0ADA:  CLRF   xD7
....................    sign = 0; 
0ADC:  CLRF   xD5
....................    base = 10; 
0ADE:  MOVLW  0A
0AE0:  MOVWF  xD6
....................    result = 0; 
0AE2:  CLRF   xD4
0AE4:  CLRF   xD3
....................  
....................    if (!s) 
0AE6:  MOVF   xD1,W
0AE8:  IORWF  xD2,W
0AEA:  BNZ   0AF4
....................       return 0; 
0AEC:  MOVLW  00
0AEE:  MOVWF  01
0AF0:  MOVWF  02
0AF2:  BRA    0CC0
....................    c = s[index++]; 
0AF4:  MOVF   xD7,W
0AF6:  INCF   xD7,F
0AF8:  CLRF   03
0AFA:  ADDWF  xD1,W
0AFC:  MOVWF  FE9
0AFE:  MOVF   xD2,W
0B00:  ADDWFC 03,W
0B02:  MOVWF  FEA
0B04:  MOVFF  FEF,D8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B08:  MOVF   xD8,W
0B0A:  SUBLW  2D
0B0C:  BNZ   0B28
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B0E:  MOVLW  01
0B10:  MOVWF  xD5
....................       c = s[index++]; 
0B12:  MOVF   xD7,W
0B14:  INCF   xD7,F
0B16:  CLRF   03
0B18:  ADDWF  xD1,W
0B1A:  MOVWF  FE9
0B1C:  MOVF   xD2,W
0B1E:  ADDWFC 03,W
0B20:  MOVWF  FEA
0B22:  MOVFF  FEF,D8
....................    } 
....................    else if (c == '+') 
0B26:  BRA    0B42
0B28:  MOVF   xD8,W
0B2A:  SUBLW  2B
0B2C:  BNZ   0B42
....................    { 
....................       c = s[index++]; 
0B2E:  MOVF   xD7,W
0B30:  INCF   xD7,F
0B32:  CLRF   03
0B34:  ADDWF  xD1,W
0B36:  MOVWF  FE9
0B38:  MOVF   xD2,W
0B3A:  ADDWFC 03,W
0B3C:  MOVWF  FEA
0B3E:  MOVFF  FEF,D8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B42:  MOVF   xD8,W
0B44:  SUBLW  2F
0B46:  BTFSC  FD8.0
0B48:  BRA    0CA4
0B4A:  MOVF   xD8,W
0B4C:  SUBLW  39
0B4E:  BTFSS  FD8.0
0B50:  BRA    0CA4
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B52:  MOVF   xD8,W
0B54:  SUBLW  30
0B56:  BNZ   0B9A
0B58:  CLRF   03
0B5A:  MOVF   xD7,W
0B5C:  ADDWF  xD1,W
0B5E:  MOVWF  FE9
0B60:  MOVF   xD2,W
0B62:  ADDWFC 03,W
0B64:  MOVWF  FEA
0B66:  MOVF   FEF,W
0B68:  SUBLW  78
0B6A:  BZ    0B80
0B6C:  CLRF   03
0B6E:  MOVF   xD7,W
0B70:  ADDWF  xD1,W
0B72:  MOVWF  FE9
0B74:  MOVF   xD2,W
0B76:  ADDWFC 03,W
0B78:  MOVWF  FEA
0B7A:  MOVF   FEF,W
0B7C:  SUBLW  58
0B7E:  BNZ   0B9A
....................       { 
....................          base = 16; 
0B80:  MOVLW  10
0B82:  MOVWF  xD6
....................          index++; 
0B84:  INCF   xD7,F
....................          c = s[index++]; 
0B86:  MOVF   xD7,W
0B88:  INCF   xD7,F
0B8A:  CLRF   03
0B8C:  ADDWF  xD1,W
0B8E:  MOVWF  FE9
0B90:  MOVF   xD2,W
0B92:  ADDWFC 03,W
0B94:  MOVWF  FEA
0B96:  MOVFF  FEF,D8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0B9A:  MOVF   xD6,W
0B9C:  SUBLW  0A
0B9E:  BNZ   0BE2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0BA0:  MOVF   xD8,W
0BA2:  SUBLW  2F
0BA4:  BC    0BE0
0BA6:  MOVF   xD8,W
0BA8:  SUBLW  39
0BAA:  BNC   0BE0
....................             result = 10*result + (c - '0'); 
0BAC:  CLRF   xDA
0BAE:  MOVLW  0A
0BB0:  MOVWF  xD9
0BB2:  MOVFF  D4,DC
0BB6:  MOVFF  D3,DB
0BBA:  BRA    0ABA
0BBC:  MOVLW  30
0BBE:  SUBWF  xD8,W
0BC0:  ADDWF  01,W
0BC2:  MOVWF  xD3
0BC4:  MOVLW  00
0BC6:  ADDWFC 02,W
0BC8:  MOVWF  xD4
....................             c = s[index++]; 
0BCA:  MOVF   xD7,W
0BCC:  INCF   xD7,F
0BCE:  CLRF   03
0BD0:  ADDWF  xD1,W
0BD2:  MOVWF  FE9
0BD4:  MOVF   xD2,W
0BD6:  ADDWFC 03,W
0BD8:  MOVWF  FEA
0BDA:  MOVFF  FEF,D8
....................          } 
0BDE:  BRA    0BA0
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0BE0:  BRA    0CA4
0BE2:  MOVF   xD6,W
0BE4:  SUBLW  10
0BE6:  BNZ   0CA4
....................       { 
....................          c = toupper(c); 
0BE8:  MOVF   xD8,W
0BEA:  SUBLW  60
0BEC:  BC    0BFA
0BEE:  MOVF   xD8,W
0BF0:  SUBLW  7A
0BF2:  BNC   0BFA
0BF4:  MOVF   xD8,W
0BF6:  ANDLW  DF
0BF8:  BRA    0BFC
0BFA:  MOVF   xD8,W
0BFC:  MOVWF  xD8
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0BFE:  MOVF   xD8,W
0C00:  SUBLW  2F
0C02:  BC    0C0A
0C04:  MOVF   xD8,W
0C06:  SUBLW  39
0C08:  BC    0C16
0C0A:  MOVF   xD8,W
0C0C:  SUBLW  40
0C0E:  BC    0CA4
0C10:  MOVF   xD8,W
0C12:  SUBLW  46
0C14:  BNC   0CA4
....................             if (c >= '0' && c <= '9') 
0C16:  MOVF   xD8,W
0C18:  SUBLW  2F
0C1A:  BC    0C4E
0C1C:  MOVF   xD8,W
0C1E:  SUBLW  39
0C20:  BNC   0C4E
....................                result = (result << 4) + (c - '0'); 
0C22:  RLCF   xD3,W
0C24:  MOVWF  xD9
0C26:  RLCF   xD4,W
0C28:  MOVWF  xDA
0C2A:  RLCF   xD9,F
0C2C:  RLCF   xDA,F
0C2E:  RLCF   xD9,F
0C30:  RLCF   xDA,F
0C32:  RLCF   xD9,F
0C34:  RLCF   xDA,F
0C36:  MOVLW  F0
0C38:  ANDWF  xD9,F
0C3A:  MOVLW  30
0C3C:  SUBWF  xD8,W
0C3E:  ADDWF  xD9,W
0C40:  MOVWF  01
0C42:  MOVLW  00
0C44:  ADDWFC xDA,W
0C46:  MOVFF  01,D3
0C4A:  MOVWF  xD4
....................             else 
0C4C:  BRA    0C7A
....................                result = (result << 4) + (c - 'A' + 10); 
0C4E:  RLCF   xD3,W
0C50:  MOVWF  xD9
0C52:  RLCF   xD4,W
0C54:  MOVWF  xDA
0C56:  RLCF   xD9,F
0C58:  RLCF   xDA,F
0C5A:  RLCF   xD9,F
0C5C:  RLCF   xDA,F
0C5E:  RLCF   xD9,F
0C60:  RLCF   xDA,F
0C62:  MOVLW  F0
0C64:  ANDWF  xD9,F
0C66:  MOVLW  41
0C68:  SUBWF  xD8,W
0C6A:  ADDLW  0A
0C6C:  ADDWF  xD9,W
0C6E:  MOVWF  01
0C70:  MOVLW  00
0C72:  ADDWFC xDA,W
0C74:  MOVFF  01,D3
0C78:  MOVWF  xD4
....................  
....................             c = s[index++];c = toupper(c); 
0C7A:  MOVF   xD7,W
0C7C:  INCF   xD7,F
0C7E:  CLRF   03
0C80:  ADDWF  xD1,W
0C82:  MOVWF  FE9
0C84:  MOVF   xD2,W
0C86:  ADDWFC 03,W
0C88:  MOVWF  FEA
0C8A:  MOVF   FEF,W
0C8C:  MOVWF  xD8
0C8E:  SUBLW  60
0C90:  BC    0C9E
0C92:  MOVF   xD8,W
0C94:  SUBLW  7A
0C96:  BNC   0C9E
0C98:  MOVF   xD8,W
0C9A:  ANDLW  DF
0C9C:  BRA    0CA0
0C9E:  MOVF   xD8,W
0CA0:  MOVWF  xD8
....................          } 
0CA2:  BRA    0BFE
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0CA4:  MOVF   xD6,W
0CA6:  SUBLW  0A
0CA8:  BNZ   0CB8
0CAA:  DECFSZ xD5,W
0CAC:  BRA    0CB8
....................       result = -result; 
0CAE:  COMF   xD3,F
0CB0:  COMF   xD4,F
0CB2:  INCF   xD3,F
0CB4:  BTFSC  FD8.2
0CB6:  INCF   xD4,F
....................  
....................    return(result); 
0CB8:  MOVFF  D3,01
0CBC:  MOVFF  D4,02
.................... } 
0CC0:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
290A:  CLRF   xD9
....................    sign = 0; 
290C:  CLRF   xD7
....................    base = 10; 
290E:  MOVLW  0A
2910:  MOVWF  xD8
....................    result = 0; 
2912:  CLRF   xD6
2914:  CLRF   xD5
2916:  CLRF   xD4
2918:  CLRF   xD3
....................  
....................    if (!s) 
291A:  MOVF   xD1,W
291C:  IORWF  xD2,W
291E:  BNZ   292A
....................       return 0; 
2920:  CLRF   00
2922:  CLRF   01
2924:  CLRF   02
2926:  CLRF   03
2928:  BRA    2BA4
....................    c = s[index++]; 
292A:  MOVF   xD9,W
292C:  INCF   xD9,F
292E:  CLRF   03
2930:  ADDWF  xD1,W
2932:  MOVWF  FE9
2934:  MOVF   xD2,W
2936:  ADDWFC 03,W
2938:  MOVWF  FEA
293A:  MOVFF  FEF,DA
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
293E:  MOVF   xDA,W
2940:  SUBLW  2D
2942:  BNZ   295E
....................    { 
....................       sign = 1;         // Set the sign to negative 
2944:  MOVLW  01
2946:  MOVWF  xD7
....................       c = s[index++]; 
2948:  MOVF   xD9,W
294A:  INCF   xD9,F
294C:  CLRF   03
294E:  ADDWF  xD1,W
2950:  MOVWF  FE9
2952:  MOVF   xD2,W
2954:  ADDWFC 03,W
2956:  MOVWF  FEA
2958:  MOVFF  FEF,DA
....................    } 
....................    else if (c == '+') 
295C:  BRA    2978
295E:  MOVF   xDA,W
2960:  SUBLW  2B
2962:  BNZ   2978
....................    { 
....................       c = s[index++]; 
2964:  MOVF   xD9,W
2966:  INCF   xD9,F
2968:  CLRF   03
296A:  ADDWF  xD1,W
296C:  MOVWF  FE9
296E:  MOVF   xD2,W
2970:  ADDWFC 03,W
2972:  MOVWF  FEA
2974:  MOVFF  FEF,DA
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2978:  MOVF   xDA,W
297A:  SUBLW  2F
297C:  BTFSC  FD8.0
297E:  BRA    2B74
2980:  MOVF   xDA,W
2982:  SUBLW  39
2984:  BTFSS  FD8.0
2986:  BRA    2B74
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2988:  MOVF   xDA,W
298A:  SUBLW  30
298C:  BNZ   29D0
298E:  CLRF   03
2990:  MOVF   xD9,W
2992:  ADDWF  xD1,W
2994:  MOVWF  FE9
2996:  MOVF   xD2,W
2998:  ADDWFC 03,W
299A:  MOVWF  FEA
299C:  MOVF   FEF,W
299E:  SUBLW  78
29A0:  BZ    29B6
29A2:  CLRF   03
29A4:  MOVF   xD9,W
29A6:  ADDWF  xD1,W
29A8:  MOVWF  FE9
29AA:  MOVF   xD2,W
29AC:  ADDWFC 03,W
29AE:  MOVWF  FEA
29B0:  MOVF   FEF,W
29B2:  SUBLW  58
29B4:  BNZ   29D0
....................       { 
....................          base = 16; 
29B6:  MOVLW  10
29B8:  MOVWF  xD8
....................          index++; 
29BA:  INCF   xD9,F
....................          c = s[index++]; 
29BC:  MOVF   xD9,W
29BE:  INCF   xD9,F
29C0:  CLRF   03
29C2:  ADDWF  xD1,W
29C4:  MOVWF  FE9
29C6:  MOVF   xD2,W
29C8:  ADDWFC 03,W
29CA:  MOVWF  FEA
29CC:  MOVFF  FEF,DA
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
29D0:  MOVF   xD8,W
29D2:  SUBLW  0A
29D4:  BNZ   2A5E
....................       { 
....................          while (c >= '0' && c <= '9') { 
29D6:  MOVF   xDA,W
29D8:  SUBLW  2F
29DA:  BC    2A5C
29DC:  MOVF   xDA,W
29DE:  SUBLW  39
29E0:  BNC   2A5C
....................             result = (result << 1) + (result << 3);  // result *= 10; 
29E2:  BCF    FD8.0
29E4:  RLCF   xD3,W
29E6:  MOVWF  xDC
29E8:  RLCF   xD4,W
29EA:  MOVWF  xDD
29EC:  RLCF   xD5,W
29EE:  MOVWF  xDE
29F0:  RLCF   xD6,W
29F2:  MOVWF  xDF
29F4:  RLCF   xD3,W
29F6:  MOVWF  00
29F8:  RLCF   xD4,W
29FA:  MOVWF  01
29FC:  RLCF   xD5,W
29FE:  MOVWF  02
2A00:  RLCF   xD6,W
2A02:  MOVWF  03
2A04:  RLCF   00,F
2A06:  RLCF   01,F
2A08:  RLCF   02,F
2A0A:  RLCF   03,F
2A0C:  RLCF   00,F
2A0E:  RLCF   01,F
2A10:  RLCF   02,F
2A12:  RLCF   03,F
2A14:  MOVLW  F8
2A16:  ANDWF  00,F
2A18:  MOVF   xDC,W
2A1A:  ADDWF  00,F
2A1C:  MOVF   xDD,W
2A1E:  ADDWFC 01,F
2A20:  MOVF   xDE,W
2A22:  ADDWFC 02,F
2A24:  MOVF   xDF,W
2A26:  ADDWFC 03,F
2A28:  MOVFF  03,D6
2A2C:  MOVFF  02,D5
2A30:  MOVFF  01,D4
2A34:  MOVFF  00,D3
....................             result += (c - '0'); 
2A38:  MOVLW  30
2A3A:  SUBWF  xDA,W
2A3C:  ADDWF  xD3,F
2A3E:  MOVLW  00
2A40:  ADDWFC xD4,F
2A42:  ADDWFC xD5,F
2A44:  ADDWFC xD6,F
....................             c = s[index++]; 
2A46:  MOVF   xD9,W
2A48:  INCF   xD9,F
2A4A:  CLRF   03
2A4C:  ADDWF  xD1,W
2A4E:  MOVWF  FE9
2A50:  MOVF   xD2,W
2A52:  ADDWFC 03,W
2A54:  MOVWF  FEA
2A56:  MOVFF  FEF,DA
....................          } 
2A5A:  BRA    29D6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2A5C:  BRA    2B74
2A5E:  MOVF   xD8,W
2A60:  SUBLW  10
2A62:  BTFSS  FD8.2
2A64:  BRA    2B74
....................       { 
....................          c = toupper(c); 
2A66:  MOVF   xDA,W
2A68:  SUBLW  60
2A6A:  BC    2A78
2A6C:  MOVF   xDA,W
2A6E:  SUBLW  7A
2A70:  BNC   2A78
2A72:  MOVF   xDA,W
2A74:  ANDLW  DF
2A76:  BRA    2A7A
2A78:  MOVF   xDA,W
2A7A:  MOVWF  xDA
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2A7C:  MOVF   xDA,W
2A7E:  SUBLW  2F
2A80:  BC    2A88
2A82:  MOVF   xDA,W
2A84:  SUBLW  39
2A86:  BC    2A96
2A88:  MOVF   xDA,W
2A8A:  SUBLW  40
2A8C:  BTFSC  FD8.0
2A8E:  BRA    2B74
2A90:  MOVF   xDA,W
2A92:  SUBLW  46
2A94:  BNC   2B74
....................             if (c >= '0' && c <= '9') 
2A96:  MOVF   xDA,W
2A98:  SUBLW  2F
2A9A:  BC    2AF6
2A9C:  MOVF   xDA,W
2A9E:  SUBLW  39
2AA0:  BNC   2AF6
....................                result = (result << 4) + (c - '0'); 
2AA2:  RLCF   xD3,W
2AA4:  MOVWF  xDC
2AA6:  RLCF   xD4,W
2AA8:  MOVWF  xDD
2AAA:  RLCF   xD5,W
2AAC:  MOVWF  xDE
2AAE:  RLCF   xD6,W
2AB0:  MOVWF  xDF
2AB2:  RLCF   xDC,F
2AB4:  RLCF   xDD,F
2AB6:  RLCF   xDE,F
2AB8:  RLCF   xDF,F
2ABA:  RLCF   xDC,F
2ABC:  RLCF   xDD,F
2ABE:  RLCF   xDE,F
2AC0:  RLCF   xDF,F
2AC2:  RLCF   xDC,F
2AC4:  RLCF   xDD,F
2AC6:  RLCF   xDE,F
2AC8:  RLCF   xDF,F
2ACA:  MOVLW  F0
2ACC:  ANDWF  xDC,F
2ACE:  MOVLW  30
2AD0:  SUBWF  xDA,W
2AD2:  ADDWF  xDC,W
2AD4:  MOVWF  00
2AD6:  MOVLW  00
2AD8:  ADDWFC xDD,W
2ADA:  MOVWF  01
2ADC:  MOVLW  00
2ADE:  ADDWFC xDE,W
2AE0:  MOVWF  02
2AE2:  MOVLW  00
2AE4:  ADDWFC xDF,W
2AE6:  MOVWF  xD6
2AE8:  MOVFF  02,D5
2AEC:  MOVFF  01,D4
2AF0:  MOVFF  00,D3
....................             else 
2AF4:  BRA    2B4A
....................                result = (result << 4) + (c - 'A' + 10); 
2AF6:  RLCF   xD3,W
2AF8:  MOVWF  xDC
2AFA:  RLCF   xD4,W
2AFC:  MOVWF  xDD
2AFE:  RLCF   xD5,W
2B00:  MOVWF  xDE
2B02:  RLCF   xD6,W
2B04:  MOVWF  xDF
2B06:  RLCF   xDC,F
2B08:  RLCF   xDD,F
2B0A:  RLCF   xDE,F
2B0C:  RLCF   xDF,F
2B0E:  RLCF   xDC,F
2B10:  RLCF   xDD,F
2B12:  RLCF   xDE,F
2B14:  RLCF   xDF,F
2B16:  RLCF   xDC,F
2B18:  RLCF   xDD,F
2B1A:  RLCF   xDE,F
2B1C:  RLCF   xDF,F
2B1E:  MOVLW  F0
2B20:  ANDWF  xDC,F
2B22:  MOVLW  41
2B24:  SUBWF  xDA,W
2B26:  ADDLW  0A
2B28:  ADDWF  xDC,W
2B2A:  MOVWF  00
2B2C:  MOVLW  00
2B2E:  ADDWFC xDD,W
2B30:  MOVWF  01
2B32:  MOVLW  00
2B34:  ADDWFC xDE,W
2B36:  MOVWF  02
2B38:  MOVLW  00
2B3A:  ADDWFC xDF,W
2B3C:  MOVWF  xD6
2B3E:  MOVFF  02,D5
2B42:  MOVFF  01,D4
2B46:  MOVFF  00,D3
....................  
....................             c = s[index++];c = toupper(c); 
2B4A:  MOVF   xD9,W
2B4C:  INCF   xD9,F
2B4E:  CLRF   03
2B50:  ADDWF  xD1,W
2B52:  MOVWF  FE9
2B54:  MOVF   xD2,W
2B56:  ADDWFC 03,W
2B58:  MOVWF  FEA
2B5A:  MOVF   FEF,W
2B5C:  MOVWF  xDA
2B5E:  SUBLW  60
2B60:  BC    2B6E
2B62:  MOVF   xDA,W
2B64:  SUBLW  7A
2B66:  BNC   2B6E
2B68:  MOVF   xDA,W
2B6A:  ANDLW  DF
2B6C:  BRA    2B70
2B6E:  MOVF   xDA,W
2B70:  MOVWF  xDA
....................          } 
2B72:  BRA    2A7C
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2B74:  MOVF   xD8,W
2B76:  SUBLW  0A
2B78:  BNZ   2B94
2B7A:  DECFSZ xD7,W
2B7C:  BRA    2B94
....................       result = -result; 
2B7E:  COMF   xD3,F
2B80:  COMF   xD4,F
2B82:  COMF   xD5,F
2B84:  COMF   xD6,F
2B86:  INCF   xD3,F
2B88:  BTFSC  FD8.2
2B8A:  INCF   xD4,F
2B8C:  BTFSC  FD8.2
2B8E:  INCF   xD5,F
2B90:  BTFSC  FD8.2
2B92:  INCF   xD6,F
....................  
....................    return(result); 
2B94:  MOVFF  D3,00
2B98:  MOVFF  D4,01
2B9C:  MOVFF  D5,02
2BA0:  MOVFF  D6,03
.................... } 
2BA4:  GOTO   3232 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
14A6:  MOVLW  01
14A8:  MOVWF  xED
14AA:  CLRF   xEE
14AC:  CLRF   xEF
14AE:  CLRF   xF0
....................      unsigned int8 i,sign=0,cnt=0; 
14B0:  CLRF   xF2
14B2:  CLRF   xF3
....................      char c; 
....................  
....................      if(num<0) { 
14B4:  BTFSC  xE9.7
14B6:  BRA    14BA
14B8:  BRA    14EA
....................          sign=1;        // Check for negative number 
14BA:  MOVLW  01
14BC:  MOVWF  xF2
....................          num*=-1; 
14BE:  MOVFF  E9,F8
14C2:  MOVFF  E8,F7
14C6:  MOVFF  E7,F6
14CA:  MOVFF  E6,F5
14CE:  MOVLW  FF
14D0:  MOVWF  xFC
14D2:  MOVWF  xFB
14D4:  MOVWF  xFA
14D6:  MOVWF  xF9
14D8:  RCALL  1330
14DA:  MOVFF  03,E9
14DE:  MOVFF  02,E8
14E2:  MOVFF  01,E7
14E6:  MOVFF  00,E6
....................      } 
....................  
....................      while(temp>0) { 
14EA:  MOVF   xED,F
14EC:  BNZ   14FA
14EE:  MOVF   xEE,F
14F0:  BNZ   14FA
14F2:  MOVF   xEF,F
14F4:  BNZ   14FA
14F6:  MOVF   xF0,F
14F8:  BZ    15E8
....................          temp=(num/base); 
14FA:  MOVFF  E9,FC
14FE:  MOVFF  E8,FB
1502:  MOVFF  E7,FA
1506:  MOVFF  E6,F9
150A:  MOVLB  1
150C:  CLRF   x00
150E:  MOVLB  0
1510:  CLRF   xFF
1512:  CLRF   xFE
1514:  MOVFF  EA,FD
1518:  RCALL  1396
151A:  MOVFF  03,F0
151E:  MOVFF  02,EF
1522:  MOVFF  01,EE
1526:  MOVFF  00,ED
....................          s[cnt]=(num%base)+'0';    // Conversion 
152A:  CLRF   03
152C:  MOVF   xF3,W
152E:  ADDWF  xEB,W
1530:  MOVWF  01
1532:  MOVF   xEC,W
1534:  ADDWFC 03,F
1536:  MOVFF  01,F5
153A:  MOVFF  03,F6
153E:  MOVFF  FEA,F8
1542:  MOVFF  FE9,F7
1546:  MOVFF  E9,FC
154A:  MOVFF  E8,FB
154E:  MOVFF  E7,FA
1552:  MOVFF  E6,F9
1556:  MOVLB  1
1558:  CLRF   x00
155A:  MOVLB  0
155C:  CLRF   xFF
155E:  CLRF   xFE
1560:  MOVFF  EA,FD
1564:  RCALL  1396
1566:  MOVFF  FEF,00
156A:  MOVFF  FEC,01
156E:  MOVFF  FEC,02
1572:  MOVFF  FEC,03
1576:  MOVFF  F8,FEA
157A:  MOVFF  F7,FE9
157E:  MOVFF  03,FC
1582:  MOVFF  02,FB
1586:  MOVFF  01,FA
158A:  MOVFF  00,F9
158E:  MOVLW  30
1590:  ADDWF  00,W
1592:  MOVWF  00
1594:  MOVLW  00
1596:  ADDWFC 01,W
1598:  MOVLW  00
159A:  ADDWFC 02,W
159C:  MOVLW  00
159E:  ADDWFC 03,W
15A0:  MOVFF  F6,FEA
15A4:  MOVFF  F5,FE9
15A8:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
15AC:  CLRF   03
15AE:  MOVF   xF3,W
15B0:  ADDWF  xEB,W
15B2:  MOVWF  FE9
15B4:  MOVF   xEC,W
15B6:  ADDWFC 03,W
15B8:  MOVWF  FEA
15BA:  MOVF   FEF,W
15BC:  SUBLW  39
15BE:  BC    15D4
....................             s[cnt]+=0x7; 
15C0:  CLRF   03
15C2:  MOVF   xF3,W
15C4:  ADDWF  xEB,W
15C6:  MOVWF  FE9
15C8:  MOVF   xEC,W
15CA:  ADDWFC 03,W
15CC:  MOVWF  FEA
15CE:  MOVLW  07
15D0:  ADDWF  FEF,W
15D2:  MOVWF  FEF
....................  
....................          cnt++; 
15D4:  INCF   xF3,F
....................          num=temp; 
15D6:  MOVFF  F0,E9
15DA:  MOVFF  EF,E8
15DE:  MOVFF  EE,E7
15E2:  MOVFF  ED,E6
....................      } 
15E6:  BRA    14EA
....................  
....................      if(sign==1) { 
15E8:  DECFSZ xF2,W
15EA:  BRA    1600
....................          s[cnt]=0x2D;      // Negative sign 
15EC:  CLRF   03
15EE:  MOVF   xF3,W
15F0:  ADDWF  xEB,W
15F2:  MOVWF  FE9
15F4:  MOVF   xEC,W
15F6:  ADDWFC 03,W
15F8:  MOVWF  FEA
15FA:  MOVLW  2D
15FC:  MOVWF  FEF
....................          cnt++; 
15FE:  INCF   xF3,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1600:  CLRF   xF1
1602:  BCF    FD8.0
1604:  RRCF   xF3,W
1606:  SUBWF  xF1,W
1608:  BC    1668
....................  
....................          c=s[i]; 
160A:  CLRF   03
160C:  MOVF   xF1,W
160E:  ADDWF  xEB,W
1610:  MOVWF  FE9
1612:  MOVF   xEC,W
1614:  ADDWFC 03,W
1616:  MOVWF  FEA
1618:  MOVFF  FEF,F4
....................          s[i]=s[cnt-i-1];        // Reverse the number 
161C:  CLRF   03
161E:  MOVF   xF1,W
1620:  ADDWF  xEB,W
1622:  MOVWF  01
1624:  MOVF   xEC,W
1626:  ADDWFC 03,F
1628:  MOVFF  03,F6
162C:  MOVF   xF1,W
162E:  SUBWF  xF3,W
1630:  ADDLW  FF
1632:  CLRF   03
1634:  ADDWF  xEB,W
1636:  MOVWF  FE9
1638:  MOVF   xEC,W
163A:  ADDWFC 03,W
163C:  MOVWF  FEA
163E:  MOVFF  FEF,F9
1642:  MOVFF  F6,FEA
1646:  MOVFF  01,FE9
164A:  MOVFF  F9,FEF
....................          s[cnt-i-1]=c; 
164E:  MOVF   xF1,W
1650:  SUBWF  xF3,W
1652:  ADDLW  FF
1654:  CLRF   03
1656:  ADDWF  xEB,W
1658:  MOVWF  FE9
165A:  MOVF   xEC,W
165C:  ADDWFC 03,W
165E:  MOVWF  FEA
1660:  MOVFF  F4,FEF
....................      } 
1664:  INCF   xF1,F
1666:  BRA    1602
....................      s[cnt]='\0';     // End the string 
1668:  CLRF   03
166A:  MOVF   xF3,W
166C:  ADDWF  xEB,W
166E:  MOVWF  FE9
1670:  MOVF   xEC,W
1672:  ADDWFC 03,W
1674:  MOVWF  FEA
1676:  CLRF   FEF
....................      return s; 
1678:  MOVFF  EB,01
167C:  MOVFF  EC,02
.................... } 
1680:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
54D4:  MOVLB  1
54D6:  BCF    x0B.0
....................    y = x; 
54D8:  MOVFF  FF,104
54DC:  MOVFF  FE,103
54E0:  MOVFF  FD,102
54E4:  MOVFF  FC,101
....................  
....................    if (x < 0) 
54E8:  MOVFF  FF,14D
54EC:  MOVFF  FE,14C
54F0:  MOVFF  FD,14B
54F4:  MOVFF  FC,14A
54F8:  CLRF   x51
54FA:  CLRF   x50
54FC:  CLRF   x4F
54FE:  CLRF   x4E
5500:  MOVLB  0
5502:  CALL   3E46
5506:  BNC   5512
....................    { 
....................       s = 1; 
5508:  MOVLB  1
550A:  BSF    x0B.0
....................       y = -y; 
550C:  MOVF   x02,W
550E:  XORLW  80
5510:  MOVWF  x02
....................    } 
....................  
....................    if (y <= 32768.0) 
5512:  MOVFF  104,14D
5516:  MOVFF  103,14C
551A:  MOVFF  102,14B
551E:  MOVFF  101,14A
5522:  MOVLB  1
5524:  CLRF   x51
5526:  CLRF   x50
5528:  CLRF   x4F
552A:  MOVLW  8E
552C:  MOVWF  x4E
552E:  MOVLB  0
5530:  CALL   3E46
5534:  BC    5538
5536:  BNZ   556A
....................   res = (float32)(unsigned int16)y; 
5538:  MOVFF  104,14D
553C:  MOVFF  103,14C
5540:  MOVFF  102,14B
5544:  MOVFF  101,14A
5548:  CALL   4420
554C:  MOVFF  02,14F
5550:  MOVFF  01,14E
5554:  CALL   43EA
5558:  MOVFF  03,108
555C:  MOVFF  02,107
5560:  MOVFF  01,106
5564:  MOVFF  00,105
....................  
....................  else if (y < 10000000.0) 
5568:  BRA    5710
556A:  MOVFF  104,14D
556E:  MOVFF  103,14C
5572:  MOVFF  102,14B
5576:  MOVFF  101,14A
557A:  MOVLW  80
557C:  MOVLB  1
557E:  MOVWF  x51
5580:  MOVLW  96
5582:  MOVWF  x50
5584:  MOVLW  18
5586:  MOVWF  x4F
5588:  MOVLW  96
558A:  MOVWF  x4E
558C:  MOVLB  0
558E:  CALL   3E46
5592:  BTFSS  FD8.0
5594:  BRA    5700
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
5596:  MOVFF  104,14D
559A:  MOVFF  103,14C
559E:  MOVFF  102,14B
55A2:  MOVFF  101,14A
55A6:  MOVLB  1
55A8:  CLRF   x51
55AA:  CLRF   x50
55AC:  CLRF   x4F
55AE:  MOVLW  8E
55B0:  MOVWF  x4E
55B2:  MOVLB  0
55B4:  CALL   0F1A
55B8:  MOVFF  03,14D
55BC:  MOVFF  02,14C
55C0:  MOVFF  01,14B
55C4:  MOVFF  00,14A
55C8:  CALL   4420
55CC:  MOVFF  02,10A
55D0:  MOVFF  01,109
....................       y = 32768.0*(y/32768.0 - (float32)l); 
55D4:  MOVFF  104,14D
55D8:  MOVFF  103,14C
55DC:  MOVFF  102,14B
55E0:  MOVFF  101,14A
55E4:  MOVLB  1
55E6:  CLRF   x51
55E8:  CLRF   x50
55EA:  CLRF   x4F
55EC:  MOVLW  8E
55EE:  MOVWF  x4E
55F0:  MOVLB  0
55F2:  CALL   0F1A
55F6:  MOVFF  00,10C
55FA:  MOVFF  01,10D
55FE:  MOVFF  02,10E
5602:  MOVFF  03,10F
5606:  MOVFF  10A,14F
560A:  MOVFF  109,14E
560E:  CALL   43EA
5612:  BSF    FD8.1
5614:  MOVFF  10F,153
5618:  MOVFF  10E,152
561C:  MOVFF  10D,151
5620:  MOVFF  10C,150
5624:  MOVFF  03,157
5628:  MOVFF  02,156
562C:  MOVFF  01,155
5630:  MOVFF  00,154
5634:  CALL   1078
5638:  MOVLB  1
563A:  CLRF   x51
563C:  CLRF   x50
563E:  CLRF   x4F
5640:  MOVLW  8E
5642:  MOVWF  x4E
5644:  MOVFF  03,155
5648:  MOVFF  02,154
564C:  MOVFF  01,153
5650:  MOVFF  00,152
5654:  MOVLB  0
5656:  CALL   0E24
565A:  MOVFF  03,104
565E:  MOVFF  02,103
5662:  MOVFF  01,102
5666:  MOVFF  00,101
....................   res = 32768.0*(float32)l; 
566A:  MOVFF  10A,14F
566E:  MOVFF  109,14E
5672:  CALL   43EA
5676:  MOVLB  1
5678:  CLRF   x51
567A:  CLRF   x50
567C:  CLRF   x4F
567E:  MOVLW  8E
5680:  MOVWF  x4E
5682:  MOVFF  03,155
5686:  MOVFF  02,154
568A:  MOVFF  01,153
568E:  MOVFF  00,152
5692:  MOVLB  0
5694:  CALL   0E24
5698:  MOVFF  03,108
569C:  MOVFF  02,107
56A0:  MOVFF  01,106
56A4:  MOVFF  00,105
....................   res += (float32)(unsigned int16)y; 
56A8:  MOVFF  104,14D
56AC:  MOVFF  103,14C
56B0:  MOVFF  102,14B
56B4:  MOVFF  101,14A
56B8:  CALL   4420
56BC:  MOVFF  02,14F
56C0:  MOVFF  01,14E
56C4:  CALL   43EA
56C8:  BCF    FD8.1
56CA:  MOVFF  108,153
56CE:  MOVFF  107,152
56D2:  MOVFF  106,151
56D6:  MOVFF  105,150
56DA:  MOVFF  03,157
56DE:  MOVFF  02,156
56E2:  MOVFF  01,155
56E6:  MOVFF  00,154
56EA:  CALL   1078
56EE:  MOVFF  03,108
56F2:  MOVFF  02,107
56F6:  MOVFF  01,106
56FA:  MOVFF  00,105
....................  } 
....................  
....................  else 
56FE:  BRA    5710
....................   res = y; 
5700:  MOVFF  104,108
5704:  MOVFF  103,107
5708:  MOVFF  102,106
570C:  MOVFF  101,105
....................  
....................  y = y - (float32)(unsigned int16)y; 
5710:  MOVFF  104,14D
5714:  MOVFF  103,14C
5718:  MOVFF  102,14B
571C:  MOVFF  101,14A
5720:  CALL   4420
5724:  MOVFF  02,14F
5728:  MOVFF  01,14E
572C:  CALL   43EA
5730:  BSF    FD8.1
5732:  MOVFF  104,153
5736:  MOVFF  103,152
573A:  MOVFF  102,151
573E:  MOVFF  101,150
5742:  MOVFF  03,157
5746:  MOVFF  02,156
574A:  MOVFF  01,155
574E:  MOVFF  00,154
5752:  CALL   1078
5756:  MOVFF  03,104
575A:  MOVFF  02,103
575E:  MOVFF  01,102
5762:  MOVFF  00,101
....................  
....................  if (s) 
5766:  MOVLB  1
5768:  BTFSS  x0B.0
576A:  BRA    5772
....................   res = -res; 
576C:  MOVF   x06,W
576E:  XORLW  80
5770:  MOVWF  x06
....................  
....................  if (y != 0) 
5772:  MOVFF  104,14D
5776:  MOVFF  103,14C
577A:  MOVFF  102,14B
577E:  MOVFF  101,14A
5782:  CLRF   x51
5784:  CLRF   x50
5786:  CLRF   x4F
5788:  CLRF   x4E
578A:  MOVLB  0
578C:  CALL   3E46
5790:  BZ    580A
....................  { 
....................   if (s == 1 && n == 0) 
5792:  MOVLB  1
5794:  BTFSS  x0B.0
5796:  BRA    57D0
5798:  MOVF   x00,F
579A:  BNZ   57D0
....................    res -= 1.0; 
579C:  BSF    FD8.1
579E:  MOVFF  108,153
57A2:  MOVFF  107,152
57A6:  MOVFF  106,151
57AA:  MOVFF  105,150
57AE:  CLRF   x57
57B0:  CLRF   x56
57B2:  CLRF   x55
57B4:  MOVLW  7F
57B6:  MOVWF  x54
57B8:  MOVLB  0
57BA:  CALL   1078
57BE:  MOVFF  03,108
57C2:  MOVFF  02,107
57C6:  MOVFF  01,106
57CA:  MOVFF  00,105
57CE:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
57D0:  BTFSC  x0B.0
57D2:  BRA    580C
57D4:  DECFSZ x00,W
57D6:  BRA    580C
....................    res += 1.0; 
57D8:  BCF    FD8.1
57DA:  MOVFF  108,153
57DE:  MOVFF  107,152
57E2:  MOVFF  106,151
57E6:  MOVFF  105,150
57EA:  CLRF   x57
57EC:  CLRF   x56
57EE:  CLRF   x55
57F0:  MOVLW  7F
57F2:  MOVWF  x54
57F4:  MOVLB  0
57F6:  CALL   1078
57FA:  MOVFF  03,108
57FE:  MOVFF  02,107
5802:  MOVFF  01,106
5806:  MOVFF  00,105
580A:  MOVLB  1
....................  } 
....................  if (x == 0) 
580C:  MOVFF  FF,14D
5810:  MOVFF  FE,14C
5814:  MOVFF  FD,14B
5818:  MOVFF  FC,14A
581C:  CLRF   x51
581E:  CLRF   x50
5820:  CLRF   x4F
5822:  CLRF   x4E
5824:  MOVLB  0
5826:  CALL   3E46
582A:  BNZ   5838
....................     res = 0; 
582C:  MOVLB  1
582E:  CLRF   x08
5830:  CLRF   x07
5832:  CLRF   x06
5834:  CLRF   x05
5836:  MOVLB  0
....................  
....................  return (res); 
5838:  MOVFF  105,00
583C:  MOVFF  106,01
5840:  MOVFF  107,02
5844:  MOVFF  108,03
.................... } 
5848:  RETLW  00
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
5868:  MOVFF  FB,FF
586C:  MOVFF  FA,FE
5870:  MOVFF  F9,FD
5874:  MOVFF  F8,FC
5878:  MOVLB  1
587A:  CLRF   x00
587C:  MOVLB  0
587E:  RCALL  54D4
.................... } 
5880:  GOTO   598C (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
584A:  MOVFF  FA,FF
584E:  MOVFF  F9,FE
5852:  MOVFF  F8,FD
5856:  MOVFF  F7,FC
585A:  MOVLW  01
585C:  MOVLB  1
585E:  MOVWF  x00
5860:  MOVLB  0
5862:  RCALL  54D4
.................... } 
5864:  GOTO   5944 (RETURN)
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
5884:  MOVFF  EA,14D
5888:  MOVFF  E9,14C
588C:  MOVFF  E8,14B
5890:  MOVFF  E7,14A
5894:  MOVLB  1
5896:  CLRF   x51
5898:  CLRF   x50
589A:  CLRF   x4F
589C:  CLRF   x4E
589E:  MOVLB  0
58A0:  CALL   3E46
58A4:  BTFSC  FD8.2
58A6:  BRA    59EA
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
58A8:  MOVFF  E6,14D
58AC:  MOVFF  E5,14C
58B0:  MOVFF  E4,14B
58B4:  MOVFF  E3,14A
58B8:  MOVFF  EA,151
58BC:  MOVFF  E9,150
58C0:  MOVFF  E8,14F
58C4:  MOVFF  E7,14E
58C8:  CALL   0F1A
58CC:  MOVFF  00,EF
58D0:  MOVFF  01,F0
58D4:  MOVFF  02,F1
58D8:  MOVFF  03,F2
58DC:  MOVFF  03,14D
58E0:  MOVFF  02,14C
58E4:  MOVFF  01,14B
58E8:  MOVFF  00,14A
58EC:  MOVLB  1
58EE:  CLRF   x51
58F0:  CLRF   x50
58F2:  CLRF   x4F
58F4:  CLRF   x4E
58F6:  MOVLB  0
58F8:  CALL   3E46
58FC:  BNC   5946
58FE:  MOVFF  E6,14D
5902:  MOVFF  E5,14C
5906:  MOVFF  E4,14B
590A:  MOVFF  E3,14A
590E:  MOVFF  EA,151
5912:  MOVFF  E9,150
5916:  MOVFF  E8,14F
591A:  MOVFF  E7,14E
591E:  CALL   0F1A
5922:  MOVFF  00,F3
5926:  MOVFF  01,F4
592A:  MOVFF  02,F5
592E:  MOVFF  03,F6
5932:  MOVFF  03,FA
5936:  MOVFF  02,F9
593A:  MOVFF  01,F8
593E:  MOVFF  00,F7
5942:  BRA    584A
5944:  BRA    598C
5946:  MOVFF  E6,14D
594A:  MOVFF  E5,14C
594E:  MOVFF  E4,14B
5952:  MOVFF  E3,14A
5956:  MOVFF  EA,151
595A:  MOVFF  E9,150
595E:  MOVFF  E8,14F
5962:  MOVFF  E7,14E
5966:  CALL   0F1A
596A:  MOVFF  00,F4
596E:  MOVFF  01,F5
5972:  MOVFF  02,F6
5976:  MOVFF  03,F7
597A:  MOVFF  03,FB
597E:  MOVFF  02,FA
5982:  MOVFF  01,F9
5986:  MOVFF  00,F8
598A:  BRA    5868
598C:  MOVFF  03,EE
5990:  MOVFF  02,ED
5994:  MOVFF  01,EC
5998:  MOVFF  00,EB
....................       return(x-(i*y)); 
599C:  MOVFF  EE,151
59A0:  MOVFF  ED,150
59A4:  MOVFF  EC,14F
59A8:  MOVFF  EB,14E
59AC:  MOVFF  EA,155
59B0:  MOVFF  E9,154
59B4:  MOVFF  E8,153
59B8:  MOVFF  E7,152
59BC:  CALL   0E24
59C0:  BSF    FD8.1
59C2:  MOVFF  E6,153
59C6:  MOVFF  E5,152
59CA:  MOVFF  E4,151
59CE:  MOVFF  E3,150
59D2:  MOVFF  03,157
59D6:  MOVFF  02,156
59DA:  MOVFF  01,155
59DE:  MOVFF  00,154
59E2:  CALL   1078
59E6:  BRA    59EA
....................    } 
....................    else 
59E8:  BRA    59EA
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
59EA:  GOTO   5C7E (RETURN)
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
48D0:  MOVFF  115,14D
48D4:  MOVFF  114,14C
48D8:  MOVFF  113,14B
48DC:  MOVFF  112,14A
48E0:  MOVLB  1
48E2:  CLRF   x51
48E4:  CLRF   x50
48E6:  CLRF   x4F
48E8:  CLRF   x4E
48EA:  MOVLB  0
48EC:  CALL   3E46
48F0:  BC    48F4
48F2:  BNZ   48FE
....................       return(0.0); 
48F4:  CLRF   00
48F6:  CLRF   01
48F8:  CLRF   02
48FA:  CLRF   03
48FC:  BRA    49F8
....................  
....................    y=x; 
48FE:  MOVFF  115,119
4902:  MOVFF  114,118
4906:  MOVFF  113,117
490A:  MOVFF  112,116
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
490E:  MOVLW  01
4910:  MOVLB  1
4912:  MOVWF  x1F
4914:  MOVLW  16
4916:  MOVWF  x1E
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
4918:  MOVFF  11E,FE9
491C:  MOVFF  11F,FEA
4920:  MOVF   FEF,W
4922:  CLRF   x23
4924:  MOVWF  x22
4926:  MOVLW  7F
4928:  ADDWF  x22,W
492A:  MOVWF  x24
492C:  MOVLW  00
492E:  ADDWFC x23,W
4930:  MOVWF  x25
4932:  BCF    FD8.0
4934:  RRCF   x25,W
4936:  RRCF   x24,W
4938:  MOVFF  11F,FEA
493C:  MOVFF  11E,FE9
4940:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
4942:  MOVFF  119,11D
4946:  MOVFF  118,11C
494A:  MOVFF  117,11B
494E:  MOVFF  116,11A
....................       y+=(x/y); 
4952:  MOVFF  115,14D
4956:  MOVFF  114,14C
495A:  MOVFF  113,14B
495E:  MOVFF  112,14A
4962:  MOVFF  119,151
4966:  MOVFF  118,150
496A:  MOVFF  117,14F
496E:  MOVFF  116,14E
4972:  MOVLB  0
4974:  CALL   0F1A
4978:  BCF    FD8.1
497A:  MOVFF  119,153
497E:  MOVFF  118,152
4982:  MOVFF  117,151
4986:  MOVFF  116,150
498A:  MOVFF  03,157
498E:  MOVFF  02,156
4992:  MOVFF  01,155
4996:  MOVFF  00,154
499A:  CALL   1078
499E:  MOVFF  03,119
49A2:  MOVFF  02,118
49A6:  MOVFF  01,117
49AA:  MOVFF  00,116
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
49AE:  MOVLB  1
49B0:  MOVFF  11E,FE9
49B4:  MOVFF  11F,FEA
49B8:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
49BA:  MOVFF  11D,14D
49BE:  MOVFF  11C,14C
49C2:  MOVFF  11B,14B
49C6:  MOVFF  11A,14A
49CA:  MOVFF  119,151
49CE:  MOVFF  118,150
49D2:  MOVFF  117,14F
49D6:  MOVFF  116,14E
49DA:  MOVLB  0
49DC:  CALL   3E46
49E0:  BTFSC  FD8.2
49E2:  BRA    49E8
49E4:  MOVLB  1
49E6:  BRA    4942
....................  
....................    return(res); 
49E8:  MOVFF  11A,00
49EC:  MOVFF  11B,01
49F0:  MOVFF  11C,02
49F4:  MOVFF  11D,03
.................... } 
49F8:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
445C:  MOVLW  7F
445E:  MOVLB  1
4460:  MOVWF  x30
4462:  CLRF   x31
4464:  CLRF   x32
4466:  CLRF   x33
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
4468:  MOVLW  7E
446A:  MOVWF  x3A
446C:  MOVLW  80
446E:  MOVWF  x3B
4470:  CLRF   x3C
4472:  CLRF   x3D
4474:  MOVLW  7A
4476:  MOVWF  x3E
4478:  MOVLW  2A
447A:  MOVWF  x3F
447C:  MOVLW  AA
447E:  MOVWF  x40
4480:  MOVLW  A3
4482:  MOVWF  x41
4484:  MOVLW  75
4486:  MOVWF  x42
4488:  MOVLW  B6
448A:  MOVWF  x43
448C:  MOVLW  09
448E:  MOVWF  x44
4490:  MOVLW  9C
4492:  MOVWF  x45
4494:  MOVLW  6F
4496:  MOVWF  x46
4498:  MOVLW  4F
449A:  MOVWF  x47
449C:  MOVLW  B4
449E:  MOVWF  x48
44A0:  MOVLW  0B
44A2:  MOVWF  x49
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
44A4:  MOVFF  127,14D
44A8:  MOVFF  126,14C
44AC:  MOVFF  125,14B
44B0:  MOVFF  124,14A
44B4:  CLRF   x51
44B6:  CLRF   x50
44B8:  CLRF   x4F
44BA:  CLRF   x4E
44BC:  MOVLB  0
44BE:  RCALL  3E46
44C0:  BNC   44CA
44C2:  MOVLB  1
44C4:  MOVF   x25,W
44C6:  XORLW  80
44C8:  MOVWF  x25
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
44CA:  MOVFF  127,14D
44CE:  MOVFF  126,14C
44D2:  MOVFF  125,14B
44D6:  MOVFF  124,14A
44DA:  MOVLW  DB
44DC:  MOVLB  1
44DE:  MOVWF  x51
44E0:  MOVLW  0F
44E2:  MOVWF  x50
44E4:  MOVLW  49
44E6:  MOVWF  x4F
44E8:  MOVLW  7F
44EA:  MOVWF  x4E
44EC:  MOVLB  0
44EE:  CALL   0F1A
44F2:  MOVFF  03,14D
44F6:  MOVFF  02,14C
44FA:  MOVFF  01,14B
44FE:  MOVFF  00,14A
4502:  RCALL  4420
4504:  MOVFF  01,134
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
4508:  MOVFF  127,14D
450C:  MOVFF  126,14C
4510:  MOVFF  125,14B
4514:  MOVFF  124,14A
4518:  MOVLW  DB
451A:  MOVLB  1
451C:  MOVWF  x51
451E:  MOVLW  0F
4520:  MOVWF  x50
4522:  MOVLW  49
4524:  MOVWF  x4F
4526:  MOVLW  7F
4528:  MOVWF  x4E
452A:  MOVLB  0
452C:  CALL   0F1A
4530:  MOVFF  00,14A
4534:  MOVFF  01,14B
4538:  MOVFF  02,14C
453C:  MOVFF  03,14D
4540:  MOVLB  1
4542:  CLRF   x4F
4544:  MOVFF  134,14E
4548:  MOVLB  0
454A:  RCALL  43EA
454C:  BSF    FD8.1
454E:  MOVFF  14D,153
4552:  MOVFF  14C,152
4556:  MOVFF  14B,151
455A:  MOVFF  14A,150
455E:  MOVFF  03,157
4562:  MOVFF  02,156
4566:  MOVFF  01,155
456A:  MOVFF  00,154
456E:  CALL   1078
4572:  MOVFF  03,139
4576:  MOVFF  02,138
457A:  MOVFF  01,137
457E:  MOVFF  00,136
....................    quad = quad % 4;                    // quadrant (0 to 3) 
4582:  MOVLW  03
4584:  MOVLB  1
4586:  ANDWF  x34,F
....................  
....................    if (quad == 0 || quad == 2) 
4588:  MOVF   x34,F
458A:  BZ    4592
458C:  MOVF   x34,W
458E:  SUBLW  02
4590:  BNZ   45CC
....................       t = frac * PI_DIV_BY_TWO; 
4592:  MOVFF  139,151
4596:  MOVFF  138,150
459A:  MOVFF  137,14F
459E:  MOVFF  136,14E
45A2:  MOVLW  DB
45A4:  MOVWF  x55
45A6:  MOVLW  0F
45A8:  MOVWF  x54
45AA:  MOVLW  49
45AC:  MOVWF  x53
45AE:  MOVLW  7F
45B0:  MOVWF  x52
45B2:  MOVLB  0
45B4:  CALL   0E24
45B8:  MOVFF  03,12F
45BC:  MOVFF  02,12E
45C0:  MOVFF  01,12D
45C4:  MOVFF  00,12C
....................    else if (quad == 1) 
45C8:  BRA    46A8
45CA:  MOVLB  1
45CC:  DECFSZ x34,W
45CE:  BRA    463E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
45D0:  BSF    FD8.1
45D2:  CLRF   x53
45D4:  CLRF   x52
45D6:  CLRF   x51
45D8:  MOVLW  7F
45DA:  MOVWF  x50
45DC:  MOVFF  139,157
45E0:  MOVFF  138,156
45E4:  MOVFF  137,155
45E8:  MOVFF  136,154
45EC:  MOVLB  0
45EE:  CALL   1078
45F2:  MOVFF  00,14A
45F6:  MOVFF  01,14B
45FA:  MOVFF  02,14C
45FE:  MOVFF  03,14D
4602:  MOVFF  03,151
4606:  MOVFF  02,150
460A:  MOVFF  01,14F
460E:  MOVFF  00,14E
4612:  MOVLW  DB
4614:  MOVLB  1
4616:  MOVWF  x55
4618:  MOVLW  0F
461A:  MOVWF  x54
461C:  MOVLW  49
461E:  MOVWF  x53
4620:  MOVLW  7F
4622:  MOVWF  x52
4624:  MOVLB  0
4626:  CALL   0E24
462A:  MOVFF  03,12F
462E:  MOVFF  02,12E
4632:  MOVFF  01,12D
4636:  MOVFF  00,12C
....................    else // should be 3 
463A:  BRA    46A8
463C:  MOVLB  1
....................       t = (frac-1) * PI_DIV_BY_TWO; 
463E:  BSF    FD8.1
4640:  MOVFF  139,153
4644:  MOVFF  138,152
4648:  MOVFF  137,151
464C:  MOVFF  136,150
4650:  CLRF   x57
4652:  CLRF   x56
4654:  CLRF   x55
4656:  MOVLW  7F
4658:  MOVWF  x54
465A:  MOVLB  0
465C:  CALL   1078
4660:  MOVFF  00,14A
4664:  MOVFF  01,14B
4668:  MOVFF  02,14C
466C:  MOVFF  03,14D
4670:  MOVFF  03,151
4674:  MOVFF  02,150
4678:  MOVFF  01,14F
467C:  MOVFF  00,14E
4680:  MOVLW  DB
4682:  MOVLB  1
4684:  MOVWF  x55
4686:  MOVLW  0F
4688:  MOVWF  x54
468A:  MOVLW  49
468C:  MOVWF  x53
468E:  MOVLW  7F
4690:  MOVWF  x52
4692:  MOVLB  0
4694:  CALL   0E24
4698:  MOVFF  03,12F
469C:  MOVFF  02,12E
46A0:  MOVFF  01,12D
46A4:  MOVFF  00,12C
....................  
....................    y = 0.999999999781; 
46A8:  MOVLB  1
46AA:  CLRF   x2B
46AC:  CLRF   x2A
46AE:  CLRF   x29
46B0:  MOVLW  7F
46B2:  MOVWF  x28
....................    t = t * t; 
46B4:  MOVFF  12F,151
46B8:  MOVFF  12E,150
46BC:  MOVFF  12D,14F
46C0:  MOVFF  12C,14E
46C4:  MOVFF  12F,155
46C8:  MOVFF  12E,154
46CC:  MOVFF  12D,153
46D0:  MOVFF  12C,152
46D4:  MOVLB  0
46D6:  CALL   0E24
46DA:  MOVFF  03,12F
46DE:  MOVFF  02,12E
46E2:  MOVFF  01,12D
46E6:  MOVFF  00,12C
....................    for (i = 0; i <= 3; i++) 
46EA:  MOVLB  1
46EC:  CLRF   x35
46EE:  MOVF   x35,W
46F0:  SUBLW  03
46F2:  BNC   47C0
....................    { 
....................       t2 = t2 * t; 
46F4:  MOVFF  133,151
46F8:  MOVFF  132,150
46FC:  MOVFF  131,14F
4700:  MOVFF  130,14E
4704:  MOVFF  12F,155
4708:  MOVFF  12E,154
470C:  MOVFF  12D,153
4710:  MOVFF  12C,152
4714:  MOVLB  0
4716:  CALL   0E24
471A:  MOVFF  03,133
471E:  MOVFF  02,132
4722:  MOVFF  01,131
4726:  MOVFF  00,130
....................       y = y + p[i] * t2; 
472A:  MOVLB  1
472C:  MOVF   x35,W
472E:  MULLW  04
4730:  MOVF   FF3,W
4732:  CLRF   03
4734:  ADDLW  3A
4736:  MOVWF  FE9
4738:  MOVLW  01
473A:  ADDWFC 03,W
473C:  MOVWF  FEA
473E:  MOVFF  FEF,14A
4742:  MOVFF  FEC,14B
4746:  MOVFF  FEC,14C
474A:  MOVFF  FEC,14D
474E:  MOVFF  14D,151
4752:  MOVFF  14C,150
4756:  MOVFF  14B,14F
475A:  MOVFF  14A,14E
475E:  MOVFF  133,155
4762:  MOVFF  132,154
4766:  MOVFF  131,153
476A:  MOVFF  130,152
476E:  MOVLB  0
4770:  CALL   0E24
4774:  MOVFF  FEA,14F
4778:  MOVFF  FE9,14E
477C:  BCF    FD8.1
477E:  MOVFF  12B,153
4782:  MOVFF  12A,152
4786:  MOVFF  129,151
478A:  MOVFF  128,150
478E:  MOVFF  03,157
4792:  MOVFF  02,156
4796:  MOVFF  01,155
479A:  MOVFF  00,154
479E:  CALL   1078
47A2:  MOVFF  14F,FEA
47A6:  MOVFF  14E,FE9
47AA:  MOVFF  03,12B
47AE:  MOVFF  02,12A
47B2:  MOVFF  01,129
47B6:  MOVFF  00,128
....................    } 
47BA:  MOVLB  1
47BC:  INCF   x35,F
47BE:  BRA    46EE
....................  
....................    if (quad == 2 || quad == 1) 
47C0:  MOVF   x34,W
47C2:  SUBLW  02
47C4:  BZ    47CA
47C6:  DECFSZ x34,W
47C8:  BRA    47D0
....................       y = -y;  // correct sign 
47CA:  MOVF   x29,W
47CC:  XORLW  80
47CE:  MOVWF  x29
....................  
....................    return (y); 
47D0:  MOVFF  128,00
47D4:  MOVFF  129,01
47D8:  MOVFF  12A,02
47DC:  MOVFF  12B,03
.................... } 
47E0:  MOVLB  0
47E2:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
47E4:  BSF    FD8.1
47E6:  MOVFF  11F,153
47EA:  MOVFF  11E,152
47EE:  MOVFF  11D,151
47F2:  MOVFF  11C,150
47F6:  MOVLW  DB
47F8:  MOVLB  1
47FA:  MOVWF  x57
47FC:  MOVLW  0F
47FE:  MOVWF  x56
4800:  MOVLW  49
4802:  MOVWF  x55
4804:  MOVLW  7F
4806:  MOVWF  x54
4808:  MOVLB  0
480A:  CALL   1078
480E:  MOVFF  00,120
4812:  MOVFF  01,121
4816:  MOVFF  02,122
481A:  MOVFF  03,123
481E:  MOVFF  03,127
4822:  MOVFF  02,126
4826:  MOVFF  01,125
482A:  MOVFF  00,124
482E:  RCALL  445C
.................... } 
4830:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
4832:  MOVFF  113,127
4836:  MOVFF  112,126
483A:  MOVFF  111,125
483E:  MOVFF  110,124
4842:  RCALL  445C
4844:  MOVFF  03,117
4848:  MOVFF  02,116
484C:  MOVFF  01,115
4850:  MOVFF  00,114
....................    if (c == 0.0) 
4854:  MOVFF  117,14D
4858:  MOVFF  116,14C
485C:  MOVFF  115,14B
4860:  MOVFF  114,14A
4864:  MOVLB  1
4866:  CLRF   x51
4868:  CLRF   x50
486A:  CLRF   x4F
486C:  CLRF   x4E
486E:  MOVLB  0
4870:  CALL   3E46
4874:  BNZ   4888
....................       return (1.0e+36); 
4876:  MOVLW  F6
4878:  MOVWF  00
487A:  MOVLW  40
487C:  MOVWF  01
487E:  MOVLW  97
4880:  MOVWF  02
4882:  MOVLW  CE
4884:  MOVWF  03
4886:  BRA    48CE
....................  
....................    s = sin(x); 
4888:  MOVFF  113,11F
488C:  MOVFF  112,11E
4890:  MOVFF  111,11D
4894:  MOVFF  110,11C
4898:  RCALL  47E4
489A:  MOVFF  03,11B
489E:  MOVFF  02,11A
48A2:  MOVFF  01,119
48A6:  MOVFF  00,118
....................    return(s/c); 
48AA:  MOVFF  11B,14D
48AE:  MOVFF  11A,14C
48B2:  MOVFF  119,14B
48B6:  MOVFF  118,14A
48BA:  MOVFF  117,151
48BE:  MOVFF  116,150
48C2:  MOVFF  115,14F
48C6:  MOVFF  114,14E
48CA:  CALL   0F1A
.................... } 
48CE:  RETLW  00
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
5092:  MOVLB  1
5094:  BCF    x09.0
....................    y = x; 
5096:  MOVFF  F7,FC
509A:  MOVFF  F6,FB
509E:  MOVFF  F5,FA
50A2:  MOVFF  F4,F9
....................  
....................    if (x < 0) 
50A6:  MOVFF  F7,14D
50AA:  MOVFF  F6,14C
50AE:  MOVFF  F5,14B
50B2:  MOVFF  F4,14A
50B6:  CLRF   x51
50B8:  CLRF   x50
50BA:  CLRF   x4F
50BC:  CLRF   x4E
50BE:  MOVLB  0
50C0:  CALL   3E46
50C4:  BNC   50D2
....................    { 
....................       s = 1; 
50C6:  MOVLB  1
50C8:  BSF    x09.0
....................       y = -y; 
50CA:  MOVLB  0
50CC:  MOVF   xFA,W
50CE:  XORLW  80
50D0:  MOVWF  xFA
....................    } 
....................  
....................    if (y > 0.5) 
50D2:  MOVLB  1
50D4:  CLRF   x4D
50D6:  CLRF   x4C
50D8:  CLRF   x4B
50DA:  MOVLW  7E
50DC:  MOVWF  x4A
50DE:  MOVFF  FC,151
50E2:  MOVFF  FB,150
50E6:  MOVFF  FA,14F
50EA:  MOVFF  F9,14E
50EE:  MOVLB  0
50F0:  CALL   3E46
50F4:  BNC   5184
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
50F6:  BSF    FD8.1
50F8:  MOVLB  1
50FA:  CLRF   x53
50FC:  CLRF   x52
50FE:  CLRF   x51
5100:  MOVLW  7F
5102:  MOVWF  x50
5104:  MOVFF  FC,157
5108:  MOVFF  FB,156
510C:  MOVFF  FA,155
5110:  MOVFF  F9,154
5114:  MOVLB  0
5116:  CALL   1078
511A:  MOVFF  00,10A
511E:  MOVFF  01,10B
5122:  MOVFF  02,10C
5126:  MOVFF  03,10D
512A:  MOVFF  03,14D
512E:  MOVFF  02,14C
5132:  MOVFF  01,14B
5136:  MOVFF  00,14A
513A:  MOVLB  1
513C:  CLRF   x51
513E:  CLRF   x50
5140:  CLRF   x4F
5142:  MOVLW  80
5144:  MOVWF  x4E
5146:  MOVLB  0
5148:  CALL   0F1A
514C:  MOVFF  00,10E
5150:  MOVFF  01,10F
5154:  MOVFF  02,110
5158:  MOVFF  03,111
515C:  MOVFF  03,115
5160:  MOVFF  02,114
5164:  MOVFF  01,113
5168:  MOVFF  00,112
516C:  CALL   48D0
5170:  MOVFF  03,FC
5174:  MOVFF  02,FB
5178:  MOVFF  01,FA
517C:  MOVFF  00,F9
....................       n += 2; 
5180:  MOVLW  02
5182:  ADDWF  xF8,F
....................    } 
....................  
....................    y2=y*y; 
5184:  MOVFF  FC,151
5188:  MOVFF  FB,150
518C:  MOVFF  FA,14F
5190:  MOVFF  F9,14E
5194:  MOVFF  FC,155
5198:  MOVFF  FB,154
519C:  MOVFF  FA,153
51A0:  MOVFF  F9,152
51A4:  CALL   0E24
51A8:  MOVFF  03,108
51AC:  MOVFF  02,107
51B0:  MOVFF  01,106
51B4:  MOVFF  00,105
....................  
....................    res = pas[0]*y2 + pas[1]; 
51B8:  MOVLW  37
51BA:  MOVLB  1
51BC:  MOVWF  x51
51BE:  MOVLW  BF
51C0:  MOVWF  x50
51C2:  MOVLW  7D
51C4:  MOVWF  x4F
51C6:  MOVWF  x4E
51C8:  MOVFF  108,155
51CC:  MOVFF  107,154
51D0:  MOVFF  106,153
51D4:  MOVFF  105,152
51D8:  MOVLB  0
51DA:  CALL   0E24
51DE:  MOVFF  00,10A
51E2:  MOVFF  01,10B
51E6:  MOVFF  02,10C
51EA:  MOVFF  03,10D
51EE:  BCF    FD8.1
51F0:  MOVFF  03,153
51F4:  MOVFF  02,152
51F8:  MOVFF  01,151
51FC:  MOVFF  00,150
5200:  MOVLW  3D
5202:  MOVLB  1
5204:  MOVWF  x57
5206:  MOVLW  AA
5208:  MOVWF  x56
520A:  MOVLW  93
520C:  MOVWF  x55
520E:  MOVLW  81
5210:  MOVWF  x54
5212:  MOVLB  0
5214:  CALL   1078
5218:  MOVFF  03,100
521C:  MOVFF  02,FF
5220:  MOVFF  01,FE
5224:  MOVFF  00,FD
....................    res = res*y2 + pas[2]; 
5228:  MOVFF  100,151
522C:  MOVFF  FF,150
5230:  MOVFF  FE,14F
5234:  MOVFF  FD,14E
5238:  MOVFF  108,155
523C:  MOVFF  107,154
5240:  MOVFF  106,153
5244:  MOVFF  105,152
5248:  CALL   0E24
524C:  MOVFF  00,10A
5250:  MOVFF  01,10B
5254:  MOVFF  02,10C
5258:  MOVFF  03,10D
525C:  BCF    FD8.1
525E:  MOVFF  03,153
5262:  MOVFF  02,152
5266:  MOVFF  01,151
526A:  MOVFF  00,150
526E:  MOVLW  EE
5270:  MOVLB  1
5272:  MOVWF  x57
5274:  MOVLW  50
5276:  MOVWF  x56
5278:  MOVLW  33
527A:  MOVWF  x55
527C:  MOVLW  81
527E:  MOVWF  x54
5280:  MOVLB  0
5282:  CALL   1078
5286:  MOVFF  03,100
528A:  MOVFF  02,FF
528E:  MOVFF  01,FE
5292:  MOVFF  00,FD
....................  
....................    r = qas[0]*y2 + qas[1]; 
5296:  MOVLB  1
5298:  CLRF   x51
529A:  CLRF   x50
529C:  CLRF   x4F
529E:  MOVLW  7F
52A0:  MOVWF  x4E
52A2:  MOVFF  108,155
52A6:  MOVFF  107,154
52AA:  MOVFF  106,153
52AE:  MOVFF  105,152
52B2:  MOVLB  0
52B4:  CALL   0E24
52B8:  MOVFF  00,10A
52BC:  MOVFF  01,10B
52C0:  MOVFF  02,10C
52C4:  MOVFF  03,10D
52C8:  BCF    FD8.1
52CA:  MOVFF  03,153
52CE:  MOVFF  02,152
52D2:  MOVFF  01,151
52D6:  MOVFF  00,150
52DA:  MOVLW  0A
52DC:  MOVLB  1
52DE:  MOVWF  x57
52E0:  MOVLW  8D
52E2:  MOVWF  x56
52E4:  MOVLW  B1
52E6:  MOVWF  x55
52E8:  MOVLW  81
52EA:  MOVWF  x54
52EC:  MOVLB  0
52EE:  CALL   1078
52F2:  MOVFF  03,104
52F6:  MOVFF  02,103
52FA:  MOVFF  01,102
52FE:  MOVFF  00,101
....................    r = r*y2 + qas[2]; 
5302:  MOVFF  104,151
5306:  MOVFF  103,150
530A:  MOVFF  102,14F
530E:  MOVFF  101,14E
5312:  MOVFF  108,155
5316:  MOVFF  107,154
531A:  MOVFF  106,153
531E:  MOVFF  105,152
5322:  CALL   0E24
5326:  MOVFF  00,10A
532A:  MOVFF  01,10B
532E:  MOVFF  02,10C
5332:  MOVFF  03,10D
5336:  BCF    FD8.1
5338:  MOVFF  03,153
533C:  MOVFF  02,152
5340:  MOVFF  01,151
5344:  MOVFF  00,150
5348:  MOVLW  EE
534A:  MOVLB  1
534C:  MOVWF  x57
534E:  MOVLW  50
5350:  MOVWF  x56
5352:  MOVLW  33
5354:  MOVWF  x55
5356:  MOVLW  81
5358:  MOVWF  x54
535A:  MOVLB  0
535C:  CALL   1078
5360:  MOVFF  03,104
5364:  MOVFF  02,103
5368:  MOVFF  01,102
536C:  MOVFF  00,101
....................  
....................    res = y*res/r; 
5370:  MOVFF  FC,151
5374:  MOVFF  FB,150
5378:  MOVFF  FA,14F
537C:  MOVFF  F9,14E
5380:  MOVFF  100,155
5384:  MOVFF  FF,154
5388:  MOVFF  FE,153
538C:  MOVFF  FD,152
5390:  CALL   0E24
5394:  MOVFF  00,10A
5398:  MOVFF  01,10B
539C:  MOVFF  02,10C
53A0:  MOVFF  03,10D
53A4:  MOVFF  03,14D
53A8:  MOVFF  02,14C
53AC:  MOVFF  01,14B
53B0:  MOVFF  00,14A
53B4:  MOVFF  104,151
53B8:  MOVFF  103,150
53BC:  MOVFF  102,14F
53C0:  MOVFF  101,14E
53C4:  CALL   0F1A
53C8:  MOVFF  03,100
53CC:  MOVFF  02,FF
53D0:  MOVFF  01,FE
53D4:  MOVFF  00,FD
....................  
....................    if (n & 2)     // |x| > 0.5 
53D8:  BTFSS  xF8.1
53DA:  BRA    5438
....................       res = PI_DIV_BY_TWO - 2.0*res; 
53DC:  MOVLB  1
53DE:  CLRF   x51
53E0:  CLRF   x50
53E2:  CLRF   x4F
53E4:  MOVLW  80
53E6:  MOVWF  x4E
53E8:  MOVFF  100,155
53EC:  MOVFF  FF,154
53F0:  MOVFF  FE,153
53F4:  MOVFF  FD,152
53F8:  MOVLB  0
53FA:  CALL   0E24
53FE:  BSF    FD8.1
5400:  MOVLW  DB
5402:  MOVLB  1
5404:  MOVWF  x53
5406:  MOVLW  0F
5408:  MOVWF  x52
540A:  MOVLW  49
540C:  MOVWF  x51
540E:  MOVLW  7F
5410:  MOVWF  x50
5412:  MOVFF  03,157
5416:  MOVFF  02,156
541A:  MOVFF  01,155
541E:  MOVFF  00,154
5422:  MOVLB  0
5424:  CALL   1078
5428:  MOVFF  03,100
542C:  MOVFF  02,FF
5430:  MOVFF  01,FE
5434:  MOVFF  00,FD
....................    if (s) 
5438:  MOVLB  1
543A:  BTFSS  x09.0
543C:  BRA    5446
....................       res = -res; 
543E:  MOVLB  0
5440:  MOVF   xFE,W
5442:  XORLW  80
5444:  MOVWF  xFE
....................    if (n & 1)           // take arccos 
5446:  MOVLB  0
5448:  BTFSS  xF8.0
544A:  BRA    5486
....................       res = PI_DIV_BY_TWO - res; 
544C:  BSF    FD8.1
544E:  MOVLW  DB
5450:  MOVLB  1
5452:  MOVWF  x53
5454:  MOVLW  0F
5456:  MOVWF  x52
5458:  MOVLW  49
545A:  MOVWF  x51
545C:  MOVLW  7F
545E:  MOVWF  x50
5460:  MOVFF  100,157
5464:  MOVFF  FF,156
5468:  MOVFF  FE,155
546C:  MOVFF  FD,154
5470:  MOVLB  0
5472:  CALL   1078
5476:  MOVFF  03,100
547A:  MOVFF  02,FF
547E:  MOVFF  01,FE
5482:  MOVFF  00,FD
....................  
....................    return(res); 
5486:  MOVFF  FD,00
548A:  MOVFF  FE,01
548E:  MOVFF  FF,02
5492:  MOVFF  100,03
.................... } 
5496:  GOTO   54B0 (RETURN)
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
549A:  MOVFF  EF,F7
549E:  MOVFF  EE,F6
54A2:  MOVFF  ED,F5
54A6:  MOVFF  EC,F4
54AA:  MOVLW  01
54AC:  MOVWF  xF8
54AE:  BRA    5092
54B0:  MOVFF  03,F3
54B4:  MOVFF  02,F2
54B8:  MOVFF  01,F1
54BC:  MOVFF  00,F0
....................    return(r); 
54C0:  MOVFF  F0,00
54C4:  MOVFF  F1,01
54C8:  MOVFF  F2,02
54CC:  MOVFF  F3,03
.................... } 
54D0:  GOTO   5BBE (RETURN)
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
3EC0:  MOVLB  1
3EC2:  BCF    x18.0
....................    flag = 0; 
3EC4:  BCF    x18.1
....................    y = x; 
3EC6:  MOVFF  10B,10F
3ECA:  MOVFF  10A,10E
3ECE:  MOVFF  109,10D
3ED2:  MOVFF  108,10C
....................  
....................    if (x < 0) 
3ED6:  MOVFF  10B,14D
3EDA:  MOVFF  10A,14C
3EDE:  MOVFF  109,14B
3EE2:  MOVFF  108,14A
3EE6:  CLRF   x51
3EE8:  CLRF   x50
3EEA:  CLRF   x4F
3EEC:  CLRF   x4E
3EEE:  MOVLB  0
3EF0:  RCALL  3E46
3EF2:  BNC   3EFE
....................    { 
....................       s = 1; 
3EF4:  MOVLB  1
3EF6:  BSF    x18.0
....................       y = -y; 
3EF8:  MOVF   x0D,W
3EFA:  XORLW  80
3EFC:  MOVWF  x0D
....................    } 
....................  
....................    if (y > 1.0) 
3EFE:  MOVLB  1
3F00:  CLRF   x4D
3F02:  CLRF   x4C
3F04:  CLRF   x4B
3F06:  MOVLW  7F
3F08:  MOVWF  x4A
3F0A:  MOVFF  10F,151
3F0E:  MOVFF  10E,150
3F12:  MOVFF  10D,14F
3F16:  MOVFF  10C,14E
3F1A:  MOVLB  0
3F1C:  RCALL  3E46
3F1E:  BNC   3F56
....................    { 
....................       y = 1.0/y; 
3F20:  MOVLB  1
3F22:  CLRF   x4D
3F24:  CLRF   x4C
3F26:  CLRF   x4B
3F28:  MOVLW  7F
3F2A:  MOVWF  x4A
3F2C:  MOVFF  10F,151
3F30:  MOVFF  10E,150
3F34:  MOVFF  10D,14F
3F38:  MOVFF  10C,14E
3F3C:  MOVLB  0
3F3E:  CALL   0F1A
3F42:  MOVFF  03,10F
3F46:  MOVFF  02,10E
3F4A:  MOVFF  01,10D
3F4E:  MOVFF  00,10C
....................       flag = 1; 
3F52:  MOVLB  1
3F54:  BSF    x18.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
3F56:  MOVLW  0A
3F58:  MOVLB  1
3F5A:  MOVWF  x51
3F5C:  MOVLW  89
3F5E:  MOVWF  x50
3F60:  MOVLW  34
3F62:  MOVWF  x4F
3F64:  MOVLW  7C
3F66:  MOVWF  x4E
3F68:  MOVFF  10F,155
3F6C:  MOVFF  10E,154
3F70:  MOVFF  10D,153
3F74:  MOVFF  10C,152
3F78:  MOVLB  0
3F7A:  CALL   0E24
3F7E:  MOVFF  00,119
3F82:  MOVFF  01,11A
3F86:  MOVFF  02,11B
3F8A:  MOVFF  03,11C
3F8E:  MOVFF  03,151
3F92:  MOVFF  02,150
3F96:  MOVFF  01,14F
3F9A:  MOVFF  00,14E
3F9E:  MOVFF  10F,155
3FA2:  MOVFF  10E,154
3FA6:  MOVFF  10D,153
3FAA:  MOVFF  10C,152
3FAE:  CALL   0E24
3FB2:  MOVFF  00,11D
3FB6:  MOVFF  01,11E
3FBA:  MOVFF  02,11F
3FBE:  MOVFF  03,120
3FC2:  BCF    FD8.1
3FC4:  MOVFF  03,153
3FC8:  MOVFF  02,152
3FCC:  MOVFF  01,151
3FD0:  MOVFF  00,150
3FD4:  MOVLW  7C
3FD6:  MOVLB  1
3FD8:  MOVWF  x57
3FDA:  MOVLW  79
3FDC:  MOVWF  x56
3FDE:  MOVLW  35
3FE0:  MOVWF  x55
3FE2:  MOVLW  81
3FE4:  MOVWF  x54
3FE6:  MOVLB  0
3FE8:  CALL   1078
3FEC:  MOVFF  03,113
3FF0:  MOVFF  02,112
3FF4:  MOVFF  01,111
3FF8:  MOVFF  00,110
....................    res = res*y*y + pat[2]; 
3FFC:  MOVFF  113,151
4000:  MOVFF  112,150
4004:  MOVFF  111,14F
4008:  MOVFF  110,14E
400C:  MOVFF  10F,155
4010:  MOVFF  10E,154
4014:  MOVFF  10D,153
4018:  MOVFF  10C,152
401C:  CALL   0E24
4020:  MOVFF  00,119
4024:  MOVFF  01,11A
4028:  MOVFF  02,11B
402C:  MOVFF  03,11C
4030:  MOVFF  03,151
4034:  MOVFF  02,150
4038:  MOVFF  01,14F
403C:  MOVFF  00,14E
4040:  MOVFF  10F,155
4044:  MOVFF  10E,154
4048:  MOVFF  10D,153
404C:  MOVFF  10C,152
4050:  CALL   0E24
4054:  MOVFF  00,11D
4058:  MOVFF  01,11E
405C:  MOVFF  02,11F
4060:  MOVFF  03,120
4064:  BCF    FD8.1
4066:  MOVFF  03,153
406A:  MOVFF  02,152
406E:  MOVFF  01,151
4072:  MOVFF  00,150
4076:  MOVLW  3F
4078:  MOVLB  1
407A:  MOVWF  x57
407C:  MOVLW  02
407E:  MOVWF  x56
4080:  MOVLW  33
4082:  MOVWF  x55
4084:  MOVLW  83
4086:  MOVWF  x54
4088:  MOVLB  0
408A:  CALL   1078
408E:  MOVFF  03,113
4092:  MOVFF  02,112
4096:  MOVFF  01,111
409A:  MOVFF  00,110
....................    res = res*y*y + pat[3]; 
409E:  MOVFF  113,151
40A2:  MOVFF  112,150
40A6:  MOVFF  111,14F
40AA:  MOVFF  110,14E
40AE:  MOVFF  10F,155
40B2:  MOVFF  10E,154
40B6:  MOVFF  10D,153
40BA:  MOVFF  10C,152
40BE:  CALL   0E24
40C2:  MOVFF  00,119
40C6:  MOVFF  01,11A
40CA:  MOVFF  02,11B
40CE:  MOVFF  03,11C
40D2:  MOVFF  03,151
40D6:  MOVFF  02,150
40DA:  MOVFF  01,14F
40DE:  MOVFF  00,14E
40E2:  MOVFF  10F,155
40E6:  MOVFF  10E,154
40EA:  MOVFF  10D,153
40EE:  MOVFF  10C,152
40F2:  CALL   0E24
40F6:  MOVFF  00,11D
40FA:  MOVFF  01,11E
40FE:  MOVFF  02,11F
4102:  MOVFF  03,120
4106:  BCF    FD8.1
4108:  MOVFF  03,153
410C:  MOVFF  02,152
4110:  MOVFF  01,151
4114:  MOVFF  00,150
4118:  MOVLW  33
411A:  MOVLB  1
411C:  MOVWF  x57
411E:  MOVLW  8C
4120:  MOVWF  x56
4122:  MOVLW  1E
4124:  MOVWF  x55
4126:  MOVLW  83
4128:  MOVWF  x54
412A:  MOVLB  0
412C:  CALL   1078
4130:  MOVFF  03,113
4134:  MOVFF  02,112
4138:  MOVFF  01,111
413C:  MOVFF  00,110
....................  
....................    r = qat[0]*y*y + qat[1]; 
4140:  MOVLB  1
4142:  CLRF   x51
4144:  CLRF   x50
4146:  CLRF   x4F
4148:  MOVLW  7F
414A:  MOVWF  x4E
414C:  MOVFF  10F,155
4150:  MOVFF  10E,154
4154:  MOVFF  10D,153
4158:  MOVFF  10C,152
415C:  MOVLB  0
415E:  CALL   0E24
4162:  MOVFF  00,119
4166:  MOVFF  01,11A
416A:  MOVFF  02,11B
416E:  MOVFF  03,11C
4172:  MOVFF  03,151
4176:  MOVFF  02,150
417A:  MOVFF  01,14F
417E:  MOVFF  00,14E
4182:  MOVFF  10F,155
4186:  MOVFF  10E,154
418A:  MOVFF  10D,153
418E:  MOVFF  10C,152
4192:  CALL   0E24
4196:  MOVFF  00,11D
419A:  MOVFF  01,11E
419E:  MOVFF  02,11F
41A2:  MOVFF  03,120
41A6:  BCF    FD8.1
41A8:  MOVFF  03,153
41AC:  MOVFF  02,152
41B0:  MOVFF  01,151
41B4:  MOVFF  00,150
41B8:  MOVLW  1B
41BA:  MOVLB  1
41BC:  MOVWF  x57
41BE:  MOVLW  E4
41C0:  MOVWF  x56
41C2:  MOVLW  35
41C4:  MOVWF  x55
41C6:  MOVLW  82
41C8:  MOVWF  x54
41CA:  MOVLB  0
41CC:  CALL   1078
41D0:  MOVFF  03,117
41D4:  MOVFF  02,116
41D8:  MOVFF  01,115
41DC:  MOVFF  00,114
....................    r = r*y*y + qat[2]; 
41E0:  MOVFF  117,151
41E4:  MOVFF  116,150
41E8:  MOVFF  115,14F
41EC:  MOVFF  114,14E
41F0:  MOVFF  10F,155
41F4:  MOVFF  10E,154
41F8:  MOVFF  10D,153
41FC:  MOVFF  10C,152
4200:  CALL   0E24
4204:  MOVFF  00,119
4208:  MOVFF  01,11A
420C:  MOVFF  02,11B
4210:  MOVFF  03,11C
4214:  MOVFF  03,151
4218:  MOVFF  02,150
421C:  MOVFF  01,14F
4220:  MOVFF  00,14E
4224:  MOVFF  10F,155
4228:  MOVFF  10E,154
422C:  MOVFF  10D,153
4230:  MOVFF  10C,152
4234:  CALL   0E24
4238:  MOVFF  00,11D
423C:  MOVFF  01,11E
4240:  MOVFF  02,11F
4244:  MOVFF  03,120
4248:  BCF    FD8.1
424A:  MOVFF  03,153
424E:  MOVFF  02,152
4252:  MOVFF  01,151
4256:  MOVFF  00,150
425A:  MOVLW  A4
425C:  MOVLB  1
425E:  MOVWF  x57
4260:  MOVLW  DB
4262:  MOVWF  x56
4264:  MOVLW  67
4266:  MOVWF  x55
4268:  MOVLW  83
426A:  MOVWF  x54
426C:  MOVLB  0
426E:  CALL   1078
4272:  MOVFF  03,117
4276:  MOVFF  02,116
427A:  MOVFF  01,115
427E:  MOVFF  00,114
....................    r = r*y*y + qat[3]; 
4282:  MOVFF  117,151
4286:  MOVFF  116,150
428A:  MOVFF  115,14F
428E:  MOVFF  114,14E
4292:  MOVFF  10F,155
4296:  MOVFF  10E,154
429A:  MOVFF  10D,153
429E:  MOVFF  10C,152
42A2:  CALL   0E24
42A6:  MOVFF  00,119
42AA:  MOVFF  01,11A
42AE:  MOVFF  02,11B
42B2:  MOVFF  03,11C
42B6:  MOVFF  03,151
42BA:  MOVFF  02,150
42BE:  MOVFF  01,14F
42C2:  MOVFF  00,14E
42C6:  MOVFF  10F,155
42CA:  MOVFF  10E,154
42CE:  MOVFF  10D,153
42D2:  MOVFF  10C,152
42D6:  CALL   0E24
42DA:  MOVFF  00,11D
42DE:  MOVFF  01,11E
42E2:  MOVFF  02,11F
42E6:  MOVFF  03,120
42EA:  BCF    FD8.1
42EC:  MOVFF  03,153
42F0:  MOVFF  02,152
42F4:  MOVFF  01,151
42F8:  MOVFF  00,150
42FC:  MOVLW  33
42FE:  MOVLB  1
4300:  MOVWF  x57
4302:  MOVLW  8C
4304:  MOVWF  x56
4306:  MOVLW  1E
4308:  MOVWF  x55
430A:  MOVLW  83
430C:  MOVWF  x54
430E:  MOVLB  0
4310:  CALL   1078
4314:  MOVFF  03,117
4318:  MOVFF  02,116
431C:  MOVFF  01,115
4320:  MOVFF  00,114
....................  
....................    res = y*res/r; 
4324:  MOVFF  10F,151
4328:  MOVFF  10E,150
432C:  MOVFF  10D,14F
4330:  MOVFF  10C,14E
4334:  MOVFF  113,155
4338:  MOVFF  112,154
433C:  MOVFF  111,153
4340:  MOVFF  110,152
4344:  CALL   0E24
4348:  MOVFF  00,119
434C:  MOVFF  01,11A
4350:  MOVFF  02,11B
4354:  MOVFF  03,11C
4358:  MOVFF  03,14D
435C:  MOVFF  02,14C
4360:  MOVFF  01,14B
4364:  MOVFF  00,14A
4368:  MOVFF  117,151
436C:  MOVFF  116,150
4370:  MOVFF  115,14F
4374:  MOVFF  114,14E
4378:  CALL   0F1A
437C:  MOVFF  03,113
4380:  MOVFF  02,112
4384:  MOVFF  01,111
4388:  MOVFF  00,110
....................  
....................  
....................    if (flag)                              // for |x| > 1 
438C:  MOVLB  1
438E:  BTFSS  x18.1
4390:  BRA    43CC
....................       res = PI_DIV_BY_TWO - res; 
4392:  BSF    FD8.1
4394:  MOVLW  DB
4396:  MOVWF  x53
4398:  MOVLW  0F
439A:  MOVWF  x52
439C:  MOVLW  49
439E:  MOVWF  x51
43A0:  MOVLW  7F
43A2:  MOVWF  x50
43A4:  MOVFF  113,157
43A8:  MOVFF  112,156
43AC:  MOVFF  111,155
43B0:  MOVFF  110,154
43B4:  MOVLB  0
43B6:  CALL   1078
43BA:  MOVFF  03,113
43BE:  MOVFF  02,112
43C2:  MOVFF  01,111
43C6:  MOVFF  00,110
43CA:  MOVLB  1
....................    if (s) 
43CC:  BTFSS  x18.0
43CE:  BRA    43D6
....................       res = -res; 
43D0:  MOVF   x11,W
43D2:  XORLW  80
43D4:  MOVWF  x11
....................  
....................    return(res); 
43D6:  MOVFF  110,00
43DA:  MOVFF  111,01
43DE:  MOVFF  112,02
43E2:  MOVFF  113,03
.................... } 
43E6:  MOVLB  0
43E8:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,NOBROWNOUT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
04BC:  CLRF   FEA
04BE:  MOVLW  EA
04C0:  MOVWF  FE9
04C2:  MOVF   FEF,W
04C4:  BZ    04E2
04C6:  MOVLW  03
04C8:  MOVWF  01
04CA:  CLRF   00
04CC:  DECFSZ 00,F
04CE:  BRA    04CC
04D0:  DECFSZ 01,F
04D2:  BRA    04CA
04D4:  MOVLW  3C
04D6:  MOVWF  00
04D8:  DECFSZ 00,F
04DA:  BRA    04D8
04DC:  BRA    04DE
04DE:  DECFSZ FEF,F
04E0:  BRA    04C6
04E2:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N) 
....................  
....................  
....................  
....................  
....................  
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct port_d_map{ 
....................    int8 lcd_nibble:4; //0:3 
....................    boolean ps_en;     //4 
....................    boolean meas_rly;  //5 
....................    boolean pwr_ctrl;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... struct port_e_map{ 
....................    boolean rs; //0 
....................    boolean emgcy; //1 
....................    boolean tx_en; //2 
....................     int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
.................... #byte PORTA =0xF80 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... ////////////// actuator parameter ///////// 
.................... #define DIM_A 101.0 
.................... #define DIM_P 9.3 
.................... #define DIM_M 5.5 
.................... #define DIM_K 30.0 
.................... #define DIM_B 0.0  
.................... #define MIN_STROKE 76.0  
.................... #define MAX_STROKE 123.5 
.................... #define ROW_SPACING 320.00 
.................... #define PANEL_WIDTH 160.00 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1   PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3   PIN_B3 
.................... #define CCW PIN_B4 
.................... #define FLASH_SELECT PIN_C2 // output 
.................... #define FLASH_CLOCK  PIN_C3 // output 
.................... #define FLASH_DI     PIN_C5 // output 
.................... #define FLASH_DO     PIN_C4 // input 
.................... #define SENSE_0       PIN_A1 
.................... #define SENSE_1       PIN_A2 
.................... #define SENSE_2       PIN_A3 
.................... #define SENSE_3       PIN_A4 
.................... #define WALL_PWR    PIN_A5 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00002 
.................... #define ADDR_TIME           0xf00004 
.................... #define ADDR_START_COUNTER  0xf00008 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x05B1} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000} 
.................... #rom ADDR_TIME={0x0000,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... //#rom ADDR_TIME={0x1C20,0x0000} 
....................  
.................... const int8 line[4] = {0,0x40,0x10,0x50}; 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... char tmp_str[20],tmp_str2[20]; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... unsigned int8 timer_ms=0; 
.................... unsigned int32 next_sun_rise; 
.................... unsigned int16 current_act_position=0; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int32 JDN,jj,g; 
.................... unsigned int32 dg,c,dc,b,db,a,da,y,m,d; 
.................... unsigned int32 YY,MM,DD,time_of_day; 
.................... unsigned int32 sec_until_sun_rise; 
.................... int16 FULL_STROKE_TICK=0; 
.................... float al; 
.................... int16 move_act_time_out=3; 
.................... int8 tx_delay=0; 
.................... int16 current_measured=0; 
.................... int8 n_avg_current_measured=0; 
.................... int16 startup_counter=0; 
.................... int16 actuator_pulse=0; 
.................... unsigned int8 index_in_page; 
....................  
.................... void init_ext_flash(void); 
.................... void ext_flash_startContinuousRead(int pageAddress); 
.................... void ext_flash_sendData(int data, int size); 
.................... void ext_flash_send16Data(int16 data, int size); 
.................... void ext_flash_sendBytes(char* data, int size); 
.................... void ext_flash_getBytes(char* data, int16 size); 
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size); 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size); 
.................... int ext_flash_getByte(void); 
.................... void ext_flash_waitUntilReady(void); 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
367A:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
367C:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
367E:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
3680:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
3682:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
3684:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
3686:  BCF    FAC.5
....................    delay_cycles(10); 
3688:  MOVLW  03
368A:  MOVWF  00
368C:  DECFSZ 00,F
368E:  BRA    368C
....................    bit_set(RCSTA,4); //CREN=1 
3690:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
3692:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
3694:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
3696:  BSF    F9D.5
....................  
.................... } 
3698:  GOTO   616C (RETURN)
....................  
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int i; 
....................    int16 temp_mem;    
....................    temp_mem= &timer_sec; 
*
05BC:  CLRF   xD3
05BE:  MOVLW  20
05C0:  MOVWF  xD2
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
05C2:  CLRF   xD1
05C4:  MOVF   xD1,W
05C6:  SUBLW  03
05C8:  BNC   060C
05CA:  MOVF   xD1,W
05CC:  ADDWF  xD2,W
05CE:  MOVWF  xD4
05D0:  MOVLW  00
05D2:  ADDWFC xD3,W
05D4:  MOVWF  xD5
05D6:  MOVLW  04
05D8:  ADDWF  xD1,W
05DA:  MOVWF  xD6
05DC:  MOVFF  FF2,D7
05E0:  BCF    FF2.7
05E2:  MOVFF  D6,FA9
05E6:  BCF    FA6.6
05E8:  BCF    FA6.7
05EA:  BSF    FA6.0
05EC:  MOVF   FA8,W
05EE:  BTFSC  xD7.7
05F0:  BSF    FF2.7
05F2:  MOVWF  xD7
05F4:  MOVFF  D5,FEA
05F8:  MOVFF  D4,FE9
05FC:  MOVFF  D7,D8
0600:  CLRF   xDA
0602:  MOVLW  01
0604:  MOVWF  xD9
0606:  RCALL  05A2
0608:  INCF   xD1,F
060A:  BRA    05C4
....................    temp_mem= &FULL_STROKE_TICK; 
060C:  CLRF   xD3
060E:  MOVLW  BA
0610:  MOVWF  xD2
....................    if (FULL_STROKE_TICK > MAX_FULL_STROKE) FULL_STROKE_TICK = MAX_FULL_STROKE; 
0612:  MOVF   xBB,W
0614:  SUBLW  06
0616:  BC    062A
0618:  XORLW  FF
061A:  BNZ   0622
061C:  MOVF   xBA,W
061E:  SUBLW  D0
0620:  BC    062A
0622:  MOVLW  07
0624:  MOVWF  xBB
0626:  MOVLW  D0
0628:  MOVWF  xBA
....................    if (FULL_STROKE_TICK <0) FULL_STROKE_TICK = 0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i),1); 
062A:  CLRF   xD1
062C:  MOVF   xD1,W
062E:  SUBLW  01
0630:  BNC   066E
0632:  MOVF   xD1,W
0634:  ADDWF  xD2,W
0636:  MOVWF  xD4
0638:  MOVLW  00
063A:  ADDWFC xD3,W
063C:  MOVWF  xD5
063E:  MOVFF  FF2,D6
0642:  BCF    FF2.7
0644:  MOVFF  D1,FA9
0648:  BCF    FA6.6
064A:  BCF    FA6.7
064C:  BSF    FA6.0
064E:  MOVF   FA8,W
0650:  BTFSC  xD6.7
0652:  BSF    FF2.7
0654:  MOVWF  xD7
0656:  MOVFF  D5,FEA
065A:  MOVFF  D4,FE9
065E:  MOVFF  D7,D8
0662:  CLRF   xDA
0664:  MOVLW  01
0666:  MOVWF  xD9
0668:  RCALL  05A2
066A:  INCF   xD1,F
066C:  BRA    062C
....................    temp_mem= &current_act_position; 
066E:  CLRF   xD3
0670:  MOVLW  6E
0672:  MOVWF  xD2
....................    if (current_act_position > FULL_STROKE_TICK) current_act_position = FULL_STROKE_TICK; 
0674:  MOVF   xBB,W
0676:  SUBWF  x6F,W
0678:  BNC   068A
067A:  BNZ   0682
067C:  MOVF   x6E,W
067E:  SUBWF  xBA,W
0680:  BC    068A
0682:  MOVFF  BB,6F
0686:  MOVFF  BA,6E
....................    if (current_act_position < 0) current_act_position =0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i),1); 
068A:  CLRF   xD1
068C:  MOVF   xD1,W
068E:  SUBLW  01
0690:  BNC   06D4
0692:  MOVF   xD1,W
0694:  ADDWF  xD2,W
0696:  MOVWF  xD4
0698:  MOVLW  00
069A:  ADDWFC xD3,W
069C:  MOVWF  xD5
069E:  MOVLW  02
06A0:  ADDWF  xD1,W
06A2:  MOVWF  xD6
06A4:  MOVFF  FF2,D7
06A8:  BCF    FF2.7
06AA:  MOVFF  D6,FA9
06AE:  BCF    FA6.6
06B0:  BCF    FA6.7
06B2:  BSF    FA6.0
06B4:  MOVF   FA8,W
06B6:  BTFSC  xD7.7
06B8:  BSF    FF2.7
06BA:  MOVWF  xD7
06BC:  MOVFF  D5,FEA
06C0:  MOVFF  D4,FE9
06C4:  MOVFF  D7,D8
06C8:  CLRF   xDA
06CA:  MOVLW  01
06CC:  MOVWF  xD9
06CE:  RCALL  05A2
06D0:  INCF   xD1,F
06D2:  BRA    068C
....................    temp_mem= &startup_counter; 
06D4:  CLRF   xD3
06D6:  MOVLW  C6
06D8:  MOVWF  xD2
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
06DA:  CLRF   xD1
06DC:  MOVF   xD1,W
06DE:  SUBLW  01
06E0:  BNC   0724
06E2:  MOVF   xD1,W
06E4:  ADDWF  xD2,W
06E6:  MOVWF  xD4
06E8:  MOVLW  00
06EA:  ADDWFC xD3,W
06EC:  MOVWF  xD5
06EE:  MOVLW  08
06F0:  ADDWF  xD1,W
06F2:  MOVWF  xD6
06F4:  MOVFF  FF2,D7
06F8:  BCF    FF2.7
06FA:  MOVFF  D6,FA9
06FE:  BCF    FA6.6
0700:  BCF    FA6.7
0702:  BSF    FA6.0
0704:  MOVF   FA8,W
0706:  BTFSC  xD7.7
0708:  BSF    FF2.7
070A:  MOVWF  xD7
070C:  MOVFF  D5,FEA
0710:  MOVFF  D4,FE9
0714:  MOVFF  D7,D8
0718:  CLRF   xDA
071A:  MOVLW  01
071C:  MOVWF  xD9
071E:  RCALL  05A2
0720:  INCF   xD1,F
0722:  BRA    06DC
.................... } 
0724:  GOTO   5EFA (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0820:  CLRF   xD2
0822:  MOVF   xD2,W
0824:  SUBLW  03
0826:  BNC   0888
0828:  MOVLW  04
082A:  ADDWF  xD2,W
082C:  MOVWF  xD3
082E:  MOVF   xD2,W
0830:  MULLW  08
0832:  MOVFF  FF3,D4
0836:  MOVFF  23,D8
083A:  MOVFF  22,D7
083E:  MOVFF  21,D6
0842:  MOVFF  20,D5
0846:  MOVF   xD4,F
0848:  BZ    0858
084A:  BCF    FD8.0
084C:  RRCF   xD8,F
084E:  RRCF   xD7,F
0850:  RRCF   xD6,F
0852:  RRCF   xD5,F
0854:  DECFSZ xD4,F
0856:  BRA    084A
0858:  MOVFF  D3,FA9
085C:  MOVFF  D5,FA8
0860:  BCF    FA6.6
0862:  BCF    FA6.7
0864:  BSF    FA6.2
0866:  MOVFF  FF2,00
086A:  BCF    FF2.7
086C:  MOVLB  F
086E:  MOVLW  55
0870:  MOVWF  FA7
0872:  MOVLW  AA
0874:  MOVWF  FA7
0876:  BSF    FA6.1
0878:  BTFSC  FA6.1
087A:  BRA    0878
087C:  BCF    FA6.2
087E:  MOVF   00,W
0880:  IORWF  FF2,F
0882:  MOVLB  0
0884:  INCF   xD2,F
0886:  BRA    0822
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i,current_act_position>>(i*8)); 
0888:  CLRF   xD2
088A:  MOVF   xD2,W
088C:  SUBLW  01
088E:  BNC   08E4
0890:  MOVLW  02
0892:  ADDWF  xD2,W
0894:  MOVWF  xD3
0896:  MOVF   xD2,W
0898:  MULLW  08
089A:  MOVFF  FF3,00
089E:  MOVFF  6F,D5
08A2:  MOVFF  6E,D4
08A6:  MOVF   00,F
08A8:  BZ    08B4
08AA:  BCF    FD8.0
08AC:  RRCF   xD5,F
08AE:  RRCF   xD4,F
08B0:  DECFSZ 00,F
08B2:  BRA    08AA
08B4:  MOVFF  D3,FA9
08B8:  MOVFF  D4,FA8
08BC:  BCF    FA6.6
08BE:  BCF    FA6.7
08C0:  BSF    FA6.2
08C2:  MOVFF  FF2,00
08C6:  BCF    FF2.7
08C8:  MOVLB  F
08CA:  MOVLW  55
08CC:  MOVWF  FA7
08CE:  MOVLW  AA
08D0:  MOVWF  FA7
08D2:  BSF    FA6.1
08D4:  BTFSC  FA6.1
08D6:  BRA    08D4
08D8:  BCF    FA6.2
08DA:  MOVF   00,W
08DC:  IORWF  FF2,F
08DE:  MOVLB  0
08E0:  INCF   xD2,F
08E2:  BRA    088A
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
08E4:  CLRF   xD2
08E6:  MOVF   xD2,W
08E8:  SUBLW  01
08EA:  BNC   0940
08EC:  MOVLW  08
08EE:  ADDWF  xD2,W
08F0:  MOVWF  xD3
08F2:  MOVF   xD2,W
08F4:  MULLW  08
08F6:  MOVFF  FF3,00
08FA:  MOVFF  C7,D5
08FE:  MOVFF  C6,D4
0902:  MOVF   00,F
0904:  BZ    0910
0906:  BCF    FD8.0
0908:  RRCF   xD5,F
090A:  RRCF   xD4,F
090C:  DECFSZ 00,F
090E:  BRA    0906
0910:  MOVFF  D3,FA9
0914:  MOVFF  D4,FA8
0918:  BCF    FA6.6
091A:  BCF    FA6.7
091C:  BSF    FA6.2
091E:  MOVFF  FF2,00
0922:  BCF    FF2.7
0924:  MOVLB  F
0926:  MOVLW  55
0928:  MOVWF  FA7
092A:  MOVLW  AA
092C:  MOVWF  FA7
092E:  BSF    FA6.1
0930:  BTFSC  FA6.1
0932:  BRA    0930
0934:  BCF    FA6.2
0936:  MOVF   00,W
0938:  IORWF  FF2,F
093A:  MOVLB  0
093C:  INCF   xD2,F
093E:  BRA    08E6
....................    if (write_cal ==1) 
0940:  DECFSZ xD1,W
0942:  BRA    099A
....................       for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i,FULL_STROKE_TICK>>(i*8)); 
0944:  CLRF   xD2
0946:  MOVF   xD2,W
0948:  SUBLW  01
094A:  BNC   099A
094C:  MOVF   xD2,W
094E:  MULLW  08
0950:  MOVFF  FF3,00
0954:  MOVFF  BB,D4
0958:  MOVFF  BA,D3
095C:  MOVF   00,F
095E:  BZ    096A
0960:  BCF    FD8.0
0962:  RRCF   xD4,F
0964:  RRCF   xD3,F
0966:  DECFSZ 00,F
0968:  BRA    0960
096A:  MOVFF  D2,FA9
096E:  MOVFF  D3,FA8
0972:  BCF    FA6.6
0974:  BCF    FA6.7
0976:  BSF    FA6.2
0978:  MOVFF  FF2,00
097C:  BCF    FF2.7
097E:  MOVLB  F
0980:  MOVLW  55
0982:  MOVWF  FA7
0984:  MOVLW  AA
0986:  MOVWF  FA7
0988:  BSF    FA6.1
098A:  BTFSC  FA6.1
098C:  BRA    098A
098E:  BCF    FA6.2
0990:  MOVF   00,W
0992:  IORWF  FF2,F
0994:  MOVLB  0
0996:  INCF   xD2,F
0998:  BRA    0946
.................... } 
099A:  RETLW  00
....................  
....................  
.................... void init_ext_flash(void) { 
....................   output_low(FLASH_CLOCK); 
*
0AAE:  BCF    F94.3
0AB0:  BCF    F8B.3
....................   output_high(FLASH_SELECT); 
0AB2:  BCF    F94.2
0AB4:  BSF    F8B.2
.................... } 
0AB6:  GOTO   5F88 (RETURN)
....................  
.................... /* 
.................... void ext_flash_startContinuousRead(int pageAddress) { 
....................   ext_flash_waitUntilReady(); 
....................   output_low(FLASH_SELECT); 
....................   ext_flash_sendData(0xE8, 8); 
....................   ext_flash_sendData(pageAddress, 14); 
....................   ext_flash_sendData(0, 10); 
....................   ext_flash_sendData(0, 16); 
....................   ext_flash_sendData(0, 16); 
.................... } 
....................  
.................... */ 
....................  
.................... int ext_flash_getByte(void) { 
....................   int flashData = 0; 
....................   output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   return(flashData); 
.................... } 
....................  
.................... void ext_flash_getBytes(char* data, int16 size) { 
....................    int16 i, j; 
....................    for(i = 0; i < size; i++) { 
*
2770:  CLRF   xFF
2772:  CLRF   xFE
2774:  MOVF   xFF,W
2776:  SUBWF  xFD,W
2778:  BNC   27D6
277A:  BNZ   2782
277C:  MOVF   xFC,W
277E:  SUBWF  xFE,W
2780:  BC    27D6
....................       for(j = 0; j < 8; j++) { 
2782:  MOVLB  1
2784:  CLRF   x01
2786:  CLRF   x00
2788:  MOVF   x01,F
278A:  BNZ   27CC
278C:  MOVF   x00,W
278E:  SUBLW  07
2790:  BNC   27CC
....................          output_high(FLASH_CLOCK); 
2792:  BCF    F94.3
2794:  BSF    F8B.3
....................          shift_left(data + i, 1, input(FLASH_DO)); 
2796:  MOVLB  0
2798:  MOVF   xFE,W
279A:  ADDWF  xFA,W
279C:  MOVLB  1
279E:  MOVWF  x02
27A0:  MOVLB  0
27A2:  MOVF   xFF,W
27A4:  ADDWFC xFB,W
27A6:  MOVLB  1
27A8:  MOVWF  x03
27AA:  BSF    F94.4
27AC:  BTFSC  F82.4
27AE:  BRA    27B4
27B0:  BCF    FD8.0
27B2:  BRA    27B6
27B4:  BSF    FD8.0
27B6:  MOVFF  103,FEA
27BA:  MOVFF  102,FE9
27BE:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
27C0:  BCF    F94.3
27C2:  BCF    F8B.3
....................       } 
27C4:  INCF   x00,F
27C6:  BTFSC  FD8.2
27C8:  INCF   x01,F
27CA:  BRA    2788
....................    } 
27CC:  MOVLB  0
27CE:  INCF   xFE,F
27D0:  BTFSC  FD8.2
27D2:  INCF   xFF,F
27D4:  BRA    2774
.................... } 
27D6:  RETLW  00
....................  
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size) { 
....................    ext_flash_waitUntilReady(); 
27D8:  RCALL  24A8
....................    output_low(FLASH_SELECT); 
27DA:  BCF    F94.2
27DC:  BCF    F8B.2
....................    ext_flash_sendData(0xD2, 8); 
27DE:  MOVLW  D2
27E0:  MOVWF  xFA
27E2:  MOVLW  08
27E4:  MOVWF  xFB
27E6:  RCALL  25DE
....................    ext_flash_send16Data(pageAddress, 15); 
27E8:  MOVFF  F4,FB
27EC:  MOVFF  F3,FA
27F0:  MOVLW  0F
27F2:  MOVWF  xFC
27F4:  RCALL  260E
....................    ext_flash_sendData(0, 1); 
27F6:  CLRF   xFA
27F8:  MOVLW  01
27FA:  MOVWF  xFB
27FC:  RCALL  25DE
....................    ext_flash_sendData(pageIndex, 8); 
27FE:  MOVFF  F5,FA
2802:  MOVLW  08
2804:  MOVWF  xFB
2806:  RCALL  25DE
....................    ext_flash_sendData(0, 16); 
2808:  CLRF   xFA
280A:  MOVLW  10
280C:  MOVWF  xFB
280E:  RCALL  25DE
....................    ext_flash_sendData(0, 16); 
2810:  CLRF   xFA
2812:  MOVLW  10
2814:  MOVWF  xFB
2816:  RCALL  25DE
....................    ext_flash_getBytes(data, size); 
2818:  MOVFF  F7,FB
281C:  MOVFF  F6,FA
2820:  MOVFF  F9,FD
2824:  MOVFF  F8,FC
2828:  RCALL  2770
....................    output_high(FLASH_SELECT); 
282A:  BCF    F94.2
282C:  BSF    F8B.2
.................... } 
282E:  RETLW  00
....................  
.................... /* 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
....................    output_low(FLASH_SELECT); 
....................    ext_flash_sendData(0x82, 8); 
....................    ext_flash_sendData(pageAddress, 14); 
....................    ext_flash_sendData(0, 10); 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
....................    output_high(FLASH_SELECT); 
.................... } 
.................... */ 
....................  
....................  
.................... void ext_flash_sendData(int data, int size) { 
....................    do { 
....................       size--; 
*
25DE:  DECF   xFB,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
25E0:  MOVFF  FA,00
25E4:  MOVF   xFB,W
25E6:  MOVWF  01
25E8:  BZ    25F2
25EA:  BCF    FD8.0
25EC:  RRCF   00,F
25EE:  DECFSZ 01,F
25F0:  BRA    25EA
25F2:  MOVF   00,W
25F4:  ANDLW  01
25F6:  BNZ   25FC
25F8:  BCF    F8B.5
25FA:  BRA    25FE
25FC:  BSF    F8B.5
25FE:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
2600:  BCF    F94.3
2602:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
2604:  BCF    F94.3
2606:  BCF    F8B.3
....................    } while(size > 0); 
2608:  MOVF   xFB,F
260A:  BNZ   25DE
.................... } 
260C:  RETLW  00
....................  
.................... void ext_flash_send16Data(int16 data, int size) { 
....................    do { 
....................       size--; 
260E:  DECF   xFC,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
2610:  MOVFF  FB,FE
2614:  MOVFF  FA,FD
2618:  MOVF   xFC,W
261A:  MOVWF  00
261C:  BZ    2628
261E:  BCF    FD8.0
2620:  RRCF   xFE,F
2622:  RRCF   xFD,F
2624:  DECFSZ 00,F
2626:  BRA    261E
2628:  MOVF   xFD,W
262A:  ANDLW  01
262C:  MOVWF  00
262E:  CLRF   03
2630:  MOVF   00,W
2632:  IORWF  03,W
2634:  BNZ   263A
2636:  BCF    F8B.5
2638:  BRA    263C
263A:  BSF    F8B.5
263C:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
263E:  BCF    F94.3
2640:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
2642:  BCF    F94.3
2644:  BCF    F8B.3
....................    } while(size > 0); 
2646:  MOVF   xFC,F
2648:  BNZ   260E
.................... } 
264A:  RETLW  00
....................  
.................... void ext_flash_sendBytes(char* data, int size) { 
....................    int i; 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
.................... } 
....................  
.................... void ext_flash_waitUntilReady(void) { 
.................... // this function read status register 
.................... // Bit7 : 1=RDY, 0=BUSY 
.................... // Bit6 : COMP, 1=Recent Main memory page compare, 0 == match 
.................... // Bit 5-2 : 0b0111 , density code for 4MBit 
.................... // Bit 1: Protect 
.................... // Bit 0: Page size. 0= 264 byte, 1=256 byte 
....................  
....................   int flashData; 
....................   int i; 
....................   output_low(FLASH_SELECT); 
*
24A8:  BCF    F94.2
24AA:  BCF    F8B.2
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24AC:  BSF    F8B.5
24AE:  BCF    F94.5
24B0:  BCF    F94.3
24B2:  BSF    F8B.3
24B4:  BCF    F94.3
24B6:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24B8:  BSF    F8B.5
24BA:  BCF    F94.5
24BC:  BCF    F94.3
24BE:  BSF    F8B.3
24C0:  BCF    F94.3
24C2:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24C4:  BCF    F8B.5
24C6:  BCF    F94.5
24C8:  BCF    F94.3
24CA:  BSF    F8B.3
24CC:  BCF    F94.3
24CE:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24D0:  BSF    F8B.5
24D2:  BCF    F94.5
24D4:  BCF    F94.3
24D6:  BSF    F8B.3
24D8:  BCF    F94.3
24DA:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24DC:  BCF    F8B.5
24DE:  BCF    F94.5
24E0:  BCF    F94.3
24E2:  BSF    F8B.3
24E4:  BCF    F94.3
24E6:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24E8:  BSF    F8B.5
24EA:  BCF    F94.5
24EC:  BCF    F94.3
24EE:  BSF    F8B.3
24F0:  BCF    F94.3
24F2:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24F4:  BSF    F8B.5
24F6:  BCF    F94.5
24F8:  BCF    F94.3
24FA:  BSF    F8B.3
24FC:  BCF    F94.3
24FE:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2500:  BSF    F8B.5
2502:  BCF    F94.5
2504:  BCF    F94.3
2506:  BSF    F8B.3
2508:  BCF    F94.3
250A:  BCF    F8B.3
....................   for(i=0;i<255;i++) { 
250C:  CLRF   xFB
250E:  INCFSZ xFB,W
2510:  BRA    2514
2512:  BRA    25D8
....................     flashData = 0; 
2514:  CLRF   xFA
....................     output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2516:  BCF    F94.3
2518:  BSF    F8B.3
251A:  BSF    F94.4
251C:  MOVLW  00
251E:  BTFSC  F82.4
2520:  MOVLW  01
2522:  ADDWF  xFA,F
2524:  BCF    F94.3
2526:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2528:  BCF    F94.3
252A:  BSF    F8B.3
252C:  BCF    FD8.0
252E:  RLCF   xFA,F
2530:  BSF    F94.4
2532:  MOVLW  00
2534:  BTFSC  F82.4
2536:  MOVLW  01
2538:  ADDWF  xFA,F
253A:  BCF    F94.3
253C:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
253E:  BCF    F94.3
2540:  BSF    F8B.3
2542:  BCF    FD8.0
2544:  RLCF   xFA,F
2546:  BSF    F94.4
2548:  MOVLW  00
254A:  BTFSC  F82.4
254C:  MOVLW  01
254E:  ADDWF  xFA,F
2550:  BCF    F94.3
2552:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2554:  BCF    F94.3
2556:  BSF    F8B.3
2558:  BCF    FD8.0
255A:  RLCF   xFA,F
255C:  BSF    F94.4
255E:  MOVLW  00
2560:  BTFSC  F82.4
2562:  MOVLW  01
2564:  ADDWF  xFA,F
2566:  BCF    F94.3
2568:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
256A:  BCF    F94.3
256C:  BSF    F8B.3
256E:  BCF    FD8.0
2570:  RLCF   xFA,F
2572:  BSF    F94.4
2574:  MOVLW  00
2576:  BTFSC  F82.4
2578:  MOVLW  01
257A:  ADDWF  xFA,F
257C:  BCF    F94.3
257E:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2580:  BCF    F94.3
2582:  BSF    F8B.3
2584:  BCF    FD8.0
2586:  RLCF   xFA,F
2588:  BSF    F94.4
258A:  MOVLW  00
258C:  BTFSC  F82.4
258E:  MOVLW  01
2590:  ADDWF  xFA,F
2592:  BCF    F94.3
2594:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2596:  BCF    F94.3
2598:  BSF    F8B.3
259A:  BCF    FD8.0
259C:  RLCF   xFA,F
259E:  BSF    F94.4
25A0:  MOVLW  00
25A2:  BTFSC  F82.4
25A4:  MOVLW  01
25A6:  ADDWF  xFA,F
25A8:  BCF    F94.3
25AA:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25AC:  BCF    F94.3
25AE:  BSF    F8B.3
25B0:  BCF    FD8.0
25B2:  RLCF   xFA,F
25B4:  BSF    F94.4
25B6:  MOVLW  00
25B8:  BTFSC  F82.4
25BA:  MOVLW  01
25BC:  ADDWF  xFA,F
25BE:  BCF    F94.3
25C0:  BCF    F8B.3
....................     if (bit_test(flashData,7) == 1) break; // device is not busy 
25C2:  BTFSS  xFA.7
25C4:  BRA    25C8
25C6:  BRA    25D8
....................    delay_cycles(50); 
25C8:  MOVLW  10
25CA:  MOVWF  00
25CC:  DECFSZ 00,F
25CE:  BRA    25CC
25D0:  NOP   
....................    restart_wdt(); 
25D2:  CLRWDT
....................   } 
25D4:  INCF   xFB,F
25D6:  BRA    250E
....................   output_high(FLASH_SELECT); 
25D8:  BCF    F94.2
25DA:  BSF    F8B.2
.................... } 
25DC:  RETLW  00
....................  
.................... void ext_flash_block_erase() { 
....................    int i; 
....................    for(i=0;i<0xFF;i++) { 
*
28CA:  CLRF   xD1
28CC:  INCFSZ xD1,W
28CE:  BRA    28D2
28D0:  BRA    2904
....................    ext_flash_waitUntilReady(); 
28D2:  RCALL  24A8
....................    output_low(FLASH_SELECT); 
28D4:  BCF    F94.2
28D6:  BCF    F8B.2
....................    ext_flash_sendData(0x50, 8); 
28D8:  MOVLW  50
28DA:  MOVWF  xFA
28DC:  MOVLW  08
28DE:  MOVWF  xFB
28E0:  RCALL  25DE
....................    ext_flash_sendData(0, 4); 
28E2:  CLRF   xFA
28E4:  MOVLW  04
28E6:  MOVWF  xFB
28E8:  RCALL  25DE
....................    ext_flash_sendData(i, 8); 
28EA:  MOVFF  D1,FA
28EE:  MOVLW  08
28F0:  MOVWF  xFB
28F2:  RCALL  25DE
....................    ext_flash_sendData(0, 12); 
28F4:  CLRF   xFA
28F6:  MOVLW  0C
28F8:  MOVWF  xFB
28FA:  RCALL  25DE
....................    output_high(FLASH_SELECT); 
28FC:  BCF    F94.2
28FE:  BSF    F8B.2
....................    } 
2900:  INCF   xD1,F
2902:  BRA    28CC
....................    ext_flash_waitUntilReady(); 
2904:  RCALL  24A8
.................... } 
2906:  GOTO   3626 (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_read() { 
....................    char data; 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2D9E:  CALL   24A8
....................    output_low(FLASH_SELECT); 
2DA2:  BCF    F94.2
2DA4:  BCF    F8B.2
....................    ext_flash_sendData(0xD1, 8); 
2DA6:  MOVLW  D1
2DA8:  MOVWF  xFA
2DAA:  MOVLW  08
2DAC:  MOVWF  xFB
2DAE:  RCALL  25DE
....................    ext_flash_send16Data(0, 16); 
2DB0:  CLRF   xFB
2DB2:  CLRF   xFA
2DB4:  MOVLW  10
2DB6:  MOVWF  xFC
2DB8:  RCALL  260E
....................    ext_flash_sendData(0, 8); 
2DBA:  CLRF   xFA
2DBC:  MOVLW  08
2DBE:  MOVWF  xFB
2DC0:  RCALL  25DE
....................    i=255; 
2DC2:  MOVLW  FF
2DC4:  MOVWF  xD2
....................    do { 
....................      ext_flash_getBytes(&data,1); 
2DC6:  CLRF   xFB
2DC8:  MOVLW  D1
2DCA:  MOVWF  xFA
2DCC:  CLRF   xFD
2DCE:  MOVLW  01
2DD0:  MOVWF  xFC
2DD2:  RCALL  2770
....................      i++; 
2DD4:  INCF   xD2,F
....................      if (i%16==0) printf("\r\n %02X:", i); 
2DD6:  MOVF   xD2,W
2DD8:  ANDLW  0F
2DDA:  BNZ   2E06
2DDC:  MOVLW  0D
2DDE:  BTFSS  F9E.4
2DE0:  BRA    2DDE
2DE2:  MOVWF  FAD
2DE4:  MOVLW  0A
2DE6:  BTFSS  F9E.4
2DE8:  BRA    2DE6
2DEA:  MOVWF  FAD
2DEC:  MOVLW  20
2DEE:  BTFSS  F9E.4
2DF0:  BRA    2DEE
2DF2:  MOVWF  FAD
2DF4:  MOVFF  D2,E9
2DF8:  MOVLW  37
2DFA:  MOVWF  xEA
2DFC:  RCALL  272E
2DFE:  MOVLW  3A
2E00:  BTFSS  F9E.4
2E02:  BRA    2E00
2E04:  MOVWF  FAD
....................       printf("%02X ",data); 
2E06:  MOVFF  D1,E9
2E0A:  MOVLW  37
2E0C:  MOVWF  xEA
2E0E:  RCALL  272E
2E10:  MOVLW  20
2E12:  BTFSS  F9E.4
2E14:  BRA    2E12
2E16:  MOVWF  FAD
....................  
....................    } while (i<255); 
2E18:  INCFSZ xD2,W
2E1A:  BRA    2DC6
....................    output_high(FLASH_SELECT);    
2E1C:  BCF    F94.2
2E1E:  BSF    F8B.2
.................... } 
2E20:  GOTO   347A (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2F30:  CALL   24A8
....................    output_low(FLASH_SELECT); 
2F34:  BCF    F94.2
2F36:  BCF    F8B.2
....................    ext_flash_sendData(0x84, 8); 
2F38:  MOVLW  84
2F3A:  MOVWF  xFA
2F3C:  MOVLW  08
2F3E:  MOVWF  xFB
2F40:  CALL   25DE
....................    ext_flash_send16Data(0, 16); 
2F44:  CLRF   xFB
2F46:  CLRF   xFA
2F48:  MOVLW  10
2F4A:  MOVWF  xFC
2F4C:  CALL   260E
....................    ext_flash_sendData(PageIndex, 8); 
2F50:  MOVFF  DD,FA
2F54:  MOVLW  08
2F56:  MOVWF  xFB
2F58:  CALL   25DE
....................    if (nData>1) { 
2F5C:  MOVF   xDE,W
2F5E:  SUBLW  01
2F60:  BC    2F7C
....................    i=255; 
2F62:  MOVLW  FF
2F64:  MOVWF  xDF
....................    do { 
....................       ext_flash_sendData(data,8); 
2F66:  MOVFF  DC,FA
2F6A:  MOVLW  08
2F6C:  MOVWF  xFB
2F6E:  CALL   25DE
....................       i++; 
2F72:  INCF   xDF,F
....................    } while(i<nData); 
2F74:  MOVF   xDE,W
2F76:  SUBWF  xDF,W
2F78:  BNC   2F66
....................    } else 
2F7A:  BRA    2F88
....................          ext_flash_sendData(data,8); 
2F7C:  MOVFF  DC,FA
2F80:  MOVLW  08
2F82:  MOVWF  xFB
2F84:  CALL   25DE
....................    output_high(FLASH_SELECT); 
2F88:  BCF    F94.2
2F8A:  BSF    F8B.2
.................... } 
2F8C:  RETLW  00
....................  
.................... void ext_flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
38AA:  CALL   24A8
....................    output_low(FLASH_SELECT); 
38AE:  BCF    F94.2
38B0:  BCF    F8B.2
....................    ext_flash_sendData(0x83, 8); 
38B2:  MOVLW  83
38B4:  MOVWF  xFA
38B6:  MOVLW  08
38B8:  MOVWF  xFB
38BA:  CALL   25DE
....................    ext_flash_send16Data(pageAddress, 15); 
38BE:  MOVFF  D8,FB
38C2:  MOVFF  D7,FA
38C6:  MOVLW  0F
38C8:  MOVWF  xFC
38CA:  CALL   260E
....................    ext_flash_send16Data(0, 9); 
38CE:  CLRF   xFB
38D0:  CLRF   xFA
38D2:  MOVLW  09
38D4:  MOVWF  xFC
38D6:  CALL   260E
....................    output_high(FLASH_SELECT); 
38DA:  BCF    F94.2
38DC:  BSF    F8B.2
.................... } 
38DE:  GOTO   3C70 (RETURN)
....................  
.................... void ext_flash_main_memory_to_buffer1(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
2CCA:  CALL   24A8
....................    output_low(FLASH_SELECT); 
2CCE:  BCF    F94.2
2CD0:  BCF    F8B.2
....................    ext_flash_sendData(0x53, 8); 
2CD2:  MOVLW  53
2CD4:  MOVWF  xFA
2CD6:  MOVLW  08
2CD8:  MOVWF  xFB
2CDA:  RCALL  25DE
....................    ext_flash_send16Data(pageAddress, 15); 
2CDC:  MOVFF  D7,FB
2CE0:  MOVFF  D6,FA
2CE4:  MOVLW  0F
2CE6:  MOVWF  xFC
2CE8:  RCALL  260E
....................    ext_flash_send16Data(0, 9); 
2CEA:  CLRF   xFB
2CEC:  CLRF   xFA
2CEE:  MOVLW  09
2CF0:  MOVWF  xFC
2CF2:  RCALL  260E
....................    output_high(FLASH_SELECT); 
2CF4:  BCF    F94.2
2CF6:  BSF    F8B.2
.................... } 
2CF8:  RETLW  00
....................  
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD.lcd_nibble=n>>4; 
*
099C:  SWAPF  xF2,W
099E:  MOVWF  00
09A0:  MOVLW  0F
09A2:  ANDWF  00,F
09A4:  MOVF   00,W
09A6:  ANDLW  0F
09A8:  MOVWF  00
09AA:  MOVLW  F0
09AC:  ANDWF  F83,W
09AE:  IORWF  00,W
09B0:  MOVWF  F83
....................       delay_us(50); 
09B2:  MOVLW  29
09B4:  MOVWF  00
09B6:  DECFSZ 00,F
09B8:  BRA    09B6
09BA:  NOP   
....................       PORTD.disp_en=1; 
09BC:  BSF    F83.7
....................       delay_us(50); 
09BE:  MOVLW  29
09C0:  MOVWF  00
09C2:  DECFSZ 00,F
09C4:  BRA    09C2
09C6:  NOP   
....................       PORTD.disp_en=0; 
09C8:  BCF    F83.7
....................      delay_us(50); 
09CA:  MOVLW  29
09CC:  MOVWF  00
09CE:  DECFSZ 00,F
09D0:  BRA    09CE
09D2:  NOP   
.................... } 
09D4:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
....................    PORTE.rs=rs; 
09D6:  BTFSS  xEE.0
09D8:  BCF    F84.0
09DA:  BTFSC  xEE.0
09DC:  BSF    F84.0
....................    lcd_send_nibble(dat&0xF0); 
09DE:  MOVF   xEF,W
09E0:  ANDLW  F0
09E2:  MOVWF  xF0
09E4:  MOVWF  xF2
09E6:  RCALL  099C
....................    lcd_send_nibble((dat<<4)&0xF0); 
09E8:  SWAPF  xEF,W
09EA:  MOVWF  00
09EC:  MOVLW  F0
09EE:  ANDWF  00,F
09F0:  MOVF   00,W
09F2:  ANDLW  F0
09F4:  MOVWF  xF1
09F6:  MOVWF  xF2
09F8:  RCALL  099C
....................    PORTE.rs=1; 
09FA:  BSF    F84.0
.................... } 
09FC:  RETLW  00
....................  
.................... void lcd_init() { 
....................    int8 i; 
....................     PORTE.rs = 0; 
09FE:  BCF    F84.0
....................     PORTD.disp_en=0; 
0A00:  BCF    F83.7
0A02:  CLRF   18
0A04:  BTFSC  FF2.7
0A06:  BSF    18.7
0A08:  BCF    FF2.7
....................    delay_ms(15); 
0A0A:  MOVLW  0F
0A0C:  MOVWF  xEA
0A0E:  RCALL  04BC
0A10:  BTFSC  18.7
0A12:  BSF    FF2.7
....................     for(i=1;i<=3;++i) { 
0A14:  MOVLW  01
0A16:  MOVWF  xD2
0A18:  MOVF   xD2,W
0A1A:  SUBLW  03
0A1C:  BNC   0A3A
....................        lcd_send_nibble(0x30);  
0A1E:  MOVLW  30
0A20:  MOVWF  xF2
0A22:  RCALL  099C
0A24:  CLRF   18
0A26:  BTFSC  FF2.7
0A28:  BSF    18.7
0A2A:  BCF    FF2.7
....................        delay_ms(15); 
0A2C:  MOVLW  0F
0A2E:  MOVWF  xEA
0A30:  RCALL  04BC
0A32:  BTFSC  18.7
0A34:  BSF    FF2.7
....................     } 
0A36:  INCF   xD2,F
0A38:  BRA    0A18
....................     lcd_send_nibble(0x20);  
0A3A:  MOVLW  20
0A3C:  MOVWF  xF2
0A3E:  RCALL  099C
0A40:  CLRF   18
0A42:  BTFSC  FF2.7
0A44:  BSF    18.7
0A46:  BCF    FF2.7
....................     delay_ms(15); 
0A48:  MOVLW  0F
0A4A:  MOVWF  xEA
0A4C:  RCALL  04BC
0A4E:  BTFSC  18.7
0A50:  BSF    FF2.7
....................     lcd_send_cmd(0,0x06); 
0A52:  CLRF   xEE
0A54:  MOVLW  06
0A56:  MOVWF  xEF
0A58:  RCALL  09D6
....................     delay_us(50); 
0A5A:  MOVLW  29
0A5C:  MOVWF  00
0A5E:  DECFSZ 00,F
0A60:  BRA    0A5E
0A62:  NOP   
....................     lcd_send_cmd(0,0x0c); 
0A64:  CLRF   xEE
0A66:  MOVLW  0C
0A68:  MOVWF  xEF
0A6A:  RCALL  09D6
....................     delay_us(50); 
0A6C:  MOVLW  29
0A6E:  MOVWF  00
0A70:  DECFSZ 00,F
0A72:  BRA    0A70
0A74:  NOP   
....................     lcd_send_cmd(0,0x10); 
0A76:  CLRF   xEE
0A78:  MOVLW  10
0A7A:  MOVWF  xEF
0A7C:  RCALL  09D6
....................     delay_us(50); 
0A7E:  MOVLW  29
0A80:  MOVWF  00
0A82:  DECFSZ 00,F
0A84:  BRA    0A82
0A86:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
0A88:  CLRF   xEE
0A8A:  MOVLW  2C
0A8C:  MOVWF  xEF
0A8E:  RCALL  09D6
....................     delay_us(50); 
0A90:  MOVLW  29
0A92:  MOVWF  00
0A94:  DECFSZ 00,F
0A96:  BRA    0A94
0A98:  NOP   
....................     lcd_send_cmd(0,0x01); 
0A9A:  CLRF   xEE
0A9C:  MOVLW  01
0A9E:  MOVWF  xEF
0AA0:  RCALL  09D6
....................     delay_us(50); 
0AA2:  MOVLW  29
0AA4:  MOVWF  00
0AA6:  DECFSZ 00,F
0AA8:  BRA    0AA6
0AAA:  NOP   
....................  
.................... } 
0AAC:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
0CC2:  MOVF   xEB,W
0CC4:  ANDLW  03
0CC6:  CLRF   03
0CC8:  MOVFF  FF2,EE
0CCC:  BCF    FF2.7
0CCE:  CALL   00AA
0CD2:  BTFSC  xEE.7
0CD4:  BSF    FF2.7
0CD6:  MOVWF  xEC
....................    address+=x; 
0CD8:  MOVF   xEA,W
0CDA:  ADDWF  xEC,F
....................    lcd_send_cmd(0,0x80|address); 
0CDC:  MOVF   xEC,W
0CDE:  IORLW  80
0CE0:  MOVWF  xED
0CE2:  CLRF   xEE
0CE4:  MOVWF  xEF
0CE6:  RCALL  09D6
.................... } 
0CE8:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0CEA:  MOVF   xE9,W
0CEC:  XORLW  0C
0CEE:  BZ    0CFA
0CF0:  XORLW  06
0CF2:  BZ    0D18
0CF4:  XORLW  02
0CF6:  BZ    0D24
0CF8:  BRA    0D2E
....................      case '\f'   : lcd_send_cmd(0,1); 
0CFA:  CLRF   xEE
0CFC:  MOVLW  01
0CFE:  MOVWF  xEF
0D00:  RCALL  09D6
0D02:  CLRF   18
0D04:  BTFSC  FF2.7
0D06:  BSF    18.7
0D08:  BCF    FF2.7
....................                    delay_ms(2); 
0D0A:  MOVLW  02
0D0C:  MOVWF  xEA
0D0E:  CALL   04BC
0D12:  BTFSC  18.7
0D14:  BSF    FF2.7
....................                                            break; 
0D16:  BRA    0D3A
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0D18:  MOVLW  01
0D1A:  MOVWF  xEA
0D1C:  MOVLW  02
0D1E:  MOVWF  xEB
0D20:  RCALL  0CC2
0D22:  BRA    0D3A
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
0D24:  CLRF   xEE
0D26:  MOVLW  10
0D28:  MOVWF  xEF
0D2A:  RCALL  09D6
0D2C:  BRA    0D3A
....................      default     : lcd_send_cmd(1,c);     break; 
0D2E:  MOVLW  01
0D30:  MOVWF  xEE
0D32:  MOVFF  E9,EF
0D36:  RCALL  09D6
0D38:  BRA    0D3A
....................    } 
.................... } 
0D3A:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<size;i++)   lcd_putc(c[i]); 
*
16B4:  CLRF   xE4
16B6:  MOVF   xE3,W
16B8:  SUBWF  xE4,W
16BA:  BC    16DA
16BC:  CLRF   03
16BE:  MOVF   xE4,W
16C0:  ADDWF  xE1,W
16C2:  MOVWF  FE9
16C4:  MOVF   xE2,W
16C6:  ADDWFC 03,W
16C8:  MOVWF  FEA
16CA:  MOVFF  FEF,E5
16CE:  MOVFF  E5,E9
16D2:  CALL   0CEA
16D6:  INCF   xE4,F
16D8:  BRA    16B6
.................... } 
16DA:  RETLW  00
....................     
....................  
.................... void print_date_time() { 
....................  
....................       JDN = (unsigned int32)((float) (Y2010_JDN*1.0+ 0.5+ (float)(UTC*1.0)/24.0 + (timer_sec)*1.0/86400.0)); 
16DC:  MOVFF  23,E3
16E0:  MOVFF  22,E2
16E4:  MOVFF  21,E1
16E8:  MOVFF  20,E0
16EC:  GOTO   0DEE
16F0:  MOVFF  03,151
16F4:  MOVFF  02,150
16F8:  MOVFF  01,14F
16FC:  MOVFF  00,14E
1700:  MOVLB  1
1702:  CLRF   x55
1704:  CLRF   x54
1706:  CLRF   x53
1708:  MOVLW  7F
170A:  MOVWF  x52
170C:  MOVLB  0
170E:  CALL   0E24
1712:  MOVFF  00,E0
1716:  MOVFF  01,E1
171A:  MOVFF  02,E2
171E:  MOVFF  03,E3
1722:  MOVFF  03,14D
1726:  MOVFF  02,14C
172A:  MOVFF  01,14B
172E:  MOVFF  00,14A
1732:  MOVLB  1
1734:  CLRF   x51
1736:  MOVLW  C0
1738:  MOVWF  x50
173A:  MOVLW  28
173C:  MOVWF  x4F
173E:  MOVLW  8F
1740:  MOVWF  x4E
1742:  MOVLB  0
1744:  CALL   0F1A
1748:  BCF    FD8.1
174A:  MOVLW  79
174C:  MOVLB  1
174E:  MOVWF  x53
1750:  MOVLW  DA
1752:  MOVWF  x52
1754:  MOVLW  15
1756:  MOVWF  x51
1758:  MOVLW  94
175A:  MOVWF  x50
175C:  MOVFF  03,157
1760:  MOVFF  02,156
1764:  MOVFF  01,155
1768:  MOVFF  00,154
176C:  MOVLB  0
176E:  RCALL  1078
1770:  MOVFF  03,E7
1774:  MOVFF  02,E6
1778:  MOVFF  01,E5
177C:  MOVFF  00,E4
1780:  BRA    12F0
1782:  MOVFF  03,75
1786:  MOVFF  02,74
178A:  MOVFF  01,73
178E:  MOVFF  00,72
....................       jj = JDN +32044; 
1792:  MOVLW  2C
1794:  ADDWF  x72,W
1796:  MOVWF  x76
1798:  MOVLW  7D
179A:  ADDWFC x73,W
179C:  MOVWF  x77
179E:  MOVLW  00
17A0:  ADDWFC x74,W
17A2:  MOVWF  x78
17A4:  MOVLW  00
17A6:  ADDWFC x75,W
17A8:  MOVWF  x79
17AA:  CLRF   18
17AC:  BTFSC  FF2.7
17AE:  BSF    18.7
17B0:  BCF    FF2.7
....................       g=jj/146097; 
17B2:  MOVFF  79,EE
17B6:  MOVFF  78,ED
17BA:  MOVFF  77,EC
17BE:  MOVFF  76,EB
17C2:  CLRF   xF2
17C4:  MOVLW  02
17C6:  MOVWF  xF1
17C8:  MOVLW  3A
17CA:  MOVWF  xF0
17CC:  MOVLW  B1
17CE:  MOVWF  xEF
17D0:  CALL   0340
17D4:  BTFSC  18.7
17D6:  BSF    FF2.7
17D8:  MOVFF  03,7D
17DC:  MOVFF  02,7C
17E0:  MOVFF  01,7B
17E4:  MOVFF  00,7A
17E8:  CLRF   18
17EA:  BTFSC  FF2.7
17EC:  BSF    18.7
17EE:  BCF    FF2.7
....................       dg=jj%146097; 
17F0:  MOVFF  79,EE
17F4:  MOVFF  78,ED
17F8:  MOVFF  77,EC
17FC:  MOVFF  76,EB
1800:  CLRF   xF2
1802:  MOVLW  02
1804:  MOVWF  xF1
1806:  MOVLW  3A
1808:  MOVWF  xF0
180A:  MOVLW  B1
180C:  MOVWF  xEF
180E:  CALL   0340
1812:  BTFSC  18.7
1814:  BSF    FF2.7
1816:  MOVFF  FEF,7E
181A:  MOVFF  FEC,7F
181E:  MOVFF  FEC,80
1822:  MOVFF  FEC,81
1826:  CLRF   18
1828:  BTFSC  FF2.7
182A:  BSF    18.7
182C:  BCF    FF2.7
....................       c=(dg/36524+1)*3/4; 
182E:  MOVFF  81,EE
1832:  MOVFF  80,ED
1836:  MOVFF  7F,EC
183A:  MOVFF  7E,EB
183E:  CLRF   xF2
1840:  CLRF   xF1
1842:  MOVLW  8E
1844:  MOVWF  xF0
1846:  MOVLW  AC
1848:  MOVWF  xEF
184A:  CALL   0340
184E:  BTFSC  18.7
1850:  BSF    FF2.7
1852:  MOVFF  03,E3
1856:  MOVFF  02,E2
185A:  MOVFF  01,E1
185E:  MOVFF  00,E0
1862:  MOVLW  01
1864:  ADDWF  00,W
1866:  MOVWF  xE4
1868:  MOVLW  00
186A:  ADDWFC 01,W
186C:  MOVWF  xE5
186E:  MOVLW  00
1870:  ADDWFC 02,W
1872:  MOVWF  xE6
1874:  MOVLW  00
1876:  ADDWFC 03,W
1878:  MOVWF  xE7
187A:  MOVWF  xF8
187C:  MOVFF  E6,F7
1880:  MOVFF  E5,F6
1884:  MOVFF  E4,F5
1888:  CLRF   xFC
188A:  CLRF   xFB
188C:  CLRF   xFA
188E:  MOVLW  03
1890:  MOVWF  xF9
1892:  RCALL  1330
1894:  RRCF   03,W
1896:  MOVWF  x85
1898:  RRCF   02,W
189A:  MOVWF  x84
189C:  RRCF   01,W
189E:  MOVWF  x83
18A0:  RRCF   00,W
18A2:  MOVWF  x82
18A4:  RRCF   x85,F
18A6:  RRCF   x84,F
18A8:  RRCF   x83,F
18AA:  RRCF   x82,F
18AC:  MOVLW  3F
18AE:  ANDWF  x85,F
....................       dc=dg-c*36524; 
18B0:  MOVFF  85,F8
18B4:  MOVFF  84,F7
18B8:  MOVFF  83,F6
18BC:  MOVFF  82,F5
18C0:  CLRF   xFC
18C2:  CLRF   xFB
18C4:  MOVLW  8E
18C6:  MOVWF  xFA
18C8:  MOVLW  AC
18CA:  MOVWF  xF9
18CC:  RCALL  1330
18CE:  MOVF   00,W
18D0:  SUBWF  x7E,W
18D2:  MOVWF  x86
18D4:  MOVF   01,W
18D6:  SUBWFB x7F,W
18D8:  MOVWF  x87
18DA:  MOVF   02,W
18DC:  SUBWFB x80,W
18DE:  MOVWF  x88
18E0:  MOVF   03,W
18E2:  SUBWFB x81,W
18E4:  MOVWF  x89
18E6:  CLRF   18
18E8:  BTFSC  FF2.7
18EA:  BSF    18.7
18EC:  BCF    FF2.7
....................       b=dc/1461; 
18EE:  MOVFF  89,EE
18F2:  MOVFF  88,ED
18F6:  MOVFF  87,EC
18FA:  MOVFF  86,EB
18FE:  CLRF   xF2
1900:  CLRF   xF1
1902:  MOVLW  05
1904:  MOVWF  xF0
1906:  MOVLW  B5
1908:  MOVWF  xEF
190A:  CALL   0340
190E:  BTFSC  18.7
1910:  BSF    FF2.7
1912:  MOVFF  03,8D
1916:  MOVFF  02,8C
191A:  MOVFF  01,8B
191E:  MOVFF  00,8A
1922:  CLRF   18
1924:  BTFSC  FF2.7
1926:  BSF    18.7
1928:  BCF    FF2.7
....................       db=dc%1461; 
192A:  MOVFF  89,EE
192E:  MOVFF  88,ED
1932:  MOVFF  87,EC
1936:  MOVFF  86,EB
193A:  CLRF   xF2
193C:  CLRF   xF1
193E:  MOVLW  05
1940:  MOVWF  xF0
1942:  MOVLW  B5
1944:  MOVWF  xEF
1946:  CALL   0340
194A:  BTFSC  18.7
194C:  BSF    FF2.7
194E:  MOVFF  FEF,8E
1952:  MOVFF  FEC,8F
1956:  MOVFF  FEC,90
195A:  MOVFF  FEC,91
195E:  CLRF   18
1960:  BTFSC  FF2.7
1962:  BSF    18.7
1964:  BCF    FF2.7
....................       a=(db/365+1)*3/4; 
1966:  MOVFF  91,EE
196A:  MOVFF  90,ED
196E:  MOVFF  8F,EC
1972:  MOVFF  8E,EB
1976:  CLRF   xF2
1978:  CLRF   xF1
197A:  MOVLW  01
197C:  MOVWF  xF0
197E:  MOVLW  6D
1980:  MOVWF  xEF
1982:  CALL   0340
1986:  BTFSC  18.7
1988:  BSF    FF2.7
198A:  MOVFF  03,E3
198E:  MOVFF  02,E2
1992:  MOVFF  01,E1
1996:  MOVFF  00,E0
199A:  MOVLW  01
199C:  ADDWF  00,W
199E:  MOVWF  xE4
19A0:  MOVLW  00
19A2:  ADDWFC 01,W
19A4:  MOVWF  xE5
19A6:  MOVLW  00
19A8:  ADDWFC 02,W
19AA:  MOVWF  xE6
19AC:  MOVLW  00
19AE:  ADDWFC 03,W
19B0:  MOVWF  xE7
19B2:  MOVWF  xF8
19B4:  MOVFF  E6,F7
19B8:  MOVFF  E5,F6
19BC:  MOVFF  E4,F5
19C0:  CLRF   xFC
19C2:  CLRF   xFB
19C4:  CLRF   xFA
19C6:  MOVLW  03
19C8:  MOVWF  xF9
19CA:  RCALL  1330
19CC:  RRCF   03,W
19CE:  MOVWF  x95
19D0:  RRCF   02,W
19D2:  MOVWF  x94
19D4:  RRCF   01,W
19D6:  MOVWF  x93
19D8:  RRCF   00,W
19DA:  MOVWF  x92
19DC:  RRCF   x95,F
19DE:  RRCF   x94,F
19E0:  RRCF   x93,F
19E2:  RRCF   x92,F
19E4:  MOVLW  3F
19E6:  ANDWF  x95,F
....................       da=db-a*365; 
19E8:  MOVFF  95,F8
19EC:  MOVFF  94,F7
19F0:  MOVFF  93,F6
19F4:  MOVFF  92,F5
19F8:  CLRF   xFC
19FA:  CLRF   xFB
19FC:  MOVLW  01
19FE:  MOVWF  xFA
1A00:  MOVLW  6D
1A02:  MOVWF  xF9
1A04:  RCALL  1330
1A06:  MOVF   00,W
1A08:  SUBWF  x8E,W
1A0A:  MOVWF  x96
1A0C:  MOVF   01,W
1A0E:  SUBWFB x8F,W
1A10:  MOVWF  x97
1A12:  MOVF   02,W
1A14:  SUBWFB x90,W
1A16:  MOVWF  x98
1A18:  MOVF   03,W
1A1A:  SUBWFB x91,W
1A1C:  MOVWF  x99
....................       y=g*400+c*100+b*4+a; 
1A1E:  MOVFF  7D,F8
1A22:  MOVFF  7C,F7
1A26:  MOVFF  7B,F6
1A2A:  MOVFF  7A,F5
1A2E:  CLRF   xFC
1A30:  CLRF   xFB
1A32:  MOVLW  01
1A34:  MOVWF  xFA
1A36:  MOVLW  90
1A38:  MOVWF  xF9
1A3A:  RCALL  1330
1A3C:  MOVFF  03,E3
1A40:  MOVFF  02,E2
1A44:  MOVFF  01,E1
1A48:  MOVFF  00,E0
1A4C:  MOVFF  85,F8
1A50:  MOVFF  84,F7
1A54:  MOVFF  83,F6
1A58:  MOVFF  82,F5
1A5C:  CLRF   xFC
1A5E:  CLRF   xFB
1A60:  CLRF   xFA
1A62:  MOVLW  64
1A64:  MOVWF  xF9
1A66:  RCALL  1330
1A68:  MOVF   00,W
1A6A:  ADDWF  xE0,W
1A6C:  MOVWF  xE4
1A6E:  MOVF   01,W
1A70:  ADDWFC xE1,W
1A72:  MOVWF  xE5
1A74:  MOVF   02,W
1A76:  ADDWFC xE2,W
1A78:  MOVWF  xE6
1A7A:  MOVF   03,W
1A7C:  ADDWFC xE3,W
1A7E:  MOVWF  xE7
1A80:  RLCF   x8A,W
1A82:  MOVWF  00
1A84:  RLCF   x8B,W
1A86:  MOVWF  01
1A88:  RLCF   x8C,W
1A8A:  MOVWF  02
1A8C:  RLCF   x8D,W
1A8E:  MOVWF  03
1A90:  RLCF   00,F
1A92:  RLCF   01,F
1A94:  RLCF   02,F
1A96:  RLCF   03,F
1A98:  MOVLW  FC
1A9A:  ANDWF  00,F
1A9C:  MOVF   00,W
1A9E:  ADDWF  xE4,W
1AA0:  MOVWF  xE8
1AA2:  MOVF   01,W
1AA4:  ADDWFC xE5,W
1AA6:  MOVWF  xE9
1AA8:  MOVF   02,W
1AAA:  ADDWFC xE6,W
1AAC:  MOVWF  xEA
1AAE:  MOVF   03,W
1AB0:  ADDWFC xE7,W
1AB2:  MOVWF  xEB
1AB4:  MOVF   x92,W
1AB6:  ADDWF  xE8,W
1AB8:  MOVWF  x9A
1ABA:  MOVF   x93,W
1ABC:  ADDWFC xE9,W
1ABE:  MOVWF  x9B
1AC0:  MOVF   x94,W
1AC2:  ADDWFC xEA,W
1AC4:  MOVWF  x9C
1AC6:  MOVF   x95,W
1AC8:  ADDWFC xEB,W
1ACA:  MOVWF  x9D
....................       m=(da*5+308)/153-2; 
1ACC:  MOVFF  99,F8
1AD0:  MOVFF  98,F7
1AD4:  MOVFF  97,F6
1AD8:  MOVFF  96,F5
1ADC:  CLRF   xFC
1ADE:  CLRF   xFB
1AE0:  CLRF   xFA
1AE2:  MOVLW  05
1AE4:  MOVWF  xF9
1AE6:  RCALL  1330
1AE8:  MOVFF  03,E3
1AEC:  MOVFF  02,E2
1AF0:  MOVFF  01,E1
1AF4:  MOVFF  00,E0
1AF8:  MOVLW  34
1AFA:  ADDWF  00,W
1AFC:  MOVWF  xE4
1AFE:  MOVLW  01
1B00:  ADDWFC 01,W
1B02:  MOVWF  xE5
1B04:  MOVLW  00
1B06:  ADDWFC 02,W
1B08:  MOVWF  xE6
1B0A:  MOVLW  00
1B0C:  ADDWFC 03,W
1B0E:  MOVWF  xE7
1B10:  CLRF   18
1B12:  BTFSC  FF2.7
1B14:  BSF    18.7
1B16:  BCF    FF2.7
1B18:  MOVWF  xEE
1B1A:  MOVFF  E6,ED
1B1E:  MOVFF  E5,EC
1B22:  MOVFF  E4,EB
1B26:  CLRF   xF2
1B28:  CLRF   xF1
1B2A:  CLRF   xF0
1B2C:  MOVLW  99
1B2E:  MOVWF  xEF
1B30:  CALL   0340
1B34:  BTFSC  18.7
1B36:  BSF    FF2.7
1B38:  MOVLW  02
1B3A:  SUBWF  00,W
1B3C:  MOVWF  x9E
1B3E:  MOVLW  00
1B40:  SUBWFB 01,W
1B42:  MOVWF  x9F
1B44:  MOVLW  00
1B46:  SUBWFB 02,W
1B48:  MOVWF  xA0
1B4A:  MOVLW  00
1B4C:  SUBWFB 03,W
1B4E:  MOVWF  xA1
....................       d=da-(m+4)*153/5+122; 
1B50:  MOVLW  04
1B52:  ADDWF  x9E,W
1B54:  MOVWF  xE0
1B56:  MOVLW  00
1B58:  ADDWFC x9F,W
1B5A:  MOVWF  xE1
1B5C:  MOVLW  00
1B5E:  ADDWFC xA0,W
1B60:  MOVWF  xE2
1B62:  MOVLW  00
1B64:  ADDWFC xA1,W
1B66:  MOVWF  xE3
1B68:  MOVWF  xF8
1B6A:  MOVFF  E2,F7
1B6E:  MOVFF  E1,F6
1B72:  MOVFF  E0,F5
1B76:  CLRF   xFC
1B78:  CLRF   xFB
1B7A:  CLRF   xFA
1B7C:  MOVLW  99
1B7E:  MOVWF  xF9
1B80:  CALL   1330
1B84:  MOVFF  03,E4
1B88:  MOVFF  02,E3
1B8C:  MOVFF  01,E2
1B90:  MOVFF  00,E1
1B94:  CLRF   18
1B96:  BTFSC  FF2.7
1B98:  BSF    18.7
1B9A:  BCF    FF2.7
1B9C:  MOVFF  03,EE
1BA0:  MOVFF  02,ED
1BA4:  MOVFF  01,EC
1BA8:  MOVFF  00,EB
1BAC:  CLRF   xF2
1BAE:  CLRF   xF1
1BB0:  CLRF   xF0
1BB2:  MOVLW  05
1BB4:  MOVWF  xEF
1BB6:  CALL   0340
1BBA:  BTFSC  18.7
1BBC:  BSF    FF2.7
1BBE:  MOVF   00,W
1BC0:  SUBWF  x96,W
1BC2:  MOVWF  xE2
1BC4:  MOVF   01,W
1BC6:  SUBWFB x97,W
1BC8:  MOVWF  xE3
1BCA:  MOVF   02,W
1BCC:  SUBWFB x98,W
1BCE:  MOVWF  xE4
1BD0:  MOVF   03,W
1BD2:  SUBWFB x99,W
1BD4:  MOVWF  xE5
1BD6:  MOVLW  7A
1BD8:  ADDWF  xE2,W
1BDA:  MOVWF  xA2
1BDC:  MOVLW  00
1BDE:  ADDWFC xE3,W
1BE0:  MOVWF  xA3
1BE2:  MOVLW  00
1BE4:  ADDWFC xE4,W
1BE6:  MOVWF  xA4
1BE8:  MOVLW  00
1BEA:  ADDWFC xE5,W
1BEC:  MOVWF  xA5
....................       YY=y-4800+(m+2)/12; 
1BEE:  MOVLW  C0
1BF0:  SUBWF  x9A,W
1BF2:  MOVWF  xE0
1BF4:  MOVLW  12
1BF6:  SUBWFB x9B,W
1BF8:  MOVWF  xE1
1BFA:  MOVLW  00
1BFC:  SUBWFB x9C,W
1BFE:  MOVWF  xE2
1C00:  MOVLW  00
1C02:  SUBWFB x9D,W
1C04:  MOVWF  xE3
1C06:  MOVLW  02
1C08:  ADDWF  x9E,W
1C0A:  MOVWF  xE4
1C0C:  MOVLW  00
1C0E:  ADDWFC x9F,W
1C10:  MOVWF  xE5
1C12:  MOVLW  00
1C14:  ADDWFC xA0,W
1C16:  MOVWF  xE6
1C18:  MOVLW  00
1C1A:  ADDWFC xA1,W
1C1C:  MOVWF  xE7
1C1E:  CLRF   18
1C20:  BTFSC  FF2.7
1C22:  BSF    18.7
1C24:  BCF    FF2.7
1C26:  MOVWF  xEE
1C28:  MOVFF  E6,ED
1C2C:  MOVFF  E5,EC
1C30:  MOVFF  E4,EB
1C34:  CLRF   xF2
1C36:  CLRF   xF1
1C38:  CLRF   xF0
1C3A:  MOVLW  0C
1C3C:  MOVWF  xEF
1C3E:  CALL   0340
1C42:  BTFSC  18.7
1C44:  BSF    FF2.7
1C46:  MOVF   00,W
1C48:  ADDWF  xE0,W
1C4A:  MOVWF  xA6
1C4C:  MOVF   01,W
1C4E:  ADDWFC xE1,W
1C50:  MOVWF  xA7
1C52:  MOVF   02,W
1C54:  ADDWFC xE2,W
1C56:  MOVWF  xA8
1C58:  MOVF   03,W
1C5A:  ADDWFC xE3,W
1C5C:  MOVWF  xA9
....................       MM=(m+2)%12+1; 
1C5E:  MOVLW  02
1C60:  ADDWF  x9E,W
1C62:  MOVWF  xE0
1C64:  MOVLW  00
1C66:  ADDWFC x9F,W
1C68:  MOVWF  xE1
1C6A:  MOVLW  00
1C6C:  ADDWFC xA0,W
1C6E:  MOVWF  xE2
1C70:  MOVLW  00
1C72:  ADDWFC xA1,W
1C74:  MOVWF  xE3
1C76:  CLRF   18
1C78:  BTFSC  FF2.7
1C7A:  BSF    18.7
1C7C:  BCF    FF2.7
1C7E:  MOVWF  xEE
1C80:  MOVFF  E2,ED
1C84:  MOVFF  E1,EC
1C88:  MOVFF  E0,EB
1C8C:  CLRF   xF2
1C8E:  CLRF   xF1
1C90:  CLRF   xF0
1C92:  MOVLW  0C
1C94:  MOVWF  xEF
1C96:  CALL   0340
1C9A:  BTFSC  18.7
1C9C:  BSF    FF2.7
1C9E:  MOVFF  FEF,E1
1CA2:  MOVFF  FEC,E2
1CA6:  MOVFF  FEC,E3
1CAA:  MOVFF  FEC,E4
1CAE:  MOVLW  01
1CB0:  ADDWF  xE1,W
1CB2:  MOVWF  xAA
1CB4:  MOVLW  00
1CB6:  ADDWFC xE2,W
1CB8:  MOVWF  xAB
1CBA:  MOVLW  00
1CBC:  ADDWFC xE3,W
1CBE:  MOVWF  xAC
1CC0:  MOVLW  00
1CC2:  ADDWFC xE4,W
1CC4:  MOVWF  xAD
....................       DD=d+1; 
1CC6:  MOVLW  01
1CC8:  ADDWF  xA2,W
1CCA:  MOVWF  xAE
1CCC:  MOVLW  00
1CCE:  ADDWFC xA3,W
1CD0:  MOVWF  xAF
1CD2:  MOVLW  00
1CD4:  ADDWFC xA4,W
1CD6:  MOVWF  xB0
1CD8:  MOVLW  00
1CDA:  ADDWFC xA5,W
1CDC:  MOVWF  xB1
....................       time_of_day = (timer_sec+((int8)UTC)*3600)%86400; 
1CDE:  MOVLW  70
1CE0:  ADDWF  20,W
1CE2:  MOVWF  xE0
1CE4:  MOVLW  62
1CE6:  ADDWFC 21,W
1CE8:  MOVWF  xE1
1CEA:  MOVLW  00
1CEC:  ADDWFC 22,W
1CEE:  MOVWF  xE2
1CF0:  MOVLW  00
1CF2:  ADDWFC 23,W
1CF4:  MOVWF  xE3
1CF6:  CLRF   18
1CF8:  BTFSC  FF2.7
1CFA:  BSF    18.7
1CFC:  BCF    FF2.7
1CFE:  MOVWF  xEE
1D00:  MOVFF  E2,ED
1D04:  MOVFF  E1,EC
1D08:  MOVFF  E0,EB
1D0C:  CLRF   xF2
1D0E:  MOVLW  01
1D10:  MOVWF  xF1
1D12:  MOVLW  51
1D14:  MOVWF  xF0
1D16:  MOVLW  80
1D18:  MOVWF  xEF
1D1A:  CALL   0340
1D1E:  BTFSC  18.7
1D20:  BSF    FF2.7
1D22:  MOVFF  FEF,B2
1D26:  MOVFF  FEC,B3
1D2A:  MOVFF  FEC,B4
1D2E:  MOVFF  FEC,B5
....................  
....................       strcpy(tmp_str,"00/00/00"); 
1D32:  CLRF   FEA
1D34:  MOVLW  2C
1D36:  MOVWF  FE9
1D38:  MOVFF  FF2,E0
1D3C:  BCF    FF2.7
1D3E:  MOVLW  00
1D40:  CALL   00C8
1D44:  TBLRD*-
1D46:  TBLRD*+
1D48:  MOVF   FF5,W
1D4A:  MOVWF  FEE
1D4C:  IORLW  00
1D4E:  BNZ   1D46
1D50:  BTFSC  xE0.7
1D52:  BSF    FF2.7
....................       itoa((int8)DD,10,tmp_str2); 
1D54:  CLRF   xE9
1D56:  CLRF   xE8
1D58:  CLRF   xE7
1D5A:  MOVFF  AE,E6
1D5E:  MOVLW  0A
1D60:  MOVWF  xEA
1D62:  CLRF   xEC
1D64:  MOVLW  40
1D66:  MOVWF  xEB
1D68:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[1]=tmp_str2[0]; else memcpy(tmp_str,tmp_str2,2); 
1D6C:  CLRF   xE3
1D6E:  MOVLW  40
1D70:  MOVWF  xE2
1D72:  RCALL  1682
1D74:  DECFSZ 01,W
1D76:  BRA    1D7E
1D78:  MOVFF  40,2D
1D7C:  BRA    1D96
1D7E:  CLRF   FEA
1D80:  MOVLW  2C
1D82:  MOVWF  FE9
1D84:  CLRF   FE2
1D86:  MOVLW  40
1D88:  MOVWF  FE1
1D8A:  MOVLW  02
1D8C:  MOVWF  01
1D8E:  MOVFF  FE6,FEE
1D92:  DECFSZ 01,F
1D94:  BRA    1D8E
....................       itoa((int8)MM,10,tmp_str2); 
1D96:  CLRF   xE9
1D98:  CLRF   xE8
1D9A:  CLRF   xE7
1D9C:  MOVFF  AA,E6
1DA0:  MOVLW  0A
1DA2:  MOVWF  xEA
1DA4:  CLRF   xEC
1DA6:  MOVLW  40
1DA8:  MOVWF  xEB
1DAA:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[4]=tmp_str2[0]; else memcpy(tmp_str+3,tmp_str2,2); 
1DAE:  CLRF   xE3
1DB0:  MOVLW  40
1DB2:  MOVWF  xE2
1DB4:  RCALL  1682
1DB6:  DECFSZ 01,W
1DB8:  BRA    1DC0
1DBA:  MOVFF  40,30
1DBE:  BRA    1DD8
1DC0:  CLRF   FEA
1DC2:  MOVLW  2F
1DC4:  MOVWF  FE9
1DC6:  CLRF   FE2
1DC8:  MOVLW  40
1DCA:  MOVWF  FE1
1DCC:  MOVLW  02
1DCE:  MOVWF  01
1DD0:  MOVFF  FE6,FEE
1DD4:  DECFSZ 01,F
1DD6:  BRA    1DD0
1DD8:  CLRF   18
1DDA:  BTFSC  FF2.7
1DDC:  BSF    18.7
1DDE:  BCF    FF2.7
....................       itoa((int8)(YY%2000),10,tmp_str2); 
1DE0:  MOVFF  A9,EE
1DE4:  MOVFF  A8,ED
1DE8:  MOVFF  A7,EC
1DEC:  MOVFF  A6,EB
1DF0:  CLRF   xF2
1DF2:  CLRF   xF1
1DF4:  MOVLW  07
1DF6:  MOVWF  xF0
1DF8:  MOVLW  D0
1DFA:  MOVWF  xEF
1DFC:  CALL   0340
1E00:  BTFSC  18.7
1E02:  BSF    FF2.7
1E04:  MOVFF  FEF,00
1E08:  MOVFF  FEC,01
1E0C:  MOVFF  FEC,02
1E10:  MOVFF  FEC,03
1E14:  MOVFF  00,E0
1E18:  CLRF   xE9
1E1A:  CLRF   xE8
1E1C:  CLRF   xE7
1E1E:  MOVFF  00,E6
1E22:  MOVLW  0A
1E24:  MOVWF  xEA
1E26:  CLRF   xEC
1E28:  MOVLW  40
1E2A:  MOVWF  xEB
1E2C:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[7]=tmp_str2[0]; else memcpy(tmp_str+6,tmp_str2,2); 
1E30:  CLRF   xE3
1E32:  MOVLW  40
1E34:  MOVWF  xE2
1E36:  RCALL  1682
1E38:  DECFSZ 01,W
1E3A:  BRA    1E42
1E3C:  MOVFF  40,33
1E40:  BRA    1E5A
1E42:  CLRF   FEA
1E44:  MOVLW  32
1E46:  MOVWF  FE9
1E48:  CLRF   FE2
1E4A:  MOVLW  40
1E4C:  MOVWF  FE1
1E4E:  MOVLW  02
1E50:  MOVWF  01
1E52:  MOVFF  FE6,FEE
1E56:  DECFSZ 01,F
1E58:  BRA    1E52
....................       lcd_gotoxy(0,0); 
1E5A:  CLRF   xEA
1E5C:  CLRF   xEB
1E5E:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
1E62:  CLRF   xE3
1E64:  MOVLW  2C
1E66:  MOVWF  xE2
1E68:  RCALL  1682
1E6A:  MOVFF  01,E0
1E6E:  CLRF   xE2
1E70:  MOVLW  2C
1E72:  MOVWF  xE1
1E74:  MOVFF  01,E3
1E78:  RCALL  16B4
....................       strcpy(tmp_str,"00:00:00"); 
1E7A:  CLRF   FEA
1E7C:  MOVLW  2C
1E7E:  MOVWF  FE9
1E80:  MOVFF  FF2,E0
1E84:  BCF    FF2.7
1E86:  MOVLW  00
1E88:  CALL   00EC
1E8C:  TBLRD*-
1E8E:  TBLRD*+
1E90:  MOVF   FF5,W
1E92:  MOVWF  FEE
1E94:  IORLW  00
1E96:  BNZ   1E8E
1E98:  BTFSC  xE0.7
1E9A:  BSF    FF2.7
1E9C:  CLRF   18
1E9E:  BTFSC  FF2.7
1EA0:  BSF    18.7
1EA2:  BCF    FF2.7
....................       itoa((int8) (time_of_day/3600),10,tmp_str2); 
1EA4:  MOVFF  B5,EE
1EA8:  MOVFF  B4,ED
1EAC:  MOVFF  B3,EC
1EB0:  MOVFF  B2,EB
1EB4:  CLRF   xF2
1EB6:  CLRF   xF1
1EB8:  MOVLW  0E
1EBA:  MOVWF  xF0
1EBC:  MOVLW  10
1EBE:  MOVWF  xEF
1EC0:  CALL   0340
1EC4:  BTFSC  18.7
1EC6:  BSF    FF2.7
1EC8:  MOVFF  00,E0
1ECC:  CLRF   xE9
1ECE:  CLRF   xE8
1ED0:  CLRF   xE7
1ED2:  MOVFF  00,E6
1ED6:  MOVLW  0A
1ED8:  MOVWF  xEA
1EDA:  CLRF   xEC
1EDC:  MOVLW  40
1EDE:  MOVWF  xEB
1EE0:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1EE4:  CLRF   xE3
1EE6:  MOVLW  40
1EE8:  MOVWF  xE2
1EEA:  CALL   1682
1EEE:  MOVF   01,W
1EF0:  SUBLW  02
1EF2:  BNC   1F38
1EF4:  CLRF   xE3
1EF6:  MOVLW  40
1EF8:  MOVWF  xE2
1EFA:  CALL   1682
1EFE:  MOVLW  2E
1F00:  BSF    FD8.0
1F02:  SUBFWB 01,W
1F04:  MOVWF  xE0
1F06:  MOVLW  00
1F08:  BTFSS  FD8.0
1F0A:  DECF   FE8,F
1F0C:  MOVWF  xE1
1F0E:  CLRF   xE3
1F10:  MOVLW  40
1F12:  MOVWF  xE2
1F14:  CALL   1682
1F18:  MOVFF  01,E2
1F1C:  MOVFF  E1,FEA
1F20:  MOVFF  E0,FE9
1F24:  CLRF   FE2
1F26:  MOVLW  40
1F28:  MOVWF  FE1
1F2A:  MOVF   01,W
1F2C:  MOVWF  01
1F2E:  BZ    1F38
1F30:  MOVFF  FE6,FEE
1F34:  DECFSZ 01,F
1F36:  BRA    1F30
1F38:  CLRF   18
1F3A:  BTFSC  FF2.7
1F3C:  BSF    18.7
1F3E:  BCF    FF2.7
....................       itoa((int8) ((time_of_day%3600)/60),10,tmp_str2); 
1F40:  MOVFF  B5,EE
1F44:  MOVFF  B4,ED
1F48:  MOVFF  B3,EC
1F4C:  MOVFF  B2,EB
1F50:  CLRF   xF2
1F52:  CLRF   xF1
1F54:  MOVLW  0E
1F56:  MOVWF  xF0
1F58:  MOVLW  10
1F5A:  MOVWF  xEF
1F5C:  CALL   0340
1F60:  BTFSC  18.7
1F62:  BSF    FF2.7
1F64:  MOVFF  FEF,E0
1F68:  MOVFF  FEC,E1
1F6C:  MOVFF  FEC,E2
1F70:  MOVFF  FEC,E3
1F74:  MOVFF  FEA,E5
1F78:  MOVFF  FE9,E4
1F7C:  CLRF   18
1F7E:  BTFSC  FF2.7
1F80:  BSF    18.7
1F82:  BCF    FF2.7
1F84:  MOVFF  E3,EE
1F88:  MOVFF  E2,ED
1F8C:  MOVFF  E1,EC
1F90:  MOVFF  E0,EB
1F94:  CLRF   xF2
1F96:  CLRF   xF1
1F98:  CLRF   xF0
1F9A:  MOVLW  3C
1F9C:  MOVWF  xEF
1F9E:  CALL   0340
1FA2:  BTFSC  18.7
1FA4:  BSF    FF2.7
1FA6:  MOVFF  E5,FEA
1FAA:  MOVFF  E4,FE9
1FAE:  MOVFF  00,E1
1FB2:  CLRF   xE9
1FB4:  CLRF   xE8
1FB6:  CLRF   xE7
1FB8:  MOVFF  00,E6
1FBC:  MOVLW  0A
1FBE:  MOVWF  xEA
1FC0:  CLRF   xEC
1FC2:  MOVLW  40
1FC4:  MOVWF  xEB
1FC6:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1FCA:  CLRF   xE3
1FCC:  MOVLW  40
1FCE:  MOVWF  xE2
1FD0:  CALL   1682
1FD4:  MOVF   01,W
1FD6:  SUBLW  02
1FD8:  BNC   201E
1FDA:  CLRF   xE3
1FDC:  MOVLW  40
1FDE:  MOVWF  xE2
1FE0:  CALL   1682
1FE4:  MOVLW  31
1FE6:  BSF    FD8.0
1FE8:  SUBFWB 01,W
1FEA:  MOVWF  xE0
1FEC:  MOVLW  00
1FEE:  BTFSS  FD8.0
1FF0:  DECF   FE8,F
1FF2:  MOVWF  xE1
1FF4:  CLRF   xE3
1FF6:  MOVLW  40
1FF8:  MOVWF  xE2
1FFA:  CALL   1682
1FFE:  MOVFF  01,E2
2002:  MOVFF  E1,FEA
2006:  MOVFF  E0,FE9
200A:  CLRF   FE2
200C:  MOVLW  40
200E:  MOVWF  FE1
2010:  MOVF   01,W
2012:  MOVWF  01
2014:  BZ    201E
2016:  MOVFF  FE6,FEE
201A:  DECFSZ 01,F
201C:  BRA    2016
201E:  CLRF   18
2020:  BTFSC  FF2.7
2022:  BSF    18.7
2024:  BCF    FF2.7
....................       itoa((int8) (time_of_day%60),10,tmp_str2); 
2026:  MOVFF  B5,EE
202A:  MOVFF  B4,ED
202E:  MOVFF  B3,EC
2032:  MOVFF  B2,EB
2036:  CLRF   xF2
2038:  CLRF   xF1
203A:  CLRF   xF0
203C:  MOVLW  3C
203E:  MOVWF  xEF
2040:  CALL   0340
2044:  BTFSC  18.7
2046:  BSF    FF2.7
2048:  MOVFF  FEF,00
204C:  MOVFF  FEC,01
2050:  MOVFF  FEC,02
2054:  MOVFF  FEC,03
2058:  MOVFF  00,E0
205C:  CLRF   xE9
205E:  CLRF   xE8
2060:  CLRF   xE7
2062:  MOVFF  00,E6
2066:  MOVLW  0A
2068:  MOVWF  xEA
206A:  CLRF   xEC
206C:  MOVLW  40
206E:  MOVWF  xEB
2070:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2074:  CLRF   xE3
2076:  MOVLW  40
2078:  MOVWF  xE2
207A:  CALL   1682
207E:  MOVF   01,W
2080:  SUBLW  02
2082:  BNC   20C8
2084:  CLRF   xE3
2086:  MOVLW  40
2088:  MOVWF  xE2
208A:  CALL   1682
208E:  MOVLW  34
2090:  BSF    FD8.0
2092:  SUBFWB 01,W
2094:  MOVWF  xE0
2096:  MOVLW  00
2098:  BTFSS  FD8.0
209A:  DECF   FE8,F
209C:  MOVWF  xE1
209E:  CLRF   xE3
20A0:  MOVLW  40
20A2:  MOVWF  xE2
20A4:  CALL   1682
20A8:  MOVFF  01,E2
20AC:  MOVFF  E1,FEA
20B0:  MOVFF  E0,FE9
20B4:  CLRF   FE2
20B6:  MOVLW  40
20B8:  MOVWF  FE1
20BA:  MOVF   01,W
20BC:  MOVWF  01
20BE:  BZ    20C8
20C0:  MOVFF  FE6,FEE
20C4:  DECFSZ 01,F
20C6:  BRA    20C0
....................       lcd_gotoxy(0,1); 
20C8:  CLRF   xEA
20CA:  MOVLW  01
20CC:  MOVWF  xEB
20CE:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
20D2:  CLRF   xE3
20D4:  MOVLW  2C
20D6:  MOVWF  xE2
20D8:  CALL   1682
20DC:  MOVFF  01,E0
20E0:  CLRF   xE2
20E2:  MOVLW  2C
20E4:  MOVWF  xE1
20E6:  MOVFF  01,E3
20EA:  CALL   16B4
....................  
....................       strcpy(tmp_str,"   "); 
20EE:  CLRF   FEA
20F0:  MOVLW  2C
20F2:  MOVWF  FE9
20F4:  MOVFF  FF2,E0
20F8:  BCF    FF2.7
20FA:  MOVLW  00
20FC:  CALL   0110
2100:  TBLRD*-
2102:  TBLRD*+
2104:  MOVF   FF5,W
2106:  MOVWF  FEE
2108:  IORLW  00
210A:  BNZ   2102
210C:  BTFSC  xE0.7
210E:  BSF    FF2.7
....................       itoa((int8)startup_counter,10,tmp_str2); 
2110:  CLRF   xE9
2112:  CLRF   xE8
2114:  CLRF   xE7
2116:  MOVFF  C6,E6
211A:  MOVLW  0A
211C:  MOVWF  xEA
211E:  CLRF   xEC
2120:  MOVLW  40
2122:  MOVWF  xEB
2124:  CALL   14A6
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2128:  CLRF   xE3
212A:  MOVLW  40
212C:  MOVWF  xE2
212E:  CALL   1682
2132:  MOVF   01,W
2134:  SUBLW  03
2136:  BNC   217C
2138:  CLRF   xE3
213A:  MOVLW  40
213C:  MOVWF  xE2
213E:  CALL   1682
2142:  MOVLW  2F
2144:  BSF    FD8.0
2146:  SUBFWB 01,W
2148:  MOVWF  xE0
214A:  MOVLW  00
214C:  BTFSS  FD8.0
214E:  DECF   FE8,F
2150:  MOVWF  xE1
2152:  CLRF   xE3
2154:  MOVLW  40
2156:  MOVWF  xE2
2158:  CALL   1682
215C:  MOVFF  01,E2
2160:  MOVFF  E1,FEA
2164:  MOVFF  E0,FE9
2168:  CLRF   FE2
216A:  MOVLW  40
216C:  MOVWF  FE1
216E:  MOVF   01,W
2170:  MOVWF  01
2172:  BZ    217C
2174:  MOVFF  FE6,FEE
2178:  DECFSZ 01,F
217A:  BRA    2174
....................        lcd_gotoxy(0,2); 
217C:  CLRF   xEA
217E:  MOVLW  02
2180:  MOVWF  xEB
2182:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
2186:  CLRF   xE3
2188:  MOVLW  2C
218A:  MOVWF  xE2
218C:  CALL   1682
2190:  MOVFF  01,E0
2194:  CLRF   xE2
2196:  MOVLW  2C
2198:  MOVWF  xE1
219A:  MOVFF  01,E3
219E:  CALL   16B4
....................  
....................  
.................... } 
21A2:  RETLW  00
....................  
.................... void download_sun_table(int16 nPage) { 
....................     int16 i,j; 
....................    disable_interrupts(GLOBAL); 
*
264C:  BCF    FF2.6
264E:  BCF    FF2.7
2650:  BTFSC  FF2.7
2652:  BRA    264E
....................    restart_wdt(); 
2654:  CLRWDT
....................    setup_wdt(WDT_OFF); 
2656:  BCF    FD1.0
....................     output_high(FLASH_SELECT); 
2658:  BCF    F94.2
265A:  BSF    F8B.2
....................     while(kbhit()) getc(); 
265C:  BTFSS  F9E.5
265E:  BRA    2668
2660:  BTFSS  F9E.5
2662:  BRA    2660
2664:  MOVF   FAE,W
2666:  BRA    265C
....................     for (j=0;j<nPage+1;j++) { 
2668:  CLRF   xD8
266A:  CLRF   xD7
266C:  MOVLW  01
266E:  ADDWF  xD3,W
2670:  MOVWF  01
2672:  MOVLW  00
2674:  ADDWFC xD4,W
2676:  MOVWF  03
2678:  MOVF   xD8,W
267A:  SUBWF  03,W
267C:  BNC   2722
267E:  BNZ   2686
2680:  MOVF   01,W
2682:  SUBWF  xD7,W
2684:  BC    2722
....................         ext_flash_waitUntilReady(); 
2686:  RCALL  24A8
....................       PORTE.tx_en=1; 
2688:  BSF    F84.2
....................         printf("OK\r\n"); 
268A:  CLRF   xD9
268C:  MOVF   xD9,W
268E:  CALL   012E
2692:  INCF   xD9,F
2694:  MOVWF  00
2696:  MOVF   00,W
2698:  BTFSS  F9E.4
269A:  BRA    2698
269C:  MOVWF  FAD
269E:  MOVLW  04
26A0:  SUBWF  xD9,W
26A2:  BNZ   268C
....................       tx_delay=TX_DLY_TIME; 
26A4:  MOVLW  01
26A6:  MOVWF  xC2
....................       //PORTE.tx_en=0; 
....................          output_low(FLASH_SELECT); 
26A8:  BCF    F94.2
26AA:  BCF    F8B.2
....................         if (j%2) ext_flash_sendData(0x82, 8); else ext_flash_sendData(0x85, 8); 
26AC:  MOVF   xD7,W
26AE:  ANDLW  01
26B0:  MOVWF  00
26B2:  CLRF   03
26B4:  MOVF   00,W
26B6:  IORWF  03,W
26B8:  BZ    26C6
26BA:  MOVLW  82
26BC:  MOVWF  xFA
26BE:  MOVLW  08
26C0:  MOVWF  xFB
26C2:  RCALL  25DE
26C4:  BRA    26D0
26C6:  MOVLW  85
26C8:  MOVWF  xFA
26CA:  MOVLW  08
26CC:  MOVWF  xFB
26CE:  RCALL  25DE
....................          ext_flash_send16Data(j+10, 15); // page address 
26D0:  MOVLW  0A
26D2:  ADDWF  xD7,W
26D4:  MOVWF  xD9
26D6:  MOVLW  00
26D8:  ADDWFC xD8,W
26DA:  MOVWF  xDA
26DC:  MOVWF  xFB
26DE:  MOVFF  D9,FA
26E2:  MOVLW  0F
26E4:  MOVWF  xFC
26E6:  RCALL  260E
....................       ext_flash_send16Data(0, 9); 
26E8:  CLRF   xFB
26EA:  CLRF   xFA
26EC:  MOVLW  09
26EE:  MOVWF  xFC
26F0:  RCALL  260E
....................       for (i=0;i<256;i++) { 
26F2:  CLRF   xD6
26F4:  CLRF   xD5
26F6:  MOVF   xD6,W
26F8:  SUBLW  00
26FA:  BNC   2716
....................             ext_flash_sendData(getc(), 8); 
26FC:  BTFSS  F9E.5
26FE:  BRA    26FC
2700:  MOVFF  FAE,D9
2704:  MOVFF  D9,FA
2708:  MOVLW  08
270A:  MOVWF  xFB
270C:  RCALL  25DE
....................       } 
270E:  INCF   xD5,F
2710:  BTFSC  FD8.2
2712:  INCF   xD6,F
2714:  BRA    26F6
....................        output_high(FLASH_SELECT); 
2716:  BCF    F94.2
2718:  BSF    F8B.2
....................    } 
271A:  INCF   xD7,F
271C:  BTFSC  FD8.2
271E:  INCF   xD8,F
2720:  BRA    266C
....................    enable_interrupts(GLOBAL); 
2722:  MOVLW  C0
2724:  IORWF  FF2,F
....................    restart_wdt(); 
2726:  CLRWDT
....................    setup_wdt(WDT_ON); 
2728:  BSF    FD1.0
....................  
.................... } 
272A:  GOTO   3626 (RETURN)
....................  
.................... /* 
.................... void print_page_data(int16 nPage) { 
....................     char temp[256]; 
....................     int16 i; 
....................     int32 time_index; 
....................  
....................    ext_flash_readPage(nPage,0,temp,264); 
....................     for(i=0;i<264;i++) { 
....................       PORTE.tx_en=1; 
....................       if((i%16) ==0) printf("\r\n%02X : ",i); 
....................       printf("%02X ",temp[i]); 
....................    } 
....................    memcpy(&time_index,temp,4); 
....................     printf("\r\n Timer Index: %Lu",time_index);    
....................     
....................  
....................  
.................... } 
.................... */ 
.................... void print_page_data(int16 nPage) { 
....................     char temp[17]; 
....................     int8 i; 
....................    int8 j; 
....................     PORTE.tx_en=1; 
*
2830:  BSF    F84.2
....................     for(i=0;i<16;i++) { 
2832:  CLRF   xE6
2834:  MOVF   xE6,W
2836:  SUBLW  0F
2838:  BNC   28C2
....................       printf("\r\n%02X : ",i); 
283A:  MOVLW  0D
283C:  BTFSS  F9E.4
283E:  BRA    283C
2840:  MOVWF  FAD
2842:  MOVLW  0A
2844:  BTFSS  F9E.4
2846:  BRA    2844
2848:  MOVWF  FAD
284A:  MOVFF  E6,E9
284E:  MOVLW  37
2850:  MOVWF  xEA
2852:  RCALL  272E
2854:  MOVLW  20
2856:  BTFSS  F9E.4
2858:  BRA    2856
285A:  MOVWF  FAD
285C:  MOVLW  3A
285E:  BTFSS  F9E.4
2860:  BRA    285E
2862:  MOVWF  FAD
2864:  MOVLW  20
2866:  BTFSS  F9E.4
2868:  BRA    2866
286A:  MOVWF  FAD
....................       ext_flash_readPage(nPage,i*16,temp,16); 
286C:  MOVF   xE6,W
286E:  MULLW  10
2870:  MOVFF  FF3,E8
2874:  MOVFF  D4,F4
2878:  MOVFF  D3,F3
287C:  MOVFF  E8,F5
2880:  CLRF   xF7
2882:  MOVLW  D5
2884:  MOVWF  xF6
2886:  CLRF   xF9
2888:  MOVLW  10
288A:  MOVWF  xF8
288C:  RCALL  27D8
....................       for (j=0;j<16;j++) printf("%02X ",temp[j]); 
288E:  CLRF   xE7
2890:  MOVF   xE7,W
2892:  SUBLW  0F
2894:  BNC   28BE
2896:  CLRF   03
2898:  MOVF   xE7,W
289A:  ADDLW  D5
289C:  MOVWF  FE9
289E:  MOVLW  00
28A0:  ADDWFC 03,W
28A2:  MOVWF  FEA
28A4:  MOVFF  FEF,E8
28A8:  MOVFF  E8,E9
28AC:  MOVLW  37
28AE:  MOVWF  xEA
28B0:  RCALL  272E
28B2:  MOVLW  20
28B4:  BTFSS  F9E.4
28B6:  BRA    28B4
28B8:  MOVWF  FAD
28BA:  INCF   xE7,F
28BC:  BRA    2890
....................    } 
28BE:  INCF   xE6,F
28C0:  BRA    2834
....................    tx_delay=TX_DLY_TIME; 
28C2:  MOVLW  01
28C4:  MOVWF  xC2
.................... } 
28C6:  GOTO   31AE (RETURN)
....................  
.................... int32 get_timer_index(int16 nDay) { // 1 page contain 2 subpage 
....................     char temp[6]; 
....................     int32 time_index; 
....................    ext_flash_readPage((nDay/2)+10,128*(nDay%2),temp,4); 
*
2C42:  BCF    FD8.0
2C44:  RRCF   xE2,W
2C46:  MOVWF  xEE
2C48:  RRCF   xE1,W
2C4A:  MOVWF  xED
2C4C:  MOVLW  0A
2C4E:  ADDWF  xED,W
2C50:  MOVWF  xEF
2C52:  MOVLW  00
2C54:  ADDWFC xEE,W
2C56:  MOVWF  xF0
2C58:  MOVF   xE1,W
2C5A:  ANDLW  01
2C5C:  MOVWF  00
2C5E:  CLRF   03
2C60:  MOVWF  02
2C62:  RLCF   00,W
2C64:  MOVWF  xF1
2C66:  RLCF   03,W
2C68:  MOVWF  xF2
2C6A:  RLCF   xF1,F
2C6C:  RLCF   xF2,F
2C6E:  RLCF   xF1,F
2C70:  RLCF   xF2,F
2C72:  RLCF   xF1,F
2C74:  RLCF   xF2,F
2C76:  RLCF   xF1,F
2C78:  RLCF   xF2,F
2C7A:  RLCF   xF1,F
2C7C:  RLCF   xF2,F
2C7E:  RLCF   xF1,F
2C80:  RLCF   xF2,F
2C82:  MOVLW  80
2C84:  ANDWF  xF1,F
2C86:  MOVFF  F0,F4
2C8A:  MOVFF  EF,F3
2C8E:  MOVFF  F1,F5
2C92:  CLRF   xF7
2C94:  MOVLW  E3
2C96:  MOVWF  xF6
2C98:  CLRF   xF9
2C9A:  MOVLW  04
2C9C:  MOVWF  xF8
2C9E:  RCALL  27D8
....................    memcpy(&time_index,temp,4); 
2CA0:  CLRF   FEA
2CA2:  MOVLW  E9
2CA4:  MOVWF  FE9
2CA6:  CLRF   FE2
2CA8:  MOVLW  E3
2CAA:  MOVWF  FE1
2CAC:  MOVLW  04
2CAE:  MOVWF  01
2CB0:  MOVFF  FE6,FEE
2CB4:  DECFSZ 01,F
2CB6:  BRA    2CB0
....................    return time_index; 
2CB8:  MOVFF  E9,00
2CBC:  MOVFF  EA,01
2CC0:  MOVFF  EB,02
2CC4:  MOVFF  EC,03
.................... } 
2CC8:  RETLW  00
....................  
.................... int16 find_day_number(int32 tsec) // return day number after 1-jan-2010, we use this to search for sun angle in flash memory page 
.................... { 
....................    return (((tsec+((int8)UTC)*3600)/86400)%1461); 
*
2BA8:  MOVLW  70
2BAA:  ADDWF  xE1,W
2BAC:  MOVWF  xE5
2BAE:  MOVLW  62
2BB0:  ADDWFC xE2,W
2BB2:  MOVWF  xE6
2BB4:  MOVLW  00
2BB6:  ADDWFC xE3,W
2BB8:  MOVWF  xE7
2BBA:  MOVLW  00
2BBC:  ADDWFC xE4,W
2BBE:  MOVWF  xE8
2BC0:  CLRF   18
2BC2:  BTFSC  FF2.7
2BC4:  BSF    18.7
2BC6:  BCF    FF2.7
2BC8:  MOVWF  xEE
2BCA:  MOVFF  E7,ED
2BCE:  MOVFF  E6,EC
2BD2:  MOVFF  E5,EB
2BD6:  CLRF   xF2
2BD8:  MOVLW  01
2BDA:  MOVWF  xF1
2BDC:  MOVLW  51
2BDE:  MOVWF  xF0
2BE0:  MOVLW  80
2BE2:  MOVWF  xEF
2BE4:  CALL   0340
2BE8:  BTFSC  18.7
2BEA:  BSF    FF2.7
2BEC:  MOVFF  03,E9
2BF0:  MOVFF  02,E8
2BF4:  MOVFF  01,E7
2BF8:  MOVFF  00,E6
2BFC:  CLRF   18
2BFE:  BTFSC  FF2.7
2C00:  BSF    18.7
2C02:  BCF    FF2.7
2C04:  MOVFF  03,EE
2C08:  MOVFF  02,ED
2C0C:  MOVFF  01,EC
2C10:  MOVFF  00,EB
2C14:  CLRF   xF2
2C16:  CLRF   xF1
2C18:  MOVLW  05
2C1A:  MOVWF  xF0
2C1C:  MOVLW  B5
2C1E:  MOVWF  xEF
2C20:  CALL   0340
2C24:  BTFSC  18.7
2C26:  BSF    FF2.7
2C28:  MOVFF  FEF,00
2C2C:  MOVFF  FEC,01
2C30:  MOVFF  FEC,02
2C34:  MOVFF  FEC,03
2C38:  MOVFF  01,02
2C3C:  MOVFF  00,01
.................... } 
2C40:  RETLW  00
....................  
.................... unsigned int8 current_sun_angle(unsigned int32 t_sec) { 
....................    unsigned int16 today;  // current day (count after epoch) 
....................    unsigned int32 sun_rise_t_sec; // time of day . compensated for time zone 
....................    unsigned int8 sun_data; 
....................    today = find_day_number(t_sec); // day after epoch 
*
369C:  MOVFF  D9,E4
36A0:  MOVFF  D8,E3
36A4:  MOVFF  D7,E2
36A8:  MOVFF  D6,E1
36AC:  CALL   2BA8
36B0:  MOVFF  02,DB
36B4:  MOVFF  01,DA
....................     sun_rise_t_sec = get_timer_index(today)*450; 
36B8:  MOVFF  DB,E2
36BC:  MOVFF  DA,E1
36C0:  CALL   2C42
36C4:  MOVFF  03,E4
36C8:  MOVFF  02,E3
36CC:  MOVFF  01,E2
36D0:  MOVFF  00,E1
36D4:  MOVFF  FEA,E6
36D8:  MOVFF  FE9,E5
36DC:  MOVFF  03,F8
36E0:  MOVFF  02,F7
36E4:  MOVFF  01,F6
36E8:  MOVFF  00,F5
36EC:  CLRF   xFC
36EE:  CLRF   xFB
36F0:  MOVLW  01
36F2:  MOVWF  xFA
36F4:  MOVLW  C2
36F6:  MOVWF  xF9
36F8:  CALL   1330
36FC:  MOVFF  E6,FEA
3700:  MOVFF  E5,FE9
3704:  MOVFF  03,DF
3708:  MOVFF  02,DE
370C:  MOVFF  01,DD
3710:  MOVFF  00,DC
3714:  CLRF   18
3716:  BTFSC  FF2.7
3718:  BSF    18.7
371A:  BCF    FF2.7
....................     if (sun_rise_t_sec > t_sec%SEC_IN_4_YEARS) return 0x0; // sun havent up yet, angle is 0 
371C:  MOVFF  D9,EE
3720:  MOVFF  D8,ED
3724:  MOVFF  D7,EC
3728:  MOVFF  D6,EB
372C:  MOVLW  07
372E:  MOVWF  xF2
3730:  MOVLW  86
3732:  MOVWF  xF1
3734:  MOVLW  1F
3736:  MOVWF  xF0
3738:  MOVLW  80
373A:  MOVWF  xEF
373C:  CALL   0340
3740:  BTFSC  18.7
3742:  BSF    FF2.7
3744:  MOVFF  FEF,00
3748:  MOVFF  FEC,01
374C:  MOVFF  FEC,02
3750:  MOVFF  FEC,03
3754:  MOVF   03,W
3756:  SUBWF  xDF,W
3758:  BNC   3778
375A:  BNZ   3772
375C:  MOVF   02,W
375E:  SUBWF  xDE,W
3760:  BNC   3778
3762:  BNZ   3772
3764:  MOVF   01,W
3766:  SUBWF  xDD,W
3768:  BNC   3778
376A:  BNZ   3772
376C:  MOVF   xDC,W
376E:  SUBWF  00,W
3770:  BC    3778
3772:  MOVLW  00
3774:  MOVWF  01
3776:  BRA    38A6
3778:  CLRF   18
377A:  BTFSC  FF2.7
377C:  BSF    18.7
377E:  BCF    FF2.7
....................    index_in_page = (t_sec%SEC_IN_4_YEARS-sun_rise_t_sec)/450; 
3780:  MOVFF  D9,EE
3784:  MOVFF  D8,ED
3788:  MOVFF  D7,EC
378C:  MOVFF  D6,EB
3790:  MOVLW  07
3792:  MOVWF  xF2
3794:  MOVLW  86
3796:  MOVWF  xF1
3798:  MOVLW  1F
379A:  MOVWF  xF0
379C:  MOVLW  80
379E:  MOVWF  xEF
37A0:  CALL   0340
37A4:  BTFSC  18.7
37A6:  BSF    FF2.7
37A8:  MOVFF  FEF,E1
37AC:  MOVFF  FEC,E2
37B0:  MOVFF  FEC,E3
37B4:  MOVFF  FEC,E4
37B8:  MOVF   xDC,W
37BA:  SUBWF  xE1,W
37BC:  MOVWF  xE5
37BE:  MOVF   xDD,W
37C0:  SUBWFB xE2,W
37C2:  MOVWF  xE6
37C4:  MOVF   xDE,W
37C6:  SUBWFB xE3,W
37C8:  MOVWF  xE7
37CA:  MOVF   xDF,W
37CC:  SUBWFB xE4,W
37CE:  MOVWF  xE8
37D0:  MOVFF  FEA,EA
37D4:  MOVFF  FE9,E9
37D8:  CLRF   18
37DA:  BTFSC  FF2.7
37DC:  BSF    18.7
37DE:  BCF    FF2.7
37E0:  MOVWF  xEE
37E2:  MOVFF  E7,ED
37E6:  MOVFF  E6,EC
37EA:  MOVFF  E5,EB
37EE:  CLRF   xF2
37F0:  CLRF   xF1
37F2:  MOVLW  01
37F4:  MOVWF  xF0
37F6:  MOVLW  C2
37F8:  MOVWF  xEF
37FA:  CALL   0340
37FE:  BTFSC  18.7
3800:  BSF    FF2.7
3802:  MOVFF  EA,FEA
3806:  MOVFF  E9,FE9
380A:  MOVFF  00,CA
....................     if (index_in_page>=124) return 0xFF; // exceed page size , sun went down 
380E:  MOVF   xCA,W
3810:  SUBLW  7B
3812:  BC    381A
3814:  MOVLW  FF
3816:  MOVWF  01
3818:  BRA    38A6
....................     ext_flash_readPage((today/2)+10,128*(today%2)+4+index_in_page,&sun_data,1); 
381A:  BCF    FD8.0
381C:  RRCF   xDB,W
381E:  MOVWF  xE2
3820:  RRCF   xDA,W
3822:  MOVWF  xE1
3824:  MOVLW  0A
3826:  ADDWF  xE1,W
3828:  MOVWF  xE3
382A:  MOVLW  00
382C:  ADDWFC xE2,W
382E:  MOVWF  xE4
3830:  MOVF   xDA,W
3832:  ANDLW  01
3834:  MOVWF  00
3836:  CLRF   03
3838:  MOVWF  02
383A:  RLCF   00,W
383C:  MOVWF  xE5
383E:  RLCF   03,W
3840:  MOVWF  xE6
3842:  RLCF   xE5,F
3844:  RLCF   xE6,F
3846:  RLCF   xE5,F
3848:  RLCF   xE6,F
384A:  RLCF   xE5,F
384C:  RLCF   xE6,F
384E:  RLCF   xE5,F
3850:  RLCF   xE6,F
3852:  RLCF   xE5,F
3854:  RLCF   xE6,F
3856:  RLCF   xE5,F
3858:  RLCF   xE6,F
385A:  MOVLW  80
385C:  ANDWF  xE5,F
385E:  MOVLW  04
3860:  ADDWF  xE5,W
3862:  MOVWF  xE7
3864:  MOVLW  00
3866:  ADDWFC xE6,W
3868:  MOVWF  xE8
386A:  MOVF   xCA,W
386C:  ADDWF  xE7,W
386E:  MOVWF  xE9
3870:  MOVLW  00
3872:  ADDWFC xE8,W
3874:  MOVWF  xEA
3876:  MOVFF  E4,F4
387A:  MOVFF  E3,F3
387E:  MOVFF  E9,F5
3882:  CLRF   xF7
3884:  MOVLW  E0
3886:  MOVWF  xF6
3888:  CLRF   xF9
388A:  MOVLW  01
388C:  MOVWF  xF8
388E:  CALL   27D8
....................    if ((index_in_page>5) && (sun_data==0)) return 0xFF; // sun went down 
3892:  MOVF   xCA,W
3894:  SUBLW  05
3896:  BC    38A2
3898:  MOVF   xE0,F
389A:  BNZ   38A2
389C:  MOVLW  FF
389E:  MOVWF  01
38A0:  BRA    38A6
....................    return sun_data; 
38A2:  MOVFF  E0,01
....................     
.................... } 
38A6:  GOTO   3A8A (RETURN)
....................  
....................  
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,boolean direction,boolean abort_when_task_armed) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
21A4:  CLRF   xDB
21A6:  CLRF   xDC
....................    unsigned int16 yyy=0;    
21A8:  CLRF   xDD
21AA:  CLRF   xDE
....................    int8 rt=5; 
21AC:  MOVLW  05
21AE:  MOVWF  xDF
....................    output_low(CCW); 
21B0:  BCF    F93.4
21B2:  BCF    F8A.4
....................    output_low(EN0); 
21B4:  BCF    F93.0
21B6:  BCF    F8A.0
....................    output_low(EN1); 
21B8:  BCF    F93.1
21BA:  BCF    F8A.1
....................    output_low(EN2); 
21BC:  BCF    F93.2
21BE:  BCF    F8A.2
....................    output_low(EN3); 
21C0:  BCF    F93.3
21C2:  BCF    F8A.3
....................    PORTD.ps_en=1; 
21C4:  BSF    F83.4
21C6:  CLRF   18
21C8:  BTFSC  FF2.7
21CA:  BSF    18.7
21CC:  BCF    FF2.7
....................     delay_ms(20); 
21CE:  MOVLW  14
21D0:  MOVWF  xEA
21D2:  CALL   04BC
21D6:  BTFSC  18.7
21D8:  BSF    FF2.7
....................  
....................    if (!direction)   { 
21DA:  MOVF   xD9,F
21DC:  BNZ   21E2
....................       output_high(CCW); 
21DE:  BCF    F93.4
21E0:  BSF    F8A.4
....................    } 
....................  
....................    PORTD.ps_en=1; 
21E2:  BSF    F83.4
21E4:  CLRF   18
21E6:  BTFSC  FF2.7
21E8:  BSF    18.7
21EA:  BCF    FF2.7
....................     delay_ms(20); 
21EC:  MOVLW  14
21EE:  MOVWF  xEA
21F0:  CALL   04BC
21F4:  BTFSC  18.7
21F6:  BSF    FF2.7
....................    output_high(EN0); 
21F8:  BCF    F93.0
21FA:  BSF    F8A.0
21FC:  CLRF   18
21FE:  BTFSC  FF2.7
2200:  BSF    18.7
2202:  BCF    FF2.7
....................     delay_ms(10); 
2204:  MOVLW  0A
2206:  MOVWF  xEA
2208:  CALL   04BC
220C:  BTFSC  18.7
220E:  BSF    FF2.7
....................  
....................    flag.prev_pulse_state = input(PIN_A2); //A2 = sensor wire for actuator 1 
2210:  BSF    F92.2
2212:  BCF    1F.2
2214:  BTFSC  F80.2
2216:  BSF    1F.2
....................    tick = timer_sec; 
2218:  MOVFF  23,27
221C:  MOVFF  22,26
2220:  MOVFF  21,25
2224:  MOVFF  20,24
....................    tick2 = timer_sec; 
2228:  MOVFF  23,2B
222C:  MOVFF  22,2A
2230:  MOVFF  21,29
2234:  MOVFF  20,28
....................    actuator_pulse =0; 
2238:  CLRF   xC9
223A:  CLRF   xC8
....................    while(1) { 
....................       xxx = (int16) (timer_sec-tick); 
223C:  MOVF   24,W
223E:  SUBWF  20,W
2240:  MOVWF  00
2242:  MOVF   25,W
2244:  SUBWFB 21,W
2246:  MOVWF  01
2248:  MOVF   26,W
224A:  SUBWFB 22,W
224C:  MOVF   27,W
224E:  SUBWFB 23,W
2250:  MOVFF  01,DC
2254:  MOVFF  00,DB
....................       yyy = (int16) (timer_sec-tick2); 
2258:  MOVF   28,W
225A:  SUBWF  20,W
225C:  MOVWF  00
225E:  MOVF   29,W
2260:  SUBWFB 21,W
2262:  MOVWF  01
2264:  MOVF   2A,W
2266:  SUBWFB 22,W
2268:  MOVF   2B,W
226A:  SUBWFB 23,W
226C:  MOVFF  01,DE
2270:  MOVFF  00,DD
....................       if ( xxx>= time_out_sec)  
2274:  MOVF   xD6,W
2276:  SUBWF  xDC,W
2278:  BNC   2284
227A:  BNZ   2282
227C:  MOVF   xD5,W
227E:  SUBWF  xDB,W
2280:  BNC   2284
....................          break; 
2282:  BRA    2370
....................        if (actuator_pulse >= nPulse) 
2284:  MOVF   xD4,W
2286:  SUBWF  xC9,W
2288:  BNC   2296
228A:  BNZ   2292
228C:  MOVF   xD3,W
228E:  SUBWF  xC8,W
2290:  BNC   2296
....................          output_low(EN0); 
2292:  BCF    F93.0
2294:  BCF    F8A.0
....................       if ( yyy >=stuck_sec) 
2296:  MOVF   xD8,W
2298:  SUBWF  xDE,W
229A:  BNC   22A6
229C:  BNZ   22A4
229E:  MOVF   xD7,W
22A0:  SUBWF  xDD,W
22A2:  BNC   22A6
....................          break; 
22A4:  BRA    2370
....................       if (abort_when_task_armed && (flag.task1_armed||flag.cmd_posted)) 
22A6:  MOVF   xDA,F
22A8:  BZ    22B4
22AA:  BTFSC  1F.0
22AC:  BRA    22B2
22AE:  BTFSS  1F.3
22B0:  BRA    22B4
....................          break; 
22B2:  BRA    2370
....................       if (flag.prev_pulse_state != input(SENSE_0)) { 
22B4:  MOVLW  00
22B6:  BTFSC  1F.2
22B8:  MOVLW  01
22BA:  MOVWF  xE0
22BC:  BSF    F92.1
22BE:  MOVLW  00
22C0:  BTFSC  F80.1
22C2:  MOVLW  01
22C4:  SUBWF  xE0,W
22C6:  BZ    2364
....................          tick2 = timer_sec; 
22C8:  MOVFF  23,2B
22CC:  MOVFF  22,2A
22D0:  MOVFF  21,29
22D4:  MOVFF  20,28
....................          flag.prev_pulse_state = input(SENSE_0); 
22D8:  BSF    F92.1
22DA:  BCF    1F.2
22DC:  BTFSC  F80.1
22DE:  BSF    1F.2
....................          if (!direction && (current_act_position >0)) current_act_position--; 
22E0:  MOVF   xD9,F
22E2:  BNZ   22F4
22E4:  MOVF   x6E,F
22E6:  BNZ   22EC
22E8:  MOVF   x6F,F
22EA:  BZ    22F4
22EC:  MOVF   x6E,W
22EE:  BTFSC  FD8.2
22F0:  DECF   x6F,F
22F2:  DECF   x6E,F
....................          if (direction && (current_act_position < FULL_STROKE_TICK)) current_act_position++; 
22F4:  MOVF   xD9,F
22F6:  BZ    230C
22F8:  MOVF   x6F,W
22FA:  SUBWF  xBB,W
22FC:  BNC   230C
22FE:  BNZ   2306
2300:  MOVF   xBA,W
2302:  SUBWF  x6E,W
2304:  BC    230C
2306:  INCF   x6E,F
2308:  BTFSC  FD8.2
230A:  INCF   x6F,F
....................          actuator_pulse=actuator_pulse+1; 
230C:  MOVLW  01
230E:  ADDWF  xC8,F
2310:  MOVLW  00
2312:  ADDWFC xC9,F
....................          lcd_gotoxy(11,2); 
2314:  MOVLW  0B
2316:  MOVWF  xEA
2318:  MOVLW  02
231A:  MOVWF  xEB
231C:  CALL   0CC2
....................          if (actuator_pulse%2==0)   lcd_putc('*'); else  lcd_putc('.'); 
2320:  MOVF   xC8,W
2322:  ANDLW  01
2324:  MOVWF  xE0
2326:  CLRF   xE1
2328:  MOVF   xE0,F
232A:  BNZ   233A
232C:  MOVF   xE1,F
232E:  BNZ   233A
2330:  MOVLW  2A
2332:  MOVWF  xE9
2334:  CALL   0CEA
2338:  BRA    2342
233A:  MOVLW  2E
233C:  MOVWF  xE9
233E:  CALL   0CEA
....................          lcd_gotoxy(12,2); 
2342:  MOVLW  0C
2344:  MOVWF  xEA
2346:  MOVLW  02
2348:  MOVWF  xEB
234A:  CALL   0CC2
....................          printf(lcd_putc,"%4lu",current_act_position); 
234E:  MOVLW  01
2350:  MOVWF  FE9
2352:  MOVFF  6F,E1
2356:  MOVFF  6E,E0
235A:  CALL   0D3C
....................          PORTE.tx_en=1; 
235E:  BSF    F84.2
....................          //printf("\r%4lu",actuator_pulse); 
....................          tx_delay=TX_DLY_TIME; 
2360:  MOVLW  01
2362:  MOVWF  xC2
....................  
....................       } 
....................       if (flag.update_time) { 
2364:  BTFSS  1F.1
2366:  BRA    236E
....................          flag.update_time = false; 
2368:  BCF    1F.1
....................          print_date_time(); 
236A:  CALL   16DC
....................       } 
....................    } 
236E:  BRA    223C
....................    lcd_gotoxy(12,2); 
2370:  MOVLW  0C
2372:  MOVWF  xEA
2374:  MOVLW  02
2376:  MOVWF  xEB
2378:  CALL   0CC2
....................     printf(lcd_putc,"%4lu",current_act_position); 
237C:  MOVLW  01
237E:  MOVWF  FE9
2380:  MOVFF  6F,E1
2384:  MOVFF  6E,E0
2388:  CALL   0D3C
....................    output_low(EN0); 
238C:  BCF    F93.0
238E:  BCF    F8A.0
....................    output_low(EN1); 
2390:  BCF    F93.1
2392:  BCF    F8A.1
....................    output_low(EN2); 
2394:  BCF    F93.2
2396:  BCF    F8A.2
....................    output_low(EN3); 
2398:  BCF    F93.3
239A:  BCF    F8A.3
....................    PORTD.ps_en=1; 
239C:  BSF    F83.4
239E:  CLRF   18
23A0:  BTFSC  FF2.7
23A2:  BSF    18.7
23A4:  BCF    FF2.7
....................     delay_ms(50); 
23A6:  MOVLW  32
23A8:  MOVWF  xEA
23AA:  CALL   04BC
23AE:  BTFSC  18.7
23B0:  BSF    FF2.7
....................    output_low(CCW); 
23B2:  BCF    F93.4
23B4:  BCF    F8A.4
23B6:  CLRF   18
23B8:  BTFSC  FF2.7
23BA:  BSF    18.7
23BC:  BCF    FF2.7
....................     delay_ms(50); 
23BE:  MOVLW  32
23C0:  MOVWF  xEA
23C2:  CALL   04BC
23C6:  BTFSC  18.7
23C8:  BSF    FF2.7
.................... } 
23CA:  RETLW  00
....................  
.................... int8 task1() { 
....................       int8 sun_angle; 
....................       lcd_init(); 
*
38E2:  CALL   09FE
38E6:  CLRF   18
38E8:  BTFSC  FF2.7
38EA:  BSF    18.7
38EC:  BCF    FF2.7
....................       if (timer_sec%SEC_IN_4_YEARS >= next_sun_rise) { 
38EE:  MOVFF  23,EE
38F2:  MOVFF  22,ED
38F6:  MOVFF  21,EC
38FA:  MOVFF  20,EB
38FE:  MOVLW  07
3900:  MOVWF  xF2
3902:  MOVLW  86
3904:  MOVWF  xF1
3906:  MOVLW  1F
3908:  MOVWF  xF0
390A:  MOVLW  80
390C:  MOVWF  xEF
390E:  CALL   0340
3912:  BTFSC  18.7
3914:  BSF    FF2.7
3916:  MOVFF  FEF,D2
391A:  MOVFF  FEC,D3
391E:  MOVFF  FEC,D4
3922:  MOVFF  FEC,D5
3926:  MOVF   x6D,W
3928:  SUBWF  xD5,W
392A:  BTFSS  FD8.0
392C:  BRA    3A14
392E:  BNZ   3946
3930:  MOVF   x6C,W
3932:  SUBWF  xD4,W
3934:  BNC   3A14
3936:  BNZ   3946
3938:  MOVF   x6B,W
393A:  SUBWF  xD3,W
393C:  BNC   3A14
393E:  BNZ   3946
3940:  MOVF   x6A,W
3942:  SUBWF  xD2,W
3944:  BNC   3A14
....................           next_sun_rise=get_timer_index(find_day_number((next_sun_rise+86400)%SEC_IN_4_YEARS))*450; 
3946:  MOVLW  80
3948:  ADDWF  x6A,W
394A:  MOVWF  xD2
394C:  MOVLW  51
394E:  ADDWFC x6B,W
3950:  MOVWF  xD3
3952:  MOVLW  01
3954:  ADDWFC x6C,W
3956:  MOVWF  xD4
3958:  MOVLW  00
395A:  ADDWFC x6D,W
395C:  MOVWF  xD5
395E:  CLRF   18
3960:  BTFSC  FF2.7
3962:  BSF    18.7
3964:  BCF    FF2.7
3966:  MOVWF  xEE
3968:  MOVFF  D4,ED
396C:  MOVFF  D3,EC
3970:  MOVFF  D2,EB
3974:  MOVLW  07
3976:  MOVWF  xF2
3978:  MOVLW  86
397A:  MOVWF  xF1
397C:  MOVLW  1F
397E:  MOVWF  xF0
3980:  MOVLW  80
3982:  MOVWF  xEF
3984:  CALL   0340
3988:  BTFSC  18.7
398A:  BSF    FF2.7
398C:  MOVFF  FEF,D3
3990:  MOVFF  FEC,D4
3994:  MOVFF  FEC,D5
3998:  MOVFF  FEC,D6
399C:  MOVFF  D6,E4
39A0:  MOVFF  D5,E3
39A4:  MOVFF  D4,E2
39A8:  MOVFF  D3,E1
39AC:  CALL   2BA8
39B0:  MOVFF  02,D5
39B4:  MOVFF  01,D4
39B8:  MOVFF  02,E2
39BC:  MOVFF  01,E1
39C0:  CALL   2C42
39C4:  MOVFF  03,D8
39C8:  MOVFF  02,D7
39CC:  MOVFF  01,D6
39D0:  MOVFF  00,D5
39D4:  MOVFF  FEA,DA
39D8:  MOVFF  FE9,D9
39DC:  MOVFF  03,F8
39E0:  MOVFF  02,F7
39E4:  MOVFF  01,F6
39E8:  MOVFF  00,F5
39EC:  CLRF   xFC
39EE:  CLRF   xFB
39F0:  MOVLW  01
39F2:  MOVWF  xFA
39F4:  MOVLW  C2
39F6:  MOVWF  xF9
39F8:  CALL   1330
39FC:  MOVFF  DA,FEA
3A00:  MOVFF  D9,FE9
3A04:  MOVFF  03,6D
3A08:  MOVFF  02,6C
3A0C:  MOVFF  01,6B
3A10:  MOVFF  00,6A
....................       } 
....................         sec_until_sun_rise = (int32) (next_sun_rise-timer_sec); 
3A14:  MOVF   20,W
3A16:  SUBWF  x6A,W
3A18:  MOVWF  00
3A1A:  MOVF   21,W
3A1C:  SUBWFB x6B,W
3A1E:  MOVWF  01
3A20:  MOVF   22,W
3A22:  SUBWFB x6C,W
3A24:  MOVWF  02
3A26:  MOVF   23,W
3A28:  SUBWFB x6D,W
3A2A:  MOVWF  xB9
3A2C:  MOVFF  02,B8
3A30:  MOVFF  01,B7
3A34:  MOVFF  00,B6
3A38:  CLRF   18
3A3A:  BTFSC  FF2.7
3A3C:  BSF    18.7
3A3E:  BCF    FF2.7
....................       sun_angle=current_sun_angle(timer_sec%SEC_IN_4_YEARS); 
3A40:  MOVFF  23,EE
3A44:  MOVFF  22,ED
3A48:  MOVFF  21,EC
3A4C:  MOVFF  20,EB
3A50:  MOVLW  07
3A52:  MOVWF  xF2
3A54:  MOVLW  86
3A56:  MOVWF  xF1
3A58:  MOVLW  1F
3A5A:  MOVWF  xF0
3A5C:  MOVLW  80
3A5E:  MOVWF  xEF
3A60:  CALL   0340
3A64:  BTFSC  18.7
3A66:  BSF    FF2.7
3A68:  MOVFF  FEF,D2
3A6C:  MOVFF  FEC,D3
3A70:  MOVFF  FEC,D4
3A74:  MOVFF  FEC,D5
3A78:  MOVFF  D5,D9
3A7C:  MOVFF  D4,D8
3A80:  MOVFF  D3,D7
3A84:  MOVFF  D2,D6
3A88:  BRA    369C
3A8A:  MOVFF  01,D1
....................  
....................       // prepare buffer1 
....................       if (sun_angle==0x00) // sun havent' come up yet, clear buffer1 
3A8E:  MOVF   xD1,F
3A90:  BNZ   3B1C
3A92:  CLRF   18
3A94:  BTFSC  FF2.7
3A96:  BSF    18.7
3A98:  BCF    FF2.7
....................       { 
....................          if(find_day_number(timer_sec%SEC_IN_4_YEARS)%2==0)  
3A9A:  MOVFF  23,EE
3A9E:  MOVFF  22,ED
3AA2:  MOVFF  21,EC
3AA6:  MOVFF  20,EB
3AAA:  MOVLW  07
3AAC:  MOVWF  xF2
3AAE:  MOVLW  86
3AB0:  MOVWF  xF1
3AB2:  MOVLW  1F
3AB4:  MOVWF  xF0
3AB6:  MOVLW  80
3AB8:  MOVWF  xEF
3ABA:  CALL   0340
3ABE:  BTFSC  18.7
3AC0:  BSF    FF2.7
3AC2:  MOVFF  FEF,D2
3AC6:  MOVFF  FEC,D3
3ACA:  MOVFF  FEC,D4
3ACE:  MOVFF  FEC,D5
3AD2:  MOVFF  D5,E4
3AD6:  MOVFF  D4,E3
3ADA:  MOVFF  D3,E2
3ADE:  MOVFF  D2,E1
3AE2:  CALL   2BA8
3AE6:  MOVFF  02,D4
3AEA:  MOVF   01,W
3AEC:  MOVWF  xD3
3AEE:  ANDLW  01
3AF0:  MOVWF  xD5
3AF2:  CLRF   xD6
3AF4:  MOVF   xD5,F
3AF6:  BNZ   3B0C
3AF8:  MOVF   xD6,F
3AFA:  BNZ   3B0C
....................             ext_flash_buffer1_write(0xAA,0,255); 
3AFC:  MOVLW  AA
3AFE:  MOVWF  xDC
3B00:  CLRF   xDD
3B02:  MOVLW  FF
3B04:  MOVWF  xDE
3B06:  CALL   2F30
....................          else 
3B0A:  BRA    3B1C
....................             ext_flash_buffer1_write(0xAA,128,127); 
3B0C:  MOVLW  AA
3B0E:  MOVWF  xDC
3B10:  MOVLW  80
3B12:  MOVWF  xDD
3B14:  MOVLW  7F
3B16:  MOVWF  xDE
3B18:  CALL   2F30
....................       } 
....................  
....................       if ((sun_angle == 0xFF) || (sun_angle == 0x00)) // sundown 
3B1C:  INCFSZ xD1,W
3B1E:  BRA    3B22
3B20:  BRA    3B26
3B22:  MOVF   xD1,F
3B24:  BNZ   3B2A
....................          sun_angle = 180; 
3B26:  MOVLW  B4
3B28:  MOVWF  xD1
....................  
....................       if (sun_angle != 180) { 
3B2A:  MOVF   xD1,W
3B2C:  SUBLW  B4
3B2E:  BTFSC  FD8.2
3B30:  BRA    3C70
....................          ext_flash_buffer1_write((int8)(current_measured/n_avg_current_measured),128*(find_day_number(timer_sec%SEC_IN_4_YEARS)%2)+4+index_in_page,1); 
3B32:  MOVFF  C4,D4
3B36:  MOVFF  C3,D3
3B3A:  CLRF   xD6
3B3C:  MOVFF  C5,D5
3B40:  CALL   2E24
3B44:  MOVFF  01,D2
3B48:  CLRF   18
3B4A:  BTFSC  FF2.7
3B4C:  BSF    18.7
3B4E:  BCF    FF2.7
3B50:  MOVFF  23,EE
3B54:  MOVFF  22,ED
3B58:  MOVFF  21,EC
3B5C:  MOVFF  20,EB
3B60:  MOVLW  07
3B62:  MOVWF  xF2
3B64:  MOVLW  86
3B66:  MOVWF  xF1
3B68:  MOVLW  1F
3B6A:  MOVWF  xF0
3B6C:  MOVLW  80
3B6E:  MOVWF  xEF
3B70:  CALL   0340
3B74:  BTFSC  18.7
3B76:  BSF    FF2.7
3B78:  MOVFF  FEF,D3
3B7C:  MOVFF  FEC,D4
3B80:  MOVFF  FEC,D5
3B84:  MOVFF  FEC,D6
3B88:  MOVFF  D6,E4
3B8C:  MOVFF  D5,E3
3B90:  MOVFF  D4,E2
3B94:  MOVFF  D3,E1
3B98:  CALL   2BA8
3B9C:  MOVFF  02,D5
3BA0:  MOVF   01,W
3BA2:  MOVWF  xD4
3BA4:  ANDLW  01
3BA6:  MOVWF  00
3BA8:  CLRF   03
3BAA:  MOVWF  02
3BAC:  RLCF   00,W
3BAE:  MOVWF  xD6
3BB0:  RLCF   03,W
3BB2:  MOVWF  xD7
3BB4:  RLCF   xD6,F
3BB6:  RLCF   xD7,F
3BB8:  RLCF   xD6,F
3BBA:  RLCF   xD7,F
3BBC:  RLCF   xD6,F
3BBE:  RLCF   xD7,F
3BC0:  RLCF   xD6,F
3BC2:  RLCF   xD7,F
3BC4:  RLCF   xD6,F
3BC6:  RLCF   xD7,F
3BC8:  RLCF   xD6,F
3BCA:  RLCF   xD7,F
3BCC:  MOVLW  80
3BCE:  ANDWF  xD6,F
3BD0:  MOVLW  04
3BD2:  ADDWF  xD6,W
3BD4:  MOVWF  xD8
3BD6:  MOVLW  00
3BD8:  ADDWFC xD7,W
3BDA:  MOVWF  xD9
3BDC:  MOVF   xCA,W
3BDE:  ADDWF  xD8,W
3BE0:  MOVWF  xDA
3BE2:  MOVLW  00
3BE4:  ADDWFC xD9,W
3BE6:  MOVWF  xDB
3BE8:  MOVFF  D2,DC
3BEC:  MOVFF  DA,DD
3BF0:  MOVLW  01
3BF2:  MOVWF  xDE
3BF4:  CALL   2F30
3BF8:  CLRF   18
3BFA:  BTFSC  FF2.7
3BFC:  BSF    18.7
3BFE:  BCF    FF2.7
....................          ext_flash_write_buffer1_to_main_memory(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
3C00:  MOVFF  23,EE
3C04:  MOVFF  22,ED
3C08:  MOVFF  21,EC
3C0C:  MOVFF  20,EB
3C10:  MOVLW  07
3C12:  MOVWF  xF2
3C14:  MOVLW  86
3C16:  MOVWF  xF1
3C18:  MOVLW  1F
3C1A:  MOVWF  xF0
3C1C:  MOVLW  80
3C1E:  MOVWF  xEF
3C20:  CALL   0340
3C24:  BTFSC  18.7
3C26:  BSF    FF2.7
3C28:  MOVFF  FEF,D2
3C2C:  MOVFF  FEC,D3
3C30:  MOVFF  FEC,D4
3C34:  MOVFF  FEC,D5
3C38:  MOVFF  D5,E4
3C3C:  MOVFF  D4,E3
3C40:  MOVFF  D3,E2
3C44:  MOVFF  D2,E1
3C48:  CALL   2BA8
3C4C:  MOVFF  02,D4
3C50:  MOVFF  01,D3
3C54:  BCF    FD8.0
3C56:  RRCF   02,W
3C58:  MOVWF  03
3C5A:  RRCF   01,W
3C5C:  MOVWF  02
3C5E:  ADDLW  F2
3C60:  MOVWF  xD5
3C62:  MOVLW  03
3C64:  ADDWFC 03,W
3C66:  MOVWF  xD6
3C68:  MOVWF  xD8
3C6A:  MOVFF  D5,D7
3C6E:  BRA    38AA
....................       } 
....................       strcpy(tmp_str,"#     "); 
3C70:  CLRF   FEA
3C72:  MOVLW  2C
3C74:  MOVWF  FE9
3C76:  MOVFF  FF2,D2
3C7A:  BCF    FF2.7
3C7C:  MOVLW  00
3C7E:  CALL   014E
3C82:  TBLRD*-
3C84:  TBLRD*+
3C86:  MOVF   FF5,W
3C88:  MOVWF  FEE
3C8A:  IORLW  00
3C8C:  BNZ   3C84
3C8E:  BTFSC  xD2.7
3C90:  BSF    FF2.7
3C92:  CLRF   18
3C94:  BTFSC  FF2.7
3C96:  BSF    18.7
3C98:  BCF    FF2.7
....................       itoa((int16)find_day_number(timer_sec%SEC_IN_4_YEARS),10,tmp_str2); 
3C9A:  MOVFF  23,EE
3C9E:  MOVFF  22,ED
3CA2:  MOVFF  21,EC
3CA6:  MOVFF  20,EB
3CAA:  MOVLW  07
3CAC:  MOVWF  xF2
3CAE:  MOVLW  86
3CB0:  MOVWF  xF1
3CB2:  MOVLW  1F
3CB4:  MOVWF  xF0
3CB6:  MOVLW  80
3CB8:  MOVWF  xEF
3CBA:  CALL   0340
3CBE:  BTFSC  18.7
3CC0:  BSF    FF2.7
3CC2:  MOVFF  FEF,D2
3CC6:  MOVFF  FEC,D3
3CCA:  MOVFF  FEC,D4
3CCE:  MOVFF  FEC,D5
3CD2:  MOVFF  D5,E4
3CD6:  MOVFF  D4,E3
3CDA:  MOVFF  D3,E2
3CDE:  MOVFF  D2,E1
3CE2:  CALL   2BA8
3CE6:  MOVFF  02,D4
3CEA:  MOVFF  01,D3
3CEE:  CLRF   xE9
3CF0:  CLRF   xE8
3CF2:  MOVFF  02,E7
3CF6:  MOVFF  01,E6
3CFA:  MOVLW  0A
3CFC:  MOVWF  xEA
3CFE:  CLRF   xEC
3D00:  MOVLW  40
3D02:  MOVWF  xEB
3D04:  CALL   14A6
....................       memcpy(tmp_str+4-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3D08:  CLRF   xE3
3D0A:  MOVLW  40
3D0C:  MOVWF  xE2
3D0E:  CALL   1682
3D12:  MOVLW  30
3D14:  BSF    FD8.0
3D16:  SUBFWB 01,W
3D18:  MOVWF  xD2
3D1A:  MOVLW  00
3D1C:  BTFSS  FD8.0
3D1E:  DECF   FE8,F
3D20:  MOVWF  xD3
3D22:  CLRF   xE3
3D24:  MOVLW  40
3D26:  MOVWF  xE2
3D28:  CALL   1682
3D2C:  MOVFF  01,D4
3D30:  MOVFF  D3,FEA
3D34:  MOVFF  D2,FE9
3D38:  CLRF   FE2
3D3A:  MOVLW  40
3D3C:  MOVWF  FE1
3D3E:  MOVF   01,W
3D40:  MOVWF  01
3D42:  BZ    3D4C
3D44:  MOVFF  FE6,FEE
3D48:  DECFSZ 01,F
3D4A:  BRA    3D44
....................       lcd_gotoxy(10,0); 
3D4C:  MOVLW  0A
3D4E:  MOVWF  xEA
3D50:  CLRF   xEB
3D52:  CALL   0CC2
....................       lcd_gotoxy(10,0);       
3D56:  MOVLW  0A
3D58:  MOVWF  xEA
3D5A:  CLRF   xEB
3D5C:  CALL   0CC2
....................       lcd_gotoxy(10,0); 
3D60:  MOVLW  0A
3D62:  MOVWF  xEA
3D64:  CLRF   xEB
3D66:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
3D6A:  CLRF   xE3
3D6C:  MOVLW  2C
3D6E:  MOVWF  xE2
3D70:  CALL   1682
3D74:  MOVFF  01,D2
3D78:  CLRF   xE2
3D7A:  MOVLW  2C
3D7C:  MOVWF  xE1
3D7E:  MOVFF  01,E3
3D82:  CALL   16B4
....................  
....................       strcpy(tmp_str,"   "); 
3D86:  CLRF   FEA
3D88:  MOVLW  2C
3D8A:  MOVWF  FE9
3D8C:  MOVFF  FF2,D2
3D90:  BCF    FF2.7
3D92:  MOVLW  00
3D94:  CALL   0110
3D98:  TBLRD*-
3D9A:  TBLRD*+
3D9C:  MOVF   FF5,W
3D9E:  MOVWF  FEE
3DA0:  IORLW  00
3DA2:  BNZ   3D9A
3DA4:  BTFSC  xD2.7
3DA6:  BSF    FF2.7
....................       tmp_str[3]=0xDF; 
3DA8:  MOVLW  DF
3DAA:  MOVWF  2F
....................       itoa((int8)sun_angle,10,tmp_str2); 
3DAC:  CLRF   xE9
3DAE:  CLRF   xE8
3DB0:  CLRF   xE7
3DB2:  MOVFF  D1,E6
3DB6:  MOVLW  0A
3DB8:  MOVWF  xEA
3DBA:  CLRF   xEC
3DBC:  MOVLW  40
3DBE:  MOVWF  xEB
3DC0:  CALL   14A6
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3DC4:  CLRF   xE3
3DC6:  MOVLW  40
3DC8:  MOVWF  xE2
3DCA:  CALL   1682
3DCE:  MOVF   01,W
3DD0:  SUBLW  03
3DD2:  BNC   3E18
3DD4:  CLRF   xE3
3DD6:  MOVLW  40
3DD8:  MOVWF  xE2
3DDA:  CALL   1682
3DDE:  MOVLW  2F
3DE0:  BSF    FD8.0
3DE2:  SUBFWB 01,W
3DE4:  MOVWF  xD2
3DE6:  MOVLW  00
3DE8:  BTFSS  FD8.0
3DEA:  DECF   FE8,F
3DEC:  MOVWF  xD3
3DEE:  CLRF   xE3
3DF0:  MOVLW  40
3DF2:  MOVWF  xE2
3DF4:  CALL   1682
3DF8:  MOVFF  01,D4
3DFC:  MOVFF  D3,FEA
3E00:  MOVFF  D2,FE9
3E04:  CLRF   FE2
3E06:  MOVLW  40
3E08:  MOVWF  FE1
3E0A:  MOVF   01,W
3E0C:  MOVWF  01
3E0E:  BZ    3E18
3E10:  MOVFF  FE6,FEE
3E14:  DECFSZ 01,F
3E16:  BRA    3E10
....................        lcd_gotoxy(10,1); 
3E18:  MOVLW  0A
3E1A:  MOVWF  xEA
3E1C:  MOVLW  01
3E1E:  MOVWF  xEB
3E20:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
3E24:  CLRF   xE3
3E26:  MOVLW  2C
3E28:  MOVWF  xE2
3E2A:  CALL   1682
3E2E:  MOVFF  01,D2
3E32:  CLRF   xE2
3E34:  MOVLW  2C
3E36:  MOVWF  xE1
3E38:  MOVFF  01,E3
3E3C:  CALL   16B4
....................  
....................       return sun_angle; 
3E40:  MOVFF  D1,01
....................  
.................... } 
3E44:  RETLW  00
....................  
.................... unsigned int8 get_backtrack_angle(unsigned int8 alpha) { 
....................  
....................    float tan_alpha,ll,dd; 
....................    float beta; 
....................    ll = PANEL_WIDTH; 
*
59EE:  CLRF   xDA
59F0:  CLRF   xD9
59F2:  MOVLW  20
59F4:  MOVWF  xD8
59F6:  MOVLW  86
59F8:  MOVWF  xD7
....................    dd = ROW_SPACING; 
59FA:  CLRF   xDE
59FC:  CLRF   xDD
59FE:  MOVLW  20
5A00:  MOVWF  xDC
5A02:  MOVLW  87
5A04:  MOVWF  xDB
....................    tan_alpha = tan( (float) (alpha) *PI/180.0); 
5A06:  MOVLB  1
5A08:  CLRF   x4F
5A0A:  MOVFF  D2,14E
5A0E:  MOVLB  0
5A10:  CALL   43EA
5A14:  MOVFF  00,E3
5A18:  MOVFF  01,E4
5A1C:  MOVFF  02,E5
5A20:  MOVFF  03,E6
5A24:  MOVFF  03,151
5A28:  MOVFF  02,150
5A2C:  MOVFF  01,14F
5A30:  MOVFF  00,14E
5A34:  MOVLW  DB
5A36:  MOVLB  1
5A38:  MOVWF  x55
5A3A:  MOVLW  0F
5A3C:  MOVWF  x54
5A3E:  MOVLW  49
5A40:  MOVWF  x53
5A42:  MOVLW  80
5A44:  MOVWF  x52
5A46:  MOVLB  0
5A48:  CALL   0E24
5A4C:  MOVFF  00,E7
5A50:  MOVFF  01,E8
5A54:  MOVFF  02,E9
5A58:  MOVFF  03,EA
5A5C:  MOVFF  03,14D
5A60:  MOVFF  02,14C
5A64:  MOVFF  01,14B
5A68:  MOVFF  00,14A
5A6C:  MOVLB  1
5A6E:  CLRF   x51
5A70:  CLRF   x50
5A72:  MOVLW  34
5A74:  MOVWF  x4F
5A76:  MOVLW  86
5A78:  MOVWF  x4E
5A7A:  MOVLB  0
5A7C:  CALL   0F1A
5A80:  MOVFF  00,EB
5A84:  MOVFF  01,EC
5A88:  MOVFF  02,ED
5A8C:  MOVFF  03,EE
5A90:  MOVFF  03,113
5A94:  MOVFF  02,112
5A98:  MOVFF  01,111
5A9C:  MOVFF  00,110
5AA0:  CALL   4832
5AA4:  MOVFF  03,D6
5AA8:  MOVFF  02,D5
5AAC:  MOVFF  01,D4
5AB0:  MOVFF  00,D3
....................  
....................    beta = acos(-1*dd/(ll*sqrt(1.0+tan_alpha*tan_alpha))) -atan(-1.0*tan_alpha); 
5AB4:  MOVLB  1
5AB6:  CLRF   x51
5AB8:  CLRF   x50
5ABA:  MOVLW  80
5ABC:  MOVWF  x4F
5ABE:  MOVLW  7F
5AC0:  MOVWF  x4E
5AC2:  MOVFF  DE,155
5AC6:  MOVFF  DD,154
5ACA:  MOVFF  DC,153
5ACE:  MOVFF  DB,152
5AD2:  MOVLB  0
5AD4:  CALL   0E24
5AD8:  MOVFF  00,E3
5ADC:  MOVFF  01,E4
5AE0:  MOVFF  02,E5
5AE4:  MOVFF  03,E6
5AE8:  MOVFF  D6,151
5AEC:  MOVFF  D5,150
5AF0:  MOVFF  D4,14F
5AF4:  MOVFF  D3,14E
5AF8:  MOVFF  D6,155
5AFC:  MOVFF  D5,154
5B00:  MOVFF  D4,153
5B04:  MOVFF  D3,152
5B08:  CALL   0E24
5B0C:  BCF    FD8.1
5B0E:  MOVLB  1
5B10:  CLRF   x53
5B12:  CLRF   x52
5B14:  CLRF   x51
5B16:  MOVLW  7F
5B18:  MOVWF  x50
5B1A:  MOVFF  03,157
5B1E:  MOVFF  02,156
5B22:  MOVFF  01,155
5B26:  MOVFF  00,154
5B2A:  MOVLB  0
5B2C:  CALL   1078
5B30:  MOVFF  00,E7
5B34:  MOVFF  01,E8
5B38:  MOVFF  02,E9
5B3C:  MOVFF  03,EA
5B40:  MOVFF  03,115
5B44:  MOVFF  02,114
5B48:  MOVFF  01,113
5B4C:  MOVFF  00,112
5B50:  CALL   48D0
5B54:  MOVFF  DA,151
5B58:  MOVFF  D9,150
5B5C:  MOVFF  D8,14F
5B60:  MOVFF  D7,14E
5B64:  MOVFF  03,155
5B68:  MOVFF  02,154
5B6C:  MOVFF  01,153
5B70:  MOVFF  00,152
5B74:  CALL   0E24
5B78:  MOVFF  E6,14D
5B7C:  MOVFF  E5,14C
5B80:  MOVFF  E4,14B
5B84:  MOVFF  E3,14A
5B88:  MOVFF  03,151
5B8C:  MOVFF  02,150
5B90:  MOVFF  01,14F
5B94:  MOVFF  00,14E
5B98:  CALL   0F1A
5B9C:  MOVFF  00,E8
5BA0:  MOVFF  01,E9
5BA4:  MOVFF  02,EA
5BA8:  MOVFF  03,EB
5BAC:  MOVFF  03,EF
5BB0:  MOVFF  02,EE
5BB4:  MOVFF  01,ED
5BB8:  MOVFF  00,EC
5BBC:  BRA    549A
5BBE:  MOVFF  00,E9
5BC2:  MOVFF  01,EA
5BC6:  MOVFF  02,EB
5BCA:  MOVFF  03,EC
5BCE:  MOVLB  1
5BD0:  CLRF   x51
5BD2:  CLRF   x50
5BD4:  MOVLW  80
5BD6:  MOVWF  x4F
5BD8:  MOVLW  7F
5BDA:  MOVWF  x4E
5BDC:  MOVFF  D6,155
5BE0:  MOVFF  D5,154
5BE4:  MOVFF  D4,153
5BE8:  MOVFF  D3,152
5BEC:  MOVLB  0
5BEE:  CALL   0E24
5BF2:  MOVFF  00,ED
5BF6:  MOVFF  01,EE
5BFA:  MOVFF  02,EF
5BFE:  MOVFF  03,F0
5C02:  MOVFF  03,10B
5C06:  MOVFF  02,10A
5C0A:  MOVFF  01,109
5C0E:  MOVFF  00,108
5C12:  CALL   3EC0
5C16:  MOVFF  FEA,EF
5C1A:  MOVFF  FE9,EE
5C1E:  BSF    FD8.1
5C20:  MOVFF  EC,153
5C24:  MOVFF  EB,152
5C28:  MOVFF  EA,151
5C2C:  MOVFF  E9,150
5C30:  MOVFF  03,157
5C34:  MOVFF  02,156
5C38:  MOVFF  01,155
5C3C:  MOVFF  00,154
5C40:  CALL   1078
5C44:  MOVFF  EF,FEA
5C48:  MOVFF  EE,FE9
5C4C:  MOVFF  03,E2
5C50:  MOVFF  02,E1
5C54:  MOVFF  01,E0
5C58:  MOVFF  00,DF
....................    return fmod(beta,PI)*180.0/PI; 
5C5C:  MOVFF  E2,E6
5C60:  MOVFF  E1,E5
5C64:  MOVFF  E0,E4
5C68:  MOVFF  DF,E3
5C6C:  MOVLW  DB
5C6E:  MOVWF  xEA
5C70:  MOVLW  0F
5C72:  MOVWF  xE9
5C74:  MOVLW  49
5C76:  MOVWF  xE8
5C78:  MOVLW  80
5C7A:  MOVWF  xE7
5C7C:  BRA    5884
5C7E:  MOVFF  00,E3
5C82:  MOVFF  01,E4
5C86:  MOVFF  02,E5
5C8A:  MOVFF  03,E6
5C8E:  MOVFF  03,151
5C92:  MOVFF  02,150
5C96:  MOVFF  01,14F
5C9A:  MOVFF  00,14E
5C9E:  MOVLB  1
5CA0:  CLRF   x55
5CA2:  CLRF   x54
5CA4:  MOVLW  34
5CA6:  MOVWF  x53
5CA8:  MOVLW  86
5CAA:  MOVWF  x52
5CAC:  MOVLB  0
5CAE:  CALL   0E24
5CB2:  MOVFF  00,E7
5CB6:  MOVFF  01,E8
5CBA:  MOVFF  02,E9
5CBE:  MOVFF  03,EA
5CC2:  MOVFF  03,14D
5CC6:  MOVFF  02,14C
5CCA:  MOVFF  01,14B
5CCE:  MOVFF  00,14A
5CD2:  MOVLW  DB
5CD4:  MOVLB  1
5CD6:  MOVWF  x51
5CD8:  MOVLW  0F
5CDA:  MOVWF  x50
5CDC:  MOVLW  49
5CDE:  MOVWF  x4F
5CE0:  MOVLW  80
5CE2:  MOVWF  x4E
5CE4:  MOVLB  0
5CE6:  CALL   0F1A
5CEA:  MOVFF  03,14D
5CEE:  MOVFF  02,14C
5CF2:  MOVFF  01,14B
5CF6:  MOVFF  00,14A
5CFA:  CALL   4420
5CFE:  MOVF   01,W
.................... } 
5D00:  RETLW  00
....................  
....................  
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       set_timer1(get_timer1()+0x8000); 
*
03BA:  MOVF   FCE,W
03BC:  MOVFF  FCF,03
03C0:  MOVLB  1
03C2:  MOVWF  x60
03C4:  MOVFF  FCF,161
03C8:  MOVLW  80
03CA:  ADDWF  FCF,W
03CC:  MOVWF  FCF
03CE:  MOVFF  160,FCE
....................       timer_sec+=1;  
03D2:  MOVLW  01
03D4:  ADDWF  20,F
03D6:  MOVLW  00
03D8:  ADDWFC 21,F
03DA:  ADDWFC 22,F
03DC:  ADDWFC 23,F
....................       flag.update_time = true; 
03DE:  BSF    1F.1
....................       restart_wdt(); 
03E0:  CLRWDT
....................       if ((timer_sec%15) ==0) 
03E2:  MOVFF  23,EE
03E6:  MOVFF  22,ED
03EA:  MOVFF  21,EC
03EE:  MOVFF  20,EB
03F2:  MOVLB  0
03F4:  CLRF   xF2
03F6:  CLRF   xF1
03F8:  CLRF   xF0
03FA:  MOVLW  0F
03FC:  MOVWF  xEF
03FE:  RCALL  0340
0400:  MOVFF  FEF,160
0404:  MOVFF  FEC,161
0408:  MOVFF  FEC,162
040C:  MOVFF  FEC,163
0410:  MOVLB  1
0412:  MOVF   x60,F
0414:  BNZ   0424
0416:  MOVF   x61,F
0418:  BNZ   0424
041A:  MOVF   x62,F
041C:  BNZ   0424
041E:  MOVF   x63,F
0420:  BNZ   0424
....................          flag.measured_current=true; 
0422:  BSF    1F.7
....................       if ((timer_sec%450) ==0) 
0424:  MOVFF  23,EE
0428:  MOVFF  22,ED
042C:  MOVFF  21,EC
0430:  MOVFF  20,EB
0434:  MOVLB  0
0436:  CLRF   xF2
0438:  CLRF   xF1
043A:  MOVLW  01
043C:  MOVWF  xF0
043E:  MOVLW  C2
0440:  MOVWF  xEF
0442:  RCALL  0340
0444:  MOVFF  FEF,160
0448:  MOVFF  FEC,161
044C:  MOVFF  FEC,162
0450:  MOVFF  FEC,163
0454:  MOVLB  1
0456:  MOVF   x60,F
0458:  BNZ   0468
045A:  MOVF   x61,F
045C:  BNZ   0468
045E:  MOVF   x62,F
0460:  BNZ   0468
0462:  MOVF   x63,F
0464:  BNZ   0468
....................          flag.task1_armed=true; 
0466:  BSF    1F.0
....................       if (timer_sec%300==30) flag.reset_rs232=true; 
0468:  MOVFF  23,EE
046C:  MOVFF  22,ED
0470:  MOVFF  21,EC
0474:  MOVFF  20,EB
0478:  MOVLB  0
047A:  CLRF   xF2
047C:  CLRF   xF1
047E:  MOVLW  01
0480:  MOVWF  xF0
0482:  MOVLW  2C
0484:  MOVWF  xEF
0486:  RCALL  0340
0488:  MOVFF  FEF,160
048C:  MOVFF  FEC,161
0490:  MOVFF  FEC,162
0494:  MOVFF  FEC,163
0498:  MOVLB  1
049A:  MOVF   x60,W
049C:  SUBLW  1E
049E:  BNZ   04AE
04A0:  MOVF   x61,F
04A2:  BNZ   04AE
04A4:  MOVF   x62,F
04A6:  BNZ   04AE
04A8:  MOVF   x63,F
04AA:  BTFSC  FD8.2
04AC:  BSF    1F.5
....................       if (tx_delay>0) tx_delay--; 
04AE:  MOVLB  0
04B0:  MOVF   xC2,F
04B2:  BTFSS  FD8.2
04B4:  DECF   xC2,F
.................... //       
.................... } 
....................  
....................  
04B6:  BCF    F9E.0
04B8:  GOTO   0064
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................     c=getc(); 
*
04E4:  BTFSS  F9E.5
04E6:  BRA    04E4
04E8:  MOVFF  FAE,160
04EC:  MOVLB  1
....................     PORTE.tx_en=1; 
04EE:  BSF    F84.2
....................    delay_ms(2); 
04F0:  MOVLW  02
04F2:  MOVLB  0
04F4:  MOVWF  xEA
04F6:  RCALL  04BC
....................      if(c==8) {  // Backspace 
04F8:  MOVLB  1
04FA:  MOVF   x60,W
04FC:  SUBLW  08
04FE:  BNZ   0528
....................         if(cmd_len>0) { 
0500:  MOVLB  0
0502:  MOVF   x68,F
0504:  BZ    0524
....................           cmd_len--; 
0506:  DECF   x68,F
....................           printf("%c",c); 
0508:  MOVLB  1
050A:  MOVF   x60,W
050C:  BTFSS  F9E.4
050E:  BRA    050C
0510:  MOVWF  FAD
....................           printf(" "); 
0512:  MOVLW  20
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
....................           printf("%c",c); 
051A:  MOVF   x60,W
051C:  BTFSS  F9E.4
051E:  BRA    051C
0520:  MOVWF  FAD
0522:  MOVLB  0
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0524:  BRA    055A
0526:  MOVLB  1
0528:  MOVF   x60,W
052A:  SUBLW  1F
052C:  BC    055A
052E:  MOVF   x60,W
0530:  SUBLW  7E
0532:  BNC   055A
....................        if(cmd_len<=MAX_CMD_LEN) { 
0534:  MOVLB  0
0536:  MOVF   x68,W
0538:  SUBLW  12
053A:  BNC   055A
....................          cmd_msg[cmd_len++]=c; 
053C:  MOVF   x68,W
053E:  INCF   x68,F
0540:  CLRF   03
0542:  ADDLW  54
0544:  MOVWF  FE9
0546:  MOVLW  00
0548:  ADDWFC 03,W
054A:  MOVWF  FEA
054C:  MOVFF  160,FEF
....................          printf("%c",c); 
0550:  MOVLB  1
0552:  MOVF   x60,W
0554:  BTFSS  F9E.4
0556:  BRA    0554
0558:  MOVWF  FAD
....................        }  
....................     if (c==13) {  
055A:  MOVLB  1
055C:  MOVF   x60,W
055E:  SUBLW  0D
0560:  BNZ   0596
....................    printf("\r\n>"); 
0562:  MOVLW  0D
0564:  BTFSS  F9E.4
0566:  BRA    0564
0568:  MOVWF  FAD
056A:  MOVLW  0A
056C:  BTFSS  F9E.4
056E:  BRA    056C
0570:  MOVWF  FAD
0572:  MOVLW  3E
0574:  BTFSS  F9E.4
0576:  BRA    0574
0578:  MOVWF  FAD
....................     //PORTE.tx_en=0; 
....................    cmd_msg[cmd_len]=0; 
057A:  CLRF   03
057C:  MOVLB  0
057E:  MOVF   x68,W
0580:  ADDLW  54
0582:  MOVWF  FE9
0584:  MOVLW  00
0586:  ADDWFC 03,W
0588:  MOVWF  FEA
058A:  CLRF   FEF
....................    if(cmd_len>1)flag.cmd_posted=true; 
058C:  MOVF   x68,W
058E:  SUBLW  01
0590:  BTFSS  FD8.0
0592:  BSF    1F.3
....................    cmd_len =0; 
0594:  CLRF   x68
....................   } 
....................    tx_delay=TX_DLY_TIME; 
0596:  MOVLW  01
0598:  MOVLB  0
059A:  MOVWF  xC2
....................  
.................... } 
....................  
059C:  BCF    F9E.5
059E:  GOTO   0064
.................... float actuator_length(int8 sun_angle) { 
.................... // return actuator length in cm at given sun_angle 
.................... float len_a,len_b,len_c,len_p,len_m,len_k,len_l; 
.................... float sin_beta,cos_beta,tan_beta; 
.................... float temp1; 
.................... float alpha; 
.................... //if (sun_angle < 30) return; 
.................... //if (sun_angle > 150) return; 
.................... len_a = DIM_A; 
*
49FA:  CLRF   xD7
49FC:  CLRF   xD6
49FE:  MOVLW  4A
4A00:  MOVWF  xD5
4A02:  MOVLW  85
4A04:  MOVWF  xD4
.................... len_b = DIM_B; 
4A06:  CLRF   xDB
4A08:  CLRF   xDA
4A0A:  CLRF   xD9
4A0C:  CLRF   xD8
.................... len_p = DIM_P; 
4A0E:  MOVLW  CD
4A10:  MOVWF  xE3
4A12:  MOVLW  CC
4A14:  MOVWF  xE2
4A16:  MOVLW  14
4A18:  MOVWF  xE1
4A1A:  MOVLW  82
4A1C:  MOVWF  xE0
.................... len_k = DIM_K; 
4A1E:  CLRF   xEB
4A20:  CLRF   xEA
4A22:  MOVLW  70
4A24:  MOVWF  xE9
4A26:  MOVLW  83
4A28:  MOVWF  xE8
.................... len_m = DIM_M; 
4A2A:  CLRF   xE7
4A2C:  CLRF   xE6
4A2E:  MOVLW  30
4A30:  MOVWF  xE5
4A32:  MOVLW  81
4A34:  MOVWF  xE4
.................... len_p = DIM_P; 
4A36:  MOVLW  CD
4A38:  MOVWF  xE3
4A3A:  MOVLW  CC
4A3C:  MOVWF  xE2
4A3E:  MOVLW  14
4A40:  MOVWF  xE1
4A42:  MOVLW  82
4A44:  MOVWF  xE0
.................... alpha = atan(len_b/len_k); 
4A46:  MOVFF  DB,14D
4A4A:  MOVFF  DA,14C
4A4E:  MOVFF  D9,14B
4A52:  MOVFF  D8,14A
4A56:  MOVFF  EB,151
4A5A:  MOVFF  EA,150
4A5E:  MOVFF  E9,14F
4A62:  MOVFF  E8,14E
4A66:  CALL   0F1A
4A6A:  MOVFF  00,104
4A6E:  MOVFF  01,105
4A72:  MOVFF  02,106
4A76:  MOVFF  03,107
4A7A:  MOVFF  03,10B
4A7E:  MOVFF  02,10A
4A82:  MOVFF  01,109
4A86:  MOVFF  00,108
4A8A:  CALL   3EC0
4A8E:  MOVFF  03,103
4A92:  MOVFF  02,102
4A96:  MOVFF  01,101
4A9A:  MOVFF  00,100
.................... sin_beta = sin((sun_angle*PI/180.0)-alpha); 
4A9E:  MOVLB  1
4AA0:  CLRF   x4F
4AA2:  MOVFF  D3,14E
4AA6:  MOVLB  0
4AA8:  RCALL  43EA
4AAA:  MOVFF  03,151
4AAE:  MOVFF  02,150
4AB2:  MOVFF  01,14F
4AB6:  MOVFF  00,14E
4ABA:  MOVLW  DB
4ABC:  MOVLB  1
4ABE:  MOVWF  x55
4AC0:  MOVLW  0F
4AC2:  MOVWF  x54
4AC4:  MOVLW  49
4AC6:  MOVWF  x53
4AC8:  MOVLW  80
4ACA:  MOVWF  x52
4ACC:  MOVLB  0
4ACE:  CALL   0E24
4AD2:  MOVFF  00,104
4AD6:  MOVFF  01,105
4ADA:  MOVFF  02,106
4ADE:  MOVFF  03,107
4AE2:  MOVFF  03,14D
4AE6:  MOVFF  02,14C
4AEA:  MOVFF  01,14B
4AEE:  MOVFF  00,14A
4AF2:  MOVLB  1
4AF4:  CLRF   x51
4AF6:  CLRF   x50
4AF8:  MOVLW  34
4AFA:  MOVWF  x4F
4AFC:  MOVLW  86
4AFE:  MOVWF  x4E
4B00:  MOVLB  0
4B02:  CALL   0F1A
4B06:  MOVFF  00,108
4B0A:  MOVFF  01,109
4B0E:  MOVFF  02,10A
4B12:  MOVFF  03,10B
4B16:  BSF    FD8.1
4B18:  MOVFF  03,153
4B1C:  MOVFF  02,152
4B20:  MOVFF  01,151
4B24:  MOVFF  00,150
4B28:  MOVFF  103,157
4B2C:  MOVFF  102,156
4B30:  MOVFF  101,155
4B34:  MOVFF  100,154
4B38:  CALL   1078
4B3C:  MOVFF  00,10C
4B40:  MOVFF  01,10D
4B44:  MOVFF  02,10E
4B48:  MOVFF  03,10F
4B4C:  MOVFF  03,11F
4B50:  MOVFF  02,11E
4B54:  MOVFF  01,11D
4B58:  MOVFF  00,11C
4B5C:  RCALL  47E4
4B5E:  MOVFF  03,F3
4B62:  MOVFF  02,F2
4B66:  MOVFF  01,F1
4B6A:  MOVFF  00,F0
.................... cos_beta = cos((sun_angle*PI/180.0)-alpha); 
4B6E:  MOVLB  1
4B70:  CLRF   x4F
4B72:  MOVFF  D3,14E
4B76:  MOVLB  0
4B78:  RCALL  43EA
4B7A:  MOVFF  03,151
4B7E:  MOVFF  02,150
4B82:  MOVFF  01,14F
4B86:  MOVFF  00,14E
4B8A:  MOVLW  DB
4B8C:  MOVLB  1
4B8E:  MOVWF  x55
4B90:  MOVLW  0F
4B92:  MOVWF  x54
4B94:  MOVLW  49
4B96:  MOVWF  x53
4B98:  MOVLW  80
4B9A:  MOVWF  x52
4B9C:  MOVLB  0
4B9E:  CALL   0E24
4BA2:  MOVFF  00,104
4BA6:  MOVFF  01,105
4BAA:  MOVFF  02,106
4BAE:  MOVFF  03,107
4BB2:  MOVFF  03,14D
4BB6:  MOVFF  02,14C
4BBA:  MOVFF  01,14B
4BBE:  MOVFF  00,14A
4BC2:  MOVLB  1
4BC4:  CLRF   x51
4BC6:  CLRF   x50
4BC8:  MOVLW  34
4BCA:  MOVWF  x4F
4BCC:  MOVLW  86
4BCE:  MOVWF  x4E
4BD0:  MOVLB  0
4BD2:  CALL   0F1A
4BD6:  MOVFF  00,108
4BDA:  MOVFF  01,109
4BDE:  MOVFF  02,10A
4BE2:  MOVFF  03,10B
4BE6:  BSF    FD8.1
4BE8:  MOVFF  03,153
4BEC:  MOVFF  02,152
4BF0:  MOVFF  01,151
4BF4:  MOVFF  00,150
4BF8:  MOVFF  103,157
4BFC:  MOVFF  102,156
4C00:  MOVFF  101,155
4C04:  MOVFF  100,154
4C08:  CALL   1078
4C0C:  MOVFF  00,10C
4C10:  MOVFF  01,10D
4C14:  MOVFF  02,10E
4C18:  MOVFF  03,10F
4C1C:  MOVFF  03,127
4C20:  MOVFF  02,126
4C24:  MOVFF  01,125
4C28:  MOVFF  00,124
4C2C:  RCALL  445C
4C2E:  MOVFF  03,F7
4C32:  MOVFF  02,F6
4C36:  MOVFF  01,F5
4C3A:  MOVFF  00,F4
.................... tan_beta = tan((sun_angle*PI/180.0)-alpha); 
4C3E:  MOVLB  1
4C40:  CLRF   x4F
4C42:  MOVFF  D3,14E
4C46:  MOVLB  0
4C48:  CALL   43EA
4C4C:  MOVFF  03,151
4C50:  MOVFF  02,150
4C54:  MOVFF  01,14F
4C58:  MOVFF  00,14E
4C5C:  MOVLW  DB
4C5E:  MOVLB  1
4C60:  MOVWF  x55
4C62:  MOVLW  0F
4C64:  MOVWF  x54
4C66:  MOVLW  49
4C68:  MOVWF  x53
4C6A:  MOVLW  80
4C6C:  MOVWF  x52
4C6E:  MOVLB  0
4C70:  CALL   0E24
4C74:  MOVFF  00,104
4C78:  MOVFF  01,105
4C7C:  MOVFF  02,106
4C80:  MOVFF  03,107
4C84:  MOVFF  03,14D
4C88:  MOVFF  02,14C
4C8C:  MOVFF  01,14B
4C90:  MOVFF  00,14A
4C94:  MOVLB  1
4C96:  CLRF   x51
4C98:  CLRF   x50
4C9A:  MOVLW  34
4C9C:  MOVWF  x4F
4C9E:  MOVLW  86
4CA0:  MOVWF  x4E
4CA2:  MOVLB  0
4CA4:  CALL   0F1A
4CA8:  MOVFF  00,108
4CAC:  MOVFF  01,109
4CB0:  MOVFF  02,10A
4CB4:  MOVFF  03,10B
4CB8:  BSF    FD8.1
4CBA:  MOVFF  03,153
4CBE:  MOVFF  02,152
4CC2:  MOVFF  01,151
4CC6:  MOVFF  00,150
4CCA:  MOVFF  103,157
4CCE:  MOVFF  102,156
4CD2:  MOVFF  101,155
4CD6:  MOVFF  100,154
4CDA:  CALL   1078
4CDE:  MOVFF  00,10C
4CE2:  MOVFF  01,10D
4CE6:  MOVFF  02,10E
4CEA:  MOVFF  03,10F
4CEE:  MOVFF  03,113
4CF2:  MOVFF  02,112
4CF6:  MOVFF  01,111
4CFA:  MOVFF  00,110
4CFE:  RCALL  4832
4D00:  MOVFF  03,FB
4D04:  MOVFF  02,FA
4D08:  MOVFF  01,F9
4D0C:  MOVFF  00,F8
....................  
....................  
.................... len_c = sqrt(len_k*len_k+len_b*len_b)-len_p/sin_beta; 
4D10:  MOVFF  EB,151
4D14:  MOVFF  EA,150
4D18:  MOVFF  E9,14F
4D1C:  MOVFF  E8,14E
4D20:  MOVFF  EB,155
4D24:  MOVFF  EA,154
4D28:  MOVFF  E9,153
4D2C:  MOVFF  E8,152
4D30:  CALL   0E24
4D34:  MOVFF  00,104
4D38:  MOVFF  01,105
4D3C:  MOVFF  02,106
4D40:  MOVFF  03,107
4D44:  MOVFF  DB,151
4D48:  MOVFF  DA,150
4D4C:  MOVFF  D9,14F
4D50:  MOVFF  D8,14E
4D54:  MOVFF  DB,155
4D58:  MOVFF  DA,154
4D5C:  MOVFF  D9,153
4D60:  MOVFF  D8,152
4D64:  CALL   0E24
4D68:  BCF    FD8.1
4D6A:  MOVFF  107,153
4D6E:  MOVFF  106,152
4D72:  MOVFF  105,151
4D76:  MOVFF  104,150
4D7A:  MOVFF  03,157
4D7E:  MOVFF  02,156
4D82:  MOVFF  01,155
4D86:  MOVFF  00,154
4D8A:  CALL   1078
4D8E:  MOVFF  00,108
4D92:  MOVFF  01,109
4D96:  MOVFF  02,10A
4D9A:  MOVFF  03,10B
4D9E:  MOVFF  03,115
4DA2:  MOVFF  02,114
4DA6:  MOVFF  01,113
4DAA:  MOVFF  00,112
4DAE:  RCALL  48D0
4DB0:  MOVFF  00,109
4DB4:  MOVFF  01,10A
4DB8:  MOVFF  02,10B
4DBC:  MOVFF  03,10C
4DC0:  MOVFF  E3,14D
4DC4:  MOVFF  E2,14C
4DC8:  MOVFF  E1,14B
4DCC:  MOVFF  E0,14A
4DD0:  MOVFF  F3,151
4DD4:  MOVFF  F2,150
4DD8:  MOVFF  F1,14F
4DDC:  MOVFF  F0,14E
4DE0:  CALL   0F1A
4DE4:  MOVFF  FEA,10E
4DE8:  MOVFF  FE9,10D
4DEC:  BSF    FD8.1
4DEE:  MOVFF  10C,153
4DF2:  MOVFF  10B,152
4DF6:  MOVFF  10A,151
4DFA:  MOVFF  109,150
4DFE:  MOVFF  03,157
4E02:  MOVFF  02,156
4E06:  MOVFF  01,155
4E0A:  MOVFF  00,154
4E0E:  CALL   1078
4E12:  MOVFF  10E,FEA
4E16:  MOVFF  10D,FE9
4E1A:  MOVFF  03,DF
4E1E:  MOVFF  02,DE
4E22:  MOVFF  01,DD
4E26:  MOVFF  00,DC
.................... temp1 = len_a - (len_p/tan_beta)-len_c*cos_beta; 
4E2A:  MOVFF  E3,14D
4E2E:  MOVFF  E2,14C
4E32:  MOVFF  E1,14B
4E36:  MOVFF  E0,14A
4E3A:  MOVFF  FB,151
4E3E:  MOVFF  FA,150
4E42:  MOVFF  F9,14F
4E46:  MOVFF  F8,14E
4E4A:  CALL   0F1A
4E4E:  BSF    FD8.1
4E50:  MOVFF  D7,153
4E54:  MOVFF  D6,152
4E58:  MOVFF  D5,151
4E5C:  MOVFF  D4,150
4E60:  MOVFF  03,157
4E64:  MOVFF  02,156
4E68:  MOVFF  01,155
4E6C:  MOVFF  00,154
4E70:  CALL   1078
4E74:  MOVFF  00,104
4E78:  MOVFF  01,105
4E7C:  MOVFF  02,106
4E80:  MOVFF  03,107
4E84:  MOVFF  DF,151
4E88:  MOVFF  DE,150
4E8C:  MOVFF  DD,14F
4E90:  MOVFF  DC,14E
4E94:  MOVFF  F7,155
4E98:  MOVFF  F6,154
4E9C:  MOVFF  F5,153
4EA0:  MOVFF  F4,152
4EA4:  CALL   0E24
4EA8:  BSF    FD8.1
4EAA:  MOVFF  107,153
4EAE:  MOVFF  106,152
4EB2:  MOVFF  105,151
4EB6:  MOVFF  104,150
4EBA:  MOVFF  03,157
4EBE:  MOVFF  02,156
4EC2:  MOVFF  01,155
4EC6:  MOVFF  00,154
4ECA:  CALL   1078
4ECE:  MOVFF  03,FF
4ED2:  MOVFF  02,FE
4ED6:  MOVFF  01,FD
4EDA:  MOVFF  00,FC
.................... len_l = len_c*sin_beta*len_c*sin_beta+temp1*temp1-len_m*len_m; 
4EDE:  MOVFF  DF,151
4EE2:  MOVFF  DE,150
4EE6:  MOVFF  DD,14F
4EEA:  MOVFF  DC,14E
4EEE:  MOVFF  F3,155
4EF2:  MOVFF  F2,154
4EF6:  MOVFF  F1,153
4EFA:  MOVFF  F0,152
4EFE:  CALL   0E24
4F02:  MOVFF  00,104
4F06:  MOVFF  01,105
4F0A:  MOVFF  02,106
4F0E:  MOVFF  03,107
4F12:  MOVFF  03,151
4F16:  MOVFF  02,150
4F1A:  MOVFF  01,14F
4F1E:  MOVFF  00,14E
4F22:  MOVFF  DF,155
4F26:  MOVFF  DE,154
4F2A:  MOVFF  DD,153
4F2E:  MOVFF  DC,152
4F32:  CALL   0E24
4F36:  MOVFF  00,108
4F3A:  MOVFF  01,109
4F3E:  MOVFF  02,10A
4F42:  MOVFF  03,10B
4F46:  MOVFF  03,151
4F4A:  MOVFF  02,150
4F4E:  MOVFF  01,14F
4F52:  MOVFF  00,14E
4F56:  MOVFF  F3,155
4F5A:  MOVFF  F2,154
4F5E:  MOVFF  F1,153
4F62:  MOVFF  F0,152
4F66:  CALL   0E24
4F6A:  MOVFF  00,10C
4F6E:  MOVFF  01,10D
4F72:  MOVFF  02,10E
4F76:  MOVFF  03,10F
4F7A:  MOVFF  FF,151
4F7E:  MOVFF  FE,150
4F82:  MOVFF  FD,14F
4F86:  MOVFF  FC,14E
4F8A:  MOVFF  FF,155
4F8E:  MOVFF  FE,154
4F92:  MOVFF  FD,153
4F96:  MOVFF  FC,152
4F9A:  CALL   0E24
4F9E:  BCF    FD8.1
4FA0:  MOVFF  10F,153
4FA4:  MOVFF  10E,152
4FA8:  MOVFF  10D,151
4FAC:  MOVFF  10C,150
4FB0:  MOVFF  03,157
4FB4:  MOVFF  02,156
4FB8:  MOVFF  01,155
4FBC:  MOVFF  00,154
4FC0:  CALL   1078
4FC4:  MOVFF  00,110
4FC8:  MOVFF  01,111
4FCC:  MOVFF  02,112
4FD0:  MOVFF  03,113
4FD4:  MOVFF  E7,151
4FD8:  MOVFF  E6,150
4FDC:  MOVFF  E5,14F
4FE0:  MOVFF  E4,14E
4FE4:  MOVFF  E7,155
4FE8:  MOVFF  E6,154
4FEC:  MOVFF  E5,153
4FF0:  MOVFF  E4,152
4FF4:  CALL   0E24
4FF8:  BSF    FD8.1
4FFA:  MOVFF  113,153
4FFE:  MOVFF  112,152
5002:  MOVFF  111,151
5006:  MOVFF  110,150
500A:  MOVFF  03,157
500E:  MOVFF  02,156
5012:  MOVFF  01,155
5016:  MOVFF  00,154
501A:  CALL   1078
501E:  MOVFF  03,EF
5022:  MOVFF  02,EE
5026:  MOVFF  01,ED
502A:  MOVFF  00,EC
.................... len_l = sqrt(len_l); 
502E:  MOVFF  EF,115
5032:  MOVFF  EE,114
5036:  MOVFF  ED,113
503A:  MOVFF  EC,112
503E:  RCALL  48D0
5040:  MOVFF  03,EF
5044:  MOVFF  02,EE
5048:  MOVFF  01,ED
504C:  MOVFF  00,EC
....................  
.................... if (len_l<50.0) 
5050:  MOVFF  EF,14D
5054:  MOVFF  EE,14C
5058:  MOVFF  ED,14B
505C:  MOVFF  EC,14A
5060:  MOVLB  1
5062:  CLRF   x51
5064:  CLRF   x50
5066:  MOVLW  48
5068:  MOVWF  x4F
506A:  MOVLW  84
506C:  MOVWF  x4E
506E:  MOVLB  0
5070:  CALL   3E46
5074:  BNC   5080
....................    return 0.0; 
5076:  CLRF   00
5078:  CLRF   01
507A:  CLRF   02
507C:  CLRF   03
507E:  BRA    5090
....................  
.................... return len_l; 
5080:  MOVFF  EC,00
5084:  MOVFF  ED,01
5088:  MOVFF  EE,02
508C:  MOVFF  EF,03
.................... } 
5090:  RETLW  00
....................  
.................... void process_cmd_msg(){ 
....................     flag.cmd_posted =false; 
*
2F8E:  BCF    1F.3
....................    switch (cmd_msg[0]) { 
2F90:  MOVLW  63
2F92:  SUBWF  54,W
2F94:  ADDLW  E9
2F96:  BTFSC  FD8.0
2F98:  BRA    3626
2F9A:  ADDLW  17
2F9C:  GOTO   3628
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
2FA0:  CLRF   FEA
2FA2:  MOVLW  54
2FA4:  MOVWF  FE9
2FA6:  CLRF   FE2
2FA8:  MOVLW  55
2FAA:  MOVWF  FE1
2FAC:  MOVLW  12
2FAE:  MOVWF  01
2FB0:  MOVFF  FE6,FEE
2FB4:  DECFSZ 01,F
2FB6:  BRA    2FB0
....................            if (atol(cmd_msg)==0) break; 
2FB8:  CLRF   xD2
2FBA:  MOVLW  54
2FBC:  MOVWF  xD1
2FBE:  CALL   0ADA
2FC2:  MOVFF  02,D2
2FC6:  MOVFF  01,D1
2FCA:  MOVF   xD1,F
2FCC:  BNZ   2FD4
2FCE:  MOVF   xD2,F
2FD0:  BNZ   2FD4
2FD2:  BRA    3626
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
2FD4:  CLRF   xD2
2FD6:  MOVLW  54
2FD8:  MOVWF  xD1
2FDA:  CALL   0ADA
2FDE:  MOVFF  02,D2
2FE2:  MOVFF  01,D1
2FE6:  MOVFF  02,D4
2FEA:  MOVFF  01,D3
2FEE:  MOVLW  23
2FF0:  MOVWF  xD6
2FF2:  MOVLW  28
2FF4:  MOVWF  xD5
2FF6:  MOVFF  C1,D8
2FFA:  MOVFF  C0,D7
2FFE:  MOVLW  01
3000:  MOVWF  xD9
3002:  CLRF   xDA
3004:  CALL   21A4
....................          break;    } 
3008:  BRA    3626
....................  
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
300A:  CLRF   FEA
300C:  MOVLW  54
300E:  MOVWF  FE9
3010:  CLRF   FE2
3012:  MOVLW  55
3014:  MOVWF  FE1
3016:  MOVLW  12
3018:  MOVWF  01
301A:  MOVFF  FE6,FEE
301E:  DECFSZ 01,F
3020:  BRA    301A
....................            if (atol(cmd_msg)==0) break; 
3022:  CLRF   xD2
3024:  MOVLW  54
3026:  MOVWF  xD1
3028:  CALL   0ADA
302C:  MOVFF  02,D2
3030:  MOVFF  01,D1
3034:  MOVF   xD1,F
3036:  BNZ   303E
3038:  MOVF   xD2,F
303A:  BNZ   303E
303C:  BRA    3626
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
303E:  CLRF   xD2
3040:  MOVLW  54
3042:  MOVWF  xD1
3044:  CALL   0ADA
3048:  MOVFF  02,D2
304C:  MOVFF  01,D1
3050:  MOVFF  02,D4
3054:  MOVFF  01,D3
3058:  MOVLW  23
305A:  MOVWF  xD6
305C:  MOVLW  28
305E:  MOVWF  xD5
3060:  MOVFF  C1,D8
3064:  MOVFF  C0,D7
3068:  CLRF   xD9
306A:  CLRF   xDA
306C:  CALL   21A4
....................          break;    } 
3070:  BRA    3626
.................... /* 
....................       case 'x':{ 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................            if (atol(cmd_msg)==1) { 
....................             setup_timer_0(RTCC_DIV_32); 
....................             move_act_time_out =4; 
....................          } else if(atol(cmd_msg)==2) { 
....................             setup_timer_0(RTCC_DIV_1); 
....................             move_act_time_out =128; 
....................          } 
....................          break;    }    
.................... */    
....................       case 'd':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3072:  CLRF   FEA
3074:  MOVLW  54
3076:  MOVWF  FE9
3078:  CLRF   FE2
307A:  MOVLW  55
307C:  MOVWF  FE1
307E:  MOVLW  12
3080:  MOVWF  01
3082:  MOVFF  FE6,FEE
3086:  DECFSZ 01,F
3088:  BRA    3082
....................            if (atol(cmd_msg)==0) break; 
308A:  CLRF   xD2
308C:  MOVLW  54
308E:  MOVWF  xD1
3090:  CALL   0ADA
3094:  MOVFF  02,D2
3098:  MOVFF  01,D1
309C:  MOVF   xD1,F
309E:  BNZ   30A6
30A0:  MOVF   xD2,F
30A2:  BNZ   30A6
30A4:  BRA    3626
....................          PORTE.tx_en=1; 
30A6:  BSF    F84.2
....................          printf("\r\n DL %ld pages ..",atol(cmd_msg)); 
30A8:  CLRF   xD2
30AA:  MOVLW  54
30AC:  MOVWF  xD1
30AE:  CALL   0ADA
30B2:  MOVFF  02,D2
30B6:  MOVFF  01,D1
30BA:  CLRF   xD3
30BC:  MOVF   xD3,W
30BE:  CALL   0170
30C2:  INCF   xD3,F
30C4:  MOVWF  00
30C6:  MOVF   00,W
30C8:  BTFSS  F9E.4
30CA:  BRA    30C8
30CC:  MOVWF  FAD
30CE:  MOVLW  06
30D0:  SUBWF  xD3,W
30D2:  BNZ   30BC
30D4:  MOVLW  10
30D6:  MOVWF  FE9
30D8:  MOVFF  D2,D5
30DC:  MOVFF  D1,D4
30E0:  CALL   23CC
30E4:  MOVLW  09
30E6:  MOVWF  xD4
30E8:  MOVF   xD4,W
30EA:  CALL   0170
30EE:  INCF   xD4,F
30F0:  MOVWF  00
30F2:  MOVF   00,W
30F4:  BTFSS  F9E.4
30F6:  BRA    30F4
30F8:  MOVWF  FAD
30FA:  MOVLW  12
30FC:  SUBWF  xD4,W
30FE:  BNZ   30E8
....................          tx_delay=TX_DLY_TIME; 
3100:  MOVLW  01
3102:  MOVWF  xC2
....................            download_sun_table(atol(cmd_msg)); 
3104:  CLRF   xD2
3106:  MOVLW  54
3108:  MOVWF  xD1
310A:  CALL   0ADA
310E:  MOVFF  02,D2
3112:  MOVFF  01,D1
3116:  MOVFF  02,D4
311A:  MOVFF  01,D3
311E:  GOTO   264C
....................          break;    } 
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
3122:  BCF    FF2.6
3124:  BCF    FF2.7
3126:  BTFSC  FF2.7
3128:  BRA    3124
....................          restart_wdt(); 
312A:  CLRWDT
....................          setup_wdt(WDT_OFF); 
312C:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
312E:  CLRF   FEA
3130:  MOVLW  54
3132:  MOVWF  FE9
3134:  CLRF   FE2
3136:  MOVLW  55
3138:  MOVWF  FE1
313A:  MOVLW  12
313C:  MOVWF  01
313E:  MOVFF  FE6,FEE
3142:  DECFSZ 01,F
3144:  BRA    313E
....................          PORTE.tx_en=1; 
3146:  BSF    F84.2
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
3148:  CLRF   xD2
314A:  MOVLW  54
314C:  MOVWF  xD1
314E:  CALL   0ADA
3152:  MOVFF  02,D2
3156:  MOVFF  01,D1
315A:  CLRF   xD3
315C:  MOVF   xD3,W
315E:  CALL   019E
3162:  INCF   xD3,F
3164:  MOVWF  00
3166:  MOVF   00,W
3168:  BTFSS  F9E.4
316A:  BRA    3168
316C:  MOVWF  FAD
316E:  MOVLW  08
3170:  SUBWF  xD3,W
3172:  BNZ   315C
3174:  MOVLW  10
3176:  MOVWF  FE9
3178:  MOVFF  D2,D5
317C:  MOVFF  D1,D4
3180:  CALL   23CC
3184:  MOVLW  3A
3186:  BTFSS  F9E.4
3188:  BRA    3186
318A:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
318C:  MOVLW  01
318E:  MOVWF  xC2
....................          print_page_data(atol(cmd_msg)); 
3190:  CLRF   xD2
3192:  MOVLW  54
3194:  MOVWF  xD1
3196:  CALL   0ADA
319A:  MOVFF  02,D2
319E:  MOVFF  01,D1
31A2:  MOVFF  02,D4
31A6:  MOVFF  01,D3
31AA:  GOTO   2830
....................          enable_interrupts(GLOBAL); 
31AE:  MOVLW  C0
31B0:  IORWF  FF2,F
....................          restart_wdt(); 
31B2:  CLRWDT
....................          setup_wdt(WDT_ON); 
31B4:  BSF    FD1.0
....................             break; } 
31B6:  BRA    3626
....................         case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
31B8:  CLRF   FEA
31BA:  MOVLW  54
31BC:  MOVWF  FE9
31BE:  CLRF   FE2
31C0:  MOVLW  55
31C2:  MOVWF  FE1
31C4:  MOVLW  12
31C6:  MOVWF  01
31C8:  MOVFF  FE6,FEE
31CC:  DECFSZ 01,F
31CE:  BRA    31C8
....................             if (atol(cmd_msg)!=22) break; 
31D0:  CLRF   xD2
31D2:  MOVLW  54
31D4:  MOVWF  xD1
31D6:  CALL   0ADA
31DA:  MOVFF  02,D2
31DE:  MOVF   01,W
31E0:  MOVWF  xD1
31E2:  SUBLW  16
31E4:  BNZ   31EA
31E6:  MOVF   xD2,F
31E8:  BZ    31EC
31EA:  BRA    3626
....................          PORTE.tx_en=1; 
31EC:  BSF    F84.2
....................          printf("\r\ndeleting entire flash data "); 
31EE:  CLRF   xD1
31F0:  MOVF   xD1,W
31F2:  CALL   01C6
31F6:  INCF   xD1,F
31F8:  MOVWF  00
31FA:  MOVF   00,W
31FC:  BTFSS  F9E.4
31FE:  BRA    31FC
3200:  MOVWF  FAD
3202:  MOVLW  1D
3204:  SUBWF  xD1,W
3206:  BNZ   31F0
....................          tx_delay=TX_DLY_TIME; 
3208:  MOVLW  01
320A:  MOVWF  xC2
....................          ext_flash_block_erase(); 
320C:  GOTO   28CA
....................             break; } 
....................       case 't': { // timer set 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3210:  CLRF   FEA
3212:  MOVLW  54
3214:  MOVWF  FE9
3216:  CLRF   FE2
3218:  MOVLW  55
321A:  MOVWF  FE1
321C:  MOVLW  12
321E:  MOVWF  01
3220:  MOVFF  FE6,FEE
3224:  DECFSZ 01,F
3226:  BRA    3220
....................          timer_sec=atoi32(cmd_msg); 
3228:  CLRF   xD2
322A:  MOVLW  54
322C:  MOVWF  xD1
322E:  GOTO   290A
3232:  MOVFF  03,23
3236:  MOVFF  02,22
323A:  MOVFF  01,21
323E:  MOVFF  00,20
....................          lcd_send_cmd(0,0x02); 
3242:  CLRF   xEE
3244:  MOVLW  02
3246:  MOVWF  xEF
3248:  CALL   09D6
324C:  CLRF   18
324E:  BTFSC  FF2.7
3250:  BSF    18.7
3252:  BCF    FF2.7
....................          next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
3254:  MOVFF  23,EE
3258:  MOVFF  22,ED
325C:  MOVFF  21,EC
3260:  MOVFF  20,EB
3264:  MOVLW  07
3266:  MOVWF  xF2
3268:  MOVLW  86
326A:  MOVWF  xF1
326C:  MOVLW  1F
326E:  MOVWF  xF0
3270:  MOVLW  80
3272:  MOVWF  xEF
3274:  CALL   0340
3278:  BTFSC  18.7
327A:  BSF    FF2.7
327C:  MOVFF  FEF,D1
3280:  MOVFF  FEC,D2
3284:  MOVFF  FEC,D3
3288:  MOVFF  FEC,D4
328C:  MOVFF  D4,E4
3290:  MOVFF  D3,E3
3294:  MOVFF  D2,E2
3298:  MOVFF  D1,E1
329C:  RCALL  2BA8
329E:  MOVFF  02,D3
32A2:  MOVFF  01,D2
32A6:  MOVFF  02,E2
32AA:  MOVFF  01,E1
32AE:  RCALL  2C42
32B0:  MOVFF  03,D6
32B4:  MOVFF  02,D5
32B8:  MOVFF  01,D4
32BC:  MOVFF  00,D3
32C0:  MOVFF  FEA,D8
32C4:  MOVFF  FE9,D7
32C8:  MOVFF  03,F8
32CC:  MOVFF  02,F7
32D0:  MOVFF  01,F6
32D4:  MOVFF  00,F5
32D8:  CLRF   xFC
32DA:  CLRF   xFB
32DC:  MOVLW  01
32DE:  MOVWF  xFA
32E0:  MOVLW  C2
32E2:  MOVWF  xF9
32E4:  CALL   1330
32E8:  MOVFF  D8,FEA
32EC:  MOVFF  D7,FE9
32F0:  MOVFF  03,6D
32F4:  MOVFF  02,6C
32F8:  MOVFF  01,6B
32FC:  MOVFF  00,6A
....................          enable_interrupts(INT_TIMER1);    
3300:  BSF    F9D.0
....................          enable_interrupts(GLOBAL);  
3302:  MOVLW  C0
3304:  IORWF  FF2,F
....................          flag.task1_armed=true; 
3306:  BSF    1F.0
....................          write_eeprom_data(0); // save full_stroke_tick and current_position 
3308:  CLRF   xD1
330A:  CALL   0820
330E:  CLRF   18
3310:  BTFSC  FF2.7
3312:  BSF    18.7
3314:  BCF    FF2.7
....................           ext_flash_main_memory_to_buffer1(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
3316:  MOVFF  23,EE
331A:  MOVFF  22,ED
331E:  MOVFF  21,EC
3322:  MOVFF  20,EB
3326:  MOVLW  07
3328:  MOVWF  xF2
332A:  MOVLW  86
332C:  MOVWF  xF1
332E:  MOVLW  1F
3330:  MOVWF  xF0
3332:  MOVLW  80
3334:  MOVWF  xEF
3336:  CALL   0340
333A:  BTFSC  18.7
333C:  BSF    FF2.7
333E:  MOVFF  FEF,D1
3342:  MOVFF  FEC,D2
3346:  MOVFF  FEC,D3
334A:  MOVFF  FEC,D4
334E:  MOVFF  D4,E4
3352:  MOVFF  D3,E3
3356:  MOVFF  D2,E2
335A:  MOVFF  D1,E1
335E:  RCALL  2BA8
3360:  MOVFF  02,D3
3364:  MOVFF  01,D2
3368:  BCF    FD8.0
336A:  RRCF   02,W
336C:  MOVWF  03
336E:  RRCF   01,W
3370:  MOVWF  02
3372:  ADDLW  F2
3374:  MOVWF  xD4
3376:  MOVLW  03
3378:  ADDWFC 03,W
337A:  MOVWF  xD5
337C:  MOVWF  xD7
337E:  MOVFF  D4,D6
3382:  RCALL  2CCA
....................          flag.setup_required =false; 
3384:  BCF    1F.4
....................          break; 
3386:  BRA    3626
....................       } 
....................       case 'h' : { //return home 
....................          move_act(2000,9000,move_act_time_out,1,0); // move actuator to west 
3388:  MOVLW  07
338A:  MOVWF  xD4
338C:  MOVLW  D0
338E:  MOVWF  xD3
3390:  MOVLW  23
3392:  MOVWF  xD6
3394:  MOVLW  28
3396:  MOVWF  xD5
3398:  MOVFF  C1,D8
339C:  MOVFF  C0,D7
33A0:  MOVLW  01
33A2:  MOVWF  xD9
33A4:  CLRF   xDA
33A6:  CALL   21A4
....................          move_act(2000,9000,move_act_time_out,0,0); // move actuator to home position 
33AA:  MOVLW  07
33AC:  MOVWF  xD4
33AE:  MOVLW  D0
33B0:  MOVWF  xD3
33B2:  MOVLW  23
33B4:  MOVWF  xD6
33B6:  MOVLW  28
33B8:  MOVWF  xD5
33BA:  MOVFF  C1,D8
33BE:  MOVFF  C0,D7
33C2:  CLRF   xD9
33C4:  CLRF   xDA
33C6:  CALL   21A4
....................          FULL_STROKE_TICK= actuator_pulse; 
33CA:  MOVFF  C9,BB
33CE:  MOVFF  C8,BA
....................          current_act_position =0; 
33D2:  CLRF   x6F
33D4:  CLRF   x6E
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
33D6:  MOVLW  01
33D8:  MOVWF  xD1
33DA:  CALL   0820
....................          break; 
33DE:  BRA    3626
....................       } 
.................... /* 
....................       case 'g': { 
....................          print_date_time(); 
....................           break; 
....................       } 
....................       case 'a': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          PORTE.tx_en=1; 
....................          printf("\r\n   Sun angle %u, stroke length =%f",atoi(cmd_msg),actuator_length(atoi(cmd_msg))); 
....................          tx_delay=TX_DLY_TIME; 
....................          break; 
....................       } 
.................... */ 
....................       case 's': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
33E0:  CLRF   FEA
33E2:  MOVLW  54
33E4:  MOVWF  FE9
33E6:  CLRF   FE2
33E8:  MOVLW  55
33EA:  MOVWF  FE1
33EC:  MOVLW  12
33EE:  MOVWF  01
33F0:  MOVFF  FE6,FEE
33F4:  DECFSZ 01,F
33F6:  BRA    33F0
....................             if (atol(cmd_msg)!=22) break; 
33F8:  CLRF   xD2
33FA:  MOVLW  54
33FC:  MOVWF  xD1
33FE:  CALL   0ADA
3402:  MOVFF  02,D2
3406:  MOVF   01,W
3408:  MOVWF  xD1
340A:  SUBLW  16
340C:  BNZ   3412
340E:  MOVF   xD2,F
3410:  BZ    3414
3412:  BRA    3626
....................          write_eeprom_data(1); 
3414:  MOVLW  01
3416:  MOVWF  xD1
3418:  CALL   0820
....................          break; 
341C:  BRA    3626
....................       } 
....................       case 'y': { //adc conversion 
....................          set_adc_channel( 0 ); 
341E:  MOVLW  00
3420:  MOVWF  01
3422:  MOVF   FC2,W
3424:  ANDLW  C7
3426:  IORWF  01,W
3428:  MOVWF  FC2
....................          delay_us(20); 
342A:  MOVLW  10
342C:  MOVWF  00
342E:  DECFSZ 00,F
3430:  BRA    342E
3432:  NOP   
....................          current_measured = (read_adc()); 
3434:  BSF    FC2.2
3436:  BTFSC  FC2.2
3438:  BRA    3436
343A:  MOVFF  FC3,C3
343E:  MOVFF  FC4,C4
....................          printf("\r\nADC= %lu",current_measured); 
3442:  CLRF   xD1
3444:  MOVF   xD1,W
3446:  CALL   01FE
344A:  INCF   xD1,F
344C:  MOVWF  00
344E:  MOVF   00,W
3450:  BTFSS  F9E.4
3452:  BRA    3450
3454:  MOVWF  FAD
3456:  MOVLW  07
3458:  SUBWF  xD1,W
345A:  BNZ   3444
345C:  MOVLW  10
345E:  MOVWF  FE9
3460:  MOVFF  C4,D6
3464:  MOVFF  C3,D5
3468:  RCALL  2CFA
....................          break; 
346A:  BRA    3626
....................       } 
....................       case 'w': { //buffer1 read 
....................          //ext_flash_buffer1_write(0x00,0x00, 1); 
....................          //ext_flash_buffer1_read(); 
....................          //ext_flash_buffer1_write(0x12,0xAA, 0); 
....................          disable_interrupts(GLOBAL); 
346C:  BCF    FF2.6
346E:  BCF    FF2.7
3470:  BTFSC  FF2.7
3472:  BRA    346E
....................          restart_wdt(); 
3474:  CLRWDT
....................          setup_wdt(WDT_OFF); 
3476:  BCF    FD1.0
....................          ext_flash_buffer1_read(); 
3478:  BRA    2D9E
....................          enable_interrupts(GLOBAL); 
347A:  MOVLW  C0
347C:  IORWF  FF2,F
....................          restart_wdt(); 
347E:  CLRWDT
....................          setup_wdt(WDT_ON); 
3480:  BSF    FD1.0
....................  
....................          //ext_flash_write_buffer1_to_main_memory(1024); 
....................          break; 
3482:  BRA    3626
....................       } 
....................       case 'i': { //adc conversion 
....................          printf("\r\nAct:%lu/%lu",current_act_position,FULL_STROKE_TICK); 
3484:  CLRF   xD1
3486:  MOVF   xD1,W
3488:  CALL   0224
348C:  INCF   xD1,F
348E:  MOVWF  00
3490:  MOVF   00,W
3492:  BTFSS  F9E.4
3494:  BRA    3492
3496:  MOVWF  FAD
3498:  MOVLW  06
349A:  SUBWF  xD1,W
349C:  BNZ   3486
349E:  MOVLW  10
34A0:  MOVWF  FE9
34A2:  MOVFF  6F,D6
34A6:  MOVFF  6E,D5
34AA:  RCALL  2CFA
34AC:  MOVLW  2F
34AE:  BTFSS  F9E.4
34B0:  BRA    34AE
34B2:  MOVWF  FAD
34B4:  MOVLW  10
34B6:  MOVWF  FE9
34B8:  MOVFF  BB,D6
34BC:  MOVFF  BA,D5
34C0:  RCALL  2CFA
....................          printf("\r\nRestart:%lu",startup_counter); 
34C2:  CLRF   xD1
34C4:  MOVF   xD1,W
34C6:  CALL   024C
34CA:  INCF   xD1,F
34CC:  MOVWF  00
34CE:  MOVF   00,W
34D0:  BTFSS  F9E.4
34D2:  BRA    34D0
34D4:  MOVWF  FAD
34D6:  MOVLW  0A
34D8:  SUBWF  xD1,W
34DA:  BNZ   34C4
34DC:  MOVLW  10
34DE:  MOVWF  FE9
34E0:  MOVFF  C7,D6
34E4:  MOVFF  C6,D5
34E8:  RCALL  2CFA
....................          printf("\r\nCurrent:%lu (%d)",current_measured/n_avg_current_measured, n_avg_current_measured); 
34EA:  MOVFF  C4,D4
34EE:  MOVFF  C3,D3
34F2:  CLRF   xD6
34F4:  MOVFF  C5,D5
34F8:  RCALL  2E24
34FA:  MOVFF  02,D2
34FE:  MOVFF  01,D1
3502:  CLRF   xD3
3504:  MOVF   xD3,W
3506:  CALL   0274
350A:  INCF   xD3,F
350C:  MOVWF  00
350E:  MOVF   00,W
3510:  BTFSS  F9E.4
3512:  BRA    3510
3514:  MOVWF  FAD
3516:  MOVLW  0A
3518:  SUBWF  xD3,W
351A:  BNZ   3504
351C:  MOVLW  10
351E:  MOVWF  FE9
3520:  MOVFF  D2,D6
3524:  MOVFF  D1,D5
3528:  CALL   2CFA
352C:  MOVLW  20
352E:  BTFSS  F9E.4
3530:  BRA    352E
3532:  MOVWF  FAD
3534:  MOVLW  28
3536:  BTFSS  F9E.4
3538:  BRA    3536
353A:  MOVWF  FAD
353C:  MOVFF  C5,D4
3540:  MOVLW  1F
3542:  MOVWF  xD5
3544:  CALL   0750
3548:  MOVLW  29
354A:  BTFSS  F9E.4
354C:  BRA    354A
354E:  MOVWF  FAD
....................          printf("\r\nTimer:%lu",timer_sec); 
3550:  CLRF   xD1
3552:  MOVF   xD1,W
3554:  CALL   02A2
3558:  INCF   xD1,F
355A:  MOVWF  00
355C:  MOVF   00,W
355E:  BTFSS  F9E.4
3560:  BRA    355E
3562:  MOVWF  FAD
3564:  MOVLW  08
3566:  SUBWF  xD1,W
3568:  BNZ   3552
356A:  MOVLW  41
356C:  MOVWF  FE9
356E:  MOVFF  23,D5
3572:  MOVFF  22,D4
3576:  MOVFF  21,D3
357A:  MOVFF  20,D2
357E:  BRA    2E66
3580:  CLRF   18
3582:  BTFSC  FF2.7
3584:  BSF    18.7
3586:  BCF    FF2.7
....................          printf("\r\n#Day:%lu",find_day_number((timer_sec)%SEC_IN_4_YEARS)); 
3588:  MOVFF  23,EE
358C:  MOVFF  22,ED
3590:  MOVFF  21,EC
3594:  MOVFF  20,EB
3598:  MOVLW  07
359A:  MOVWF  xF2
359C:  MOVLW  86
359E:  MOVWF  xF1
35A0:  MOVLW  1F
35A2:  MOVWF  xF0
35A4:  MOVLW  80
35A6:  MOVWF  xEF
35A8:  CALL   0340
35AC:  BTFSC  18.7
35AE:  BSF    FF2.7
35B0:  MOVFF  FEF,D1
35B4:  MOVFF  FEC,D2
35B8:  MOVFF  FEC,D3
35BC:  MOVFF  FEC,D4
35C0:  MOVFF  D4,E4
35C4:  MOVFF  D3,E3
35C8:  MOVFF  D2,E2
35CC:  MOVFF  D1,E1
35D0:  CALL   2BA8
35D4:  MOVFF  02,D3
35D8:  MOVFF  01,D2
35DC:  CLRF   xD4
35DE:  MOVF   xD4,W
35E0:  CALL   02C8
35E4:  INCF   xD4,F
35E6:  MOVWF  00
35E8:  MOVF   00,W
35EA:  BTFSS  F9E.4
35EC:  BRA    35EA
35EE:  MOVWF  FAD
35F0:  MOVLW  07
35F2:  SUBWF  xD4,W
35F4:  BNZ   35DE
35F6:  MOVLW  10
35F8:  MOVWF  FE9
35FA:  MOVFF  D3,D6
35FE:  MOVFF  D2,D5
3602:  CALL   2CFA
....................  
....................          break; 
3606:  BRA    3626
....................       } 
....................       case 'c': { //clear write buffer 
....................           ext_flash_buffer1_write(0xAA,0,255); 
3608:  MOVLW  AA
360A:  MOVWF  xDC
360C:  CLRF   xDD
360E:  MOVLW  FF
3610:  MOVWF  xDE
3612:  RCALL  2F30
....................          break; 
3614:  BRA    3626
....................       } 
....................  
....................       case 'x': { //stop timer 
....................          flag.setup_required=true;          
3616:  BSF    1F.4
....................          restart_wdt(); 
3618:  CLRWDT
....................          setup_wdt(WDT_OFF); 
361A:  BCF    FD1.0
....................          break; 
361C:  BRA    3626
....................       } 
....................  
....................       case 'o': { //start timer 
....................          flag.setup_required=false;          
361E:  BCF    1F.4
....................          setup_wdt(WDT_ON); 
3620:  BSF    FD1.0
....................          restart_wdt(); 
3622:  CLRWDT
....................          break; 
3624:  BRA    3626
....................       } 
....................  
....................  
....................       } 
....................        
....................    } 
3626:  RETLW  00
....................  
.................... void print_len_and_tick() 
.................... { 
....................    lcd_gotoxy(0,3); 
*
5D02:  CLRF   xEA
5D04:  MOVLW  03
5D06:  MOVWF  xEB
5D08:  CALL   0CC2
....................    itoa((int16)(al),10,tmp_str); 
5D0C:  MOVFF  BF,14D
5D10:  MOVFF  BE,14C
5D14:  MOVFF  BD,14B
5D18:  MOVFF  BC,14A
5D1C:  CALL   4420
5D20:  MOVFF  02,D2
5D24:  MOVFF  01,D1
5D28:  CLRF   xE9
5D2A:  CLRF   xE8
5D2C:  MOVFF  02,E7
5D30:  MOVFF  01,E6
5D34:  MOVLW  0A
5D36:  MOVWF  xEA
5D38:  CLRF   xEC
5D3A:  MOVLW  2C
5D3C:  MOVWF  xEB
5D3E:  CALL   14A6
....................     printf(lcd_putc,"L=%s.",tmp_str); 
5D42:  MOVLW  4C
5D44:  MOVWF  xE9
5D46:  CALL   0CEA
5D4A:  MOVLW  3D
5D4C:  MOVWF  xE9
5D4E:  CALL   0CEA
5D52:  CLRF   FEA
5D54:  MOVLW  2C
5D56:  MOVWF  FE9
5D58:  MOVLW  00
5D5A:  IORWF  FEF,W
5D5C:  BZ    5D7E
5D5E:  MOVFF  FEA,D2
5D62:  MOVFF  FE9,D1
5D66:  MOVFF  FEF,E9
5D6A:  CALL   0CEA
5D6E:  MOVFF  D2,FEA
5D72:  MOVFF  D1,FE9
5D76:  INCF   FE9,F
5D78:  BTFSC  FD8.2
5D7A:  INCF   FEA,F
5D7C:  BRA    5D58
5D7E:  MOVLW  2E
5D80:  MOVWF  xE9
5D82:  CALL   0CEA
....................    itoa((int16)(al*100.0)%100,10,tmp_str); 
5D86:  MOVFF  BF,151
5D8A:  MOVFF  BE,150
5D8E:  MOVFF  BD,14F
5D92:  MOVFF  BC,14E
5D96:  MOVLB  1
5D98:  CLRF   x55
5D9A:  CLRF   x54
5D9C:  MOVLW  48
5D9E:  MOVWF  x53
5DA0:  MOVLW  85
5DA2:  MOVWF  x52
5DA4:  MOVLB  0
5DA6:  CALL   0E24
5DAA:  MOVFF  03,14D
5DAE:  MOVFF  02,14C
5DB2:  MOVFF  01,14B
5DB6:  MOVFF  00,14A
5DBA:  CALL   4420
5DBE:  MOVFF  02,D2
5DC2:  MOVFF  01,D1
5DC6:  MOVFF  02,D4
5DCA:  MOVFF  01,D3
5DCE:  CLRF   xD6
5DD0:  MOVLW  64
5DD2:  MOVWF  xD5
5DD4:  CALL   2E24
5DD8:  MOVFF  00,D2
5DDC:  MOVFF  03,D3
5DE0:  CLRF   xE9
5DE2:  CLRF   xE8
5DE4:  MOVFF  03,E7
5DE8:  MOVFF  00,E6
5DEC:  MOVLW  0A
5DEE:  MOVWF  xEA
5DF0:  CLRF   xEC
5DF2:  MOVLW  2C
5DF4:  MOVWF  xEB
5DF6:  CALL   14A6
....................     printf(lcd_putc,"%scm",tmp_str); 
5DFA:  CLRF   FEA
5DFC:  MOVLW  2C
5DFE:  MOVWF  FE9
5E00:  MOVLW  00
5E02:  IORWF  FEF,W
5E04:  BZ    5E26
5E06:  MOVFF  FEA,D2
5E0A:  MOVFF  FE9,D1
5E0E:  MOVFF  FEF,E9
5E12:  CALL   0CEA
5E16:  MOVFF  D2,FEA
5E1A:  MOVFF  D1,FE9
5E1E:  INCF   FE9,F
5E20:  BTFSC  FD8.2
5E22:  INCF   FEA,F
5E24:  BRA    5E00
5E26:  MOVLW  63
5E28:  MOVWF  xE9
5E2A:  CALL   0CEA
5E2E:  MOVLW  6D
5E30:  MOVWF  xE9
5E32:  CALL   0CEA
....................    lcd_gotoxy(11,3); 
5E36:  MOVLW  0B
5E38:  MOVWF  xEA
5E3A:  MOVLW  03
5E3C:  MOVWF  xEB
5E3E:  CALL   0CC2
....................     printf(lcd_putc,"*%4lu",target_act_position); 
5E42:  MOVLW  2A
5E44:  MOVWF  xE9
5E46:  CALL   0CEA
5E4A:  MOVLW  01
5E4C:  MOVWF  FE9
5E4E:  MOVFF  71,E1
5E52:  MOVFF  70,E0
5E56:  CALL   0D3C
....................  
.................... } 
5E5A:  RETLW  00
....................  
....................  
.................... void main() { 
5E5C:  CLRF   FF8
5E5E:  BCF    FD0.7
5E60:  BSF    0D.7
5E62:  CLRF   FEA
5E64:  CLRF   FE9
5E66:  MOVLW  0A
5E68:  MOVWF  FAF
5E6A:  MOVLW  A6
5E6C:  MOVWF  FAC
5E6E:  MOVLW  90
5E70:  MOVWF  FAB
5E72:  BSF    FC1.0
5E74:  BSF    FC1.1
5E76:  BSF    FC1.2
5E78:  BCF    FC1.3
5E7A:  MOVLW  07
5E7C:  MOVWF  FB4
5E7E:  CLRF   19
5E80:  CLRF   1A
5E82:  CLRF   20
5E84:  CLRF   21
5E86:  CLRF   22
5E88:  CLRF   23
5E8A:  CLRF   24
5E8C:  CLRF   25
5E8E:  CLRF   26
5E90:  CLRF   27
5E92:  CLRF   28
5E94:  CLRF   29
5E96:  CLRF   2A
5E98:  CLRF   2B
5E9A:  CLRF   x68
5E9C:  CLRF   x69
5E9E:  CLRF   x6E
5EA0:  CLRF   x6F
5EA2:  CLRF   x70
5EA4:  CLRF   x71
5EA6:  CLRF   xBA
5EA8:  CLRF   xBB
5EAA:  MOVLW  03
5EAC:  MOVWF  xC0
5EAE:  CLRF   xC1
5EB0:  CLRF   xC2
5EB2:  CLRF   xC3
5EB4:  CLRF   xC4
5EB6:  CLRF   xC5
5EB8:  CLRF   xC6
5EBA:  CLRF   xC7
5EBC:  CLRF   xC8
5EBE:  CLRF   xC9
....................     unsigned int8 solar_angle; 
....................    int16 tick=0; 
5EC0:  CLRF   xCC
5EC2:  CLRF   xCD
....................    int16 temp_mem; 
....................    int8 i; 
....................     set_tris_d(0x00); // all D are output 
5EC4:  MOVLW  00
5EC6:  MOVWF  F95
....................    set_tris_e(0b00000010); // RE1 = emergnecy input 
5EC8:  BCF    F96.0
5ECA:  BSF    F96.1
5ECC:  BCF    F96.2
....................    set_tris_a(0b11111111); // A0 -1 is output 
5ECE:  MOVLW  FF
5ED0:  MOVWF  F92
....................    set_tris_b(0xA0); 
5ED2:  MOVLW  A0
5ED4:  MOVWF  F93
....................    set_tris_c(0b10010000); 
5ED6:  MOVLW  90
5ED8:  MOVWF  F94
....................    timer_sec=0; 
5EDA:  CLRF   23
5EDC:  CLRF   22
5EDE:  CLRF   21
5EE0:  CLRF   20
5EE2:  CLRF   18
5EE4:  BTFSC  FF2.7
5EE6:  BSF    18.7
5EE8:  BCF    FF2.7
....................    delay_ms(200); 
5EEA:  MOVLW  C8
5EEC:  MOVWF  xEA
5EEE:  CALL   04BC
5EF2:  BTFSC  18.7
5EF4:  BSF    FF2.7
....................    read_eeprom_data(); 
5EF6:  GOTO   05BC
....................    restart_wdt(); 
5EFA:  CLRWDT
....................    setup_wdt(WDT_OFF); 
5EFC:  BCF    FD1.0
....................    setup_adc_ports(AN0); 
5EFE:  BCF    FC1.0
5F00:  BSF    FC1.1
5F02:  BSF    FC1.2
5F04:  BSF    FC1.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
5F06:  BCF    FC1.6
5F08:  BSF    FC2.6
5F0A:  BSF    FC2.7
5F0C:  BSF    FC1.7
5F0E:  BSF    FC2.0
....................    set_adc_channel( 0 ); 
5F10:  MOVLW  00
5F12:  MOVWF  01
5F14:  MOVF   FC2,W
5F16:  ANDLW  C7
5F18:  IORWF  01,W
5F1A:  MOVWF  FC2
....................    current_measured =0; 
5F1C:  CLRF   xC4
5F1E:  CLRF   xC3
....................    startup_counter++; 
5F20:  INCF   xC6,F
5F22:  BTFSC  FD8.2
5F24:  INCF   xC7,F
....................    printf("\r\nVer2.1 Restart Cause:%3d",restart_cause()); 
5F26:  MOVF   FD0,W
5F28:  ANDLW  0F
5F2A:  BTFSS  FD0.4
5F2C:  MOVLW  00
5F2E:  BSF    FD0.0
5F30:  BSF    FD0.1
5F32:  BSF    FD0.4
5F34:  BSF    FD8.3
5F36:  BSF    FD8.4
5F38:  MOVWF  xD1
5F3A:  CLRF   xD2
5F3C:  MOVF   xD2,W
5F3E:  CALL   02EE
5F42:  INCF   xD2,F
5F44:  MOVWF  00
5F46:  MOVF   00,W
5F48:  BTFSS  F9E.4
5F4A:  BRA    5F48
5F4C:  MOVWF  FAD
5F4E:  MOVLW  17
5F50:  SUBWF  xD2,W
5F52:  BNZ   5F3C
5F54:  MOVFF  D1,D4
5F58:  MOVLW  13
5F5A:  MOVWF  xD5
5F5C:  CALL   0750
....................    write_eeprom_data(0); 
5F60:  CLRF   xD1
5F62:  CALL   0820
....................    output_low(CCW); 
5F66:  BCF    F93.4
5F68:  BCF    F8A.4
....................    output_low(EN0); 
5F6A:  BCF    F93.0
5F6C:  BCF    F8A.0
....................    output_low(EN1); 
5F6E:  BCF    F93.1
5F70:  BCF    F8A.1
....................    output_low(EN2); 
5F72:  BCF    F93.2
5F74:  BCF    F8A.2
....................    output_low(EN3); 
5F76:  BCF    F93.3
5F78:  BCF    F8A.3
....................    PORTD.ps_en=1; 
5F7A:  BSF    F83.4
....................    PORTD.disp_en=0;  
5F7C:  BCF    F83.7
....................    PORTE.tx_en=1; 
5F7E:  BSF    F84.2
....................    lcd_init(); 
5F80:  CALL   09FE
....................    init_ext_flash(); 
5F84:  GOTO   0AAE
....................    restart_wdt(); 
5F88:  CLRWDT
....................    portd.pwr_ctrl=0; 
5F8A:  BCF    F83.6
....................     output_high(FLASH_SELECT); 
5F8C:  BCF    F94.2
5F8E:  BSF    F8B.2
....................     setup_timer_0(RTCC_DIV_32); 
5F90:  MOVLW  84
5F92:  MOVWF  FD5
....................    T1CON = 0x8F; 
5F94:  MOVLW  8F
5F96:  MOVWF  FCD
....................    //setup_timer_0(RTCC_DIV_1); 
....................     disable_interrupts(INT_TIMER0);   // Setup interrupt on falling edge 
5F98:  BCF    FF2.5
....................     disable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
5F9A:  BCF    F9D.0
....................     disable_interrupts(GLOBAL); 
5F9C:  BCF    FF2.6
5F9E:  BCF    FF2.7
5FA0:  BTFSC  FF2.7
5FA2:  BRA    5F9E
....................    flag=0; 
5FA4:  CLRF   1F
....................     strcpy(cmd_msg,""); 
5FA6:  CLRF   FEA
5FA8:  MOVLW  54
5FAA:  MOVWF  FE9
5FAC:  MOVFF  FF2,D1
5FB0:  BCF    FF2.7
5FB2:  MOVLW  00
5FB4:  CALL   0324
5FB8:  TBLRD*-
5FBA:  TBLRD*+
5FBC:  MOVF   FF5,W
5FBE:  MOVWF  FEE
5FC0:  IORLW  00
5FC2:  BNZ   5FBA
5FC4:  BTFSC  xD1.7
5FC6:  BSF    FF2.7
....................    if (timer_sec ==0x00000000) 
5FC8:  MOVF   20,F
5FCA:  BNZ   5FDC
5FCC:  MOVF   21,F
5FCE:  BNZ   5FDC
5FD0:  MOVF   22,F
5FD2:  BNZ   5FDC
5FD4:  MOVF   23,F
5FD6:  BNZ   5FDC
....................       flag.setup_required = true; 
5FD8:  BSF    1F.4
....................    else 
5FDA:  BRA    5FDE
....................       flag.setup_required = false; 
5FDC:  BCF    1F.4
....................  
.................... ///////////////// 
....................    enable_interrupts(INT_RDA); 
5FDE:  BSF    F9D.5
....................    enable_interrupts(INT_TIMER1);   
5FE0:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);  
5FE2:  MOVLW  C0
5FE4:  IORWF  FF2,F
....................    while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
5FE6:  BTFSS  1F.4
5FE8:  BRA    5FF4
5FEA:  BTFSS  1F.3
5FEC:  BRA    5FF2
5FEE:  CALL   2F8E
5FF2:  BRA    5FE6
....................    setup_wdt(WDT_ON); 
5FF4:  BSF    FD1.0
5FF6:  CLRF   18
5FF8:  BTFSC  FF2.7
5FFA:  BSF    18.7
5FFC:  BCF    FF2.7
....................    next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
5FFE:  MOVFF  23,EE
6002:  MOVFF  22,ED
6006:  MOVFF  21,EC
600A:  MOVFF  20,EB
600E:  MOVLW  07
6010:  MOVWF  xF2
6012:  MOVLW  86
6014:  MOVWF  xF1
6016:  MOVLW  1F
6018:  MOVWF  xF0
601A:  MOVLW  80
601C:  MOVWF  xEF
601E:  CALL   0340
6022:  BTFSC  18.7
6024:  BSF    FF2.7
6026:  MOVFF  FEF,D1
602A:  MOVFF  FEC,D2
602E:  MOVFF  FEC,D3
6032:  MOVFF  FEC,D4
6036:  MOVFF  D4,E4
603A:  MOVFF  D3,E3
603E:  MOVFF  D2,E2
6042:  MOVFF  D1,E1
6046:  CALL   2BA8
604A:  MOVFF  02,D3
604E:  MOVFF  01,D2
6052:  MOVFF  02,E2
6056:  MOVFF  01,E1
605A:  CALL   2C42
605E:  MOVFF  03,D6
6062:  MOVFF  02,D5
6066:  MOVFF  01,D4
606A:  MOVFF  00,D3
606E:  MOVFF  FEA,D8
6072:  MOVFF  FE9,D7
6076:  MOVFF  03,F8
607A:  MOVFF  02,F7
607E:  MOVFF  01,F6
6082:  MOVFF  00,F5
6086:  CLRF   xFC
6088:  CLRF   xFB
608A:  MOVLW  01
608C:  MOVWF  xFA
608E:  MOVLW  C2
6090:  MOVWF  xF9
6092:  CALL   1330
6096:  MOVFF  D8,FEA
609A:  MOVFF  D7,FE9
609E:  MOVFF  03,6D
60A2:  MOVFF  02,6C
60A6:  MOVFF  01,6B
60AA:  MOVFF  00,6A
....................  
.................... ////////////////// 
....................    // take sun angle and calculate the length of actuator needed to push 
....................    // also need counter of reed switch 
....................    flag.task1_armed =true; 
60AE:  BSF    1F.0
60B0:  CLRF   18
60B2:  BTFSC  FF2.7
60B4:  BSF    18.7
60B6:  BCF    FF2.7
....................    ext_flash_main_memory_to_buffer1(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
60B8:  MOVFF  23,EE
60BC:  MOVFF  22,ED
60C0:  MOVFF  21,EC
60C4:  MOVFF  20,EB
60C8:  MOVLW  07
60CA:  MOVWF  xF2
60CC:  MOVLW  86
60CE:  MOVWF  xF1
60D0:  MOVLW  1F
60D2:  MOVWF  xF0
60D4:  MOVLW  80
60D6:  MOVWF  xEF
60D8:  CALL   0340
60DC:  BTFSC  18.7
60DE:  BSF    FF2.7
60E0:  MOVFF  FEF,D1
60E4:  MOVFF  FEC,D2
60E8:  MOVFF  FEC,D3
60EC:  MOVFF  FEC,D4
60F0:  MOVFF  D4,E4
60F4:  MOVFF  D3,E3
60F8:  MOVFF  D2,E2
60FC:  MOVFF  D1,E1
6100:  CALL   2BA8
6104:  MOVFF  02,D3
6108:  MOVFF  01,D2
610C:  BCF    FD8.0
610E:  RRCF   02,W
6110:  MOVWF  03
6112:  RRCF   01,W
6114:  MOVWF  02
6116:  ADDLW  F2
6118:  MOVWF  xD4
611A:  MOVLW  03
611C:  ADDWFC 03,W
611E:  MOVWF  xD5
6120:  MOVWF  xD7
6122:  MOVFF  D4,D6
6126:  CALL   2CCA
....................  
....................    while(1) { 
....................  
....................       while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
612A:  BTFSS  1F.4
612C:  BRA    6138
612E:  BTFSS  1F.3
6130:  BRA    6136
6132:  CALL   2F8E
6136:  BRA    612A
....................  
....................       if (flag.update_time) { 
6138:  BTFSS  1F.1
613A:  BRA    6142
....................          flag.update_time = false; 
613C:  BCF    1F.1
....................          print_date_time(); 
613E:  CALL   16DC
....................       } 
....................  
....................       if (flag.measured_current) {    
6142:  BTFSS  1F.7
6144:  BRA    6158
....................          flag.measured_current = false; 
6146:  BCF    1F.7
....................          current_measured += (read_adc()); 
6148:  BSF    FC2.2
614A:  BTFSC  FC2.2
614C:  BRA    614A
614E:  MOVF   FC3,W
6150:  ADDWF  xC3,F
6152:  MOVF   FC4,W
6154:  ADDWFC xC4,F
....................          n_avg_current_measured++; 
6156:  INCF   xC5,F
....................       } 
....................  
....................       if (flag.cmd_posted) { 
6158:  BTFSS  1F.3
615A:  BRA    6162
....................          flag.cmd_posted = false; 
615C:  BCF    1F.3
....................          process_cmd_msg(); 
615E:  CALL   2F8E
....................       } 
....................       if (flag.reset_rs232) { 
6162:  BTFSS  1F.5
6164:  BRA    616C
....................          flag.reset_rs232 =false; 
6166:  BCF    1F.5
....................           init_rs232(); 
6168:  GOTO   367A
....................       } 
....................       if (input(WALL_PWR)==false) { 
616C:  BSF    F92.5
616E:  BTFSC  F80.5
6170:  BRA    6176
....................          flag.pwr_state = false; 
6172:  BCF    1F.6
....................       } else { 
6174:  BRA    6180
....................          if (flag.pwr_state==false) 
6176:  BTFSC  1F.6
6178:  BRA    617E
....................             lcd_init(); 
617A:  CALL   09FE
....................          flag.pwr_state=true; 
617E:  BSF    1F.6
....................       } 
....................       if (tx_delay==0) PORTE.tx_en=0; 
6180:  MOVF   xC2,F
6182:  BTFSC  FD8.2
6184:  BCF    F84.2
....................       if (flag.task1_armed) { 
6186:  BTFSS  1F.0
6188:  BRA    64C8
....................          flag.task1_armed = false; 
618A:  BCF    1F.0
....................          solar_angle= task1(); 
618C:  CALL   38E2
6190:  MOVFF  01,CB
....................  
....................          if ((solar_angle>30) && (solar_angle<150)) { 
6194:  MOVF   xCB,W
6196:  SUBLW  1E
6198:  BC    61C4
619A:  MOVF   xCB,W
619C:  SUBLW  95
619E:  BNC   61C4
....................             lcd_gotoxy(0,3); 
61A0:  CLRF   xEA
61A2:  MOVLW  03
61A4:  MOVWF  xEB
61A6:  CALL   0CC2
....................             al=actuator_length(solar_angle); 
61AA:  MOVFF  CB,D3
61AE:  CALL   49FA
61B2:  MOVFF  03,BF
61B6:  MOVFF  02,BE
61BA:  MOVFF  01,BD
61BE:  MOVFF  00,BC
....................          } else { 
61C2:  BRA    6238
....................             if ((solar_angle>0) && (solar_angle<=30)) { 
61C4:  MOVF   xCB,F
61C6:  BZ    61FA
61C8:  MOVF   xCB,W
61CA:  SUBLW  1E
61CC:  BNC   61FA
....................                al=actuator_length(90-get_backtrack_angle(90-solar_angle)); 
61CE:  MOVLW  5A
61D0:  BSF    FD8.0
61D2:  SUBFWB xCB,W
61D4:  MOVWF  xD1
61D6:  MOVWF  xD2
61D8:  RCALL  59EE
61DA:  MOVLW  5A
61DC:  BSF    FD8.0
61DE:  SUBFWB 01,W
61E0:  MOVWF  xD2
61E2:  MOVWF  xD3
61E4:  CALL   49FA
61E8:  MOVFF  03,BF
61EC:  MOVFF  02,BE
61F0:  MOVFF  01,BD
61F4:  MOVFF  00,BC
....................             } else if ((solar_angle>=150) && (solar_angle<=180)) { 
61F8:  BRA    6238
61FA:  MOVF   xCB,W
61FC:  SUBLW  95
61FE:  BC    6238
6200:  MOVF   xCB,W
6202:  SUBLW  B4
6204:  BNC   6238
....................                lcd_gotoxy(0,3); 
6206:  CLRF   xEA
6208:  MOVLW  03
620A:  MOVWF  xEB
620C:  CALL   0CC2
....................                al=actuator_length(90+get_backtrack_angle(solar_angle-90)); 
6210:  MOVLW  5A
6212:  SUBWF  xCB,W
6214:  MOVWF  xD1
6216:  MOVWF  xD2
6218:  CALL   59EE
621C:  MOVLW  5A
621E:  ADDWF  01,W
6220:  MOVWF  xD2
6222:  MOVWF  xD3
6224:  CALL   49FA
6228:  MOVFF  03,BF
622C:  MOVFF  02,BE
6230:  MOVFF  01,BD
6234:  MOVFF  00,BC
....................             } 
....................          } 
....................          if((al >= MIN_STROKE) && (al <=MAX_STROKE)) { 
6238:  MOVLB  1
623A:  CLRF   x4D
623C:  CLRF   x4C
623E:  MOVLW  18
6240:  MOVWF  x4B
6242:  MOVLW  85
6244:  MOVWF  x4A
6246:  MOVFF  BF,151
624A:  MOVFF  BE,150
624E:  MOVFF  BD,14F
6252:  MOVFF  BC,14E
6256:  MOVLB  0
6258:  CALL   3E46
625C:  BC    6260
625E:  BNZ   6340
6260:  MOVFF  BF,14D
6264:  MOVFF  BE,14C
6268:  MOVFF  BD,14B
626C:  MOVFF  BC,14A
6270:  MOVLB  1
6272:  CLRF   x51
6274:  CLRF   x50
6276:  MOVLW  77
6278:  MOVWF  x4F
627A:  MOVLW  85
627C:  MOVWF  x4E
627E:  MOVLB  0
6280:  CALL   3E46
6284:  BC    6288
6286:  BNZ   6340
....................             tick = ((al-MIN_STROKE)/(MAX_STROKE-MIN_STROKE))*FULL_STROKE_TICK; 
6288:  BSF    FD8.1
628A:  MOVFF  BF,153
628E:  MOVFF  BE,152
6292:  MOVFF  BD,151
6296:  MOVFF  BC,150
629A:  MOVLB  1
629C:  CLRF   x57
629E:  CLRF   x56
62A0:  MOVLW  18
62A2:  MOVWF  x55
62A4:  MOVLW  85
62A6:  MOVWF  x54
62A8:  MOVLB  0
62AA:  CALL   1078
62AE:  MOVFF  00,D1
62B2:  MOVFF  01,D2
62B6:  MOVFF  02,D3
62BA:  MOVFF  03,D4
62BE:  MOVFF  03,14D
62C2:  MOVFF  02,14C
62C6:  MOVFF  01,14B
62CA:  MOVFF  00,14A
62CE:  MOVLB  1
62D0:  CLRF   x51
62D2:  CLRF   x50
62D4:  MOVLW  3E
62D6:  MOVWF  x4F
62D8:  MOVLW  84
62DA:  MOVWF  x4E
62DC:  MOVLB  0
62DE:  CALL   0F1A
62E2:  MOVFF  00,D5
62E6:  MOVFF  01,D6
62EA:  MOVFF  02,D7
62EE:  MOVFF  03,D8
62F2:  MOVFF  BB,14F
62F6:  MOVFF  BA,14E
62FA:  CALL   43EA
62FE:  MOVFF  D8,151
6302:  MOVFF  D7,150
6306:  MOVFF  D6,14F
630A:  MOVFF  D5,14E
630E:  MOVFF  03,155
6312:  MOVFF  02,154
6316:  MOVFF  01,153
631A:  MOVFF  00,152
631E:  CALL   0E24
6322:  MOVFF  03,14D
6326:  MOVFF  02,14C
632A:  MOVFF  01,14B
632E:  MOVFF  00,14A
6332:  CALL   4420
6336:  MOVFF  02,CD
633A:  MOVFF  01,CC
....................          } else if (al<MIN_STROKE) { 
633E:  BRA    639A
6340:  MOVFF  BF,14D
6344:  MOVFF  BE,14C
6348:  MOVFF  BD,14B
634C:  MOVFF  BC,14A
6350:  MOVLB  1
6352:  CLRF   x51
6354:  CLRF   x50
6356:  MOVLW  18
6358:  MOVWF  x4F
635A:  MOVLW  85
635C:  MOVWF  x4E
635E:  MOVLB  0
6360:  CALL   3E46
6364:  BNC   636C
....................             tick = 0; 
6366:  CLRF   xCD
6368:  CLRF   xCC
....................          } else if (al>MAX_STROKE) { 
636A:  BRA    639A
636C:  MOVLB  1
636E:  CLRF   x4D
6370:  CLRF   x4C
6372:  MOVLW  77
6374:  MOVWF  x4B
6376:  MOVLW  85
6378:  MOVWF  x4A
637A:  MOVFF  BF,151
637E:  MOVFF  BE,150
6382:  MOVFF  BD,14F
6386:  MOVFF  BC,14E
638A:  MOVLB  0
638C:  CALL   3E46
6390:  BNC   639A
....................             tick = FULL_STROKE_TICK; 
6392:  MOVFF  BB,CD
6396:  MOVFF  BA,CC
....................          } 
....................          target_act_position = tick; 
639A:  MOVFF  CD,71
639E:  MOVFF  CC,70
....................               write_eeprom_data(0); 
63A2:  CLRF   xD1
63A4:  CALL   0820
....................          print_len_and_tick(); 
63A8:  RCALL  5D02
....................  
....................          if(current_act_position > (target_act_position+5))// move east 
63AA:  MOVLW  05
63AC:  ADDWF  x70,W
63AE:  MOVWF  01
63B0:  MOVLW  00
63B2:  ADDWFC x71,W
63B4:  MOVWF  03
63B6:  MOVF   03,W
63B8:  SUBWF  x6F,W
63BA:  BNC   63F2
63BC:  BNZ   63C4
63BE:  MOVF   x6E,W
63C0:  SUBWF  01,W
63C2:  BC    63F2
....................          { 
....................             move_act(current_act_position-target_act_position,4500,move_act_time_out,0,1); 
63C4:  MOVF   x70,W
63C6:  SUBWF  x6E,W
63C8:  MOVWF  xD1
63CA:  MOVF   x71,W
63CC:  SUBWFB x6F,W
63CE:  MOVWF  xD2
63D0:  MOVWF  xD4
63D2:  MOVFF  D1,D3
63D6:  MOVLW  11
63D8:  MOVWF  xD6
63DA:  MOVLW  94
63DC:  MOVWF  xD5
63DE:  MOVFF  C1,D8
63E2:  MOVFF  C0,D7
63E6:  CLRF   xD9
63E8:  MOVLW  01
63EA:  MOVWF  xDA
63EC:  CALL   21A4
....................          } else if((current_act_position+5) < target_act_position)// move west 
63F0:  BRA    6492
63F2:  MOVLW  05
63F4:  ADDWF  x6E,W
63F6:  MOVWF  xD1
63F8:  MOVLW  00
63FA:  ADDWFC x6F,W
63FC:  MOVWF  xD2
63FE:  SUBWF  x71,W
6400:  BNC   6438
6402:  BNZ   640A
6404:  MOVF   x70,W
6406:  SUBWF  xD1,W
6408:  BC    6438
....................          { 
....................             move_act(target_act_position-current_act_position,4500,move_act_time_out,1,1); 
640A:  MOVF   x6E,W
640C:  SUBWF  x70,W
640E:  MOVWF  xD1
6410:  MOVF   x6F,W
6412:  SUBWFB x71,W
6414:  MOVWF  xD2
6416:  MOVWF  xD4
6418:  MOVFF  D1,D3
641C:  MOVLW  11
641E:  MOVWF  xD6
6420:  MOVLW  94
6422:  MOVWF  xD5
6424:  MOVFF  C1,D8
6428:  MOVFF  C0,D7
642C:  MOVLW  01
642E:  MOVWF  xD9
6430:  MOVWF  xDA
6432:  CALL   21A4
....................          } else if (target_act_position == 0x00)  // move east all the way 
6436:  BRA    6492
6438:  MOVF   x70,F
643A:  BNZ   6464
643C:  MOVF   x71,F
643E:  BNZ   6464
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,0,1); 
6440:  MOVFF  BB,D4
6444:  MOVFF  BA,D3
6448:  MOVLW  11
644A:  MOVWF  xD6
644C:  MOVLW  94
644E:  MOVWF  xD5
6450:  MOVFF  C1,D8
6454:  MOVFF  C0,D7
6458:  CLRF   xD9
645A:  MOVLW  01
645C:  MOVWF  xDA
645E:  CALL   21A4
....................          else if (target_act_position == FULL_STROKE_TICK) // move west all the way 
6462:  BRA    6492
6464:  MOVF   xBA,W
6466:  SUBWF  x70,W
6468:  BNZ   6492
646A:  MOVF   xBB,W
646C:  SUBWF  x71,W
646E:  BNZ   6492
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,1,1); 
6470:  MOVFF  BB,D4
6474:  MOVFF  BA,D3
6478:  MOVLW  11
647A:  MOVWF  xD6
647C:  MOVLW  94
647E:  MOVWF  xD5
6480:  MOVFF  C1,D8
6484:  MOVFF  C0,D7
6488:  MOVLW  01
648A:  MOVWF  xD9
648C:  MOVWF  xDA
648E:  CALL   21A4
6492:  CLRF   18
6494:  BTFSC  FF2.7
6496:  BSF    18.7
6498:  BCF    FF2.7
....................          delay_ms(20); 
649A:  MOVLW  14
649C:  MOVWF  xEA
649E:  CALL   04BC
64A2:  BTFSC  18.7
64A4:  BSF    FF2.7
....................          task1(); 
64A6:  CALL   38E2
....................          print_len_and_tick(); 
64AA:  RCALL  5D02
....................          write_eeprom_data(0); 
64AC:  CLRF   xD1
64AE:  CALL   0820
....................          PORTE.tx_en=1; 
64B2:  BSF    F84.2
....................          current_measured=0; 
64B4:  CLRF   xC4
64B6:  CLRF   xC3
....................          n_avg_current_measured=0; 
64B8:  CLRF   xC5
....................          printf("."); 
64BA:  MOVLW  2E
64BC:  BTFSS  F9E.4
64BE:  BRA    64BC
64C0:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
64C2:  MOVLW  01
64C4:  MOVWF  xC2
....................          sleep(); 
64C6:  SLEEP 
....................       } 
....................    } 
64C8:  BRA    612A
....................  
.................... } 
64CA:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: B1 05 00 00 00 00 00 00 00 00 
