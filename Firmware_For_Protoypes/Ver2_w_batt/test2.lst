CCS PCH C Compiler, Version 4.078, 37503               09-¾.¤.-10 11:21

               Filename: G:\Solar_Tracker_Final\Code\Ver2_w_batt\test2.lst

               ROM used: 25706 bytes (78%)
                         Largest free fragment is 7058
               RAM used: 217 (14%) at main() level
                         356 (23%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
0000:  GOTO   5DF4
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   03BA
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04E4
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1682:  MOVFF  E3,E5
1686:  MOVFF  E2,E4
168A:  MOVFF  E5,03
168E:  MOVFF  E4,FE9
1692:  MOVFF  E5,FEA
1696:  MOVF   FEF,F
1698:  BZ    16A2
169A:  INCF   xE4,F
169C:  BTFSC  FD8.2
169E:  INCF   xE5,F
16A0:  BRA    168A
....................    return(sc - s); 
16A2:  MOVF   xE2,W
16A4:  SUBWF  xE4,W
16A6:  MOVWF  00
16A8:  MOVF   xE3,W
16AA:  SUBWFB xE5,W
16AC:  MOVWF  03
16AE:  MOVFF  00,01
.................... } 
16B2:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0ADA:  CLRF   xD7
....................    sign = 0; 
0ADC:  CLRF   xD5
....................    base = 10; 
0ADE:  MOVLW  0A
0AE0:  MOVWF  xD6
....................    result = 0; 
0AE2:  CLRF   xD4
0AE4:  CLRF   xD3
....................  
....................    if (!s) 
0AE6:  MOVF   xD1,W
0AE8:  IORWF  xD2,W
0AEA:  BNZ   0AF4
....................       return 0; 
0AEC:  MOVLW  00
0AEE:  MOVWF  01
0AF0:  MOVWF  02
0AF2:  BRA    0CC0
....................    c = s[index++]; 
0AF4:  MOVF   xD7,W
0AF6:  INCF   xD7,F
0AF8:  CLRF   03
0AFA:  ADDWF  xD1,W
0AFC:  MOVWF  FE9
0AFE:  MOVF   xD2,W
0B00:  ADDWFC 03,W
0B02:  MOVWF  FEA
0B04:  MOVFF  FEF,D8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B08:  MOVF   xD8,W
0B0A:  SUBLW  2D
0B0C:  BNZ   0B28
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B0E:  MOVLW  01
0B10:  MOVWF  xD5
....................       c = s[index++]; 
0B12:  MOVF   xD7,W
0B14:  INCF   xD7,F
0B16:  CLRF   03
0B18:  ADDWF  xD1,W
0B1A:  MOVWF  FE9
0B1C:  MOVF   xD2,W
0B1E:  ADDWFC 03,W
0B20:  MOVWF  FEA
0B22:  MOVFF  FEF,D8
....................    } 
....................    else if (c == '+') 
0B26:  BRA    0B42
0B28:  MOVF   xD8,W
0B2A:  SUBLW  2B
0B2C:  BNZ   0B42
....................    { 
....................       c = s[index++]; 
0B2E:  MOVF   xD7,W
0B30:  INCF   xD7,F
0B32:  CLRF   03
0B34:  ADDWF  xD1,W
0B36:  MOVWF  FE9
0B38:  MOVF   xD2,W
0B3A:  ADDWFC 03,W
0B3C:  MOVWF  FEA
0B3E:  MOVFF  FEF,D8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B42:  MOVF   xD8,W
0B44:  SUBLW  2F
0B46:  BTFSC  FD8.0
0B48:  BRA    0CA4
0B4A:  MOVF   xD8,W
0B4C:  SUBLW  39
0B4E:  BTFSS  FD8.0
0B50:  BRA    0CA4
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B52:  MOVF   xD8,W
0B54:  SUBLW  30
0B56:  BNZ   0B9A
0B58:  CLRF   03
0B5A:  MOVF   xD7,W
0B5C:  ADDWF  xD1,W
0B5E:  MOVWF  FE9
0B60:  MOVF   xD2,W
0B62:  ADDWFC 03,W
0B64:  MOVWF  FEA
0B66:  MOVF   FEF,W
0B68:  SUBLW  78
0B6A:  BZ    0B80
0B6C:  CLRF   03
0B6E:  MOVF   xD7,W
0B70:  ADDWF  xD1,W
0B72:  MOVWF  FE9
0B74:  MOVF   xD2,W
0B76:  ADDWFC 03,W
0B78:  MOVWF  FEA
0B7A:  MOVF   FEF,W
0B7C:  SUBLW  58
0B7E:  BNZ   0B9A
....................       { 
....................          base = 16; 
0B80:  MOVLW  10
0B82:  MOVWF  xD6
....................          index++; 
0B84:  INCF   xD7,F
....................          c = s[index++]; 
0B86:  MOVF   xD7,W
0B88:  INCF   xD7,F
0B8A:  CLRF   03
0B8C:  ADDWF  xD1,W
0B8E:  MOVWF  FE9
0B90:  MOVF   xD2,W
0B92:  ADDWFC 03,W
0B94:  MOVWF  FEA
0B96:  MOVFF  FEF,D8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0B9A:  MOVF   xD6,W
0B9C:  SUBLW  0A
0B9E:  BNZ   0BE2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0BA0:  MOVF   xD8,W
0BA2:  SUBLW  2F
0BA4:  BC    0BE0
0BA6:  MOVF   xD8,W
0BA8:  SUBLW  39
0BAA:  BNC   0BE0
....................             result = 10*result + (c - '0'); 
0BAC:  CLRF   xDA
0BAE:  MOVLW  0A
0BB0:  MOVWF  xD9
0BB2:  MOVFF  D4,DC
0BB6:  MOVFF  D3,DB
0BBA:  BRA    0ABA
0BBC:  MOVLW  30
0BBE:  SUBWF  xD8,W
0BC0:  ADDWF  01,W
0BC2:  MOVWF  xD3
0BC4:  MOVLW  00
0BC6:  ADDWFC 02,W
0BC8:  MOVWF  xD4
....................             c = s[index++]; 
0BCA:  MOVF   xD7,W
0BCC:  INCF   xD7,F
0BCE:  CLRF   03
0BD0:  ADDWF  xD1,W
0BD2:  MOVWF  FE9
0BD4:  MOVF   xD2,W
0BD6:  ADDWFC 03,W
0BD8:  MOVWF  FEA
0BDA:  MOVFF  FEF,D8
....................          } 
0BDE:  BRA    0BA0
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0BE0:  BRA    0CA4
0BE2:  MOVF   xD6,W
0BE4:  SUBLW  10
0BE6:  BNZ   0CA4
....................       { 
....................          c = toupper(c); 
0BE8:  MOVF   xD8,W
0BEA:  SUBLW  60
0BEC:  BC    0BFA
0BEE:  MOVF   xD8,W
0BF0:  SUBLW  7A
0BF2:  BNC   0BFA
0BF4:  MOVF   xD8,W
0BF6:  ANDLW  DF
0BF8:  BRA    0BFC
0BFA:  MOVF   xD8,W
0BFC:  MOVWF  xD8
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0BFE:  MOVF   xD8,W
0C00:  SUBLW  2F
0C02:  BC    0C0A
0C04:  MOVF   xD8,W
0C06:  SUBLW  39
0C08:  BC    0C16
0C0A:  MOVF   xD8,W
0C0C:  SUBLW  40
0C0E:  BC    0CA4
0C10:  MOVF   xD8,W
0C12:  SUBLW  46
0C14:  BNC   0CA4
....................             if (c >= '0' && c <= '9') 
0C16:  MOVF   xD8,W
0C18:  SUBLW  2F
0C1A:  BC    0C4E
0C1C:  MOVF   xD8,W
0C1E:  SUBLW  39
0C20:  BNC   0C4E
....................                result = (result << 4) + (c - '0'); 
0C22:  RLCF   xD3,W
0C24:  MOVWF  xD9
0C26:  RLCF   xD4,W
0C28:  MOVWF  xDA
0C2A:  RLCF   xD9,F
0C2C:  RLCF   xDA,F
0C2E:  RLCF   xD9,F
0C30:  RLCF   xDA,F
0C32:  RLCF   xD9,F
0C34:  RLCF   xDA,F
0C36:  MOVLW  F0
0C38:  ANDWF  xD9,F
0C3A:  MOVLW  30
0C3C:  SUBWF  xD8,W
0C3E:  ADDWF  xD9,W
0C40:  MOVWF  01
0C42:  MOVLW  00
0C44:  ADDWFC xDA,W
0C46:  MOVFF  01,D3
0C4A:  MOVWF  xD4
....................             else 
0C4C:  BRA    0C7A
....................                result = (result << 4) + (c - 'A' + 10); 
0C4E:  RLCF   xD3,W
0C50:  MOVWF  xD9
0C52:  RLCF   xD4,W
0C54:  MOVWF  xDA
0C56:  RLCF   xD9,F
0C58:  RLCF   xDA,F
0C5A:  RLCF   xD9,F
0C5C:  RLCF   xDA,F
0C5E:  RLCF   xD9,F
0C60:  RLCF   xDA,F
0C62:  MOVLW  F0
0C64:  ANDWF  xD9,F
0C66:  MOVLW  41
0C68:  SUBWF  xD8,W
0C6A:  ADDLW  0A
0C6C:  ADDWF  xD9,W
0C6E:  MOVWF  01
0C70:  MOVLW  00
0C72:  ADDWFC xDA,W
0C74:  MOVFF  01,D3
0C78:  MOVWF  xD4
....................  
....................             c = s[index++];c = toupper(c); 
0C7A:  MOVF   xD7,W
0C7C:  INCF   xD7,F
0C7E:  CLRF   03
0C80:  ADDWF  xD1,W
0C82:  MOVWF  FE9
0C84:  MOVF   xD2,W
0C86:  ADDWFC 03,W
0C88:  MOVWF  FEA
0C8A:  MOVF   FEF,W
0C8C:  MOVWF  xD8
0C8E:  SUBLW  60
0C90:  BC    0C9E
0C92:  MOVF   xD8,W
0C94:  SUBLW  7A
0C96:  BNC   0C9E
0C98:  MOVF   xD8,W
0C9A:  ANDLW  DF
0C9C:  BRA    0CA0
0C9E:  MOVF   xD8,W
0CA0:  MOVWF  xD8
....................          } 
0CA2:  BRA    0BFE
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0CA4:  MOVF   xD6,W
0CA6:  SUBLW  0A
0CA8:  BNZ   0CB8
0CAA:  DECFSZ xD5,W
0CAC:  BRA    0CB8
....................       result = -result; 
0CAE:  COMF   xD3,F
0CB0:  COMF   xD4,F
0CB2:  INCF   xD3,F
0CB4:  BTFSC  FD8.2
0CB6:  INCF   xD4,F
....................  
....................    return(result); 
0CB8:  MOVFF  D3,01
0CBC:  MOVFF  D4,02
.................... } 
0CC0:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
290A:  CLRF   xD9
....................    sign = 0; 
290C:  CLRF   xD7
....................    base = 10; 
290E:  MOVLW  0A
2910:  MOVWF  xD8
....................    result = 0; 
2912:  CLRF   xD6
2914:  CLRF   xD5
2916:  CLRF   xD4
2918:  CLRF   xD3
....................  
....................    if (!s) 
291A:  MOVF   xD1,W
291C:  IORWF  xD2,W
291E:  BNZ   292A
....................       return 0; 
2920:  CLRF   00
2922:  CLRF   01
2924:  CLRF   02
2926:  CLRF   03
2928:  BRA    2BA4
....................    c = s[index++]; 
292A:  MOVF   xD9,W
292C:  INCF   xD9,F
292E:  CLRF   03
2930:  ADDWF  xD1,W
2932:  MOVWF  FE9
2934:  MOVF   xD2,W
2936:  ADDWFC 03,W
2938:  MOVWF  FEA
293A:  MOVFF  FEF,DA
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
293E:  MOVF   xDA,W
2940:  SUBLW  2D
2942:  BNZ   295E
....................    { 
....................       sign = 1;         // Set the sign to negative 
2944:  MOVLW  01
2946:  MOVWF  xD7
....................       c = s[index++]; 
2948:  MOVF   xD9,W
294A:  INCF   xD9,F
294C:  CLRF   03
294E:  ADDWF  xD1,W
2950:  MOVWF  FE9
2952:  MOVF   xD2,W
2954:  ADDWFC 03,W
2956:  MOVWF  FEA
2958:  MOVFF  FEF,DA
....................    } 
....................    else if (c == '+') 
295C:  BRA    2978
295E:  MOVF   xDA,W
2960:  SUBLW  2B
2962:  BNZ   2978
....................    { 
....................       c = s[index++]; 
2964:  MOVF   xD9,W
2966:  INCF   xD9,F
2968:  CLRF   03
296A:  ADDWF  xD1,W
296C:  MOVWF  FE9
296E:  MOVF   xD2,W
2970:  ADDWFC 03,W
2972:  MOVWF  FEA
2974:  MOVFF  FEF,DA
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2978:  MOVF   xDA,W
297A:  SUBLW  2F
297C:  BTFSC  FD8.0
297E:  BRA    2B74
2980:  MOVF   xDA,W
2982:  SUBLW  39
2984:  BTFSS  FD8.0
2986:  BRA    2B74
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2988:  MOVF   xDA,W
298A:  SUBLW  30
298C:  BNZ   29D0
298E:  CLRF   03
2990:  MOVF   xD9,W
2992:  ADDWF  xD1,W
2994:  MOVWF  FE9
2996:  MOVF   xD2,W
2998:  ADDWFC 03,W
299A:  MOVWF  FEA
299C:  MOVF   FEF,W
299E:  SUBLW  78
29A0:  BZ    29B6
29A2:  CLRF   03
29A4:  MOVF   xD9,W
29A6:  ADDWF  xD1,W
29A8:  MOVWF  FE9
29AA:  MOVF   xD2,W
29AC:  ADDWFC 03,W
29AE:  MOVWF  FEA
29B0:  MOVF   FEF,W
29B2:  SUBLW  58
29B4:  BNZ   29D0
....................       { 
....................          base = 16; 
29B6:  MOVLW  10
29B8:  MOVWF  xD8
....................          index++; 
29BA:  INCF   xD9,F
....................          c = s[index++]; 
29BC:  MOVF   xD9,W
29BE:  INCF   xD9,F
29C0:  CLRF   03
29C2:  ADDWF  xD1,W
29C4:  MOVWF  FE9
29C6:  MOVF   xD2,W
29C8:  ADDWFC 03,W
29CA:  MOVWF  FEA
29CC:  MOVFF  FEF,DA
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
29D0:  MOVF   xD8,W
29D2:  SUBLW  0A
29D4:  BNZ   2A5E
....................       { 
....................          while (c >= '0' && c <= '9') { 
29D6:  MOVF   xDA,W
29D8:  SUBLW  2F
29DA:  BC    2A5C
29DC:  MOVF   xDA,W
29DE:  SUBLW  39
29E0:  BNC   2A5C
....................             result = (result << 1) + (result << 3);  // result *= 10; 
29E2:  BCF    FD8.0
29E4:  RLCF   xD3,W
29E6:  MOVWF  xDC
29E8:  RLCF   xD4,W
29EA:  MOVWF  xDD
29EC:  RLCF   xD5,W
29EE:  MOVWF  xDE
29F0:  RLCF   xD6,W
29F2:  MOVWF  xDF
29F4:  RLCF   xD3,W
29F6:  MOVWF  00
29F8:  RLCF   xD4,W
29FA:  MOVWF  01
29FC:  RLCF   xD5,W
29FE:  MOVWF  02
2A00:  RLCF   xD6,W
2A02:  MOVWF  03
2A04:  RLCF   00,F
2A06:  RLCF   01,F
2A08:  RLCF   02,F
2A0A:  RLCF   03,F
2A0C:  RLCF   00,F
2A0E:  RLCF   01,F
2A10:  RLCF   02,F
2A12:  RLCF   03,F
2A14:  MOVLW  F8
2A16:  ANDWF  00,F
2A18:  MOVF   xDC,W
2A1A:  ADDWF  00,F
2A1C:  MOVF   xDD,W
2A1E:  ADDWFC 01,F
2A20:  MOVF   xDE,W
2A22:  ADDWFC 02,F
2A24:  MOVF   xDF,W
2A26:  ADDWFC 03,F
2A28:  MOVFF  03,D6
2A2C:  MOVFF  02,D5
2A30:  MOVFF  01,D4
2A34:  MOVFF  00,D3
....................             result += (c - '0'); 
2A38:  MOVLW  30
2A3A:  SUBWF  xDA,W
2A3C:  ADDWF  xD3,F
2A3E:  MOVLW  00
2A40:  ADDWFC xD4,F
2A42:  ADDWFC xD5,F
2A44:  ADDWFC xD6,F
....................             c = s[index++]; 
2A46:  MOVF   xD9,W
2A48:  INCF   xD9,F
2A4A:  CLRF   03
2A4C:  ADDWF  xD1,W
2A4E:  MOVWF  FE9
2A50:  MOVF   xD2,W
2A52:  ADDWFC 03,W
2A54:  MOVWF  FEA
2A56:  MOVFF  FEF,DA
....................          } 
2A5A:  BRA    29D6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2A5C:  BRA    2B74
2A5E:  MOVF   xD8,W
2A60:  SUBLW  10
2A62:  BTFSS  FD8.2
2A64:  BRA    2B74
....................       { 
....................          c = toupper(c); 
2A66:  MOVF   xDA,W
2A68:  SUBLW  60
2A6A:  BC    2A78
2A6C:  MOVF   xDA,W
2A6E:  SUBLW  7A
2A70:  BNC   2A78
2A72:  MOVF   xDA,W
2A74:  ANDLW  DF
2A76:  BRA    2A7A
2A78:  MOVF   xDA,W
2A7A:  MOVWF  xDA
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2A7C:  MOVF   xDA,W
2A7E:  SUBLW  2F
2A80:  BC    2A88
2A82:  MOVF   xDA,W
2A84:  SUBLW  39
2A86:  BC    2A96
2A88:  MOVF   xDA,W
2A8A:  SUBLW  40
2A8C:  BTFSC  FD8.0
2A8E:  BRA    2B74
2A90:  MOVF   xDA,W
2A92:  SUBLW  46
2A94:  BNC   2B74
....................             if (c >= '0' && c <= '9') 
2A96:  MOVF   xDA,W
2A98:  SUBLW  2F
2A9A:  BC    2AF6
2A9C:  MOVF   xDA,W
2A9E:  SUBLW  39
2AA0:  BNC   2AF6
....................                result = (result << 4) + (c - '0'); 
2AA2:  RLCF   xD3,W
2AA4:  MOVWF  xDC
2AA6:  RLCF   xD4,W
2AA8:  MOVWF  xDD
2AAA:  RLCF   xD5,W
2AAC:  MOVWF  xDE
2AAE:  RLCF   xD6,W
2AB0:  MOVWF  xDF
2AB2:  RLCF   xDC,F
2AB4:  RLCF   xDD,F
2AB6:  RLCF   xDE,F
2AB8:  RLCF   xDF,F
2ABA:  RLCF   xDC,F
2ABC:  RLCF   xDD,F
2ABE:  RLCF   xDE,F
2AC0:  RLCF   xDF,F
2AC2:  RLCF   xDC,F
2AC4:  RLCF   xDD,F
2AC6:  RLCF   xDE,F
2AC8:  RLCF   xDF,F
2ACA:  MOVLW  F0
2ACC:  ANDWF  xDC,F
2ACE:  MOVLW  30
2AD0:  SUBWF  xDA,W
2AD2:  ADDWF  xDC,W
2AD4:  MOVWF  00
2AD6:  MOVLW  00
2AD8:  ADDWFC xDD,W
2ADA:  MOVWF  01
2ADC:  MOVLW  00
2ADE:  ADDWFC xDE,W
2AE0:  MOVWF  02
2AE2:  MOVLW  00
2AE4:  ADDWFC xDF,W
2AE6:  MOVWF  xD6
2AE8:  MOVFF  02,D5
2AEC:  MOVFF  01,D4
2AF0:  MOVFF  00,D3
....................             else 
2AF4:  BRA    2B4A
....................                result = (result << 4) + (c - 'A' + 10); 
2AF6:  RLCF   xD3,W
2AF8:  MOVWF  xDC
2AFA:  RLCF   xD4,W
2AFC:  MOVWF  xDD
2AFE:  RLCF   xD5,W
2B00:  MOVWF  xDE
2B02:  RLCF   xD6,W
2B04:  MOVWF  xDF
2B06:  RLCF   xDC,F
2B08:  RLCF   xDD,F
2B0A:  RLCF   xDE,F
2B0C:  RLCF   xDF,F
2B0E:  RLCF   xDC,F
2B10:  RLCF   xDD,F
2B12:  RLCF   xDE,F
2B14:  RLCF   xDF,F
2B16:  RLCF   xDC,F
2B18:  RLCF   xDD,F
2B1A:  RLCF   xDE,F
2B1C:  RLCF   xDF,F
2B1E:  MOVLW  F0
2B20:  ANDWF  xDC,F
2B22:  MOVLW  41
2B24:  SUBWF  xDA,W
2B26:  ADDLW  0A
2B28:  ADDWF  xDC,W
2B2A:  MOVWF  00
2B2C:  MOVLW  00
2B2E:  ADDWFC xDD,W
2B30:  MOVWF  01
2B32:  MOVLW  00
2B34:  ADDWFC xDE,W
2B36:  MOVWF  02
2B38:  MOVLW  00
2B3A:  ADDWFC xDF,W
2B3C:  MOVWF  xD6
2B3E:  MOVFF  02,D5
2B42:  MOVFF  01,D4
2B46:  MOVFF  00,D3
....................  
....................             c = s[index++];c = toupper(c); 
2B4A:  MOVF   xD9,W
2B4C:  INCF   xD9,F
2B4E:  CLRF   03
2B50:  ADDWF  xD1,W
2B52:  MOVWF  FE9
2B54:  MOVF   xD2,W
2B56:  ADDWFC 03,W
2B58:  MOVWF  FEA
2B5A:  MOVF   FEF,W
2B5C:  MOVWF  xDA
2B5E:  SUBLW  60
2B60:  BC    2B6E
2B62:  MOVF   xDA,W
2B64:  SUBLW  7A
2B66:  BNC   2B6E
2B68:  MOVF   xDA,W
2B6A:  ANDLW  DF
2B6C:  BRA    2B70
2B6E:  MOVF   xDA,W
2B70:  MOVWF  xDA
....................          } 
2B72:  BRA    2A7C
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2B74:  MOVF   xD8,W
2B76:  SUBLW  0A
2B78:  BNZ   2B94
2B7A:  DECFSZ xD7,W
2B7C:  BRA    2B94
....................       result = -result; 
2B7E:  COMF   xD3,F
2B80:  COMF   xD4,F
2B82:  COMF   xD5,F
2B84:  COMF   xD6,F
2B86:  INCF   xD3,F
2B88:  BTFSC  FD8.2
2B8A:  INCF   xD4,F
2B8C:  BTFSC  FD8.2
2B8E:  INCF   xD5,F
2B90:  BTFSC  FD8.2
2B92:  INCF   xD6,F
....................  
....................    return(result); 
2B94:  MOVFF  D3,00
2B98:  MOVFF  D4,01
2B9C:  MOVFF  D5,02
2BA0:  MOVFF  D6,03
.................... } 
2BA4:  GOTO   3202 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
14A6:  MOVLW  01
14A8:  MOVWF  xED
14AA:  CLRF   xEE
14AC:  CLRF   xEF
14AE:  CLRF   xF0
....................      unsigned int8 i,sign=0,cnt=0; 
14B0:  CLRF   xF2
14B2:  CLRF   xF3
....................      char c; 
....................  
....................      if(num<0) { 
14B4:  BTFSC  xE9.7
14B6:  BRA    14BA
14B8:  BRA    14EA
....................          sign=1;        // Check for negative number 
14BA:  MOVLW  01
14BC:  MOVWF  xF2
....................          num*=-1; 
14BE:  MOVFF  E9,F8
14C2:  MOVFF  E8,F7
14C6:  MOVFF  E7,F6
14CA:  MOVFF  E6,F5
14CE:  MOVLW  FF
14D0:  MOVWF  xFC
14D2:  MOVWF  xFB
14D4:  MOVWF  xFA
14D6:  MOVWF  xF9
14D8:  RCALL  1330
14DA:  MOVFF  03,E9
14DE:  MOVFF  02,E8
14E2:  MOVFF  01,E7
14E6:  MOVFF  00,E6
....................      } 
....................  
....................      while(temp>0) { 
14EA:  MOVF   xED,F
14EC:  BNZ   14FA
14EE:  MOVF   xEE,F
14F0:  BNZ   14FA
14F2:  MOVF   xEF,F
14F4:  BNZ   14FA
14F6:  MOVF   xF0,F
14F8:  BZ    15E8
....................          temp=(num/base); 
14FA:  MOVFF  E9,FC
14FE:  MOVFF  E8,FB
1502:  MOVFF  E7,FA
1506:  MOVFF  E6,F9
150A:  MOVLB  1
150C:  CLRF   x00
150E:  MOVLB  0
1510:  CLRF   xFF
1512:  CLRF   xFE
1514:  MOVFF  EA,FD
1518:  RCALL  1396
151A:  MOVFF  03,F0
151E:  MOVFF  02,EF
1522:  MOVFF  01,EE
1526:  MOVFF  00,ED
....................          s[cnt]=(num%base)+'0';    // Conversion 
152A:  CLRF   03
152C:  MOVF   xF3,W
152E:  ADDWF  xEB,W
1530:  MOVWF  01
1532:  MOVF   xEC,W
1534:  ADDWFC 03,F
1536:  MOVFF  01,F5
153A:  MOVFF  03,F6
153E:  MOVFF  FEA,F8
1542:  MOVFF  FE9,F7
1546:  MOVFF  E9,FC
154A:  MOVFF  E8,FB
154E:  MOVFF  E7,FA
1552:  MOVFF  E6,F9
1556:  MOVLB  1
1558:  CLRF   x00
155A:  MOVLB  0
155C:  CLRF   xFF
155E:  CLRF   xFE
1560:  MOVFF  EA,FD
1564:  RCALL  1396
1566:  MOVFF  FEF,00
156A:  MOVFF  FEC,01
156E:  MOVFF  FEC,02
1572:  MOVFF  FEC,03
1576:  MOVFF  F8,FEA
157A:  MOVFF  F7,FE9
157E:  MOVFF  03,FC
1582:  MOVFF  02,FB
1586:  MOVFF  01,FA
158A:  MOVFF  00,F9
158E:  MOVLW  30
1590:  ADDWF  00,W
1592:  MOVWF  00
1594:  MOVLW  00
1596:  ADDWFC 01,W
1598:  MOVLW  00
159A:  ADDWFC 02,W
159C:  MOVLW  00
159E:  ADDWFC 03,W
15A0:  MOVFF  F6,FEA
15A4:  MOVFF  F5,FE9
15A8:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
15AC:  CLRF   03
15AE:  MOVF   xF3,W
15B0:  ADDWF  xEB,W
15B2:  MOVWF  FE9
15B4:  MOVF   xEC,W
15B6:  ADDWFC 03,W
15B8:  MOVWF  FEA
15BA:  MOVF   FEF,W
15BC:  SUBLW  39
15BE:  BC    15D4
....................             s[cnt]+=0x7; 
15C0:  CLRF   03
15C2:  MOVF   xF3,W
15C4:  ADDWF  xEB,W
15C6:  MOVWF  FE9
15C8:  MOVF   xEC,W
15CA:  ADDWFC 03,W
15CC:  MOVWF  FEA
15CE:  MOVLW  07
15D0:  ADDWF  FEF,W
15D2:  MOVWF  FEF
....................  
....................          cnt++; 
15D4:  INCF   xF3,F
....................          num=temp; 
15D6:  MOVFF  F0,E9
15DA:  MOVFF  EF,E8
15DE:  MOVFF  EE,E7
15E2:  MOVFF  ED,E6
....................      } 
15E6:  BRA    14EA
....................  
....................      if(sign==1) { 
15E8:  DECFSZ xF2,W
15EA:  BRA    1600
....................          s[cnt]=0x2D;      // Negative sign 
15EC:  CLRF   03
15EE:  MOVF   xF3,W
15F0:  ADDWF  xEB,W
15F2:  MOVWF  FE9
15F4:  MOVF   xEC,W
15F6:  ADDWFC 03,W
15F8:  MOVWF  FEA
15FA:  MOVLW  2D
15FC:  MOVWF  FEF
....................          cnt++; 
15FE:  INCF   xF3,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1600:  CLRF   xF1
1602:  BCF    FD8.0
1604:  RRCF   xF3,W
1606:  SUBWF  xF1,W
1608:  BC    1668
....................  
....................          c=s[i]; 
160A:  CLRF   03
160C:  MOVF   xF1,W
160E:  ADDWF  xEB,W
1610:  MOVWF  FE9
1612:  MOVF   xEC,W
1614:  ADDWFC 03,W
1616:  MOVWF  FEA
1618:  MOVFF  FEF,F4
....................          s[i]=s[cnt-i-1];        // Reverse the number 
161C:  CLRF   03
161E:  MOVF   xF1,W
1620:  ADDWF  xEB,W
1622:  MOVWF  01
1624:  MOVF   xEC,W
1626:  ADDWFC 03,F
1628:  MOVFF  03,F6
162C:  MOVF   xF1,W
162E:  SUBWF  xF3,W
1630:  ADDLW  FF
1632:  CLRF   03
1634:  ADDWF  xEB,W
1636:  MOVWF  FE9
1638:  MOVF   xEC,W
163A:  ADDWFC 03,W
163C:  MOVWF  FEA
163E:  MOVFF  FEF,F9
1642:  MOVFF  F6,FEA
1646:  MOVFF  01,FE9
164A:  MOVFF  F9,FEF
....................          s[cnt-i-1]=c; 
164E:  MOVF   xF1,W
1650:  SUBWF  xF3,W
1652:  ADDLW  FF
1654:  CLRF   03
1656:  ADDWF  xEB,W
1658:  MOVWF  FE9
165A:  MOVF   xEC,W
165C:  ADDWFC 03,W
165E:  MOVWF  FEA
1660:  MOVFF  F4,FEF
....................      } 
1664:  INCF   xF1,F
1666:  BRA    1602
....................      s[cnt]='\0';     // End the string 
1668:  CLRF   03
166A:  MOVF   xF3,W
166C:  ADDWF  xEB,W
166E:  MOVWF  FE9
1670:  MOVF   xEC,W
1672:  ADDWFC 03,W
1674:  MOVWF  FEA
1676:  CLRF   FEF
....................      return s; 
1678:  MOVFF  EB,01
167C:  MOVFF  EC,02
.................... } 
1680:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
546C:  MOVLB  1
546E:  BCF    x0B.0
....................    y = x; 
5470:  MOVFF  FF,104
5474:  MOVFF  FE,103
5478:  MOVFF  FD,102
547C:  MOVFF  FC,101
....................  
....................    if (x < 0) 
5480:  MOVFF  FF,14D
5484:  MOVFF  FE,14C
5488:  MOVFF  FD,14B
548C:  MOVFF  FC,14A
5490:  CLRF   x51
5492:  CLRF   x50
5494:  CLRF   x4F
5496:  CLRF   x4E
5498:  MOVLB  0
549A:  CALL   3DD6
549E:  BNC   54AA
....................    { 
....................       s = 1; 
54A0:  MOVLB  1
54A2:  BSF    x0B.0
....................       y = -y; 
54A4:  MOVF   x02,W
54A6:  XORLW  80
54A8:  MOVWF  x02
....................    } 
....................  
....................    if (y <= 32768.0) 
54AA:  MOVFF  104,14D
54AE:  MOVFF  103,14C
54B2:  MOVFF  102,14B
54B6:  MOVFF  101,14A
54BA:  MOVLB  1
54BC:  CLRF   x51
54BE:  CLRF   x50
54C0:  CLRF   x4F
54C2:  MOVLW  8E
54C4:  MOVWF  x4E
54C6:  MOVLB  0
54C8:  CALL   3DD6
54CC:  BC    54D0
54CE:  BNZ   5502
....................   res = (float32)(unsigned int16)y; 
54D0:  MOVFF  104,14D
54D4:  MOVFF  103,14C
54D8:  MOVFF  102,14B
54DC:  MOVFF  101,14A
54E0:  CALL   43B0
54E4:  MOVFF  02,14F
54E8:  MOVFF  01,14E
54EC:  CALL   437A
54F0:  MOVFF  03,108
54F4:  MOVFF  02,107
54F8:  MOVFF  01,106
54FC:  MOVFF  00,105
....................  
....................  else if (y < 10000000.0) 
5500:  BRA    56A8
5502:  MOVFF  104,14D
5506:  MOVFF  103,14C
550A:  MOVFF  102,14B
550E:  MOVFF  101,14A
5512:  MOVLW  80
5514:  MOVLB  1
5516:  MOVWF  x51
5518:  MOVLW  96
551A:  MOVWF  x50
551C:  MOVLW  18
551E:  MOVWF  x4F
5520:  MOVLW  96
5522:  MOVWF  x4E
5524:  MOVLB  0
5526:  CALL   3DD6
552A:  BTFSS  FD8.0
552C:  BRA    5698
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
552E:  MOVFF  104,14D
5532:  MOVFF  103,14C
5536:  MOVFF  102,14B
553A:  MOVFF  101,14A
553E:  MOVLB  1
5540:  CLRF   x51
5542:  CLRF   x50
5544:  CLRF   x4F
5546:  MOVLW  8E
5548:  MOVWF  x4E
554A:  MOVLB  0
554C:  CALL   0F1A
5550:  MOVFF  03,14D
5554:  MOVFF  02,14C
5558:  MOVFF  01,14B
555C:  MOVFF  00,14A
5560:  CALL   43B0
5564:  MOVFF  02,10A
5568:  MOVFF  01,109
....................       y = 32768.0*(y/32768.0 - (float32)l); 
556C:  MOVFF  104,14D
5570:  MOVFF  103,14C
5574:  MOVFF  102,14B
5578:  MOVFF  101,14A
557C:  MOVLB  1
557E:  CLRF   x51
5580:  CLRF   x50
5582:  CLRF   x4F
5584:  MOVLW  8E
5586:  MOVWF  x4E
5588:  MOVLB  0
558A:  CALL   0F1A
558E:  MOVFF  00,10C
5592:  MOVFF  01,10D
5596:  MOVFF  02,10E
559A:  MOVFF  03,10F
559E:  MOVFF  10A,14F
55A2:  MOVFF  109,14E
55A6:  CALL   437A
55AA:  BSF    FD8.1
55AC:  MOVFF  10F,153
55B0:  MOVFF  10E,152
55B4:  MOVFF  10D,151
55B8:  MOVFF  10C,150
55BC:  MOVFF  03,157
55C0:  MOVFF  02,156
55C4:  MOVFF  01,155
55C8:  MOVFF  00,154
55CC:  CALL   1078
55D0:  MOVLB  1
55D2:  CLRF   x51
55D4:  CLRF   x50
55D6:  CLRF   x4F
55D8:  MOVLW  8E
55DA:  MOVWF  x4E
55DC:  MOVFF  03,155
55E0:  MOVFF  02,154
55E4:  MOVFF  01,153
55E8:  MOVFF  00,152
55EC:  MOVLB  0
55EE:  CALL   0E24
55F2:  MOVFF  03,104
55F6:  MOVFF  02,103
55FA:  MOVFF  01,102
55FE:  MOVFF  00,101
....................   res = 32768.0*(float32)l; 
5602:  MOVFF  10A,14F
5606:  MOVFF  109,14E
560A:  CALL   437A
560E:  MOVLB  1
5610:  CLRF   x51
5612:  CLRF   x50
5614:  CLRF   x4F
5616:  MOVLW  8E
5618:  MOVWF  x4E
561A:  MOVFF  03,155
561E:  MOVFF  02,154
5622:  MOVFF  01,153
5626:  MOVFF  00,152
562A:  MOVLB  0
562C:  CALL   0E24
5630:  MOVFF  03,108
5634:  MOVFF  02,107
5638:  MOVFF  01,106
563C:  MOVFF  00,105
....................   res += (float32)(unsigned int16)y; 
5640:  MOVFF  104,14D
5644:  MOVFF  103,14C
5648:  MOVFF  102,14B
564C:  MOVFF  101,14A
5650:  CALL   43B0
5654:  MOVFF  02,14F
5658:  MOVFF  01,14E
565C:  CALL   437A
5660:  BCF    FD8.1
5662:  MOVFF  108,153
5666:  MOVFF  107,152
566A:  MOVFF  106,151
566E:  MOVFF  105,150
5672:  MOVFF  03,157
5676:  MOVFF  02,156
567A:  MOVFF  01,155
567E:  MOVFF  00,154
5682:  CALL   1078
5686:  MOVFF  03,108
568A:  MOVFF  02,107
568E:  MOVFF  01,106
5692:  MOVFF  00,105
....................  } 
....................  
....................  else 
5696:  BRA    56A8
....................   res = y; 
5698:  MOVFF  104,108
569C:  MOVFF  103,107
56A0:  MOVFF  102,106
56A4:  MOVFF  101,105
....................  
....................  y = y - (float32)(unsigned int16)y; 
56A8:  MOVFF  104,14D
56AC:  MOVFF  103,14C
56B0:  MOVFF  102,14B
56B4:  MOVFF  101,14A
56B8:  CALL   43B0
56BC:  MOVFF  02,14F
56C0:  MOVFF  01,14E
56C4:  CALL   437A
56C8:  BSF    FD8.1
56CA:  MOVFF  104,153
56CE:  MOVFF  103,152
56D2:  MOVFF  102,151
56D6:  MOVFF  101,150
56DA:  MOVFF  03,157
56DE:  MOVFF  02,156
56E2:  MOVFF  01,155
56E6:  MOVFF  00,154
56EA:  CALL   1078
56EE:  MOVFF  03,104
56F2:  MOVFF  02,103
56F6:  MOVFF  01,102
56FA:  MOVFF  00,101
....................  
....................  if (s) 
56FE:  MOVLB  1
5700:  BTFSS  x0B.0
5702:  BRA    570A
....................   res = -res; 
5704:  MOVF   x06,W
5706:  XORLW  80
5708:  MOVWF  x06
....................  
....................  if (y != 0) 
570A:  MOVFF  104,14D
570E:  MOVFF  103,14C
5712:  MOVFF  102,14B
5716:  MOVFF  101,14A
571A:  CLRF   x51
571C:  CLRF   x50
571E:  CLRF   x4F
5720:  CLRF   x4E
5722:  MOVLB  0
5724:  CALL   3DD6
5728:  BZ    57A2
....................  { 
....................   if (s == 1 && n == 0) 
572A:  MOVLB  1
572C:  BTFSS  x0B.0
572E:  BRA    5768
5730:  MOVF   x00,F
5732:  BNZ   5768
....................    res -= 1.0; 
5734:  BSF    FD8.1
5736:  MOVFF  108,153
573A:  MOVFF  107,152
573E:  MOVFF  106,151
5742:  MOVFF  105,150
5746:  CLRF   x57
5748:  CLRF   x56
574A:  CLRF   x55
574C:  MOVLW  7F
574E:  MOVWF  x54
5750:  MOVLB  0
5752:  CALL   1078
5756:  MOVFF  03,108
575A:  MOVFF  02,107
575E:  MOVFF  01,106
5762:  MOVFF  00,105
5766:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
5768:  BTFSC  x0B.0
576A:  BRA    57A4
576C:  DECFSZ x00,W
576E:  BRA    57A4
....................    res += 1.0; 
5770:  BCF    FD8.1
5772:  MOVFF  108,153
5776:  MOVFF  107,152
577A:  MOVFF  106,151
577E:  MOVFF  105,150
5782:  CLRF   x57
5784:  CLRF   x56
5786:  CLRF   x55
5788:  MOVLW  7F
578A:  MOVWF  x54
578C:  MOVLB  0
578E:  CALL   1078
5792:  MOVFF  03,108
5796:  MOVFF  02,107
579A:  MOVFF  01,106
579E:  MOVFF  00,105
57A2:  MOVLB  1
....................  } 
....................  if (x == 0) 
57A4:  MOVFF  FF,14D
57A8:  MOVFF  FE,14C
57AC:  MOVFF  FD,14B
57B0:  MOVFF  FC,14A
57B4:  CLRF   x51
57B6:  CLRF   x50
57B8:  CLRF   x4F
57BA:  CLRF   x4E
57BC:  MOVLB  0
57BE:  CALL   3DD6
57C2:  BNZ   57D0
....................     res = 0; 
57C4:  MOVLB  1
57C6:  CLRF   x08
57C8:  CLRF   x07
57CA:  CLRF   x06
57CC:  CLRF   x05
57CE:  MOVLB  0
....................  
....................  return (res); 
57D0:  MOVFF  105,00
57D4:  MOVFF  106,01
57D8:  MOVFF  107,02
57DC:  MOVFF  108,03
.................... } 
57E0:  RETLW  00
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
5800:  MOVFF  FB,FF
5804:  MOVFF  FA,FE
5808:  MOVFF  F9,FD
580C:  MOVFF  F8,FC
5810:  MOVLB  1
5812:  CLRF   x00
5814:  MOVLB  0
5816:  RCALL  546C
.................... } 
5818:  GOTO   5924 (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
57E2:  MOVFF  FA,FF
57E6:  MOVFF  F9,FE
57EA:  MOVFF  F8,FD
57EE:  MOVFF  F7,FC
57F2:  MOVLW  01
57F4:  MOVLB  1
57F6:  MOVWF  x00
57F8:  MOVLB  0
57FA:  RCALL  546C
.................... } 
57FC:  GOTO   58DC (RETURN)
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
581C:  MOVFF  EA,14D
5820:  MOVFF  E9,14C
5824:  MOVFF  E8,14B
5828:  MOVFF  E7,14A
582C:  MOVLB  1
582E:  CLRF   x51
5830:  CLRF   x50
5832:  CLRF   x4F
5834:  CLRF   x4E
5836:  MOVLB  0
5838:  CALL   3DD6
583C:  BTFSC  FD8.2
583E:  BRA    5982
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
5840:  MOVFF  E6,14D
5844:  MOVFF  E5,14C
5848:  MOVFF  E4,14B
584C:  MOVFF  E3,14A
5850:  MOVFF  EA,151
5854:  MOVFF  E9,150
5858:  MOVFF  E8,14F
585C:  MOVFF  E7,14E
5860:  CALL   0F1A
5864:  MOVFF  00,EF
5868:  MOVFF  01,F0
586C:  MOVFF  02,F1
5870:  MOVFF  03,F2
5874:  MOVFF  03,14D
5878:  MOVFF  02,14C
587C:  MOVFF  01,14B
5880:  MOVFF  00,14A
5884:  MOVLB  1
5886:  CLRF   x51
5888:  CLRF   x50
588A:  CLRF   x4F
588C:  CLRF   x4E
588E:  MOVLB  0
5890:  CALL   3DD6
5894:  BNC   58DE
5896:  MOVFF  E6,14D
589A:  MOVFF  E5,14C
589E:  MOVFF  E4,14B
58A2:  MOVFF  E3,14A
58A6:  MOVFF  EA,151
58AA:  MOVFF  E9,150
58AE:  MOVFF  E8,14F
58B2:  MOVFF  E7,14E
58B6:  CALL   0F1A
58BA:  MOVFF  00,F3
58BE:  MOVFF  01,F4
58C2:  MOVFF  02,F5
58C6:  MOVFF  03,F6
58CA:  MOVFF  03,FA
58CE:  MOVFF  02,F9
58D2:  MOVFF  01,F8
58D6:  MOVFF  00,F7
58DA:  BRA    57E2
58DC:  BRA    5924
58DE:  MOVFF  E6,14D
58E2:  MOVFF  E5,14C
58E6:  MOVFF  E4,14B
58EA:  MOVFF  E3,14A
58EE:  MOVFF  EA,151
58F2:  MOVFF  E9,150
58F6:  MOVFF  E8,14F
58FA:  MOVFF  E7,14E
58FE:  CALL   0F1A
5902:  MOVFF  00,F4
5906:  MOVFF  01,F5
590A:  MOVFF  02,F6
590E:  MOVFF  03,F7
5912:  MOVFF  03,FB
5916:  MOVFF  02,FA
591A:  MOVFF  01,F9
591E:  MOVFF  00,F8
5922:  BRA    5800
5924:  MOVFF  03,EE
5928:  MOVFF  02,ED
592C:  MOVFF  01,EC
5930:  MOVFF  00,EB
....................       return(x-(i*y)); 
5934:  MOVFF  EE,151
5938:  MOVFF  ED,150
593C:  MOVFF  EC,14F
5940:  MOVFF  EB,14E
5944:  MOVFF  EA,155
5948:  MOVFF  E9,154
594C:  MOVFF  E8,153
5950:  MOVFF  E7,152
5954:  CALL   0E24
5958:  BSF    FD8.1
595A:  MOVFF  E6,153
595E:  MOVFF  E5,152
5962:  MOVFF  E4,151
5966:  MOVFF  E3,150
596A:  MOVFF  03,157
596E:  MOVFF  02,156
5972:  MOVFF  01,155
5976:  MOVFF  00,154
597A:  CALL   1078
597E:  BRA    5982
....................    } 
....................    else 
5980:  BRA    5982
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
5982:  GOTO   5C16 (RETURN)
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
4860:  MOVFF  115,14D
4864:  MOVFF  114,14C
4868:  MOVFF  113,14B
486C:  MOVFF  112,14A
4870:  MOVLB  1
4872:  CLRF   x51
4874:  CLRF   x50
4876:  CLRF   x4F
4878:  CLRF   x4E
487A:  MOVLB  0
487C:  CALL   3DD6
4880:  BC    4884
4882:  BNZ   488E
....................       return(0.0); 
4884:  CLRF   00
4886:  CLRF   01
4888:  CLRF   02
488A:  CLRF   03
488C:  BRA    4988
....................  
....................    y=x; 
488E:  MOVFF  115,119
4892:  MOVFF  114,118
4896:  MOVFF  113,117
489A:  MOVFF  112,116
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
489E:  MOVLW  01
48A0:  MOVLB  1
48A2:  MOVWF  x1F
48A4:  MOVLW  16
48A6:  MOVWF  x1E
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
48A8:  MOVFF  11E,FE9
48AC:  MOVFF  11F,FEA
48B0:  MOVF   FEF,W
48B2:  CLRF   x23
48B4:  MOVWF  x22
48B6:  MOVLW  7F
48B8:  ADDWF  x22,W
48BA:  MOVWF  x24
48BC:  MOVLW  00
48BE:  ADDWFC x23,W
48C0:  MOVWF  x25
48C2:  BCF    FD8.0
48C4:  RRCF   x25,W
48C6:  RRCF   x24,W
48C8:  MOVFF  11F,FEA
48CC:  MOVFF  11E,FE9
48D0:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
48D2:  MOVFF  119,11D
48D6:  MOVFF  118,11C
48DA:  MOVFF  117,11B
48DE:  MOVFF  116,11A
....................       y+=(x/y); 
48E2:  MOVFF  115,14D
48E6:  MOVFF  114,14C
48EA:  MOVFF  113,14B
48EE:  MOVFF  112,14A
48F2:  MOVFF  119,151
48F6:  MOVFF  118,150
48FA:  MOVFF  117,14F
48FE:  MOVFF  116,14E
4902:  MOVLB  0
4904:  CALL   0F1A
4908:  BCF    FD8.1
490A:  MOVFF  119,153
490E:  MOVFF  118,152
4912:  MOVFF  117,151
4916:  MOVFF  116,150
491A:  MOVFF  03,157
491E:  MOVFF  02,156
4922:  MOVFF  01,155
4926:  MOVFF  00,154
492A:  CALL   1078
492E:  MOVFF  03,119
4932:  MOVFF  02,118
4936:  MOVFF  01,117
493A:  MOVFF  00,116
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
493E:  MOVLB  1
4940:  MOVFF  11E,FE9
4944:  MOVFF  11F,FEA
4948:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
494A:  MOVFF  11D,14D
494E:  MOVFF  11C,14C
4952:  MOVFF  11B,14B
4956:  MOVFF  11A,14A
495A:  MOVFF  119,151
495E:  MOVFF  118,150
4962:  MOVFF  117,14F
4966:  MOVFF  116,14E
496A:  MOVLB  0
496C:  CALL   3DD6
4970:  BTFSC  FD8.2
4972:  BRA    4978
4974:  MOVLB  1
4976:  BRA    48D2
....................  
....................    return(res); 
4978:  MOVFF  11A,00
497C:  MOVFF  11B,01
4980:  MOVFF  11C,02
4984:  MOVFF  11D,03
.................... } 
4988:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
43EC:  MOVLW  7F
43EE:  MOVLB  1
43F0:  MOVWF  x30
43F2:  CLRF   x31
43F4:  CLRF   x32
43F6:  CLRF   x33
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
43F8:  MOVLW  7E
43FA:  MOVWF  x3A
43FC:  MOVLW  80
43FE:  MOVWF  x3B
4400:  CLRF   x3C
4402:  CLRF   x3D
4404:  MOVLW  7A
4406:  MOVWF  x3E
4408:  MOVLW  2A
440A:  MOVWF  x3F
440C:  MOVLW  AA
440E:  MOVWF  x40
4410:  MOVLW  A3
4412:  MOVWF  x41
4414:  MOVLW  75
4416:  MOVWF  x42
4418:  MOVLW  B6
441A:  MOVWF  x43
441C:  MOVLW  09
441E:  MOVWF  x44
4420:  MOVLW  9C
4422:  MOVWF  x45
4424:  MOVLW  6F
4426:  MOVWF  x46
4428:  MOVLW  4F
442A:  MOVWF  x47
442C:  MOVLW  B4
442E:  MOVWF  x48
4430:  MOVLW  0B
4432:  MOVWF  x49
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
4434:  MOVFF  127,14D
4438:  MOVFF  126,14C
443C:  MOVFF  125,14B
4440:  MOVFF  124,14A
4444:  CLRF   x51
4446:  CLRF   x50
4448:  CLRF   x4F
444A:  CLRF   x4E
444C:  MOVLB  0
444E:  RCALL  3DD6
4450:  BNC   445A
4452:  MOVLB  1
4454:  MOVF   x25,W
4456:  XORLW  80
4458:  MOVWF  x25
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
445A:  MOVFF  127,14D
445E:  MOVFF  126,14C
4462:  MOVFF  125,14B
4466:  MOVFF  124,14A
446A:  MOVLW  DB
446C:  MOVLB  1
446E:  MOVWF  x51
4470:  MOVLW  0F
4472:  MOVWF  x50
4474:  MOVLW  49
4476:  MOVWF  x4F
4478:  MOVLW  7F
447A:  MOVWF  x4E
447C:  MOVLB  0
447E:  CALL   0F1A
4482:  MOVFF  03,14D
4486:  MOVFF  02,14C
448A:  MOVFF  01,14B
448E:  MOVFF  00,14A
4492:  RCALL  43B0
4494:  MOVFF  01,134
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
4498:  MOVFF  127,14D
449C:  MOVFF  126,14C
44A0:  MOVFF  125,14B
44A4:  MOVFF  124,14A
44A8:  MOVLW  DB
44AA:  MOVLB  1
44AC:  MOVWF  x51
44AE:  MOVLW  0F
44B0:  MOVWF  x50
44B2:  MOVLW  49
44B4:  MOVWF  x4F
44B6:  MOVLW  7F
44B8:  MOVWF  x4E
44BA:  MOVLB  0
44BC:  CALL   0F1A
44C0:  MOVFF  00,14A
44C4:  MOVFF  01,14B
44C8:  MOVFF  02,14C
44CC:  MOVFF  03,14D
44D0:  MOVLB  1
44D2:  CLRF   x4F
44D4:  MOVFF  134,14E
44D8:  MOVLB  0
44DA:  RCALL  437A
44DC:  BSF    FD8.1
44DE:  MOVFF  14D,153
44E2:  MOVFF  14C,152
44E6:  MOVFF  14B,151
44EA:  MOVFF  14A,150
44EE:  MOVFF  03,157
44F2:  MOVFF  02,156
44F6:  MOVFF  01,155
44FA:  MOVFF  00,154
44FE:  CALL   1078
4502:  MOVFF  03,139
4506:  MOVFF  02,138
450A:  MOVFF  01,137
450E:  MOVFF  00,136
....................    quad = quad % 4;                    // quadrant (0 to 3) 
4512:  MOVLW  03
4514:  MOVLB  1
4516:  ANDWF  x34,F
....................  
....................    if (quad == 0 || quad == 2) 
4518:  MOVF   x34,F
451A:  BZ    4522
451C:  MOVF   x34,W
451E:  SUBLW  02
4520:  BNZ   455C
....................       t = frac * PI_DIV_BY_TWO; 
4522:  MOVFF  139,151
4526:  MOVFF  138,150
452A:  MOVFF  137,14F
452E:  MOVFF  136,14E
4532:  MOVLW  DB
4534:  MOVWF  x55
4536:  MOVLW  0F
4538:  MOVWF  x54
453A:  MOVLW  49
453C:  MOVWF  x53
453E:  MOVLW  7F
4540:  MOVWF  x52
4542:  MOVLB  0
4544:  CALL   0E24
4548:  MOVFF  03,12F
454C:  MOVFF  02,12E
4550:  MOVFF  01,12D
4554:  MOVFF  00,12C
....................    else if (quad == 1) 
4558:  BRA    4638
455A:  MOVLB  1
455C:  DECFSZ x34,W
455E:  BRA    45CE
....................       t = (1-frac) * PI_DIV_BY_TWO; 
4560:  BSF    FD8.1
4562:  CLRF   x53
4564:  CLRF   x52
4566:  CLRF   x51
4568:  MOVLW  7F
456A:  MOVWF  x50
456C:  MOVFF  139,157
4570:  MOVFF  138,156
4574:  MOVFF  137,155
4578:  MOVFF  136,154
457C:  MOVLB  0
457E:  CALL   1078
4582:  MOVFF  00,14A
4586:  MOVFF  01,14B
458A:  MOVFF  02,14C
458E:  MOVFF  03,14D
4592:  MOVFF  03,151
4596:  MOVFF  02,150
459A:  MOVFF  01,14F
459E:  MOVFF  00,14E
45A2:  MOVLW  DB
45A4:  MOVLB  1
45A6:  MOVWF  x55
45A8:  MOVLW  0F
45AA:  MOVWF  x54
45AC:  MOVLW  49
45AE:  MOVWF  x53
45B0:  MOVLW  7F
45B2:  MOVWF  x52
45B4:  MOVLB  0
45B6:  CALL   0E24
45BA:  MOVFF  03,12F
45BE:  MOVFF  02,12E
45C2:  MOVFF  01,12D
45C6:  MOVFF  00,12C
....................    else // should be 3 
45CA:  BRA    4638
45CC:  MOVLB  1
....................       t = (frac-1) * PI_DIV_BY_TWO; 
45CE:  BSF    FD8.1
45D0:  MOVFF  139,153
45D4:  MOVFF  138,152
45D8:  MOVFF  137,151
45DC:  MOVFF  136,150
45E0:  CLRF   x57
45E2:  CLRF   x56
45E4:  CLRF   x55
45E6:  MOVLW  7F
45E8:  MOVWF  x54
45EA:  MOVLB  0
45EC:  CALL   1078
45F0:  MOVFF  00,14A
45F4:  MOVFF  01,14B
45F8:  MOVFF  02,14C
45FC:  MOVFF  03,14D
4600:  MOVFF  03,151
4604:  MOVFF  02,150
4608:  MOVFF  01,14F
460C:  MOVFF  00,14E
4610:  MOVLW  DB
4612:  MOVLB  1
4614:  MOVWF  x55
4616:  MOVLW  0F
4618:  MOVWF  x54
461A:  MOVLW  49
461C:  MOVWF  x53
461E:  MOVLW  7F
4620:  MOVWF  x52
4622:  MOVLB  0
4624:  CALL   0E24
4628:  MOVFF  03,12F
462C:  MOVFF  02,12E
4630:  MOVFF  01,12D
4634:  MOVFF  00,12C
....................  
....................    y = 0.999999999781; 
4638:  MOVLB  1
463A:  CLRF   x2B
463C:  CLRF   x2A
463E:  CLRF   x29
4640:  MOVLW  7F
4642:  MOVWF  x28
....................    t = t * t; 
4644:  MOVFF  12F,151
4648:  MOVFF  12E,150
464C:  MOVFF  12D,14F
4650:  MOVFF  12C,14E
4654:  MOVFF  12F,155
4658:  MOVFF  12E,154
465C:  MOVFF  12D,153
4660:  MOVFF  12C,152
4664:  MOVLB  0
4666:  CALL   0E24
466A:  MOVFF  03,12F
466E:  MOVFF  02,12E
4672:  MOVFF  01,12D
4676:  MOVFF  00,12C
....................    for (i = 0; i <= 3; i++) 
467A:  MOVLB  1
467C:  CLRF   x35
467E:  MOVF   x35,W
4680:  SUBLW  03
4682:  BNC   4750
....................    { 
....................       t2 = t2 * t; 
4684:  MOVFF  133,151
4688:  MOVFF  132,150
468C:  MOVFF  131,14F
4690:  MOVFF  130,14E
4694:  MOVFF  12F,155
4698:  MOVFF  12E,154
469C:  MOVFF  12D,153
46A0:  MOVFF  12C,152
46A4:  MOVLB  0
46A6:  CALL   0E24
46AA:  MOVFF  03,133
46AE:  MOVFF  02,132
46B2:  MOVFF  01,131
46B6:  MOVFF  00,130
....................       y = y + p[i] * t2; 
46BA:  MOVLB  1
46BC:  MOVF   x35,W
46BE:  MULLW  04
46C0:  MOVF   FF3,W
46C2:  CLRF   03
46C4:  ADDLW  3A
46C6:  MOVWF  FE9
46C8:  MOVLW  01
46CA:  ADDWFC 03,W
46CC:  MOVWF  FEA
46CE:  MOVFF  FEF,14A
46D2:  MOVFF  FEC,14B
46D6:  MOVFF  FEC,14C
46DA:  MOVFF  FEC,14D
46DE:  MOVFF  14D,151
46E2:  MOVFF  14C,150
46E6:  MOVFF  14B,14F
46EA:  MOVFF  14A,14E
46EE:  MOVFF  133,155
46F2:  MOVFF  132,154
46F6:  MOVFF  131,153
46FA:  MOVFF  130,152
46FE:  MOVLB  0
4700:  CALL   0E24
4704:  MOVFF  FEA,14F
4708:  MOVFF  FE9,14E
470C:  BCF    FD8.1
470E:  MOVFF  12B,153
4712:  MOVFF  12A,152
4716:  MOVFF  129,151
471A:  MOVFF  128,150
471E:  MOVFF  03,157
4722:  MOVFF  02,156
4726:  MOVFF  01,155
472A:  MOVFF  00,154
472E:  CALL   1078
4732:  MOVFF  14F,FEA
4736:  MOVFF  14E,FE9
473A:  MOVFF  03,12B
473E:  MOVFF  02,12A
4742:  MOVFF  01,129
4746:  MOVFF  00,128
....................    } 
474A:  MOVLB  1
474C:  INCF   x35,F
474E:  BRA    467E
....................  
....................    if (quad == 2 || quad == 1) 
4750:  MOVF   x34,W
4752:  SUBLW  02
4754:  BZ    475A
4756:  DECFSZ x34,W
4758:  BRA    4760
....................       y = -y;  // correct sign 
475A:  MOVF   x29,W
475C:  XORLW  80
475E:  MOVWF  x29
....................  
....................    return (y); 
4760:  MOVFF  128,00
4764:  MOVFF  129,01
4768:  MOVFF  12A,02
476C:  MOVFF  12B,03
.................... } 
4770:  MOVLB  0
4772:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
4774:  BSF    FD8.1
4776:  MOVFF  11F,153
477A:  MOVFF  11E,152
477E:  MOVFF  11D,151
4782:  MOVFF  11C,150
4786:  MOVLW  DB
4788:  MOVLB  1
478A:  MOVWF  x57
478C:  MOVLW  0F
478E:  MOVWF  x56
4790:  MOVLW  49
4792:  MOVWF  x55
4794:  MOVLW  7F
4796:  MOVWF  x54
4798:  MOVLB  0
479A:  CALL   1078
479E:  MOVFF  00,120
47A2:  MOVFF  01,121
47A6:  MOVFF  02,122
47AA:  MOVFF  03,123
47AE:  MOVFF  03,127
47B2:  MOVFF  02,126
47B6:  MOVFF  01,125
47BA:  MOVFF  00,124
47BE:  RCALL  43EC
.................... } 
47C0:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
47C2:  MOVFF  113,127
47C6:  MOVFF  112,126
47CA:  MOVFF  111,125
47CE:  MOVFF  110,124
47D2:  RCALL  43EC
47D4:  MOVFF  03,117
47D8:  MOVFF  02,116
47DC:  MOVFF  01,115
47E0:  MOVFF  00,114
....................    if (c == 0.0) 
47E4:  MOVFF  117,14D
47E8:  MOVFF  116,14C
47EC:  MOVFF  115,14B
47F0:  MOVFF  114,14A
47F4:  MOVLB  1
47F6:  CLRF   x51
47F8:  CLRF   x50
47FA:  CLRF   x4F
47FC:  CLRF   x4E
47FE:  MOVLB  0
4800:  CALL   3DD6
4804:  BNZ   4818
....................       return (1.0e+36); 
4806:  MOVLW  F6
4808:  MOVWF  00
480A:  MOVLW  40
480C:  MOVWF  01
480E:  MOVLW  97
4810:  MOVWF  02
4812:  MOVLW  CE
4814:  MOVWF  03
4816:  BRA    485E
....................  
....................    s = sin(x); 
4818:  MOVFF  113,11F
481C:  MOVFF  112,11E
4820:  MOVFF  111,11D
4824:  MOVFF  110,11C
4828:  RCALL  4774
482A:  MOVFF  03,11B
482E:  MOVFF  02,11A
4832:  MOVFF  01,119
4836:  MOVFF  00,118
....................    return(s/c); 
483A:  MOVFF  11B,14D
483E:  MOVFF  11A,14C
4842:  MOVFF  119,14B
4846:  MOVFF  118,14A
484A:  MOVFF  117,151
484E:  MOVFF  116,150
4852:  MOVFF  115,14F
4856:  MOVFF  114,14E
485A:  CALL   0F1A
.................... } 
485E:  RETLW  00
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
502A:  MOVLB  1
502C:  BCF    x09.0
....................    y = x; 
502E:  MOVFF  F7,FC
5032:  MOVFF  F6,FB
5036:  MOVFF  F5,FA
503A:  MOVFF  F4,F9
....................  
....................    if (x < 0) 
503E:  MOVFF  F7,14D
5042:  MOVFF  F6,14C
5046:  MOVFF  F5,14B
504A:  MOVFF  F4,14A
504E:  CLRF   x51
5050:  CLRF   x50
5052:  CLRF   x4F
5054:  CLRF   x4E
5056:  MOVLB  0
5058:  CALL   3DD6
505C:  BNC   506A
....................    { 
....................       s = 1; 
505E:  MOVLB  1
5060:  BSF    x09.0
....................       y = -y; 
5062:  MOVLB  0
5064:  MOVF   xFA,W
5066:  XORLW  80
5068:  MOVWF  xFA
....................    } 
....................  
....................    if (y > 0.5) 
506A:  MOVLB  1
506C:  CLRF   x4D
506E:  CLRF   x4C
5070:  CLRF   x4B
5072:  MOVLW  7E
5074:  MOVWF  x4A
5076:  MOVFF  FC,151
507A:  MOVFF  FB,150
507E:  MOVFF  FA,14F
5082:  MOVFF  F9,14E
5086:  MOVLB  0
5088:  CALL   3DD6
508C:  BNC   511C
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
508E:  BSF    FD8.1
5090:  MOVLB  1
5092:  CLRF   x53
5094:  CLRF   x52
5096:  CLRF   x51
5098:  MOVLW  7F
509A:  MOVWF  x50
509C:  MOVFF  FC,157
50A0:  MOVFF  FB,156
50A4:  MOVFF  FA,155
50A8:  MOVFF  F9,154
50AC:  MOVLB  0
50AE:  CALL   1078
50B2:  MOVFF  00,10A
50B6:  MOVFF  01,10B
50BA:  MOVFF  02,10C
50BE:  MOVFF  03,10D
50C2:  MOVFF  03,14D
50C6:  MOVFF  02,14C
50CA:  MOVFF  01,14B
50CE:  MOVFF  00,14A
50D2:  MOVLB  1
50D4:  CLRF   x51
50D6:  CLRF   x50
50D8:  CLRF   x4F
50DA:  MOVLW  80
50DC:  MOVWF  x4E
50DE:  MOVLB  0
50E0:  CALL   0F1A
50E4:  MOVFF  00,10E
50E8:  MOVFF  01,10F
50EC:  MOVFF  02,110
50F0:  MOVFF  03,111
50F4:  MOVFF  03,115
50F8:  MOVFF  02,114
50FC:  MOVFF  01,113
5100:  MOVFF  00,112
5104:  CALL   4860
5108:  MOVFF  03,FC
510C:  MOVFF  02,FB
5110:  MOVFF  01,FA
5114:  MOVFF  00,F9
....................       n += 2; 
5118:  MOVLW  02
511A:  ADDWF  xF8,F
....................    } 
....................  
....................    y2=y*y; 
511C:  MOVFF  FC,151
5120:  MOVFF  FB,150
5124:  MOVFF  FA,14F
5128:  MOVFF  F9,14E
512C:  MOVFF  FC,155
5130:  MOVFF  FB,154
5134:  MOVFF  FA,153
5138:  MOVFF  F9,152
513C:  CALL   0E24
5140:  MOVFF  03,108
5144:  MOVFF  02,107
5148:  MOVFF  01,106
514C:  MOVFF  00,105
....................  
....................    res = pas[0]*y2 + pas[1]; 
5150:  MOVLW  37
5152:  MOVLB  1
5154:  MOVWF  x51
5156:  MOVLW  BF
5158:  MOVWF  x50
515A:  MOVLW  7D
515C:  MOVWF  x4F
515E:  MOVWF  x4E
5160:  MOVFF  108,155
5164:  MOVFF  107,154
5168:  MOVFF  106,153
516C:  MOVFF  105,152
5170:  MOVLB  0
5172:  CALL   0E24
5176:  MOVFF  00,10A
517A:  MOVFF  01,10B
517E:  MOVFF  02,10C
5182:  MOVFF  03,10D
5186:  BCF    FD8.1
5188:  MOVFF  03,153
518C:  MOVFF  02,152
5190:  MOVFF  01,151
5194:  MOVFF  00,150
5198:  MOVLW  3D
519A:  MOVLB  1
519C:  MOVWF  x57
519E:  MOVLW  AA
51A0:  MOVWF  x56
51A2:  MOVLW  93
51A4:  MOVWF  x55
51A6:  MOVLW  81
51A8:  MOVWF  x54
51AA:  MOVLB  0
51AC:  CALL   1078
51B0:  MOVFF  03,100
51B4:  MOVFF  02,FF
51B8:  MOVFF  01,FE
51BC:  MOVFF  00,FD
....................    res = res*y2 + pas[2]; 
51C0:  MOVFF  100,151
51C4:  MOVFF  FF,150
51C8:  MOVFF  FE,14F
51CC:  MOVFF  FD,14E
51D0:  MOVFF  108,155
51D4:  MOVFF  107,154
51D8:  MOVFF  106,153
51DC:  MOVFF  105,152
51E0:  CALL   0E24
51E4:  MOVFF  00,10A
51E8:  MOVFF  01,10B
51EC:  MOVFF  02,10C
51F0:  MOVFF  03,10D
51F4:  BCF    FD8.1
51F6:  MOVFF  03,153
51FA:  MOVFF  02,152
51FE:  MOVFF  01,151
5202:  MOVFF  00,150
5206:  MOVLW  EE
5208:  MOVLB  1
520A:  MOVWF  x57
520C:  MOVLW  50
520E:  MOVWF  x56
5210:  MOVLW  33
5212:  MOVWF  x55
5214:  MOVLW  81
5216:  MOVWF  x54
5218:  MOVLB  0
521A:  CALL   1078
521E:  MOVFF  03,100
5222:  MOVFF  02,FF
5226:  MOVFF  01,FE
522A:  MOVFF  00,FD
....................  
....................    r = qas[0]*y2 + qas[1]; 
522E:  MOVLB  1
5230:  CLRF   x51
5232:  CLRF   x50
5234:  CLRF   x4F
5236:  MOVLW  7F
5238:  MOVWF  x4E
523A:  MOVFF  108,155
523E:  MOVFF  107,154
5242:  MOVFF  106,153
5246:  MOVFF  105,152
524A:  MOVLB  0
524C:  CALL   0E24
5250:  MOVFF  00,10A
5254:  MOVFF  01,10B
5258:  MOVFF  02,10C
525C:  MOVFF  03,10D
5260:  BCF    FD8.1
5262:  MOVFF  03,153
5266:  MOVFF  02,152
526A:  MOVFF  01,151
526E:  MOVFF  00,150
5272:  MOVLW  0A
5274:  MOVLB  1
5276:  MOVWF  x57
5278:  MOVLW  8D
527A:  MOVWF  x56
527C:  MOVLW  B1
527E:  MOVWF  x55
5280:  MOVLW  81
5282:  MOVWF  x54
5284:  MOVLB  0
5286:  CALL   1078
528A:  MOVFF  03,104
528E:  MOVFF  02,103
5292:  MOVFF  01,102
5296:  MOVFF  00,101
....................    r = r*y2 + qas[2]; 
529A:  MOVFF  104,151
529E:  MOVFF  103,150
52A2:  MOVFF  102,14F
52A6:  MOVFF  101,14E
52AA:  MOVFF  108,155
52AE:  MOVFF  107,154
52B2:  MOVFF  106,153
52B6:  MOVFF  105,152
52BA:  CALL   0E24
52BE:  MOVFF  00,10A
52C2:  MOVFF  01,10B
52C6:  MOVFF  02,10C
52CA:  MOVFF  03,10D
52CE:  BCF    FD8.1
52D0:  MOVFF  03,153
52D4:  MOVFF  02,152
52D8:  MOVFF  01,151
52DC:  MOVFF  00,150
52E0:  MOVLW  EE
52E2:  MOVLB  1
52E4:  MOVWF  x57
52E6:  MOVLW  50
52E8:  MOVWF  x56
52EA:  MOVLW  33
52EC:  MOVWF  x55
52EE:  MOVLW  81
52F0:  MOVWF  x54
52F2:  MOVLB  0
52F4:  CALL   1078
52F8:  MOVFF  03,104
52FC:  MOVFF  02,103
5300:  MOVFF  01,102
5304:  MOVFF  00,101
....................  
....................    res = y*res/r; 
5308:  MOVFF  FC,151
530C:  MOVFF  FB,150
5310:  MOVFF  FA,14F
5314:  MOVFF  F9,14E
5318:  MOVFF  100,155
531C:  MOVFF  FF,154
5320:  MOVFF  FE,153
5324:  MOVFF  FD,152
5328:  CALL   0E24
532C:  MOVFF  00,10A
5330:  MOVFF  01,10B
5334:  MOVFF  02,10C
5338:  MOVFF  03,10D
533C:  MOVFF  03,14D
5340:  MOVFF  02,14C
5344:  MOVFF  01,14B
5348:  MOVFF  00,14A
534C:  MOVFF  104,151
5350:  MOVFF  103,150
5354:  MOVFF  102,14F
5358:  MOVFF  101,14E
535C:  CALL   0F1A
5360:  MOVFF  03,100
5364:  MOVFF  02,FF
5368:  MOVFF  01,FE
536C:  MOVFF  00,FD
....................  
....................    if (n & 2)     // |x| > 0.5 
5370:  BTFSS  xF8.1
5372:  BRA    53D0
....................       res = PI_DIV_BY_TWO - 2.0*res; 
5374:  MOVLB  1
5376:  CLRF   x51
5378:  CLRF   x50
537A:  CLRF   x4F
537C:  MOVLW  80
537E:  MOVWF  x4E
5380:  MOVFF  100,155
5384:  MOVFF  FF,154
5388:  MOVFF  FE,153
538C:  MOVFF  FD,152
5390:  MOVLB  0
5392:  CALL   0E24
5396:  BSF    FD8.1
5398:  MOVLW  DB
539A:  MOVLB  1
539C:  MOVWF  x53
539E:  MOVLW  0F
53A0:  MOVWF  x52
53A2:  MOVLW  49
53A4:  MOVWF  x51
53A6:  MOVLW  7F
53A8:  MOVWF  x50
53AA:  MOVFF  03,157
53AE:  MOVFF  02,156
53B2:  MOVFF  01,155
53B6:  MOVFF  00,154
53BA:  MOVLB  0
53BC:  CALL   1078
53C0:  MOVFF  03,100
53C4:  MOVFF  02,FF
53C8:  MOVFF  01,FE
53CC:  MOVFF  00,FD
....................    if (s) 
53D0:  MOVLB  1
53D2:  BTFSS  x09.0
53D4:  BRA    53DE
....................       res = -res; 
53D6:  MOVLB  0
53D8:  MOVF   xFE,W
53DA:  XORLW  80
53DC:  MOVWF  xFE
....................    if (n & 1)           // take arccos 
53DE:  MOVLB  0
53E0:  BTFSS  xF8.0
53E2:  BRA    541E
....................       res = PI_DIV_BY_TWO - res; 
53E4:  BSF    FD8.1
53E6:  MOVLW  DB
53E8:  MOVLB  1
53EA:  MOVWF  x53
53EC:  MOVLW  0F
53EE:  MOVWF  x52
53F0:  MOVLW  49
53F2:  MOVWF  x51
53F4:  MOVLW  7F
53F6:  MOVWF  x50
53F8:  MOVFF  100,157
53FC:  MOVFF  FF,156
5400:  MOVFF  FE,155
5404:  MOVFF  FD,154
5408:  MOVLB  0
540A:  CALL   1078
540E:  MOVFF  03,100
5412:  MOVFF  02,FF
5416:  MOVFF  01,FE
541A:  MOVFF  00,FD
....................  
....................    return(res); 
541E:  MOVFF  FD,00
5422:  MOVFF  FE,01
5426:  MOVFF  FF,02
542A:  MOVFF  100,03
.................... } 
542E:  GOTO   5448 (RETURN)
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
5432:  MOVFF  EF,F7
5436:  MOVFF  EE,F6
543A:  MOVFF  ED,F5
543E:  MOVFF  EC,F4
5442:  MOVLW  01
5444:  MOVWF  xF8
5446:  BRA    502A
5448:  MOVFF  03,F3
544C:  MOVFF  02,F2
5450:  MOVFF  01,F1
5454:  MOVFF  00,F0
....................    return(r); 
5458:  MOVFF  F0,00
545C:  MOVFF  F1,01
5460:  MOVFF  F2,02
5464:  MOVFF  F3,03
.................... } 
5468:  GOTO   5B56 (RETURN)
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
3E50:  MOVLB  1
3E52:  BCF    x18.0
....................    flag = 0; 
3E54:  BCF    x18.1
....................    y = x; 
3E56:  MOVFF  10B,10F
3E5A:  MOVFF  10A,10E
3E5E:  MOVFF  109,10D
3E62:  MOVFF  108,10C
....................  
....................    if (x < 0) 
3E66:  MOVFF  10B,14D
3E6A:  MOVFF  10A,14C
3E6E:  MOVFF  109,14B
3E72:  MOVFF  108,14A
3E76:  CLRF   x51
3E78:  CLRF   x50
3E7A:  CLRF   x4F
3E7C:  CLRF   x4E
3E7E:  MOVLB  0
3E80:  RCALL  3DD6
3E82:  BNC   3E8E
....................    { 
....................       s = 1; 
3E84:  MOVLB  1
3E86:  BSF    x18.0
....................       y = -y; 
3E88:  MOVF   x0D,W
3E8A:  XORLW  80
3E8C:  MOVWF  x0D
....................    } 
....................  
....................    if (y > 1.0) 
3E8E:  MOVLB  1
3E90:  CLRF   x4D
3E92:  CLRF   x4C
3E94:  CLRF   x4B
3E96:  MOVLW  7F
3E98:  MOVWF  x4A
3E9A:  MOVFF  10F,151
3E9E:  MOVFF  10E,150
3EA2:  MOVFF  10D,14F
3EA6:  MOVFF  10C,14E
3EAA:  MOVLB  0
3EAC:  RCALL  3DD6
3EAE:  BNC   3EE6
....................    { 
....................       y = 1.0/y; 
3EB0:  MOVLB  1
3EB2:  CLRF   x4D
3EB4:  CLRF   x4C
3EB6:  CLRF   x4B
3EB8:  MOVLW  7F
3EBA:  MOVWF  x4A
3EBC:  MOVFF  10F,151
3EC0:  MOVFF  10E,150
3EC4:  MOVFF  10D,14F
3EC8:  MOVFF  10C,14E
3ECC:  MOVLB  0
3ECE:  CALL   0F1A
3ED2:  MOVFF  03,10F
3ED6:  MOVFF  02,10E
3EDA:  MOVFF  01,10D
3EDE:  MOVFF  00,10C
....................       flag = 1; 
3EE2:  MOVLB  1
3EE4:  BSF    x18.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
3EE6:  MOVLW  0A
3EE8:  MOVLB  1
3EEA:  MOVWF  x51
3EEC:  MOVLW  89
3EEE:  MOVWF  x50
3EF0:  MOVLW  34
3EF2:  MOVWF  x4F
3EF4:  MOVLW  7C
3EF6:  MOVWF  x4E
3EF8:  MOVFF  10F,155
3EFC:  MOVFF  10E,154
3F00:  MOVFF  10D,153
3F04:  MOVFF  10C,152
3F08:  MOVLB  0
3F0A:  CALL   0E24
3F0E:  MOVFF  00,119
3F12:  MOVFF  01,11A
3F16:  MOVFF  02,11B
3F1A:  MOVFF  03,11C
3F1E:  MOVFF  03,151
3F22:  MOVFF  02,150
3F26:  MOVFF  01,14F
3F2A:  MOVFF  00,14E
3F2E:  MOVFF  10F,155
3F32:  MOVFF  10E,154
3F36:  MOVFF  10D,153
3F3A:  MOVFF  10C,152
3F3E:  CALL   0E24
3F42:  MOVFF  00,11D
3F46:  MOVFF  01,11E
3F4A:  MOVFF  02,11F
3F4E:  MOVFF  03,120
3F52:  BCF    FD8.1
3F54:  MOVFF  03,153
3F58:  MOVFF  02,152
3F5C:  MOVFF  01,151
3F60:  MOVFF  00,150
3F64:  MOVLW  7C
3F66:  MOVLB  1
3F68:  MOVWF  x57
3F6A:  MOVLW  79
3F6C:  MOVWF  x56
3F6E:  MOVLW  35
3F70:  MOVWF  x55
3F72:  MOVLW  81
3F74:  MOVWF  x54
3F76:  MOVLB  0
3F78:  CALL   1078
3F7C:  MOVFF  03,113
3F80:  MOVFF  02,112
3F84:  MOVFF  01,111
3F88:  MOVFF  00,110
....................    res = res*y*y + pat[2]; 
3F8C:  MOVFF  113,151
3F90:  MOVFF  112,150
3F94:  MOVFF  111,14F
3F98:  MOVFF  110,14E
3F9C:  MOVFF  10F,155
3FA0:  MOVFF  10E,154
3FA4:  MOVFF  10D,153
3FA8:  MOVFF  10C,152
3FAC:  CALL   0E24
3FB0:  MOVFF  00,119
3FB4:  MOVFF  01,11A
3FB8:  MOVFF  02,11B
3FBC:  MOVFF  03,11C
3FC0:  MOVFF  03,151
3FC4:  MOVFF  02,150
3FC8:  MOVFF  01,14F
3FCC:  MOVFF  00,14E
3FD0:  MOVFF  10F,155
3FD4:  MOVFF  10E,154
3FD8:  MOVFF  10D,153
3FDC:  MOVFF  10C,152
3FE0:  CALL   0E24
3FE4:  MOVFF  00,11D
3FE8:  MOVFF  01,11E
3FEC:  MOVFF  02,11F
3FF0:  MOVFF  03,120
3FF4:  BCF    FD8.1
3FF6:  MOVFF  03,153
3FFA:  MOVFF  02,152
3FFE:  MOVFF  01,151
4002:  MOVFF  00,150
4006:  MOVLW  3F
4008:  MOVLB  1
400A:  MOVWF  x57
400C:  MOVLW  02
400E:  MOVWF  x56
4010:  MOVLW  33
4012:  MOVWF  x55
4014:  MOVLW  83
4016:  MOVWF  x54
4018:  MOVLB  0
401A:  CALL   1078
401E:  MOVFF  03,113
4022:  MOVFF  02,112
4026:  MOVFF  01,111
402A:  MOVFF  00,110
....................    res = res*y*y + pat[3]; 
402E:  MOVFF  113,151
4032:  MOVFF  112,150
4036:  MOVFF  111,14F
403A:  MOVFF  110,14E
403E:  MOVFF  10F,155
4042:  MOVFF  10E,154
4046:  MOVFF  10D,153
404A:  MOVFF  10C,152
404E:  CALL   0E24
4052:  MOVFF  00,119
4056:  MOVFF  01,11A
405A:  MOVFF  02,11B
405E:  MOVFF  03,11C
4062:  MOVFF  03,151
4066:  MOVFF  02,150
406A:  MOVFF  01,14F
406E:  MOVFF  00,14E
4072:  MOVFF  10F,155
4076:  MOVFF  10E,154
407A:  MOVFF  10D,153
407E:  MOVFF  10C,152
4082:  CALL   0E24
4086:  MOVFF  00,11D
408A:  MOVFF  01,11E
408E:  MOVFF  02,11F
4092:  MOVFF  03,120
4096:  BCF    FD8.1
4098:  MOVFF  03,153
409C:  MOVFF  02,152
40A0:  MOVFF  01,151
40A4:  MOVFF  00,150
40A8:  MOVLW  33
40AA:  MOVLB  1
40AC:  MOVWF  x57
40AE:  MOVLW  8C
40B0:  MOVWF  x56
40B2:  MOVLW  1E
40B4:  MOVWF  x55
40B6:  MOVLW  83
40B8:  MOVWF  x54
40BA:  MOVLB  0
40BC:  CALL   1078
40C0:  MOVFF  03,113
40C4:  MOVFF  02,112
40C8:  MOVFF  01,111
40CC:  MOVFF  00,110
....................  
....................    r = qat[0]*y*y + qat[1]; 
40D0:  MOVLB  1
40D2:  CLRF   x51
40D4:  CLRF   x50
40D6:  CLRF   x4F
40D8:  MOVLW  7F
40DA:  MOVWF  x4E
40DC:  MOVFF  10F,155
40E0:  MOVFF  10E,154
40E4:  MOVFF  10D,153
40E8:  MOVFF  10C,152
40EC:  MOVLB  0
40EE:  CALL   0E24
40F2:  MOVFF  00,119
40F6:  MOVFF  01,11A
40FA:  MOVFF  02,11B
40FE:  MOVFF  03,11C
4102:  MOVFF  03,151
4106:  MOVFF  02,150
410A:  MOVFF  01,14F
410E:  MOVFF  00,14E
4112:  MOVFF  10F,155
4116:  MOVFF  10E,154
411A:  MOVFF  10D,153
411E:  MOVFF  10C,152
4122:  CALL   0E24
4126:  MOVFF  00,11D
412A:  MOVFF  01,11E
412E:  MOVFF  02,11F
4132:  MOVFF  03,120
4136:  BCF    FD8.1
4138:  MOVFF  03,153
413C:  MOVFF  02,152
4140:  MOVFF  01,151
4144:  MOVFF  00,150
4148:  MOVLW  1B
414A:  MOVLB  1
414C:  MOVWF  x57
414E:  MOVLW  E4
4150:  MOVWF  x56
4152:  MOVLW  35
4154:  MOVWF  x55
4156:  MOVLW  82
4158:  MOVWF  x54
415A:  MOVLB  0
415C:  CALL   1078
4160:  MOVFF  03,117
4164:  MOVFF  02,116
4168:  MOVFF  01,115
416C:  MOVFF  00,114
....................    r = r*y*y + qat[2]; 
4170:  MOVFF  117,151
4174:  MOVFF  116,150
4178:  MOVFF  115,14F
417C:  MOVFF  114,14E
4180:  MOVFF  10F,155
4184:  MOVFF  10E,154
4188:  MOVFF  10D,153
418C:  MOVFF  10C,152
4190:  CALL   0E24
4194:  MOVFF  00,119
4198:  MOVFF  01,11A
419C:  MOVFF  02,11B
41A0:  MOVFF  03,11C
41A4:  MOVFF  03,151
41A8:  MOVFF  02,150
41AC:  MOVFF  01,14F
41B0:  MOVFF  00,14E
41B4:  MOVFF  10F,155
41B8:  MOVFF  10E,154
41BC:  MOVFF  10D,153
41C0:  MOVFF  10C,152
41C4:  CALL   0E24
41C8:  MOVFF  00,11D
41CC:  MOVFF  01,11E
41D0:  MOVFF  02,11F
41D4:  MOVFF  03,120
41D8:  BCF    FD8.1
41DA:  MOVFF  03,153
41DE:  MOVFF  02,152
41E2:  MOVFF  01,151
41E6:  MOVFF  00,150
41EA:  MOVLW  A4
41EC:  MOVLB  1
41EE:  MOVWF  x57
41F0:  MOVLW  DB
41F2:  MOVWF  x56
41F4:  MOVLW  67
41F6:  MOVWF  x55
41F8:  MOVLW  83
41FA:  MOVWF  x54
41FC:  MOVLB  0
41FE:  CALL   1078
4202:  MOVFF  03,117
4206:  MOVFF  02,116
420A:  MOVFF  01,115
420E:  MOVFF  00,114
....................    r = r*y*y + qat[3]; 
4212:  MOVFF  117,151
4216:  MOVFF  116,150
421A:  MOVFF  115,14F
421E:  MOVFF  114,14E
4222:  MOVFF  10F,155
4226:  MOVFF  10E,154
422A:  MOVFF  10D,153
422E:  MOVFF  10C,152
4232:  CALL   0E24
4236:  MOVFF  00,119
423A:  MOVFF  01,11A
423E:  MOVFF  02,11B
4242:  MOVFF  03,11C
4246:  MOVFF  03,151
424A:  MOVFF  02,150
424E:  MOVFF  01,14F
4252:  MOVFF  00,14E
4256:  MOVFF  10F,155
425A:  MOVFF  10E,154
425E:  MOVFF  10D,153
4262:  MOVFF  10C,152
4266:  CALL   0E24
426A:  MOVFF  00,11D
426E:  MOVFF  01,11E
4272:  MOVFF  02,11F
4276:  MOVFF  03,120
427A:  BCF    FD8.1
427C:  MOVFF  03,153
4280:  MOVFF  02,152
4284:  MOVFF  01,151
4288:  MOVFF  00,150
428C:  MOVLW  33
428E:  MOVLB  1
4290:  MOVWF  x57
4292:  MOVLW  8C
4294:  MOVWF  x56
4296:  MOVLW  1E
4298:  MOVWF  x55
429A:  MOVLW  83
429C:  MOVWF  x54
429E:  MOVLB  0
42A0:  CALL   1078
42A4:  MOVFF  03,117
42A8:  MOVFF  02,116
42AC:  MOVFF  01,115
42B0:  MOVFF  00,114
....................  
....................    res = y*res/r; 
42B4:  MOVFF  10F,151
42B8:  MOVFF  10E,150
42BC:  MOVFF  10D,14F
42C0:  MOVFF  10C,14E
42C4:  MOVFF  113,155
42C8:  MOVFF  112,154
42CC:  MOVFF  111,153
42D0:  MOVFF  110,152
42D4:  CALL   0E24
42D8:  MOVFF  00,119
42DC:  MOVFF  01,11A
42E0:  MOVFF  02,11B
42E4:  MOVFF  03,11C
42E8:  MOVFF  03,14D
42EC:  MOVFF  02,14C
42F0:  MOVFF  01,14B
42F4:  MOVFF  00,14A
42F8:  MOVFF  117,151
42FC:  MOVFF  116,150
4300:  MOVFF  115,14F
4304:  MOVFF  114,14E
4308:  CALL   0F1A
430C:  MOVFF  03,113
4310:  MOVFF  02,112
4314:  MOVFF  01,111
4318:  MOVFF  00,110
....................  
....................  
....................    if (flag)                              // for |x| > 1 
431C:  MOVLB  1
431E:  BTFSS  x18.1
4320:  BRA    435C
....................       res = PI_DIV_BY_TWO - res; 
4322:  BSF    FD8.1
4324:  MOVLW  DB
4326:  MOVWF  x53
4328:  MOVLW  0F
432A:  MOVWF  x52
432C:  MOVLW  49
432E:  MOVWF  x51
4330:  MOVLW  7F
4332:  MOVWF  x50
4334:  MOVFF  113,157
4338:  MOVFF  112,156
433C:  MOVFF  111,155
4340:  MOVFF  110,154
4344:  MOVLB  0
4346:  CALL   1078
434A:  MOVFF  03,113
434E:  MOVFF  02,112
4352:  MOVFF  01,111
4356:  MOVFF  00,110
435A:  MOVLB  1
....................    if (s) 
435C:  BTFSS  x18.0
435E:  BRA    4366
....................       res = -res; 
4360:  MOVF   x11,W
4362:  XORLW  80
4364:  MOVWF  x11
....................  
....................    return(res); 
4366:  MOVFF  110,00
436A:  MOVFF  111,01
436E:  MOVFF  112,02
4372:  MOVFF  113,03
.................... } 
4376:  MOVLB  0
4378:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,NOBROWNOUT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
04BC:  CLRF   FEA
04BE:  MOVLW  EA
04C0:  MOVWF  FE9
04C2:  MOVF   FEF,W
04C4:  BZ    04E2
04C6:  MOVLW  03
04C8:  MOVWF  01
04CA:  CLRF   00
04CC:  DECFSZ 00,F
04CE:  BRA    04CC
04D0:  DECFSZ 01,F
04D2:  BRA    04CA
04D4:  MOVLW  3C
04D6:  MOVWF  00
04D8:  DECFSZ 00,F
04DA:  BRA    04D8
04DC:  BRA    04DE
04DE:  DECFSZ FEF,F
04E0:  BRA    04C6
04E2:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N) 
....................  
....................  
....................  
....................  
....................  
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct port_d_map{ 
....................    int8 lcd_nibble:4; //0:3 
....................    boolean ps_en;     //4 
....................    boolean meas_rly;  //5 
....................    boolean pwr_ctrl;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... struct port_e_map{ 
....................    boolean rs; //0 
....................    boolean emgcy; //1 
....................    boolean tx_en; //2 
....................     int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
.................... #byte PORTA =0xF80 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... ////////////// actuator parameter ///////// 
.................... #define DIM_A 107.5 
.................... #define DIM_P 9.3 
.................... #define DIM_M 5.5 
.................... #define DIM_K 36.0 
.................... #define DIM_B 15.8 
.................... #define MIN_STROKE 70.3  
.................... #define MAX_STROKE 128.0 
.................... #define ROW_SPACING 320.00 
.................... #define PANEL_WIDTH 160.00 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1   PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3   PIN_B3 
.................... #define CCW PIN_B4 
.................... #define FLASH_SELECT PIN_C2 // output 
.................... #define FLASH_CLOCK  PIN_C3 // output 
.................... #define FLASH_DI     PIN_C5 // output 
.................... #define FLASH_DO     PIN_C4 // input 
.................... #define SENSE_0       PIN_A1 
.................... #define SENSE_1       PIN_A2 
.................... #define SENSE_2       PIN_A3 
.................... #define SENSE_3       PIN_A4 
.................... #define WALL_PWR    PIN_A5 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00002 
.................... #define ADDR_TIME           0xf00004 
.................... #define ADDR_START_COUNTER  0xf00008 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x05B1} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000} 
.................... #rom ADDR_TIME={0x0000,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... //#rom ADDR_TIME={0x1C20,0x0000} 
....................  
.................... const int8 line[4] = {0,0x40,0x10,0x50}; 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... char tmp_str[20],tmp_str2[20]; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... unsigned int8 timer_ms=0; 
.................... unsigned int32 next_sun_rise; 
.................... unsigned int16 current_act_position=0; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int32 JDN,jj,g; 
.................... unsigned int32 dg,c,dc,b,db,a,da,y,m,d; 
.................... unsigned int32 YY,MM,DD,time_of_day; 
.................... unsigned int32 sec_until_sun_rise; 
.................... int16 FULL_STROKE_TICK=0; 
.................... float al; 
.................... int16 move_act_time_out=8; 
.................... int8 tx_delay=0; 
.................... int16 current_measured=0; 
.................... int8 n_avg_current_measured=0; 
.................... int16 startup_counter=0; 
.................... int16 actuator_pulse=0; 
.................... unsigned int8 index_in_page; 
....................  
.................... void init_ext_flash(void); 
.................... void ext_flash_startContinuousRead(int pageAddress); 
.................... void ext_flash_sendData(int data, int size); 
.................... void ext_flash_send16Data(int16 data, int size); 
.................... void ext_flash_sendBytes(char* data, int size); 
.................... void ext_flash_getBytes(char* data, int16 size); 
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size); 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size); 
.................... int ext_flash_getByte(void); 
.................... void ext_flash_waitUntilReady(void); 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
360A:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
360C:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
360E:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
3610:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
3612:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
3614:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
3616:  BCF    FAC.5
....................    delay_cycles(10); 
3618:  MOVLW  03
361A:  MOVWF  00
361C:  DECFSZ 00,F
361E:  BRA    361C
....................    bit_set(RCSTA,4); //CREN=1 
3620:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
3622:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
3624:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
3626:  BSF    F9D.5
....................  
.................... } 
3628:  GOTO   6104 (RETURN)
....................  
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int i; 
....................    int16 temp_mem;    
....................    temp_mem= &timer_sec; 
*
05BC:  CLRF   xD3
05BE:  MOVLW  20
05C0:  MOVWF  xD2
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
05C2:  CLRF   xD1
05C4:  MOVF   xD1,W
05C6:  SUBLW  03
05C8:  BNC   060C
05CA:  MOVF   xD1,W
05CC:  ADDWF  xD2,W
05CE:  MOVWF  xD4
05D0:  MOVLW  00
05D2:  ADDWFC xD3,W
05D4:  MOVWF  xD5
05D6:  MOVLW  04
05D8:  ADDWF  xD1,W
05DA:  MOVWF  xD6
05DC:  MOVFF  FF2,D7
05E0:  BCF    FF2.7
05E2:  MOVFF  D6,FA9
05E6:  BCF    FA6.6
05E8:  BCF    FA6.7
05EA:  BSF    FA6.0
05EC:  MOVF   FA8,W
05EE:  BTFSC  xD7.7
05F0:  BSF    FF2.7
05F2:  MOVWF  xD7
05F4:  MOVFF  D5,FEA
05F8:  MOVFF  D4,FE9
05FC:  MOVFF  D7,D8
0600:  CLRF   xDA
0602:  MOVLW  01
0604:  MOVWF  xD9
0606:  RCALL  05A2
0608:  INCF   xD1,F
060A:  BRA    05C4
....................    temp_mem= &FULL_STROKE_TICK; 
060C:  CLRF   xD3
060E:  MOVLW  BA
0610:  MOVWF  xD2
....................    if (FULL_STROKE_TICK > MAX_FULL_STROKE) FULL_STROKE_TICK = MAX_FULL_STROKE; 
0612:  MOVF   xBB,W
0614:  SUBLW  06
0616:  BC    062A
0618:  XORLW  FF
061A:  BNZ   0622
061C:  MOVF   xBA,W
061E:  SUBLW  D0
0620:  BC    062A
0622:  MOVLW  07
0624:  MOVWF  xBB
0626:  MOVLW  D0
0628:  MOVWF  xBA
....................    if (FULL_STROKE_TICK <0) FULL_STROKE_TICK = 0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i),1); 
062A:  CLRF   xD1
062C:  MOVF   xD1,W
062E:  SUBLW  01
0630:  BNC   066E
0632:  MOVF   xD1,W
0634:  ADDWF  xD2,W
0636:  MOVWF  xD4
0638:  MOVLW  00
063A:  ADDWFC xD3,W
063C:  MOVWF  xD5
063E:  MOVFF  FF2,D6
0642:  BCF    FF2.7
0644:  MOVFF  D1,FA9
0648:  BCF    FA6.6
064A:  BCF    FA6.7
064C:  BSF    FA6.0
064E:  MOVF   FA8,W
0650:  BTFSC  xD6.7
0652:  BSF    FF2.7
0654:  MOVWF  xD7
0656:  MOVFF  D5,FEA
065A:  MOVFF  D4,FE9
065E:  MOVFF  D7,D8
0662:  CLRF   xDA
0664:  MOVLW  01
0666:  MOVWF  xD9
0668:  RCALL  05A2
066A:  INCF   xD1,F
066C:  BRA    062C
....................    temp_mem= &current_act_position; 
066E:  CLRF   xD3
0670:  MOVLW  6E
0672:  MOVWF  xD2
....................    if (current_act_position > FULL_STROKE_TICK) current_act_position = FULL_STROKE_TICK; 
0674:  MOVF   xBB,W
0676:  SUBWF  x6F,W
0678:  BNC   068A
067A:  BNZ   0682
067C:  MOVF   x6E,W
067E:  SUBWF  xBA,W
0680:  BC    068A
0682:  MOVFF  BB,6F
0686:  MOVFF  BA,6E
....................    if (current_act_position < 0) current_act_position =0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i),1); 
068A:  CLRF   xD1
068C:  MOVF   xD1,W
068E:  SUBLW  01
0690:  BNC   06D4
0692:  MOVF   xD1,W
0694:  ADDWF  xD2,W
0696:  MOVWF  xD4
0698:  MOVLW  00
069A:  ADDWFC xD3,W
069C:  MOVWF  xD5
069E:  MOVLW  02
06A0:  ADDWF  xD1,W
06A2:  MOVWF  xD6
06A4:  MOVFF  FF2,D7
06A8:  BCF    FF2.7
06AA:  MOVFF  D6,FA9
06AE:  BCF    FA6.6
06B0:  BCF    FA6.7
06B2:  BSF    FA6.0
06B4:  MOVF   FA8,W
06B6:  BTFSC  xD7.7
06B8:  BSF    FF2.7
06BA:  MOVWF  xD7
06BC:  MOVFF  D5,FEA
06C0:  MOVFF  D4,FE9
06C4:  MOVFF  D7,D8
06C8:  CLRF   xDA
06CA:  MOVLW  01
06CC:  MOVWF  xD9
06CE:  RCALL  05A2
06D0:  INCF   xD1,F
06D2:  BRA    068C
....................    temp_mem= &startup_counter; 
06D4:  CLRF   xD3
06D6:  MOVLW  C6
06D8:  MOVWF  xD2
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
06DA:  CLRF   xD1
06DC:  MOVF   xD1,W
06DE:  SUBLW  01
06E0:  BNC   0724
06E2:  MOVF   xD1,W
06E4:  ADDWF  xD2,W
06E6:  MOVWF  xD4
06E8:  MOVLW  00
06EA:  ADDWFC xD3,W
06EC:  MOVWF  xD5
06EE:  MOVLW  08
06F0:  ADDWF  xD1,W
06F2:  MOVWF  xD6
06F4:  MOVFF  FF2,D7
06F8:  BCF    FF2.7
06FA:  MOVFF  D6,FA9
06FE:  BCF    FA6.6
0700:  BCF    FA6.7
0702:  BSF    FA6.0
0704:  MOVF   FA8,W
0706:  BTFSC  xD7.7
0708:  BSF    FF2.7
070A:  MOVWF  xD7
070C:  MOVFF  D5,FEA
0710:  MOVFF  D4,FE9
0714:  MOVFF  D7,D8
0718:  CLRF   xDA
071A:  MOVLW  01
071C:  MOVWF  xD9
071E:  RCALL  05A2
0720:  INCF   xD1,F
0722:  BRA    06DC
.................... } 
0724:  GOTO   5E92 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0820:  CLRF   xD2
0822:  MOVF   xD2,W
0824:  SUBLW  03
0826:  BNC   0888
0828:  MOVLW  04
082A:  ADDWF  xD2,W
082C:  MOVWF  xD3
082E:  MOVF   xD2,W
0830:  MULLW  08
0832:  MOVFF  FF3,D4
0836:  MOVFF  23,D8
083A:  MOVFF  22,D7
083E:  MOVFF  21,D6
0842:  MOVFF  20,D5
0846:  MOVF   xD4,F
0848:  BZ    0858
084A:  BCF    FD8.0
084C:  RRCF   xD8,F
084E:  RRCF   xD7,F
0850:  RRCF   xD6,F
0852:  RRCF   xD5,F
0854:  DECFSZ xD4,F
0856:  BRA    084A
0858:  MOVFF  D3,FA9
085C:  MOVFF  D5,FA8
0860:  BCF    FA6.6
0862:  BCF    FA6.7
0864:  BSF    FA6.2
0866:  MOVFF  FF2,00
086A:  BCF    FF2.7
086C:  MOVLB  F
086E:  MOVLW  55
0870:  MOVWF  FA7
0872:  MOVLW  AA
0874:  MOVWF  FA7
0876:  BSF    FA6.1
0878:  BTFSC  FA6.1
087A:  BRA    0878
087C:  BCF    FA6.2
087E:  MOVF   00,W
0880:  IORWF  FF2,F
0882:  MOVLB  0
0884:  INCF   xD2,F
0886:  BRA    0822
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i,current_act_position>>(i*8)); 
0888:  CLRF   xD2
088A:  MOVF   xD2,W
088C:  SUBLW  01
088E:  BNC   08E4
0890:  MOVLW  02
0892:  ADDWF  xD2,W
0894:  MOVWF  xD3
0896:  MOVF   xD2,W
0898:  MULLW  08
089A:  MOVFF  FF3,00
089E:  MOVFF  6F,D5
08A2:  MOVFF  6E,D4
08A6:  MOVF   00,F
08A8:  BZ    08B4
08AA:  BCF    FD8.0
08AC:  RRCF   xD5,F
08AE:  RRCF   xD4,F
08B0:  DECFSZ 00,F
08B2:  BRA    08AA
08B4:  MOVFF  D3,FA9
08B8:  MOVFF  D4,FA8
08BC:  BCF    FA6.6
08BE:  BCF    FA6.7
08C0:  BSF    FA6.2
08C2:  MOVFF  FF2,00
08C6:  BCF    FF2.7
08C8:  MOVLB  F
08CA:  MOVLW  55
08CC:  MOVWF  FA7
08CE:  MOVLW  AA
08D0:  MOVWF  FA7
08D2:  BSF    FA6.1
08D4:  BTFSC  FA6.1
08D6:  BRA    08D4
08D8:  BCF    FA6.2
08DA:  MOVF   00,W
08DC:  IORWF  FF2,F
08DE:  MOVLB  0
08E0:  INCF   xD2,F
08E2:  BRA    088A
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
08E4:  CLRF   xD2
08E6:  MOVF   xD2,W
08E8:  SUBLW  01
08EA:  BNC   0940
08EC:  MOVLW  08
08EE:  ADDWF  xD2,W
08F0:  MOVWF  xD3
08F2:  MOVF   xD2,W
08F4:  MULLW  08
08F6:  MOVFF  FF3,00
08FA:  MOVFF  C7,D5
08FE:  MOVFF  C6,D4
0902:  MOVF   00,F
0904:  BZ    0910
0906:  BCF    FD8.0
0908:  RRCF   xD5,F
090A:  RRCF   xD4,F
090C:  DECFSZ 00,F
090E:  BRA    0906
0910:  MOVFF  D3,FA9
0914:  MOVFF  D4,FA8
0918:  BCF    FA6.6
091A:  BCF    FA6.7
091C:  BSF    FA6.2
091E:  MOVFF  FF2,00
0922:  BCF    FF2.7
0924:  MOVLB  F
0926:  MOVLW  55
0928:  MOVWF  FA7
092A:  MOVLW  AA
092C:  MOVWF  FA7
092E:  BSF    FA6.1
0930:  BTFSC  FA6.1
0932:  BRA    0930
0934:  BCF    FA6.2
0936:  MOVF   00,W
0938:  IORWF  FF2,F
093A:  MOVLB  0
093C:  INCF   xD2,F
093E:  BRA    08E6
....................    if (write_cal ==1) 
0940:  DECFSZ xD1,W
0942:  BRA    099A
....................       for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i,FULL_STROKE_TICK>>(i*8)); 
0944:  CLRF   xD2
0946:  MOVF   xD2,W
0948:  SUBLW  01
094A:  BNC   099A
094C:  MOVF   xD2,W
094E:  MULLW  08
0950:  MOVFF  FF3,00
0954:  MOVFF  BB,D4
0958:  MOVFF  BA,D3
095C:  MOVF   00,F
095E:  BZ    096A
0960:  BCF    FD8.0
0962:  RRCF   xD4,F
0964:  RRCF   xD3,F
0966:  DECFSZ 00,F
0968:  BRA    0960
096A:  MOVFF  D2,FA9
096E:  MOVFF  D3,FA8
0972:  BCF    FA6.6
0974:  BCF    FA6.7
0976:  BSF    FA6.2
0978:  MOVFF  FF2,00
097C:  BCF    FF2.7
097E:  MOVLB  F
0980:  MOVLW  55
0982:  MOVWF  FA7
0984:  MOVLW  AA
0986:  MOVWF  FA7
0988:  BSF    FA6.1
098A:  BTFSC  FA6.1
098C:  BRA    098A
098E:  BCF    FA6.2
0990:  MOVF   00,W
0992:  IORWF  FF2,F
0994:  MOVLB  0
0996:  INCF   xD2,F
0998:  BRA    0946
.................... } 
099A:  RETLW  00
....................  
....................  
.................... void init_ext_flash(void) { 
....................   output_low(FLASH_CLOCK); 
*
0AAE:  BCF    F94.3
0AB0:  BCF    F8B.3
....................   output_high(FLASH_SELECT); 
0AB2:  BCF    F94.2
0AB4:  BSF    F8B.2
.................... } 
0AB6:  GOTO   5F20 (RETURN)
....................  
.................... /* 
.................... void ext_flash_startContinuousRead(int pageAddress) { 
....................   ext_flash_waitUntilReady(); 
....................   output_low(FLASH_SELECT); 
....................   ext_flash_sendData(0xE8, 8); 
....................   ext_flash_sendData(pageAddress, 14); 
....................   ext_flash_sendData(0, 10); 
....................   ext_flash_sendData(0, 16); 
....................   ext_flash_sendData(0, 16); 
.................... } 
....................  
.................... */ 
....................  
.................... int ext_flash_getByte(void) { 
....................   int flashData = 0; 
....................   output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   return(flashData); 
.................... } 
....................  
.................... void ext_flash_getBytes(char* data, int16 size) { 
....................    int16 i, j; 
....................    for(i = 0; i < size; i++) { 
*
2770:  CLRF   xFF
2772:  CLRF   xFE
2774:  MOVF   xFF,W
2776:  SUBWF  xFD,W
2778:  BNC   27D6
277A:  BNZ   2782
277C:  MOVF   xFC,W
277E:  SUBWF  xFE,W
2780:  BC    27D6
....................       for(j = 0; j < 8; j++) { 
2782:  MOVLB  1
2784:  CLRF   x01
2786:  CLRF   x00
2788:  MOVF   x01,F
278A:  BNZ   27CC
278C:  MOVF   x00,W
278E:  SUBLW  07
2790:  BNC   27CC
....................          output_high(FLASH_CLOCK); 
2792:  BCF    F94.3
2794:  BSF    F8B.3
....................          shift_left(data + i, 1, input(FLASH_DO)); 
2796:  MOVLB  0
2798:  MOVF   xFE,W
279A:  ADDWF  xFA,W
279C:  MOVLB  1
279E:  MOVWF  x02
27A0:  MOVLB  0
27A2:  MOVF   xFF,W
27A4:  ADDWFC xFB,W
27A6:  MOVLB  1
27A8:  MOVWF  x03
27AA:  BSF    F94.4
27AC:  BTFSC  F82.4
27AE:  BRA    27B4
27B0:  BCF    FD8.0
27B2:  BRA    27B6
27B4:  BSF    FD8.0
27B6:  MOVFF  103,FEA
27BA:  MOVFF  102,FE9
27BE:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
27C0:  BCF    F94.3
27C2:  BCF    F8B.3
....................       } 
27C4:  INCF   x00,F
27C6:  BTFSC  FD8.2
27C8:  INCF   x01,F
27CA:  BRA    2788
....................    } 
27CC:  MOVLB  0
27CE:  INCF   xFE,F
27D0:  BTFSC  FD8.2
27D2:  INCF   xFF,F
27D4:  BRA    2774
.................... } 
27D6:  RETLW  00
....................  
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size) { 
....................    ext_flash_waitUntilReady(); 
27D8:  RCALL  24A8
....................    output_low(FLASH_SELECT); 
27DA:  BCF    F94.2
27DC:  BCF    F8B.2
....................    ext_flash_sendData(0xD2, 8); 
27DE:  MOVLW  D2
27E0:  MOVWF  xFA
27E2:  MOVLW  08
27E4:  MOVWF  xFB
27E6:  RCALL  25DE
....................    ext_flash_send16Data(pageAddress, 15); 
27E8:  MOVFF  F4,FB
27EC:  MOVFF  F3,FA
27F0:  MOVLW  0F
27F2:  MOVWF  xFC
27F4:  RCALL  260E
....................    ext_flash_sendData(0, 1); 
27F6:  CLRF   xFA
27F8:  MOVLW  01
27FA:  MOVWF  xFB
27FC:  RCALL  25DE
....................    ext_flash_sendData(pageIndex, 8); 
27FE:  MOVFF  F5,FA
2802:  MOVLW  08
2804:  MOVWF  xFB
2806:  RCALL  25DE
....................    ext_flash_sendData(0, 16); 
2808:  CLRF   xFA
280A:  MOVLW  10
280C:  MOVWF  xFB
280E:  RCALL  25DE
....................    ext_flash_sendData(0, 16); 
2810:  CLRF   xFA
2812:  MOVLW  10
2814:  MOVWF  xFB
2816:  RCALL  25DE
....................    ext_flash_getBytes(data, size); 
2818:  MOVFF  F7,FB
281C:  MOVFF  F6,FA
2820:  MOVFF  F9,FD
2824:  MOVFF  F8,FC
2828:  RCALL  2770
....................    output_high(FLASH_SELECT); 
282A:  BCF    F94.2
282C:  BSF    F8B.2
.................... } 
282E:  RETLW  00
....................  
.................... /* 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
....................    output_low(FLASH_SELECT); 
....................    ext_flash_sendData(0x82, 8); 
....................    ext_flash_sendData(pageAddress, 14); 
....................    ext_flash_sendData(0, 10); 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
....................    output_high(FLASH_SELECT); 
.................... } 
.................... */ 
....................  
....................  
.................... void ext_flash_sendData(int data, int size) { 
....................    do { 
....................       size--; 
*
25DE:  DECF   xFB,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
25E0:  MOVFF  FA,00
25E4:  MOVF   xFB,W
25E6:  MOVWF  01
25E8:  BZ    25F2
25EA:  BCF    FD8.0
25EC:  RRCF   00,F
25EE:  DECFSZ 01,F
25F0:  BRA    25EA
25F2:  MOVF   00,W
25F4:  ANDLW  01
25F6:  BNZ   25FC
25F8:  BCF    F8B.5
25FA:  BRA    25FE
25FC:  BSF    F8B.5
25FE:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
2600:  BCF    F94.3
2602:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
2604:  BCF    F94.3
2606:  BCF    F8B.3
....................    } while(size > 0); 
2608:  MOVF   xFB,F
260A:  BNZ   25DE
.................... } 
260C:  RETLW  00
....................  
.................... void ext_flash_send16Data(int16 data, int size) { 
....................    do { 
....................       size--; 
260E:  DECF   xFC,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
2610:  MOVFF  FB,FE
2614:  MOVFF  FA,FD
2618:  MOVF   xFC,W
261A:  MOVWF  00
261C:  BZ    2628
261E:  BCF    FD8.0
2620:  RRCF   xFE,F
2622:  RRCF   xFD,F
2624:  DECFSZ 00,F
2626:  BRA    261E
2628:  MOVF   xFD,W
262A:  ANDLW  01
262C:  MOVWF  00
262E:  CLRF   03
2630:  MOVF   00,W
2632:  IORWF  03,W
2634:  BNZ   263A
2636:  BCF    F8B.5
2638:  BRA    263C
263A:  BSF    F8B.5
263C:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
263E:  BCF    F94.3
2640:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
2642:  BCF    F94.3
2644:  BCF    F8B.3
....................    } while(size > 0); 
2646:  MOVF   xFC,F
2648:  BNZ   260E
.................... } 
264A:  RETLW  00
....................  
.................... void ext_flash_sendBytes(char* data, int size) { 
....................    int i; 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
.................... } 
....................  
.................... void ext_flash_waitUntilReady(void) { 
.................... // this function read status register 
.................... // Bit7 : 1=RDY, 0=BUSY 
.................... // Bit6 : COMP, 1=Recent Main memory page compare, 0 == match 
.................... // Bit 5-2 : 0b0111 , density code for 4MBit 
.................... // Bit 1: Protect 
.................... // Bit 0: Page size. 0= 264 byte, 1=256 byte 
....................  
....................   int flashData; 
....................   int i; 
....................   output_low(FLASH_SELECT); 
*
24A8:  BCF    F94.2
24AA:  BCF    F8B.2
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24AC:  BSF    F8B.5
24AE:  BCF    F94.5
24B0:  BCF    F94.3
24B2:  BSF    F8B.3
24B4:  BCF    F94.3
24B6:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24B8:  BSF    F8B.5
24BA:  BCF    F94.5
24BC:  BCF    F94.3
24BE:  BSF    F8B.3
24C0:  BCF    F94.3
24C2:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24C4:  BCF    F8B.5
24C6:  BCF    F94.5
24C8:  BCF    F94.3
24CA:  BSF    F8B.3
24CC:  BCF    F94.3
24CE:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24D0:  BSF    F8B.5
24D2:  BCF    F94.5
24D4:  BCF    F94.3
24D6:  BSF    F8B.3
24D8:  BCF    F94.3
24DA:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24DC:  BCF    F8B.5
24DE:  BCF    F94.5
24E0:  BCF    F94.3
24E2:  BSF    F8B.3
24E4:  BCF    F94.3
24E6:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24E8:  BSF    F8B.5
24EA:  BCF    F94.5
24EC:  BCF    F94.3
24EE:  BSF    F8B.3
24F0:  BCF    F94.3
24F2:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
24F4:  BSF    F8B.5
24F6:  BCF    F94.5
24F8:  BCF    F94.3
24FA:  BSF    F8B.3
24FC:  BCF    F94.3
24FE:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2500:  BSF    F8B.5
2502:  BCF    F94.5
2504:  BCF    F94.3
2506:  BSF    F8B.3
2508:  BCF    F94.3
250A:  BCF    F8B.3
....................   for(i=0;i<255;i++) { 
250C:  CLRF   xFB
250E:  INCFSZ xFB,W
2510:  BRA    2514
2512:  BRA    25D8
....................     flashData = 0; 
2514:  CLRF   xFA
....................     output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2516:  BCF    F94.3
2518:  BSF    F8B.3
251A:  BSF    F94.4
251C:  MOVLW  00
251E:  BTFSC  F82.4
2520:  MOVLW  01
2522:  ADDWF  xFA,F
2524:  BCF    F94.3
2526:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2528:  BCF    F94.3
252A:  BSF    F8B.3
252C:  BCF    FD8.0
252E:  RLCF   xFA,F
2530:  BSF    F94.4
2532:  MOVLW  00
2534:  BTFSC  F82.4
2536:  MOVLW  01
2538:  ADDWF  xFA,F
253A:  BCF    F94.3
253C:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
253E:  BCF    F94.3
2540:  BSF    F8B.3
2542:  BCF    FD8.0
2544:  RLCF   xFA,F
2546:  BSF    F94.4
2548:  MOVLW  00
254A:  BTFSC  F82.4
254C:  MOVLW  01
254E:  ADDWF  xFA,F
2550:  BCF    F94.3
2552:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2554:  BCF    F94.3
2556:  BSF    F8B.3
2558:  BCF    FD8.0
255A:  RLCF   xFA,F
255C:  BSF    F94.4
255E:  MOVLW  00
2560:  BTFSC  F82.4
2562:  MOVLW  01
2564:  ADDWF  xFA,F
2566:  BCF    F94.3
2568:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
256A:  BCF    F94.3
256C:  BSF    F8B.3
256E:  BCF    FD8.0
2570:  RLCF   xFA,F
2572:  BSF    F94.4
2574:  MOVLW  00
2576:  BTFSC  F82.4
2578:  MOVLW  01
257A:  ADDWF  xFA,F
257C:  BCF    F94.3
257E:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2580:  BCF    F94.3
2582:  BSF    F8B.3
2584:  BCF    FD8.0
2586:  RLCF   xFA,F
2588:  BSF    F94.4
258A:  MOVLW  00
258C:  BTFSC  F82.4
258E:  MOVLW  01
2590:  ADDWF  xFA,F
2592:  BCF    F94.3
2594:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2596:  BCF    F94.3
2598:  BSF    F8B.3
259A:  BCF    FD8.0
259C:  RLCF   xFA,F
259E:  BSF    F94.4
25A0:  MOVLW  00
25A2:  BTFSC  F82.4
25A4:  MOVLW  01
25A6:  ADDWF  xFA,F
25A8:  BCF    F94.3
25AA:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
25AC:  BCF    F94.3
25AE:  BSF    F8B.3
25B0:  BCF    FD8.0
25B2:  RLCF   xFA,F
25B4:  BSF    F94.4
25B6:  MOVLW  00
25B8:  BTFSC  F82.4
25BA:  MOVLW  01
25BC:  ADDWF  xFA,F
25BE:  BCF    F94.3
25C0:  BCF    F8B.3
....................     if (bit_test(flashData,7) == 1) break; // device is not busy 
25C2:  BTFSS  xFA.7
25C4:  BRA    25C8
25C6:  BRA    25D8
....................    delay_cycles(50); 
25C8:  MOVLW  10
25CA:  MOVWF  00
25CC:  DECFSZ 00,F
25CE:  BRA    25CC
25D0:  NOP   
....................    restart_wdt(); 
25D2:  CLRWDT
....................   } 
25D4:  INCF   xFB,F
25D6:  BRA    250E
....................   output_high(FLASH_SELECT); 
25D8:  BCF    F94.2
25DA:  BSF    F8B.2
.................... } 
25DC:  RETLW  00
....................  
.................... void ext_flash_block_erase() { 
....................    int i; 
....................    for(i=0;i<0xFF;i++) { 
*
28CA:  CLRF   xD1
28CC:  INCFSZ xD1,W
28CE:  BRA    28D2
28D0:  BRA    2904
....................    ext_flash_waitUntilReady(); 
28D2:  RCALL  24A8
....................    output_low(FLASH_SELECT); 
28D4:  BCF    F94.2
28D6:  BCF    F8B.2
....................    ext_flash_sendData(0x50, 8); 
28D8:  MOVLW  50
28DA:  MOVWF  xFA
28DC:  MOVLW  08
28DE:  MOVWF  xFB
28E0:  RCALL  25DE
....................    ext_flash_sendData(0, 4); 
28E2:  CLRF   xFA
28E4:  MOVLW  04
28E6:  MOVWF  xFB
28E8:  RCALL  25DE
....................    ext_flash_sendData(i, 8); 
28EA:  MOVFF  D1,FA
28EE:  MOVLW  08
28F0:  MOVWF  xFB
28F2:  RCALL  25DE
....................    ext_flash_sendData(0, 12); 
28F4:  CLRF   xFA
28F6:  MOVLW  0C
28F8:  MOVWF  xFB
28FA:  RCALL  25DE
....................    output_high(FLASH_SELECT); 
28FC:  BCF    F94.2
28FE:  BSF    F8B.2
....................    } 
2900:  INCF   xD1,F
2902:  BRA    28CC
....................    ext_flash_waitUntilReady(); 
2904:  RCALL  24A8
.................... } 
2906:  GOTO   357E (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_read() { 
....................    char data; 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2D6E:  CALL   24A8
....................    output_low(FLASH_SELECT); 
2D72:  BCF    F94.2
2D74:  BCF    F8B.2
....................    ext_flash_sendData(0xD1, 8); 
2D76:  MOVLW  D1
2D78:  MOVWF  xFA
2D7A:  MOVLW  08
2D7C:  MOVWF  xFB
2D7E:  RCALL  25DE
....................    ext_flash_send16Data(0, 16); 
2D80:  CLRF   xFB
2D82:  CLRF   xFA
2D84:  MOVLW  10
2D86:  MOVWF  xFC
2D88:  RCALL  260E
....................    ext_flash_sendData(0, 8); 
2D8A:  CLRF   xFA
2D8C:  MOVLW  08
2D8E:  MOVWF  xFB
2D90:  RCALL  25DE
....................    i=255; 
2D92:  MOVLW  FF
2D94:  MOVWF  xD2
....................    do { 
....................      ext_flash_getBytes(&data,1); 
2D96:  CLRF   xFB
2D98:  MOVLW  D1
2D9A:  MOVWF  xFA
2D9C:  CLRF   xFD
2D9E:  MOVLW  01
2DA0:  MOVWF  xFC
2DA2:  RCALL  2770
....................      i++; 
2DA4:  INCF   xD2,F
....................      if (i%16==0) printf("\r\n %02X:", i); 
2DA6:  MOVF   xD2,W
2DA8:  ANDLW  0F
2DAA:  BNZ   2DD6
2DAC:  MOVLW  0D
2DAE:  BTFSS  F9E.4
2DB0:  BRA    2DAE
2DB2:  MOVWF  FAD
2DB4:  MOVLW  0A
2DB6:  BTFSS  F9E.4
2DB8:  BRA    2DB6
2DBA:  MOVWF  FAD
2DBC:  MOVLW  20
2DBE:  BTFSS  F9E.4
2DC0:  BRA    2DBE
2DC2:  MOVWF  FAD
2DC4:  MOVFF  D2,E9
2DC8:  MOVLW  37
2DCA:  MOVWF  xEA
2DCC:  RCALL  272E
2DCE:  MOVLW  3A
2DD0:  BTFSS  F9E.4
2DD2:  BRA    2DD0
2DD4:  MOVWF  FAD
....................       printf("%02X ",data); 
2DD6:  MOVFF  D1,E9
2DDA:  MOVLW  37
2DDC:  MOVWF  xEA
2DDE:  RCALL  272E
2DE0:  MOVLW  20
2DE2:  BTFSS  F9E.4
2DE4:  BRA    2DE2
2DE6:  MOVWF  FAD
....................  
....................    } while (i<255); 
2DE8:  INCFSZ xD2,W
2DEA:  BRA    2D96
....................    output_high(FLASH_SELECT);    
2DEC:  BCF    F94.2
2DEE:  BSF    F8B.2
.................... } 
2DF0:  GOTO   33D4 (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
2F00:  CALL   24A8
....................    output_low(FLASH_SELECT); 
2F04:  BCF    F94.2
2F06:  BCF    F8B.2
....................    ext_flash_sendData(0x84, 8); 
2F08:  MOVLW  84
2F0A:  MOVWF  xFA
2F0C:  MOVLW  08
2F0E:  MOVWF  xFB
2F10:  CALL   25DE
....................    ext_flash_send16Data(0, 16); 
2F14:  CLRF   xFB
2F16:  CLRF   xFA
2F18:  MOVLW  10
2F1A:  MOVWF  xFC
2F1C:  CALL   260E
....................    ext_flash_sendData(PageIndex, 8); 
2F20:  MOVFF  DD,FA
2F24:  MOVLW  08
2F26:  MOVWF  xFB
2F28:  CALL   25DE
....................    if (nData>1) { 
2F2C:  MOVF   xDE,W
2F2E:  SUBLW  01
2F30:  BC    2F4C
....................    i=255; 
2F32:  MOVLW  FF
2F34:  MOVWF  xDF
....................    do { 
....................       ext_flash_sendData(data,8); 
2F36:  MOVFF  DC,FA
2F3A:  MOVLW  08
2F3C:  MOVWF  xFB
2F3E:  CALL   25DE
....................       i++; 
2F42:  INCF   xDF,F
....................    } while(i<nData); 
2F44:  MOVF   xDE,W
2F46:  SUBWF  xDF,W
2F48:  BNC   2F36
....................    } else 
2F4A:  BRA    2F58
....................          ext_flash_sendData(data,8); 
2F4C:  MOVFF  DC,FA
2F50:  MOVLW  08
2F52:  MOVWF  xFB
2F54:  CALL   25DE
....................    output_high(FLASH_SELECT); 
2F58:  BCF    F94.2
2F5A:  BSF    F8B.2
.................... } 
2F5C:  RETLW  00
....................  
.................... void ext_flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
383A:  CALL   24A8
....................    output_low(FLASH_SELECT); 
383E:  BCF    F94.2
3840:  BCF    F8B.2
....................    ext_flash_sendData(0x83, 8); 
3842:  MOVLW  83
3844:  MOVWF  xFA
3846:  MOVLW  08
3848:  MOVWF  xFB
384A:  CALL   25DE
....................    ext_flash_send16Data(pageAddress, 15); 
384E:  MOVFF  D8,FB
3852:  MOVFF  D7,FA
3856:  MOVLW  0F
3858:  MOVWF  xFC
385A:  CALL   260E
....................    ext_flash_send16Data(0, 9); 
385E:  CLRF   xFB
3860:  CLRF   xFA
3862:  MOVLW  09
3864:  MOVWF  xFC
3866:  CALL   260E
....................    output_high(FLASH_SELECT); 
386A:  BCF    F94.2
386C:  BSF    F8B.2
.................... } 
386E:  GOTO   3C00 (RETURN)
....................  
.................... void ext_flash_main_memory_to_buffer1(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
35D2:  CALL   24A8
....................    output_low(FLASH_SELECT); 
35D6:  BCF    F94.2
35D8:  BCF    F8B.2
....................    ext_flash_sendData(0x53, 8); 
35DA:  MOVLW  53
35DC:  MOVWF  xFA
35DE:  MOVLW  08
35E0:  MOVWF  xFB
35E2:  CALL   25DE
....................    ext_flash_send16Data(pageAddress, 15); 
35E6:  MOVFF  D7,FB
35EA:  MOVFF  D6,FA
35EE:  MOVLW  0F
35F0:  MOVWF  xFC
35F2:  CALL   260E
....................    ext_flash_send16Data(0, 9); 
35F6:  CLRF   xFB
35F8:  CLRF   xFA
35FA:  MOVLW  09
35FC:  MOVWF  xFC
35FE:  CALL   260E
....................    output_high(FLASH_SELECT); 
3602:  BCF    F94.2
3604:  BSF    F8B.2
.................... } 
3606:  GOTO   60C2 (RETURN)
....................  
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD.lcd_nibble=n>>4; 
*
099C:  SWAPF  xF2,W
099E:  MOVWF  00
09A0:  MOVLW  0F
09A2:  ANDWF  00,F
09A4:  MOVF   00,W
09A6:  ANDLW  0F
09A8:  MOVWF  00
09AA:  MOVLW  F0
09AC:  ANDWF  F83,W
09AE:  IORWF  00,W
09B0:  MOVWF  F83
....................       delay_us(50); 
09B2:  MOVLW  29
09B4:  MOVWF  00
09B6:  DECFSZ 00,F
09B8:  BRA    09B6
09BA:  NOP   
....................       PORTD.disp_en=1; 
09BC:  BSF    F83.7
....................       delay_us(50); 
09BE:  MOVLW  29
09C0:  MOVWF  00
09C2:  DECFSZ 00,F
09C4:  BRA    09C2
09C6:  NOP   
....................       PORTD.disp_en=0; 
09C8:  BCF    F83.7
....................      delay_us(50); 
09CA:  MOVLW  29
09CC:  MOVWF  00
09CE:  DECFSZ 00,F
09D0:  BRA    09CE
09D2:  NOP   
.................... } 
09D4:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
....................    PORTE.rs=rs; 
09D6:  BTFSS  xEE.0
09D8:  BCF    F84.0
09DA:  BTFSC  xEE.0
09DC:  BSF    F84.0
....................    lcd_send_nibble(dat&0xF0); 
09DE:  MOVF   xEF,W
09E0:  ANDLW  F0
09E2:  MOVWF  xF0
09E4:  MOVWF  xF2
09E6:  RCALL  099C
....................    lcd_send_nibble((dat<<4)&0xF0); 
09E8:  SWAPF  xEF,W
09EA:  MOVWF  00
09EC:  MOVLW  F0
09EE:  ANDWF  00,F
09F0:  MOVF   00,W
09F2:  ANDLW  F0
09F4:  MOVWF  xF1
09F6:  MOVWF  xF2
09F8:  RCALL  099C
....................    PORTE.rs=1; 
09FA:  BSF    F84.0
.................... } 
09FC:  RETLW  00
....................  
.................... void lcd_init() { 
....................    int8 i; 
....................     PORTE.rs = 0; 
09FE:  BCF    F84.0
....................     PORTD.disp_en=0; 
0A00:  BCF    F83.7
0A02:  CLRF   18
0A04:  BTFSC  FF2.7
0A06:  BSF    18.7
0A08:  BCF    FF2.7
....................    delay_ms(15); 
0A0A:  MOVLW  0F
0A0C:  MOVWF  xEA
0A0E:  RCALL  04BC
0A10:  BTFSC  18.7
0A12:  BSF    FF2.7
....................     for(i=1;i<=3;++i) { 
0A14:  MOVLW  01
0A16:  MOVWF  xD2
0A18:  MOVF   xD2,W
0A1A:  SUBLW  03
0A1C:  BNC   0A3A
....................        lcd_send_nibble(0x30);  
0A1E:  MOVLW  30
0A20:  MOVWF  xF2
0A22:  RCALL  099C
0A24:  CLRF   18
0A26:  BTFSC  FF2.7
0A28:  BSF    18.7
0A2A:  BCF    FF2.7
....................        delay_ms(15); 
0A2C:  MOVLW  0F
0A2E:  MOVWF  xEA
0A30:  RCALL  04BC
0A32:  BTFSC  18.7
0A34:  BSF    FF2.7
....................     } 
0A36:  INCF   xD2,F
0A38:  BRA    0A18
....................     lcd_send_nibble(0x20);  
0A3A:  MOVLW  20
0A3C:  MOVWF  xF2
0A3E:  RCALL  099C
0A40:  CLRF   18
0A42:  BTFSC  FF2.7
0A44:  BSF    18.7
0A46:  BCF    FF2.7
....................     delay_ms(15); 
0A48:  MOVLW  0F
0A4A:  MOVWF  xEA
0A4C:  RCALL  04BC
0A4E:  BTFSC  18.7
0A50:  BSF    FF2.7
....................     lcd_send_cmd(0,0x06); 
0A52:  CLRF   xEE
0A54:  MOVLW  06
0A56:  MOVWF  xEF
0A58:  RCALL  09D6
....................     delay_us(50); 
0A5A:  MOVLW  29
0A5C:  MOVWF  00
0A5E:  DECFSZ 00,F
0A60:  BRA    0A5E
0A62:  NOP   
....................     lcd_send_cmd(0,0x0c); 
0A64:  CLRF   xEE
0A66:  MOVLW  0C
0A68:  MOVWF  xEF
0A6A:  RCALL  09D6
....................     delay_us(50); 
0A6C:  MOVLW  29
0A6E:  MOVWF  00
0A70:  DECFSZ 00,F
0A72:  BRA    0A70
0A74:  NOP   
....................     lcd_send_cmd(0,0x10); 
0A76:  CLRF   xEE
0A78:  MOVLW  10
0A7A:  MOVWF  xEF
0A7C:  RCALL  09D6
....................     delay_us(50); 
0A7E:  MOVLW  29
0A80:  MOVWF  00
0A82:  DECFSZ 00,F
0A84:  BRA    0A82
0A86:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
0A88:  CLRF   xEE
0A8A:  MOVLW  2C
0A8C:  MOVWF  xEF
0A8E:  RCALL  09D6
....................     delay_us(50); 
0A90:  MOVLW  29
0A92:  MOVWF  00
0A94:  DECFSZ 00,F
0A96:  BRA    0A94
0A98:  NOP   
....................     lcd_send_cmd(0,0x01); 
0A9A:  CLRF   xEE
0A9C:  MOVLW  01
0A9E:  MOVWF  xEF
0AA0:  RCALL  09D6
....................     delay_us(50); 
0AA2:  MOVLW  29
0AA4:  MOVWF  00
0AA6:  DECFSZ 00,F
0AA8:  BRA    0AA6
0AAA:  NOP   
....................  
.................... } 
0AAC:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
0CC2:  MOVF   xEB,W
0CC4:  ANDLW  03
0CC6:  CLRF   03
0CC8:  MOVFF  FF2,EE
0CCC:  BCF    FF2.7
0CCE:  CALL   00AA
0CD2:  BTFSC  xEE.7
0CD4:  BSF    FF2.7
0CD6:  MOVWF  xEC
....................    address+=x; 
0CD8:  MOVF   xEA,W
0CDA:  ADDWF  xEC,F
....................    lcd_send_cmd(0,0x80|address); 
0CDC:  MOVF   xEC,W
0CDE:  IORLW  80
0CE0:  MOVWF  xED
0CE2:  CLRF   xEE
0CE4:  MOVWF  xEF
0CE6:  RCALL  09D6
.................... } 
0CE8:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0CEA:  MOVF   xE9,W
0CEC:  XORLW  0C
0CEE:  BZ    0CFA
0CF0:  XORLW  06
0CF2:  BZ    0D18
0CF4:  XORLW  02
0CF6:  BZ    0D24
0CF8:  BRA    0D2E
....................      case '\f'   : lcd_send_cmd(0,1); 
0CFA:  CLRF   xEE
0CFC:  MOVLW  01
0CFE:  MOVWF  xEF
0D00:  RCALL  09D6
0D02:  CLRF   18
0D04:  BTFSC  FF2.7
0D06:  BSF    18.7
0D08:  BCF    FF2.7
....................                    delay_ms(2); 
0D0A:  MOVLW  02
0D0C:  MOVWF  xEA
0D0E:  CALL   04BC
0D12:  BTFSC  18.7
0D14:  BSF    FF2.7
....................                                            break; 
0D16:  BRA    0D3A
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0D18:  MOVLW  01
0D1A:  MOVWF  xEA
0D1C:  MOVLW  02
0D1E:  MOVWF  xEB
0D20:  RCALL  0CC2
0D22:  BRA    0D3A
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
0D24:  CLRF   xEE
0D26:  MOVLW  10
0D28:  MOVWF  xEF
0D2A:  RCALL  09D6
0D2C:  BRA    0D3A
....................      default     : lcd_send_cmd(1,c);     break; 
0D2E:  MOVLW  01
0D30:  MOVWF  xEE
0D32:  MOVFF  E9,EF
0D36:  RCALL  09D6
0D38:  BRA    0D3A
....................    } 
.................... } 
0D3A:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<size;i++)   lcd_putc(c[i]); 
*
16B4:  CLRF   xE4
16B6:  MOVF   xE3,W
16B8:  SUBWF  xE4,W
16BA:  BC    16DA
16BC:  CLRF   03
16BE:  MOVF   xE4,W
16C0:  ADDWF  xE1,W
16C2:  MOVWF  FE9
16C4:  MOVF   xE2,W
16C6:  ADDWFC 03,W
16C8:  MOVWF  FEA
16CA:  MOVFF  FEF,E5
16CE:  MOVFF  E5,E9
16D2:  CALL   0CEA
16D6:  INCF   xE4,F
16D8:  BRA    16B6
.................... } 
16DA:  RETLW  00
....................     
....................  
.................... void print_date_time() { 
....................  
....................       JDN = (unsigned int32)((float) (Y2010_JDN*1.0+ 0.5+ (float)(UTC*1.0)/24.0 + (timer_sec)*1.0/86400.0)); 
16DC:  MOVFF  23,E3
16E0:  MOVFF  22,E2
16E4:  MOVFF  21,E1
16E8:  MOVFF  20,E0
16EC:  GOTO   0DEE
16F0:  MOVFF  03,151
16F4:  MOVFF  02,150
16F8:  MOVFF  01,14F
16FC:  MOVFF  00,14E
1700:  MOVLB  1
1702:  CLRF   x55
1704:  CLRF   x54
1706:  CLRF   x53
1708:  MOVLW  7F
170A:  MOVWF  x52
170C:  MOVLB  0
170E:  CALL   0E24
1712:  MOVFF  00,E0
1716:  MOVFF  01,E1
171A:  MOVFF  02,E2
171E:  MOVFF  03,E3
1722:  MOVFF  03,14D
1726:  MOVFF  02,14C
172A:  MOVFF  01,14B
172E:  MOVFF  00,14A
1732:  MOVLB  1
1734:  CLRF   x51
1736:  MOVLW  C0
1738:  MOVWF  x50
173A:  MOVLW  28
173C:  MOVWF  x4F
173E:  MOVLW  8F
1740:  MOVWF  x4E
1742:  MOVLB  0
1744:  CALL   0F1A
1748:  BCF    FD8.1
174A:  MOVLW  79
174C:  MOVLB  1
174E:  MOVWF  x53
1750:  MOVLW  DA
1752:  MOVWF  x52
1754:  MOVLW  15
1756:  MOVWF  x51
1758:  MOVLW  94
175A:  MOVWF  x50
175C:  MOVFF  03,157
1760:  MOVFF  02,156
1764:  MOVFF  01,155
1768:  MOVFF  00,154
176C:  MOVLB  0
176E:  RCALL  1078
1770:  MOVFF  03,E7
1774:  MOVFF  02,E6
1778:  MOVFF  01,E5
177C:  MOVFF  00,E4
1780:  BRA    12F0
1782:  MOVFF  03,75
1786:  MOVFF  02,74
178A:  MOVFF  01,73
178E:  MOVFF  00,72
....................       jj = JDN +32044; 
1792:  MOVLW  2C
1794:  ADDWF  x72,W
1796:  MOVWF  x76
1798:  MOVLW  7D
179A:  ADDWFC x73,W
179C:  MOVWF  x77
179E:  MOVLW  00
17A0:  ADDWFC x74,W
17A2:  MOVWF  x78
17A4:  MOVLW  00
17A6:  ADDWFC x75,W
17A8:  MOVWF  x79
17AA:  CLRF   18
17AC:  BTFSC  FF2.7
17AE:  BSF    18.7
17B0:  BCF    FF2.7
....................       g=jj/146097; 
17B2:  MOVFF  79,EE
17B6:  MOVFF  78,ED
17BA:  MOVFF  77,EC
17BE:  MOVFF  76,EB
17C2:  CLRF   xF2
17C4:  MOVLW  02
17C6:  MOVWF  xF1
17C8:  MOVLW  3A
17CA:  MOVWF  xF0
17CC:  MOVLW  B1
17CE:  MOVWF  xEF
17D0:  CALL   0340
17D4:  BTFSC  18.7
17D6:  BSF    FF2.7
17D8:  MOVFF  03,7D
17DC:  MOVFF  02,7C
17E0:  MOVFF  01,7B
17E4:  MOVFF  00,7A
17E8:  CLRF   18
17EA:  BTFSC  FF2.7
17EC:  BSF    18.7
17EE:  BCF    FF2.7
....................       dg=jj%146097; 
17F0:  MOVFF  79,EE
17F4:  MOVFF  78,ED
17F8:  MOVFF  77,EC
17FC:  MOVFF  76,EB
1800:  CLRF   xF2
1802:  MOVLW  02
1804:  MOVWF  xF1
1806:  MOVLW  3A
1808:  MOVWF  xF0
180A:  MOVLW  B1
180C:  MOVWF  xEF
180E:  CALL   0340
1812:  BTFSC  18.7
1814:  BSF    FF2.7
1816:  MOVFF  FEF,7E
181A:  MOVFF  FEC,7F
181E:  MOVFF  FEC,80
1822:  MOVFF  FEC,81
1826:  CLRF   18
1828:  BTFSC  FF2.7
182A:  BSF    18.7
182C:  BCF    FF2.7
....................       c=(dg/36524+1)*3/4; 
182E:  MOVFF  81,EE
1832:  MOVFF  80,ED
1836:  MOVFF  7F,EC
183A:  MOVFF  7E,EB
183E:  CLRF   xF2
1840:  CLRF   xF1
1842:  MOVLW  8E
1844:  MOVWF  xF0
1846:  MOVLW  AC
1848:  MOVWF  xEF
184A:  CALL   0340
184E:  BTFSC  18.7
1850:  BSF    FF2.7
1852:  MOVFF  03,E3
1856:  MOVFF  02,E2
185A:  MOVFF  01,E1
185E:  MOVFF  00,E0
1862:  MOVLW  01
1864:  ADDWF  00,W
1866:  MOVWF  xE4
1868:  MOVLW  00
186A:  ADDWFC 01,W
186C:  MOVWF  xE5
186E:  MOVLW  00
1870:  ADDWFC 02,W
1872:  MOVWF  xE6
1874:  MOVLW  00
1876:  ADDWFC 03,W
1878:  MOVWF  xE7
187A:  MOVWF  xF8
187C:  MOVFF  E6,F7
1880:  MOVFF  E5,F6
1884:  MOVFF  E4,F5
1888:  CLRF   xFC
188A:  CLRF   xFB
188C:  CLRF   xFA
188E:  MOVLW  03
1890:  MOVWF  xF9
1892:  RCALL  1330
1894:  RRCF   03,W
1896:  MOVWF  x85
1898:  RRCF   02,W
189A:  MOVWF  x84
189C:  RRCF   01,W
189E:  MOVWF  x83
18A0:  RRCF   00,W
18A2:  MOVWF  x82
18A4:  RRCF   x85,F
18A6:  RRCF   x84,F
18A8:  RRCF   x83,F
18AA:  RRCF   x82,F
18AC:  MOVLW  3F
18AE:  ANDWF  x85,F
....................       dc=dg-c*36524; 
18B0:  MOVFF  85,F8
18B4:  MOVFF  84,F7
18B8:  MOVFF  83,F6
18BC:  MOVFF  82,F5
18C0:  CLRF   xFC
18C2:  CLRF   xFB
18C4:  MOVLW  8E
18C6:  MOVWF  xFA
18C8:  MOVLW  AC
18CA:  MOVWF  xF9
18CC:  RCALL  1330
18CE:  MOVF   00,W
18D0:  SUBWF  x7E,W
18D2:  MOVWF  x86
18D4:  MOVF   01,W
18D6:  SUBWFB x7F,W
18D8:  MOVWF  x87
18DA:  MOVF   02,W
18DC:  SUBWFB x80,W
18DE:  MOVWF  x88
18E0:  MOVF   03,W
18E2:  SUBWFB x81,W
18E4:  MOVWF  x89
18E6:  CLRF   18
18E8:  BTFSC  FF2.7
18EA:  BSF    18.7
18EC:  BCF    FF2.7
....................       b=dc/1461; 
18EE:  MOVFF  89,EE
18F2:  MOVFF  88,ED
18F6:  MOVFF  87,EC
18FA:  MOVFF  86,EB
18FE:  CLRF   xF2
1900:  CLRF   xF1
1902:  MOVLW  05
1904:  MOVWF  xF0
1906:  MOVLW  B5
1908:  MOVWF  xEF
190A:  CALL   0340
190E:  BTFSC  18.7
1910:  BSF    FF2.7
1912:  MOVFF  03,8D
1916:  MOVFF  02,8C
191A:  MOVFF  01,8B
191E:  MOVFF  00,8A
1922:  CLRF   18
1924:  BTFSC  FF2.7
1926:  BSF    18.7
1928:  BCF    FF2.7
....................       db=dc%1461; 
192A:  MOVFF  89,EE
192E:  MOVFF  88,ED
1932:  MOVFF  87,EC
1936:  MOVFF  86,EB
193A:  CLRF   xF2
193C:  CLRF   xF1
193E:  MOVLW  05
1940:  MOVWF  xF0
1942:  MOVLW  B5
1944:  MOVWF  xEF
1946:  CALL   0340
194A:  BTFSC  18.7
194C:  BSF    FF2.7
194E:  MOVFF  FEF,8E
1952:  MOVFF  FEC,8F
1956:  MOVFF  FEC,90
195A:  MOVFF  FEC,91
195E:  CLRF   18
1960:  BTFSC  FF2.7
1962:  BSF    18.7
1964:  BCF    FF2.7
....................       a=(db/365+1)*3/4; 
1966:  MOVFF  91,EE
196A:  MOVFF  90,ED
196E:  MOVFF  8F,EC
1972:  MOVFF  8E,EB
1976:  CLRF   xF2
1978:  CLRF   xF1
197A:  MOVLW  01
197C:  MOVWF  xF0
197E:  MOVLW  6D
1980:  MOVWF  xEF
1982:  CALL   0340
1986:  BTFSC  18.7
1988:  BSF    FF2.7
198A:  MOVFF  03,E3
198E:  MOVFF  02,E2
1992:  MOVFF  01,E1
1996:  MOVFF  00,E0
199A:  MOVLW  01
199C:  ADDWF  00,W
199E:  MOVWF  xE4
19A0:  MOVLW  00
19A2:  ADDWFC 01,W
19A4:  MOVWF  xE5
19A6:  MOVLW  00
19A8:  ADDWFC 02,W
19AA:  MOVWF  xE6
19AC:  MOVLW  00
19AE:  ADDWFC 03,W
19B0:  MOVWF  xE7
19B2:  MOVWF  xF8
19B4:  MOVFF  E6,F7
19B8:  MOVFF  E5,F6
19BC:  MOVFF  E4,F5
19C0:  CLRF   xFC
19C2:  CLRF   xFB
19C4:  CLRF   xFA
19C6:  MOVLW  03
19C8:  MOVWF  xF9
19CA:  RCALL  1330
19CC:  RRCF   03,W
19CE:  MOVWF  x95
19D0:  RRCF   02,W
19D2:  MOVWF  x94
19D4:  RRCF   01,W
19D6:  MOVWF  x93
19D8:  RRCF   00,W
19DA:  MOVWF  x92
19DC:  RRCF   x95,F
19DE:  RRCF   x94,F
19E0:  RRCF   x93,F
19E2:  RRCF   x92,F
19E4:  MOVLW  3F
19E6:  ANDWF  x95,F
....................       da=db-a*365; 
19E8:  MOVFF  95,F8
19EC:  MOVFF  94,F7
19F0:  MOVFF  93,F6
19F4:  MOVFF  92,F5
19F8:  CLRF   xFC
19FA:  CLRF   xFB
19FC:  MOVLW  01
19FE:  MOVWF  xFA
1A00:  MOVLW  6D
1A02:  MOVWF  xF9
1A04:  RCALL  1330
1A06:  MOVF   00,W
1A08:  SUBWF  x8E,W
1A0A:  MOVWF  x96
1A0C:  MOVF   01,W
1A0E:  SUBWFB x8F,W
1A10:  MOVWF  x97
1A12:  MOVF   02,W
1A14:  SUBWFB x90,W
1A16:  MOVWF  x98
1A18:  MOVF   03,W
1A1A:  SUBWFB x91,W
1A1C:  MOVWF  x99
....................       y=g*400+c*100+b*4+a; 
1A1E:  MOVFF  7D,F8
1A22:  MOVFF  7C,F7
1A26:  MOVFF  7B,F6
1A2A:  MOVFF  7A,F5
1A2E:  CLRF   xFC
1A30:  CLRF   xFB
1A32:  MOVLW  01
1A34:  MOVWF  xFA
1A36:  MOVLW  90
1A38:  MOVWF  xF9
1A3A:  RCALL  1330
1A3C:  MOVFF  03,E3
1A40:  MOVFF  02,E2
1A44:  MOVFF  01,E1
1A48:  MOVFF  00,E0
1A4C:  MOVFF  85,F8
1A50:  MOVFF  84,F7
1A54:  MOVFF  83,F6
1A58:  MOVFF  82,F5
1A5C:  CLRF   xFC
1A5E:  CLRF   xFB
1A60:  CLRF   xFA
1A62:  MOVLW  64
1A64:  MOVWF  xF9
1A66:  RCALL  1330
1A68:  MOVF   00,W
1A6A:  ADDWF  xE0,W
1A6C:  MOVWF  xE4
1A6E:  MOVF   01,W
1A70:  ADDWFC xE1,W
1A72:  MOVWF  xE5
1A74:  MOVF   02,W
1A76:  ADDWFC xE2,W
1A78:  MOVWF  xE6
1A7A:  MOVF   03,W
1A7C:  ADDWFC xE3,W
1A7E:  MOVWF  xE7
1A80:  RLCF   x8A,W
1A82:  MOVWF  00
1A84:  RLCF   x8B,W
1A86:  MOVWF  01
1A88:  RLCF   x8C,W
1A8A:  MOVWF  02
1A8C:  RLCF   x8D,W
1A8E:  MOVWF  03
1A90:  RLCF   00,F
1A92:  RLCF   01,F
1A94:  RLCF   02,F
1A96:  RLCF   03,F
1A98:  MOVLW  FC
1A9A:  ANDWF  00,F
1A9C:  MOVF   00,W
1A9E:  ADDWF  xE4,W
1AA0:  MOVWF  xE8
1AA2:  MOVF   01,W
1AA4:  ADDWFC xE5,W
1AA6:  MOVWF  xE9
1AA8:  MOVF   02,W
1AAA:  ADDWFC xE6,W
1AAC:  MOVWF  xEA
1AAE:  MOVF   03,W
1AB0:  ADDWFC xE7,W
1AB2:  MOVWF  xEB
1AB4:  MOVF   x92,W
1AB6:  ADDWF  xE8,W
1AB8:  MOVWF  x9A
1ABA:  MOVF   x93,W
1ABC:  ADDWFC xE9,W
1ABE:  MOVWF  x9B
1AC0:  MOVF   x94,W
1AC2:  ADDWFC xEA,W
1AC4:  MOVWF  x9C
1AC6:  MOVF   x95,W
1AC8:  ADDWFC xEB,W
1ACA:  MOVWF  x9D
....................       m=(da*5+308)/153-2; 
1ACC:  MOVFF  99,F8
1AD0:  MOVFF  98,F7
1AD4:  MOVFF  97,F6
1AD8:  MOVFF  96,F5
1ADC:  CLRF   xFC
1ADE:  CLRF   xFB
1AE0:  CLRF   xFA
1AE2:  MOVLW  05
1AE4:  MOVWF  xF9
1AE6:  RCALL  1330
1AE8:  MOVFF  03,E3
1AEC:  MOVFF  02,E2
1AF0:  MOVFF  01,E1
1AF4:  MOVFF  00,E0
1AF8:  MOVLW  34
1AFA:  ADDWF  00,W
1AFC:  MOVWF  xE4
1AFE:  MOVLW  01
1B00:  ADDWFC 01,W
1B02:  MOVWF  xE5
1B04:  MOVLW  00
1B06:  ADDWFC 02,W
1B08:  MOVWF  xE6
1B0A:  MOVLW  00
1B0C:  ADDWFC 03,W
1B0E:  MOVWF  xE7
1B10:  CLRF   18
1B12:  BTFSC  FF2.7
1B14:  BSF    18.7
1B16:  BCF    FF2.7
1B18:  MOVWF  xEE
1B1A:  MOVFF  E6,ED
1B1E:  MOVFF  E5,EC
1B22:  MOVFF  E4,EB
1B26:  CLRF   xF2
1B28:  CLRF   xF1
1B2A:  CLRF   xF0
1B2C:  MOVLW  99
1B2E:  MOVWF  xEF
1B30:  CALL   0340
1B34:  BTFSC  18.7
1B36:  BSF    FF2.7
1B38:  MOVLW  02
1B3A:  SUBWF  00,W
1B3C:  MOVWF  x9E
1B3E:  MOVLW  00
1B40:  SUBWFB 01,W
1B42:  MOVWF  x9F
1B44:  MOVLW  00
1B46:  SUBWFB 02,W
1B48:  MOVWF  xA0
1B4A:  MOVLW  00
1B4C:  SUBWFB 03,W
1B4E:  MOVWF  xA1
....................       d=da-(m+4)*153/5+122; 
1B50:  MOVLW  04
1B52:  ADDWF  x9E,W
1B54:  MOVWF  xE0
1B56:  MOVLW  00
1B58:  ADDWFC x9F,W
1B5A:  MOVWF  xE1
1B5C:  MOVLW  00
1B5E:  ADDWFC xA0,W
1B60:  MOVWF  xE2
1B62:  MOVLW  00
1B64:  ADDWFC xA1,W
1B66:  MOVWF  xE3
1B68:  MOVWF  xF8
1B6A:  MOVFF  E2,F7
1B6E:  MOVFF  E1,F6
1B72:  MOVFF  E0,F5
1B76:  CLRF   xFC
1B78:  CLRF   xFB
1B7A:  CLRF   xFA
1B7C:  MOVLW  99
1B7E:  MOVWF  xF9
1B80:  CALL   1330
1B84:  MOVFF  03,E4
1B88:  MOVFF  02,E3
1B8C:  MOVFF  01,E2
1B90:  MOVFF  00,E1
1B94:  CLRF   18
1B96:  BTFSC  FF2.7
1B98:  BSF    18.7
1B9A:  BCF    FF2.7
1B9C:  MOVFF  03,EE
1BA0:  MOVFF  02,ED
1BA4:  MOVFF  01,EC
1BA8:  MOVFF  00,EB
1BAC:  CLRF   xF2
1BAE:  CLRF   xF1
1BB0:  CLRF   xF0
1BB2:  MOVLW  05
1BB4:  MOVWF  xEF
1BB6:  CALL   0340
1BBA:  BTFSC  18.7
1BBC:  BSF    FF2.7
1BBE:  MOVF   00,W
1BC0:  SUBWF  x96,W
1BC2:  MOVWF  xE2
1BC4:  MOVF   01,W
1BC6:  SUBWFB x97,W
1BC8:  MOVWF  xE3
1BCA:  MOVF   02,W
1BCC:  SUBWFB x98,W
1BCE:  MOVWF  xE4
1BD0:  MOVF   03,W
1BD2:  SUBWFB x99,W
1BD4:  MOVWF  xE5
1BD6:  MOVLW  7A
1BD8:  ADDWF  xE2,W
1BDA:  MOVWF  xA2
1BDC:  MOVLW  00
1BDE:  ADDWFC xE3,W
1BE0:  MOVWF  xA3
1BE2:  MOVLW  00
1BE4:  ADDWFC xE4,W
1BE6:  MOVWF  xA4
1BE8:  MOVLW  00
1BEA:  ADDWFC xE5,W
1BEC:  MOVWF  xA5
....................       YY=y-4800+(m+2)/12; 
1BEE:  MOVLW  C0
1BF0:  SUBWF  x9A,W
1BF2:  MOVWF  xE0
1BF4:  MOVLW  12
1BF6:  SUBWFB x9B,W
1BF8:  MOVWF  xE1
1BFA:  MOVLW  00
1BFC:  SUBWFB x9C,W
1BFE:  MOVWF  xE2
1C00:  MOVLW  00
1C02:  SUBWFB x9D,W
1C04:  MOVWF  xE3
1C06:  MOVLW  02
1C08:  ADDWF  x9E,W
1C0A:  MOVWF  xE4
1C0C:  MOVLW  00
1C0E:  ADDWFC x9F,W
1C10:  MOVWF  xE5
1C12:  MOVLW  00
1C14:  ADDWFC xA0,W
1C16:  MOVWF  xE6
1C18:  MOVLW  00
1C1A:  ADDWFC xA1,W
1C1C:  MOVWF  xE7
1C1E:  CLRF   18
1C20:  BTFSC  FF2.7
1C22:  BSF    18.7
1C24:  BCF    FF2.7
1C26:  MOVWF  xEE
1C28:  MOVFF  E6,ED
1C2C:  MOVFF  E5,EC
1C30:  MOVFF  E4,EB
1C34:  CLRF   xF2
1C36:  CLRF   xF1
1C38:  CLRF   xF0
1C3A:  MOVLW  0C
1C3C:  MOVWF  xEF
1C3E:  CALL   0340
1C42:  BTFSC  18.7
1C44:  BSF    FF2.7
1C46:  MOVF   00,W
1C48:  ADDWF  xE0,W
1C4A:  MOVWF  xA6
1C4C:  MOVF   01,W
1C4E:  ADDWFC xE1,W
1C50:  MOVWF  xA7
1C52:  MOVF   02,W
1C54:  ADDWFC xE2,W
1C56:  MOVWF  xA8
1C58:  MOVF   03,W
1C5A:  ADDWFC xE3,W
1C5C:  MOVWF  xA9
....................       MM=(m+2)%12+1; 
1C5E:  MOVLW  02
1C60:  ADDWF  x9E,W
1C62:  MOVWF  xE0
1C64:  MOVLW  00
1C66:  ADDWFC x9F,W
1C68:  MOVWF  xE1
1C6A:  MOVLW  00
1C6C:  ADDWFC xA0,W
1C6E:  MOVWF  xE2
1C70:  MOVLW  00
1C72:  ADDWFC xA1,W
1C74:  MOVWF  xE3
1C76:  CLRF   18
1C78:  BTFSC  FF2.7
1C7A:  BSF    18.7
1C7C:  BCF    FF2.7
1C7E:  MOVWF  xEE
1C80:  MOVFF  E2,ED
1C84:  MOVFF  E1,EC
1C88:  MOVFF  E0,EB
1C8C:  CLRF   xF2
1C8E:  CLRF   xF1
1C90:  CLRF   xF0
1C92:  MOVLW  0C
1C94:  MOVWF  xEF
1C96:  CALL   0340
1C9A:  BTFSC  18.7
1C9C:  BSF    FF2.7
1C9E:  MOVFF  FEF,E1
1CA2:  MOVFF  FEC,E2
1CA6:  MOVFF  FEC,E3
1CAA:  MOVFF  FEC,E4
1CAE:  MOVLW  01
1CB0:  ADDWF  xE1,W
1CB2:  MOVWF  xAA
1CB4:  MOVLW  00
1CB6:  ADDWFC xE2,W
1CB8:  MOVWF  xAB
1CBA:  MOVLW  00
1CBC:  ADDWFC xE3,W
1CBE:  MOVWF  xAC
1CC0:  MOVLW  00
1CC2:  ADDWFC xE4,W
1CC4:  MOVWF  xAD
....................       DD=d+1; 
1CC6:  MOVLW  01
1CC8:  ADDWF  xA2,W
1CCA:  MOVWF  xAE
1CCC:  MOVLW  00
1CCE:  ADDWFC xA3,W
1CD0:  MOVWF  xAF
1CD2:  MOVLW  00
1CD4:  ADDWFC xA4,W
1CD6:  MOVWF  xB0
1CD8:  MOVLW  00
1CDA:  ADDWFC xA5,W
1CDC:  MOVWF  xB1
....................       time_of_day = (timer_sec+((int8)UTC)*3600)%86400; 
1CDE:  MOVLW  70
1CE0:  ADDWF  20,W
1CE2:  MOVWF  xE0
1CE4:  MOVLW  62
1CE6:  ADDWFC 21,W
1CE8:  MOVWF  xE1
1CEA:  MOVLW  00
1CEC:  ADDWFC 22,W
1CEE:  MOVWF  xE2
1CF0:  MOVLW  00
1CF2:  ADDWFC 23,W
1CF4:  MOVWF  xE3
1CF6:  CLRF   18
1CF8:  BTFSC  FF2.7
1CFA:  BSF    18.7
1CFC:  BCF    FF2.7
1CFE:  MOVWF  xEE
1D00:  MOVFF  E2,ED
1D04:  MOVFF  E1,EC
1D08:  MOVFF  E0,EB
1D0C:  CLRF   xF2
1D0E:  MOVLW  01
1D10:  MOVWF  xF1
1D12:  MOVLW  51
1D14:  MOVWF  xF0
1D16:  MOVLW  80
1D18:  MOVWF  xEF
1D1A:  CALL   0340
1D1E:  BTFSC  18.7
1D20:  BSF    FF2.7
1D22:  MOVFF  FEF,B2
1D26:  MOVFF  FEC,B3
1D2A:  MOVFF  FEC,B4
1D2E:  MOVFF  FEC,B5
....................  
....................       strcpy(tmp_str,"00/00/00"); 
1D32:  CLRF   FEA
1D34:  MOVLW  2C
1D36:  MOVWF  FE9
1D38:  MOVFF  FF2,E0
1D3C:  BCF    FF2.7
1D3E:  MOVLW  00
1D40:  CALL   00C8
1D44:  TBLRD*-
1D46:  TBLRD*+
1D48:  MOVF   FF5,W
1D4A:  MOVWF  FEE
1D4C:  IORLW  00
1D4E:  BNZ   1D46
1D50:  BTFSC  xE0.7
1D52:  BSF    FF2.7
....................       itoa((int8)DD,10,tmp_str2); 
1D54:  CLRF   xE9
1D56:  CLRF   xE8
1D58:  CLRF   xE7
1D5A:  MOVFF  AE,E6
1D5E:  MOVLW  0A
1D60:  MOVWF  xEA
1D62:  CLRF   xEC
1D64:  MOVLW  40
1D66:  MOVWF  xEB
1D68:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[1]=tmp_str2[0]; else memcpy(tmp_str,tmp_str2,2); 
1D6C:  CLRF   xE3
1D6E:  MOVLW  40
1D70:  MOVWF  xE2
1D72:  RCALL  1682
1D74:  DECFSZ 01,W
1D76:  BRA    1D7E
1D78:  MOVFF  40,2D
1D7C:  BRA    1D96
1D7E:  CLRF   FEA
1D80:  MOVLW  2C
1D82:  MOVWF  FE9
1D84:  CLRF   FE2
1D86:  MOVLW  40
1D88:  MOVWF  FE1
1D8A:  MOVLW  02
1D8C:  MOVWF  01
1D8E:  MOVFF  FE6,FEE
1D92:  DECFSZ 01,F
1D94:  BRA    1D8E
....................       itoa((int8)MM,10,tmp_str2); 
1D96:  CLRF   xE9
1D98:  CLRF   xE8
1D9A:  CLRF   xE7
1D9C:  MOVFF  AA,E6
1DA0:  MOVLW  0A
1DA2:  MOVWF  xEA
1DA4:  CLRF   xEC
1DA6:  MOVLW  40
1DA8:  MOVWF  xEB
1DAA:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[4]=tmp_str2[0]; else memcpy(tmp_str+3,tmp_str2,2); 
1DAE:  CLRF   xE3
1DB0:  MOVLW  40
1DB2:  MOVWF  xE2
1DB4:  RCALL  1682
1DB6:  DECFSZ 01,W
1DB8:  BRA    1DC0
1DBA:  MOVFF  40,30
1DBE:  BRA    1DD8
1DC0:  CLRF   FEA
1DC2:  MOVLW  2F
1DC4:  MOVWF  FE9
1DC6:  CLRF   FE2
1DC8:  MOVLW  40
1DCA:  MOVWF  FE1
1DCC:  MOVLW  02
1DCE:  MOVWF  01
1DD0:  MOVFF  FE6,FEE
1DD4:  DECFSZ 01,F
1DD6:  BRA    1DD0
1DD8:  CLRF   18
1DDA:  BTFSC  FF2.7
1DDC:  BSF    18.7
1DDE:  BCF    FF2.7
....................       itoa((int8)(YY%2000),10,tmp_str2); 
1DE0:  MOVFF  A9,EE
1DE4:  MOVFF  A8,ED
1DE8:  MOVFF  A7,EC
1DEC:  MOVFF  A6,EB
1DF0:  CLRF   xF2
1DF2:  CLRF   xF1
1DF4:  MOVLW  07
1DF6:  MOVWF  xF0
1DF8:  MOVLW  D0
1DFA:  MOVWF  xEF
1DFC:  CALL   0340
1E00:  BTFSC  18.7
1E02:  BSF    FF2.7
1E04:  MOVFF  FEF,00
1E08:  MOVFF  FEC,01
1E0C:  MOVFF  FEC,02
1E10:  MOVFF  FEC,03
1E14:  MOVFF  00,E0
1E18:  CLRF   xE9
1E1A:  CLRF   xE8
1E1C:  CLRF   xE7
1E1E:  MOVFF  00,E6
1E22:  MOVLW  0A
1E24:  MOVWF  xEA
1E26:  CLRF   xEC
1E28:  MOVLW  40
1E2A:  MOVWF  xEB
1E2C:  CALL   14A6
....................       if (strlen(tmp_str2)==1) tmp_str[7]=tmp_str2[0]; else memcpy(tmp_str+6,tmp_str2,2); 
1E30:  CLRF   xE3
1E32:  MOVLW  40
1E34:  MOVWF  xE2
1E36:  RCALL  1682
1E38:  DECFSZ 01,W
1E3A:  BRA    1E42
1E3C:  MOVFF  40,33
1E40:  BRA    1E5A
1E42:  CLRF   FEA
1E44:  MOVLW  32
1E46:  MOVWF  FE9
1E48:  CLRF   FE2
1E4A:  MOVLW  40
1E4C:  MOVWF  FE1
1E4E:  MOVLW  02
1E50:  MOVWF  01
1E52:  MOVFF  FE6,FEE
1E56:  DECFSZ 01,F
1E58:  BRA    1E52
....................       lcd_gotoxy(0,0); 
1E5A:  CLRF   xEA
1E5C:  CLRF   xEB
1E5E:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
1E62:  CLRF   xE3
1E64:  MOVLW  2C
1E66:  MOVWF  xE2
1E68:  RCALL  1682
1E6A:  MOVFF  01,E0
1E6E:  CLRF   xE2
1E70:  MOVLW  2C
1E72:  MOVWF  xE1
1E74:  MOVFF  01,E3
1E78:  RCALL  16B4
....................       strcpy(tmp_str,"00:00:00"); 
1E7A:  CLRF   FEA
1E7C:  MOVLW  2C
1E7E:  MOVWF  FE9
1E80:  MOVFF  FF2,E0
1E84:  BCF    FF2.7
1E86:  MOVLW  00
1E88:  CALL   00EC
1E8C:  TBLRD*-
1E8E:  TBLRD*+
1E90:  MOVF   FF5,W
1E92:  MOVWF  FEE
1E94:  IORLW  00
1E96:  BNZ   1E8E
1E98:  BTFSC  xE0.7
1E9A:  BSF    FF2.7
1E9C:  CLRF   18
1E9E:  BTFSC  FF2.7
1EA0:  BSF    18.7
1EA2:  BCF    FF2.7
....................       itoa((int8) (time_of_day/3600),10,tmp_str2); 
1EA4:  MOVFF  B5,EE
1EA8:  MOVFF  B4,ED
1EAC:  MOVFF  B3,EC
1EB0:  MOVFF  B2,EB
1EB4:  CLRF   xF2
1EB6:  CLRF   xF1
1EB8:  MOVLW  0E
1EBA:  MOVWF  xF0
1EBC:  MOVLW  10
1EBE:  MOVWF  xEF
1EC0:  CALL   0340
1EC4:  BTFSC  18.7
1EC6:  BSF    FF2.7
1EC8:  MOVFF  00,E0
1ECC:  CLRF   xE9
1ECE:  CLRF   xE8
1ED0:  CLRF   xE7
1ED2:  MOVFF  00,E6
1ED6:  MOVLW  0A
1ED8:  MOVWF  xEA
1EDA:  CLRF   xEC
1EDC:  MOVLW  40
1EDE:  MOVWF  xEB
1EE0:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1EE4:  CLRF   xE3
1EE6:  MOVLW  40
1EE8:  MOVWF  xE2
1EEA:  CALL   1682
1EEE:  MOVF   01,W
1EF0:  SUBLW  02
1EF2:  BNC   1F38
1EF4:  CLRF   xE3
1EF6:  MOVLW  40
1EF8:  MOVWF  xE2
1EFA:  CALL   1682
1EFE:  MOVLW  2E
1F00:  BSF    FD8.0
1F02:  SUBFWB 01,W
1F04:  MOVWF  xE0
1F06:  MOVLW  00
1F08:  BTFSS  FD8.0
1F0A:  DECF   FE8,F
1F0C:  MOVWF  xE1
1F0E:  CLRF   xE3
1F10:  MOVLW  40
1F12:  MOVWF  xE2
1F14:  CALL   1682
1F18:  MOVFF  01,E2
1F1C:  MOVFF  E1,FEA
1F20:  MOVFF  E0,FE9
1F24:  CLRF   FE2
1F26:  MOVLW  40
1F28:  MOVWF  FE1
1F2A:  MOVF   01,W
1F2C:  MOVWF  01
1F2E:  BZ    1F38
1F30:  MOVFF  FE6,FEE
1F34:  DECFSZ 01,F
1F36:  BRA    1F30
1F38:  CLRF   18
1F3A:  BTFSC  FF2.7
1F3C:  BSF    18.7
1F3E:  BCF    FF2.7
....................       itoa((int8) ((time_of_day%3600)/60),10,tmp_str2); 
1F40:  MOVFF  B5,EE
1F44:  MOVFF  B4,ED
1F48:  MOVFF  B3,EC
1F4C:  MOVFF  B2,EB
1F50:  CLRF   xF2
1F52:  CLRF   xF1
1F54:  MOVLW  0E
1F56:  MOVWF  xF0
1F58:  MOVLW  10
1F5A:  MOVWF  xEF
1F5C:  CALL   0340
1F60:  BTFSC  18.7
1F62:  BSF    FF2.7
1F64:  MOVFF  FEF,E0
1F68:  MOVFF  FEC,E1
1F6C:  MOVFF  FEC,E2
1F70:  MOVFF  FEC,E3
1F74:  MOVFF  FEA,E5
1F78:  MOVFF  FE9,E4
1F7C:  CLRF   18
1F7E:  BTFSC  FF2.7
1F80:  BSF    18.7
1F82:  BCF    FF2.7
1F84:  MOVFF  E3,EE
1F88:  MOVFF  E2,ED
1F8C:  MOVFF  E1,EC
1F90:  MOVFF  E0,EB
1F94:  CLRF   xF2
1F96:  CLRF   xF1
1F98:  CLRF   xF0
1F9A:  MOVLW  3C
1F9C:  MOVWF  xEF
1F9E:  CALL   0340
1FA2:  BTFSC  18.7
1FA4:  BSF    FF2.7
1FA6:  MOVFF  E5,FEA
1FAA:  MOVFF  E4,FE9
1FAE:  MOVFF  00,E1
1FB2:  CLRF   xE9
1FB4:  CLRF   xE8
1FB6:  CLRF   xE7
1FB8:  MOVFF  00,E6
1FBC:  MOVLW  0A
1FBE:  MOVWF  xEA
1FC0:  CLRF   xEC
1FC2:  MOVLW  40
1FC4:  MOVWF  xEB
1FC6:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1FCA:  CLRF   xE3
1FCC:  MOVLW  40
1FCE:  MOVWF  xE2
1FD0:  CALL   1682
1FD4:  MOVF   01,W
1FD6:  SUBLW  02
1FD8:  BNC   201E
1FDA:  CLRF   xE3
1FDC:  MOVLW  40
1FDE:  MOVWF  xE2
1FE0:  CALL   1682
1FE4:  MOVLW  31
1FE6:  BSF    FD8.0
1FE8:  SUBFWB 01,W
1FEA:  MOVWF  xE0
1FEC:  MOVLW  00
1FEE:  BTFSS  FD8.0
1FF0:  DECF   FE8,F
1FF2:  MOVWF  xE1
1FF4:  CLRF   xE3
1FF6:  MOVLW  40
1FF8:  MOVWF  xE2
1FFA:  CALL   1682
1FFE:  MOVFF  01,E2
2002:  MOVFF  E1,FEA
2006:  MOVFF  E0,FE9
200A:  CLRF   FE2
200C:  MOVLW  40
200E:  MOVWF  FE1
2010:  MOVF   01,W
2012:  MOVWF  01
2014:  BZ    201E
2016:  MOVFF  FE6,FEE
201A:  DECFSZ 01,F
201C:  BRA    2016
201E:  CLRF   18
2020:  BTFSC  FF2.7
2022:  BSF    18.7
2024:  BCF    FF2.7
....................       itoa((int8) (time_of_day%60),10,tmp_str2); 
2026:  MOVFF  B5,EE
202A:  MOVFF  B4,ED
202E:  MOVFF  B3,EC
2032:  MOVFF  B2,EB
2036:  CLRF   xF2
2038:  CLRF   xF1
203A:  CLRF   xF0
203C:  MOVLW  3C
203E:  MOVWF  xEF
2040:  CALL   0340
2044:  BTFSC  18.7
2046:  BSF    FF2.7
2048:  MOVFF  FEF,00
204C:  MOVFF  FEC,01
2050:  MOVFF  FEC,02
2054:  MOVFF  FEC,03
2058:  MOVFF  00,E0
205C:  CLRF   xE9
205E:  CLRF   xE8
2060:  CLRF   xE7
2062:  MOVFF  00,E6
2066:  MOVLW  0A
2068:  MOVWF  xEA
206A:  CLRF   xEC
206C:  MOVLW  40
206E:  MOVWF  xEB
2070:  CALL   14A6
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2074:  CLRF   xE3
2076:  MOVLW  40
2078:  MOVWF  xE2
207A:  CALL   1682
207E:  MOVF   01,W
2080:  SUBLW  02
2082:  BNC   20C8
2084:  CLRF   xE3
2086:  MOVLW  40
2088:  MOVWF  xE2
208A:  CALL   1682
208E:  MOVLW  34
2090:  BSF    FD8.0
2092:  SUBFWB 01,W
2094:  MOVWF  xE0
2096:  MOVLW  00
2098:  BTFSS  FD8.0
209A:  DECF   FE8,F
209C:  MOVWF  xE1
209E:  CLRF   xE3
20A0:  MOVLW  40
20A2:  MOVWF  xE2
20A4:  CALL   1682
20A8:  MOVFF  01,E2
20AC:  MOVFF  E1,FEA
20B0:  MOVFF  E0,FE9
20B4:  CLRF   FE2
20B6:  MOVLW  40
20B8:  MOVWF  FE1
20BA:  MOVF   01,W
20BC:  MOVWF  01
20BE:  BZ    20C8
20C0:  MOVFF  FE6,FEE
20C4:  DECFSZ 01,F
20C6:  BRA    20C0
....................       lcd_gotoxy(0,1); 
20C8:  CLRF   xEA
20CA:  MOVLW  01
20CC:  MOVWF  xEB
20CE:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
20D2:  CLRF   xE3
20D4:  MOVLW  2C
20D6:  MOVWF  xE2
20D8:  CALL   1682
20DC:  MOVFF  01,E0
20E0:  CLRF   xE2
20E2:  MOVLW  2C
20E4:  MOVWF  xE1
20E6:  MOVFF  01,E3
20EA:  CALL   16B4
....................  
....................       strcpy(tmp_str,"   "); 
20EE:  CLRF   FEA
20F0:  MOVLW  2C
20F2:  MOVWF  FE9
20F4:  MOVFF  FF2,E0
20F8:  BCF    FF2.7
20FA:  MOVLW  00
20FC:  CALL   0110
2100:  TBLRD*-
2102:  TBLRD*+
2104:  MOVF   FF5,W
2106:  MOVWF  FEE
2108:  IORLW  00
210A:  BNZ   2102
210C:  BTFSC  xE0.7
210E:  BSF    FF2.7
....................       itoa((int8)startup_counter,10,tmp_str2); 
2110:  CLRF   xE9
2112:  CLRF   xE8
2114:  CLRF   xE7
2116:  MOVFF  C6,E6
211A:  MOVLW  0A
211C:  MOVWF  xEA
211E:  CLRF   xEC
2120:  MOVLW  40
2122:  MOVWF  xEB
2124:  CALL   14A6
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2128:  CLRF   xE3
212A:  MOVLW  40
212C:  MOVWF  xE2
212E:  CALL   1682
2132:  MOVF   01,W
2134:  SUBLW  03
2136:  BNC   217C
2138:  CLRF   xE3
213A:  MOVLW  40
213C:  MOVWF  xE2
213E:  CALL   1682
2142:  MOVLW  2F
2144:  BSF    FD8.0
2146:  SUBFWB 01,W
2148:  MOVWF  xE0
214A:  MOVLW  00
214C:  BTFSS  FD8.0
214E:  DECF   FE8,F
2150:  MOVWF  xE1
2152:  CLRF   xE3
2154:  MOVLW  40
2156:  MOVWF  xE2
2158:  CALL   1682
215C:  MOVFF  01,E2
2160:  MOVFF  E1,FEA
2164:  MOVFF  E0,FE9
2168:  CLRF   FE2
216A:  MOVLW  40
216C:  MOVWF  FE1
216E:  MOVF   01,W
2170:  MOVWF  01
2172:  BZ    217C
2174:  MOVFF  FE6,FEE
2178:  DECFSZ 01,F
217A:  BRA    2174
....................        lcd_gotoxy(0,2); 
217C:  CLRF   xEA
217E:  MOVLW  02
2180:  MOVWF  xEB
2182:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
2186:  CLRF   xE3
2188:  MOVLW  2C
218A:  MOVWF  xE2
218C:  CALL   1682
2190:  MOVFF  01,E0
2194:  CLRF   xE2
2196:  MOVLW  2C
2198:  MOVWF  xE1
219A:  MOVFF  01,E3
219E:  CALL   16B4
....................  
....................  
.................... } 
21A2:  RETLW  00
....................  
.................... void download_sun_table(int16 nPage) { 
....................     int16 i,j; 
....................    disable_interrupts(GLOBAL); 
*
264C:  BCF    FF2.6
264E:  BCF    FF2.7
2650:  BTFSC  FF2.7
2652:  BRA    264E
....................    restart_wdt(); 
2654:  CLRWDT
....................    setup_wdt(WDT_OFF); 
2656:  BCF    FD1.0
....................     output_high(FLASH_SELECT); 
2658:  BCF    F94.2
265A:  BSF    F8B.2
....................     while(kbhit()) getc(); 
265C:  BTFSS  F9E.5
265E:  BRA    2668
2660:  BTFSS  F9E.5
2662:  BRA    2660
2664:  MOVF   FAE,W
2666:  BRA    265C
....................     for (j=0;j<nPage+1;j++) { 
2668:  CLRF   xD8
266A:  CLRF   xD7
266C:  MOVLW  01
266E:  ADDWF  xD3,W
2670:  MOVWF  01
2672:  MOVLW  00
2674:  ADDWFC xD4,W
2676:  MOVWF  03
2678:  MOVF   xD8,W
267A:  SUBWF  03,W
267C:  BNC   2722
267E:  BNZ   2686
2680:  MOVF   01,W
2682:  SUBWF  xD7,W
2684:  BC    2722
....................         ext_flash_waitUntilReady(); 
2686:  RCALL  24A8
....................       PORTE.tx_en=1; 
2688:  BSF    F84.2
....................         printf("OK\r\n"); 
268A:  CLRF   xD9
268C:  MOVF   xD9,W
268E:  CALL   012E
2692:  INCF   xD9,F
2694:  MOVWF  00
2696:  MOVF   00,W
2698:  BTFSS  F9E.4
269A:  BRA    2698
269C:  MOVWF  FAD
269E:  MOVLW  04
26A0:  SUBWF  xD9,W
26A2:  BNZ   268C
....................       tx_delay=TX_DLY_TIME; 
26A4:  MOVLW  01
26A6:  MOVWF  xC2
....................       //PORTE.tx_en=0; 
....................          output_low(FLASH_SELECT); 
26A8:  BCF    F94.2
26AA:  BCF    F8B.2
....................         if (j%2) ext_flash_sendData(0x82, 8); else ext_flash_sendData(0x85, 8); 
26AC:  MOVF   xD7,W
26AE:  ANDLW  01
26B0:  MOVWF  00
26B2:  CLRF   03
26B4:  MOVF   00,W
26B6:  IORWF  03,W
26B8:  BZ    26C6
26BA:  MOVLW  82
26BC:  MOVWF  xFA
26BE:  MOVLW  08
26C0:  MOVWF  xFB
26C2:  RCALL  25DE
26C4:  BRA    26D0
26C6:  MOVLW  85
26C8:  MOVWF  xFA
26CA:  MOVLW  08
26CC:  MOVWF  xFB
26CE:  RCALL  25DE
....................          ext_flash_send16Data(j+10, 15); // page address 
26D0:  MOVLW  0A
26D2:  ADDWF  xD7,W
26D4:  MOVWF  xD9
26D6:  MOVLW  00
26D8:  ADDWFC xD8,W
26DA:  MOVWF  xDA
26DC:  MOVWF  xFB
26DE:  MOVFF  D9,FA
26E2:  MOVLW  0F
26E4:  MOVWF  xFC
26E6:  RCALL  260E
....................       ext_flash_send16Data(0, 9); 
26E8:  CLRF   xFB
26EA:  CLRF   xFA
26EC:  MOVLW  09
26EE:  MOVWF  xFC
26F0:  RCALL  260E
....................       for (i=0;i<256;i++) { 
26F2:  CLRF   xD6
26F4:  CLRF   xD5
26F6:  MOVF   xD6,W
26F8:  SUBLW  00
26FA:  BNC   2716
....................             ext_flash_sendData(getc(), 8); 
26FC:  BTFSS  F9E.5
26FE:  BRA    26FC
2700:  MOVFF  FAE,D9
2704:  MOVFF  D9,FA
2708:  MOVLW  08
270A:  MOVWF  xFB
270C:  RCALL  25DE
....................       } 
270E:  INCF   xD5,F
2710:  BTFSC  FD8.2
2712:  INCF   xD6,F
2714:  BRA    26F6
....................        output_high(FLASH_SELECT); 
2716:  BCF    F94.2
2718:  BSF    F8B.2
....................    } 
271A:  INCF   xD7,F
271C:  BTFSC  FD8.2
271E:  INCF   xD8,F
2720:  BRA    266C
....................    enable_interrupts(GLOBAL); 
2722:  MOVLW  C0
2724:  IORWF  FF2,F
....................    restart_wdt(); 
2726:  CLRWDT
....................    setup_wdt(WDT_ON); 
2728:  BSF    FD1.0
....................  
.................... } 
272A:  GOTO   357E (RETURN)
....................  
.................... /* 
.................... void print_page_data(int16 nPage) { 
....................     char temp[256]; 
....................     int16 i; 
....................     int32 time_index; 
....................  
....................    ext_flash_readPage(nPage,0,temp,264); 
....................     for(i=0;i<264;i++) { 
....................       PORTE.tx_en=1; 
....................       if((i%16) ==0) printf("\r\n%02X : ",i); 
....................       printf("%02X ",temp[i]); 
....................    } 
....................    memcpy(&time_index,temp,4); 
....................     printf("\r\n Timer Index: %Lu",time_index);    
....................     
....................  
....................  
.................... } 
.................... */ 
.................... void print_page_data(int16 nPage) { 
....................     char temp[17]; 
....................     int8 i; 
....................    int8 j; 
....................     PORTE.tx_en=1; 
*
2830:  BSF    F84.2
....................     for(i=0;i<16;i++) { 
2832:  CLRF   xE6
2834:  MOVF   xE6,W
2836:  SUBLW  0F
2838:  BNC   28C2
....................       printf("\r\n%02X : ",i); 
283A:  MOVLW  0D
283C:  BTFSS  F9E.4
283E:  BRA    283C
2840:  MOVWF  FAD
2842:  MOVLW  0A
2844:  BTFSS  F9E.4
2846:  BRA    2844
2848:  MOVWF  FAD
284A:  MOVFF  E6,E9
284E:  MOVLW  37
2850:  MOVWF  xEA
2852:  RCALL  272E
2854:  MOVLW  20
2856:  BTFSS  F9E.4
2858:  BRA    2856
285A:  MOVWF  FAD
285C:  MOVLW  3A
285E:  BTFSS  F9E.4
2860:  BRA    285E
2862:  MOVWF  FAD
2864:  MOVLW  20
2866:  BTFSS  F9E.4
2868:  BRA    2866
286A:  MOVWF  FAD
....................       ext_flash_readPage(nPage,i*16,temp,16); 
286C:  MOVF   xE6,W
286E:  MULLW  10
2870:  MOVFF  FF3,E8
2874:  MOVFF  D4,F4
2878:  MOVFF  D3,F3
287C:  MOVFF  E8,F5
2880:  CLRF   xF7
2882:  MOVLW  D5
2884:  MOVWF  xF6
2886:  CLRF   xF9
2888:  MOVLW  10
288A:  MOVWF  xF8
288C:  RCALL  27D8
....................       for (j=0;j<16;j++) printf("%02X ",temp[j]); 
288E:  CLRF   xE7
2890:  MOVF   xE7,W
2892:  SUBLW  0F
2894:  BNC   28BE
2896:  CLRF   03
2898:  MOVF   xE7,W
289A:  ADDLW  D5
289C:  MOVWF  FE9
289E:  MOVLW  00
28A0:  ADDWFC 03,W
28A2:  MOVWF  FEA
28A4:  MOVFF  FEF,E8
28A8:  MOVFF  E8,E9
28AC:  MOVLW  37
28AE:  MOVWF  xEA
28B0:  RCALL  272E
28B2:  MOVLW  20
28B4:  BTFSS  F9E.4
28B6:  BRA    28B4
28B8:  MOVWF  FAD
28BA:  INCF   xE7,F
28BC:  BRA    2890
....................    } 
28BE:  INCF   xE6,F
28C0:  BRA    2834
....................    tx_delay=TX_DLY_TIME; 
28C2:  MOVLW  01
28C4:  MOVWF  xC2
.................... } 
28C6:  GOTO   317E (RETURN)
....................  
.................... int32 get_timer_index(int16 nDay) { // 1 page contain 2 subpage 
....................     char temp[6]; 
....................     int32 time_index; 
....................    ext_flash_readPage((nDay/2)+10,128*(nDay%2),temp,4); 
*
2C42:  BCF    FD8.0
2C44:  RRCF   xE2,W
2C46:  MOVWF  xEE
2C48:  RRCF   xE1,W
2C4A:  MOVWF  xED
2C4C:  MOVLW  0A
2C4E:  ADDWF  xED,W
2C50:  MOVWF  xEF
2C52:  MOVLW  00
2C54:  ADDWFC xEE,W
2C56:  MOVWF  xF0
2C58:  MOVF   xE1,W
2C5A:  ANDLW  01
2C5C:  MOVWF  00
2C5E:  CLRF   03
2C60:  MOVWF  02
2C62:  RLCF   00,W
2C64:  MOVWF  xF1
2C66:  RLCF   03,W
2C68:  MOVWF  xF2
2C6A:  RLCF   xF1,F
2C6C:  RLCF   xF2,F
2C6E:  RLCF   xF1,F
2C70:  RLCF   xF2,F
2C72:  RLCF   xF1,F
2C74:  RLCF   xF2,F
2C76:  RLCF   xF1,F
2C78:  RLCF   xF2,F
2C7A:  RLCF   xF1,F
2C7C:  RLCF   xF2,F
2C7E:  RLCF   xF1,F
2C80:  RLCF   xF2,F
2C82:  MOVLW  80
2C84:  ANDWF  xF1,F
2C86:  MOVFF  F0,F4
2C8A:  MOVFF  EF,F3
2C8E:  MOVFF  F1,F5
2C92:  CLRF   xF7
2C94:  MOVLW  E3
2C96:  MOVWF  xF6
2C98:  CLRF   xF9
2C9A:  MOVLW  04
2C9C:  MOVWF  xF8
2C9E:  RCALL  27D8
....................    memcpy(&time_index,temp,4); 
2CA0:  CLRF   FEA
2CA2:  MOVLW  E9
2CA4:  MOVWF  FE9
2CA6:  CLRF   FE2
2CA8:  MOVLW  E3
2CAA:  MOVWF  FE1
2CAC:  MOVLW  04
2CAE:  MOVWF  01
2CB0:  MOVFF  FE6,FEE
2CB4:  DECFSZ 01,F
2CB6:  BRA    2CB0
....................    return time_index; 
2CB8:  MOVFF  E9,00
2CBC:  MOVFF  EA,01
2CC0:  MOVFF  EB,02
2CC4:  MOVFF  EC,03
.................... } 
2CC8:  RETLW  00
....................  
.................... int16 find_day_number(int32 tsec) // return day number after 1-jan-2010, we use this to search for sun angle in flash memory page 
.................... { 
....................    return (((tsec+((int8)UTC)*3600)/86400)%1461); 
*
2BA8:  MOVLW  70
2BAA:  ADDWF  xE1,W
2BAC:  MOVWF  xE5
2BAE:  MOVLW  62
2BB0:  ADDWFC xE2,W
2BB2:  MOVWF  xE6
2BB4:  MOVLW  00
2BB6:  ADDWFC xE3,W
2BB8:  MOVWF  xE7
2BBA:  MOVLW  00
2BBC:  ADDWFC xE4,W
2BBE:  MOVWF  xE8
2BC0:  CLRF   18
2BC2:  BTFSC  FF2.7
2BC4:  BSF    18.7
2BC6:  BCF    FF2.7
2BC8:  MOVWF  xEE
2BCA:  MOVFF  E7,ED
2BCE:  MOVFF  E6,EC
2BD2:  MOVFF  E5,EB
2BD6:  CLRF   xF2
2BD8:  MOVLW  01
2BDA:  MOVWF  xF1
2BDC:  MOVLW  51
2BDE:  MOVWF  xF0
2BE0:  MOVLW  80
2BE2:  MOVWF  xEF
2BE4:  CALL   0340
2BE8:  BTFSC  18.7
2BEA:  BSF    FF2.7
2BEC:  MOVFF  03,E9
2BF0:  MOVFF  02,E8
2BF4:  MOVFF  01,E7
2BF8:  MOVFF  00,E6
2BFC:  CLRF   18
2BFE:  BTFSC  FF2.7
2C00:  BSF    18.7
2C02:  BCF    FF2.7
2C04:  MOVFF  03,EE
2C08:  MOVFF  02,ED
2C0C:  MOVFF  01,EC
2C10:  MOVFF  00,EB
2C14:  CLRF   xF2
2C16:  CLRF   xF1
2C18:  MOVLW  05
2C1A:  MOVWF  xF0
2C1C:  MOVLW  B5
2C1E:  MOVWF  xEF
2C20:  CALL   0340
2C24:  BTFSC  18.7
2C26:  BSF    FF2.7
2C28:  MOVFF  FEF,00
2C2C:  MOVFF  FEC,01
2C30:  MOVFF  FEC,02
2C34:  MOVFF  FEC,03
2C38:  MOVFF  01,02
2C3C:  MOVFF  00,01
.................... } 
2C40:  RETLW  00
....................  
.................... unsigned int8 current_sun_angle(unsigned int32 t_sec) { 
....................    unsigned int16 today;  // current day (count after epoch) 
....................    unsigned int32 sun_rise_t_sec; // time of day . compensated for time zone 
....................    unsigned int8 sun_data; 
....................    today = find_day_number(t_sec); // day after epoch 
*
362C:  MOVFF  D9,E4
3630:  MOVFF  D8,E3
3634:  MOVFF  D7,E2
3638:  MOVFF  D6,E1
363C:  CALL   2BA8
3640:  MOVFF  02,DB
3644:  MOVFF  01,DA
....................     sun_rise_t_sec = get_timer_index(today)*450; 
3648:  MOVFF  DB,E2
364C:  MOVFF  DA,E1
3650:  CALL   2C42
3654:  MOVFF  03,E4
3658:  MOVFF  02,E3
365C:  MOVFF  01,E2
3660:  MOVFF  00,E1
3664:  MOVFF  FEA,E6
3668:  MOVFF  FE9,E5
366C:  MOVFF  03,F8
3670:  MOVFF  02,F7
3674:  MOVFF  01,F6
3678:  MOVFF  00,F5
367C:  CLRF   xFC
367E:  CLRF   xFB
3680:  MOVLW  01
3682:  MOVWF  xFA
3684:  MOVLW  C2
3686:  MOVWF  xF9
3688:  CALL   1330
368C:  MOVFF  E6,FEA
3690:  MOVFF  E5,FE9
3694:  MOVFF  03,DF
3698:  MOVFF  02,DE
369C:  MOVFF  01,DD
36A0:  MOVFF  00,DC
36A4:  CLRF   18
36A6:  BTFSC  FF2.7
36A8:  BSF    18.7
36AA:  BCF    FF2.7
....................     if (sun_rise_t_sec > t_sec%SEC_IN_4_YEARS) return 0x0; // sun havent up yet, angle is 0 
36AC:  MOVFF  D9,EE
36B0:  MOVFF  D8,ED
36B4:  MOVFF  D7,EC
36B8:  MOVFF  D6,EB
36BC:  MOVLW  07
36BE:  MOVWF  xF2
36C0:  MOVLW  86
36C2:  MOVWF  xF1
36C4:  MOVLW  1F
36C6:  MOVWF  xF0
36C8:  MOVLW  80
36CA:  MOVWF  xEF
36CC:  CALL   0340
36D0:  BTFSC  18.7
36D2:  BSF    FF2.7
36D4:  MOVFF  FEF,00
36D8:  MOVFF  FEC,01
36DC:  MOVFF  FEC,02
36E0:  MOVFF  FEC,03
36E4:  MOVF   03,W
36E6:  SUBWF  xDF,W
36E8:  BNC   3708
36EA:  BNZ   3702
36EC:  MOVF   02,W
36EE:  SUBWF  xDE,W
36F0:  BNC   3708
36F2:  BNZ   3702
36F4:  MOVF   01,W
36F6:  SUBWF  xDD,W
36F8:  BNC   3708
36FA:  BNZ   3702
36FC:  MOVF   xDC,W
36FE:  SUBWF  00,W
3700:  BC    3708
3702:  MOVLW  00
3704:  MOVWF  01
3706:  BRA    3836
3708:  CLRF   18
370A:  BTFSC  FF2.7
370C:  BSF    18.7
370E:  BCF    FF2.7
....................    index_in_page = (t_sec%SEC_IN_4_YEARS-sun_rise_t_sec)/450; 
3710:  MOVFF  D9,EE
3714:  MOVFF  D8,ED
3718:  MOVFF  D7,EC
371C:  MOVFF  D6,EB
3720:  MOVLW  07
3722:  MOVWF  xF2
3724:  MOVLW  86
3726:  MOVWF  xF1
3728:  MOVLW  1F
372A:  MOVWF  xF0
372C:  MOVLW  80
372E:  MOVWF  xEF
3730:  CALL   0340
3734:  BTFSC  18.7
3736:  BSF    FF2.7
3738:  MOVFF  FEF,E1
373C:  MOVFF  FEC,E2
3740:  MOVFF  FEC,E3
3744:  MOVFF  FEC,E4
3748:  MOVF   xDC,W
374A:  SUBWF  xE1,W
374C:  MOVWF  xE5
374E:  MOVF   xDD,W
3750:  SUBWFB xE2,W
3752:  MOVWF  xE6
3754:  MOVF   xDE,W
3756:  SUBWFB xE3,W
3758:  MOVWF  xE7
375A:  MOVF   xDF,W
375C:  SUBWFB xE4,W
375E:  MOVWF  xE8
3760:  MOVFF  FEA,EA
3764:  MOVFF  FE9,E9
3768:  CLRF   18
376A:  BTFSC  FF2.7
376C:  BSF    18.7
376E:  BCF    FF2.7
3770:  MOVWF  xEE
3772:  MOVFF  E7,ED
3776:  MOVFF  E6,EC
377A:  MOVFF  E5,EB
377E:  CLRF   xF2
3780:  CLRF   xF1
3782:  MOVLW  01
3784:  MOVWF  xF0
3786:  MOVLW  C2
3788:  MOVWF  xEF
378A:  CALL   0340
378E:  BTFSC  18.7
3790:  BSF    FF2.7
3792:  MOVFF  EA,FEA
3796:  MOVFF  E9,FE9
379A:  MOVFF  00,CA
....................     if (index_in_page>=124) return 0xFF; // exceed page size , sun went down 
379E:  MOVF   xCA,W
37A0:  SUBLW  7B
37A2:  BC    37AA
37A4:  MOVLW  FF
37A6:  MOVWF  01
37A8:  BRA    3836
....................     ext_flash_readPage((today/2)+10,128*(today%2)+4+index_in_page,&sun_data,1); 
37AA:  BCF    FD8.0
37AC:  RRCF   xDB,W
37AE:  MOVWF  xE2
37B0:  RRCF   xDA,W
37B2:  MOVWF  xE1
37B4:  MOVLW  0A
37B6:  ADDWF  xE1,W
37B8:  MOVWF  xE3
37BA:  MOVLW  00
37BC:  ADDWFC xE2,W
37BE:  MOVWF  xE4
37C0:  MOVF   xDA,W
37C2:  ANDLW  01
37C4:  MOVWF  00
37C6:  CLRF   03
37C8:  MOVWF  02
37CA:  RLCF   00,W
37CC:  MOVWF  xE5
37CE:  RLCF   03,W
37D0:  MOVWF  xE6
37D2:  RLCF   xE5,F
37D4:  RLCF   xE6,F
37D6:  RLCF   xE5,F
37D8:  RLCF   xE6,F
37DA:  RLCF   xE5,F
37DC:  RLCF   xE6,F
37DE:  RLCF   xE5,F
37E0:  RLCF   xE6,F
37E2:  RLCF   xE5,F
37E4:  RLCF   xE6,F
37E6:  RLCF   xE5,F
37E8:  RLCF   xE6,F
37EA:  MOVLW  80
37EC:  ANDWF  xE5,F
37EE:  MOVLW  04
37F0:  ADDWF  xE5,W
37F2:  MOVWF  xE7
37F4:  MOVLW  00
37F6:  ADDWFC xE6,W
37F8:  MOVWF  xE8
37FA:  MOVF   xCA,W
37FC:  ADDWF  xE7,W
37FE:  MOVWF  xE9
3800:  MOVLW  00
3802:  ADDWFC xE8,W
3804:  MOVWF  xEA
3806:  MOVFF  E4,F4
380A:  MOVFF  E3,F3
380E:  MOVFF  E9,F5
3812:  CLRF   xF7
3814:  MOVLW  E0
3816:  MOVWF  xF6
3818:  CLRF   xF9
381A:  MOVLW  01
381C:  MOVWF  xF8
381E:  CALL   27D8
....................    if ((index_in_page>5) && (sun_data==0)) return 0xFF; // sun went down 
3822:  MOVF   xCA,W
3824:  SUBLW  05
3826:  BC    3832
3828:  MOVF   xE0,F
382A:  BNZ   3832
382C:  MOVLW  FF
382E:  MOVWF  01
3830:  BRA    3836
....................    return sun_data; 
3832:  MOVFF  E0,01
....................     
.................... } 
3836:  GOTO   3A1A (RETURN)
....................  
....................  
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,boolean direction,boolean abort_when_task_armed) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
21A4:  CLRF   xDB
21A6:  CLRF   xDC
....................    unsigned int16 yyy=0;    
21A8:  CLRF   xDD
21AA:  CLRF   xDE
....................    int8 rt=5; 
21AC:  MOVLW  05
21AE:  MOVWF  xDF
....................    output_low(CCW); 
21B0:  BCF    F93.4
21B2:  BCF    F8A.4
....................    output_low(EN0); 
21B4:  BCF    F93.0
21B6:  BCF    F8A.0
....................    output_low(EN1); 
21B8:  BCF    F93.1
21BA:  BCF    F8A.1
....................    output_low(EN2); 
21BC:  BCF    F93.2
21BE:  BCF    F8A.2
....................    output_low(EN3); 
21C0:  BCF    F93.3
21C2:  BCF    F8A.3
....................    PORTD.ps_en=0; 
21C4:  BCF    F83.4
21C6:  CLRF   18
21C8:  BTFSC  FF2.7
21CA:  BSF    18.7
21CC:  BCF    FF2.7
....................     delay_ms(20); 
21CE:  MOVLW  14
21D0:  MOVWF  xEA
21D2:  CALL   04BC
21D6:  BTFSC  18.7
21D8:  BSF    FF2.7
....................  
....................    if (!direction)   { 
21DA:  MOVF   xD9,F
21DC:  BNZ   21E2
....................       output_high(CCW); 
21DE:  BCF    F93.4
21E0:  BSF    F8A.4
....................    } 
....................  
....................    PORTD.ps_en=1; 
21E2:  BSF    F83.4
21E4:  CLRF   18
21E6:  BTFSC  FF2.7
21E8:  BSF    18.7
21EA:  BCF    FF2.7
....................     delay_ms(20); 
21EC:  MOVLW  14
21EE:  MOVWF  xEA
21F0:  CALL   04BC
21F4:  BTFSC  18.7
21F6:  BSF    FF2.7
....................    output_high(EN0); 
21F8:  BCF    F93.0
21FA:  BSF    F8A.0
21FC:  CLRF   18
21FE:  BTFSC  FF2.7
2200:  BSF    18.7
2202:  BCF    FF2.7
....................     delay_ms(10); 
2204:  MOVLW  0A
2206:  MOVWF  xEA
2208:  CALL   04BC
220C:  BTFSC  18.7
220E:  BSF    FF2.7
....................  
....................    flag.prev_pulse_state = input(PIN_A2); //A2 = sensor wire for actuator 1 
2210:  BSF    F92.2
2212:  BCF    1F.2
2214:  BTFSC  F80.2
2216:  BSF    1F.2
....................    tick = timer_sec; 
2218:  MOVFF  23,27
221C:  MOVFF  22,26
2220:  MOVFF  21,25
2224:  MOVFF  20,24
....................    tick2 = timer_sec; 
2228:  MOVFF  23,2B
222C:  MOVFF  22,2A
2230:  MOVFF  21,29
2234:  MOVFF  20,28
....................    actuator_pulse =0; 
2238:  CLRF   xC9
223A:  CLRF   xC8
....................    while(1) { 
....................       xxx = (int16) (timer_sec-tick); 
223C:  MOVF   24,W
223E:  SUBWF  20,W
2240:  MOVWF  00
2242:  MOVF   25,W
2244:  SUBWFB 21,W
2246:  MOVWF  01
2248:  MOVF   26,W
224A:  SUBWFB 22,W
224C:  MOVF   27,W
224E:  SUBWFB 23,W
2250:  MOVFF  01,DC
2254:  MOVFF  00,DB
....................       yyy = (int16) (timer_sec-tick2); 
2258:  MOVF   28,W
225A:  SUBWF  20,W
225C:  MOVWF  00
225E:  MOVF   29,W
2260:  SUBWFB 21,W
2262:  MOVWF  01
2264:  MOVF   2A,W
2266:  SUBWFB 22,W
2268:  MOVF   2B,W
226A:  SUBWFB 23,W
226C:  MOVFF  01,DE
2270:  MOVFF  00,DD
....................       if ( xxx>= time_out_sec)  
2274:  MOVF   xD6,W
2276:  SUBWF  xDC,W
2278:  BNC   2284
227A:  BNZ   2282
227C:  MOVF   xD5,W
227E:  SUBWF  xDB,W
2280:  BNC   2284
....................          break; 
2282:  BRA    2370
....................        if (actuator_pulse >= nPulse) 
2284:  MOVF   xD4,W
2286:  SUBWF  xC9,W
2288:  BNC   2296
228A:  BNZ   2292
228C:  MOVF   xD3,W
228E:  SUBWF  xC8,W
2290:  BNC   2296
....................          output_low(EN0); 
2292:  BCF    F93.0
2294:  BCF    F8A.0
....................       if ( yyy >=stuck_sec) 
2296:  MOVF   xD8,W
2298:  SUBWF  xDE,W
229A:  BNC   22A6
229C:  BNZ   22A4
229E:  MOVF   xD7,W
22A0:  SUBWF  xDD,W
22A2:  BNC   22A6
....................          break; 
22A4:  BRA    2370
....................       if (abort_when_task_armed && (flag.task1_armed||flag.cmd_posted)) 
22A6:  MOVF   xDA,F
22A8:  BZ    22B4
22AA:  BTFSC  1F.0
22AC:  BRA    22B2
22AE:  BTFSS  1F.3
22B0:  BRA    22B4
....................          break; 
22B2:  BRA    2370
....................       if (flag.prev_pulse_state != input(SENSE_0)) { 
22B4:  MOVLW  00
22B6:  BTFSC  1F.2
22B8:  MOVLW  01
22BA:  MOVWF  xE0
22BC:  BSF    F92.1
22BE:  MOVLW  00
22C0:  BTFSC  F80.1
22C2:  MOVLW  01
22C4:  SUBWF  xE0,W
22C6:  BZ    2364
....................          tick2 = timer_sec; 
22C8:  MOVFF  23,2B
22CC:  MOVFF  22,2A
22D0:  MOVFF  21,29
22D4:  MOVFF  20,28
....................          flag.prev_pulse_state = input(SENSE_0); 
22D8:  BSF    F92.1
22DA:  BCF    1F.2
22DC:  BTFSC  F80.1
22DE:  BSF    1F.2
....................          if (!direction && (current_act_position >0)) current_act_position--; 
22E0:  MOVF   xD9,F
22E2:  BNZ   22F4
22E4:  MOVF   x6E,F
22E6:  BNZ   22EC
22E8:  MOVF   x6F,F
22EA:  BZ    22F4
22EC:  MOVF   x6E,W
22EE:  BTFSC  FD8.2
22F0:  DECF   x6F,F
22F2:  DECF   x6E,F
....................          if (direction && (current_act_position < FULL_STROKE_TICK)) current_act_position++; 
22F4:  MOVF   xD9,F
22F6:  BZ    230C
22F8:  MOVF   x6F,W
22FA:  SUBWF  xBB,W
22FC:  BNC   230C
22FE:  BNZ   2306
2300:  MOVF   xBA,W
2302:  SUBWF  x6E,W
2304:  BC    230C
2306:  INCF   x6E,F
2308:  BTFSC  FD8.2
230A:  INCF   x6F,F
....................          actuator_pulse=actuator_pulse+1; 
230C:  MOVLW  01
230E:  ADDWF  xC8,F
2310:  MOVLW  00
2312:  ADDWFC xC9,F
....................          lcd_gotoxy(11,2); 
2314:  MOVLW  0B
2316:  MOVWF  xEA
2318:  MOVLW  02
231A:  MOVWF  xEB
231C:  CALL   0CC2
....................          if (actuator_pulse%2==0)   lcd_putc('*'); else  lcd_putc('.'); 
2320:  MOVF   xC8,W
2322:  ANDLW  01
2324:  MOVWF  xE0
2326:  CLRF   xE1
2328:  MOVF   xE0,F
232A:  BNZ   233A
232C:  MOVF   xE1,F
232E:  BNZ   233A
2330:  MOVLW  2A
2332:  MOVWF  xE9
2334:  CALL   0CEA
2338:  BRA    2342
233A:  MOVLW  2E
233C:  MOVWF  xE9
233E:  CALL   0CEA
....................          lcd_gotoxy(12,2); 
2342:  MOVLW  0C
2344:  MOVWF  xEA
2346:  MOVLW  02
2348:  MOVWF  xEB
234A:  CALL   0CC2
....................          printf(lcd_putc,"%4lu",current_act_position); 
234E:  MOVLW  01
2350:  MOVWF  FE9
2352:  MOVFF  6F,E1
2356:  MOVFF  6E,E0
235A:  CALL   0D3C
....................          PORTE.tx_en=1; 
235E:  BSF    F84.2
....................          //printf("\r%4lu",actuator_pulse); 
....................          tx_delay=TX_DLY_TIME; 
2360:  MOVLW  01
2362:  MOVWF  xC2
....................  
....................       } 
....................       if (flag.update_time) { 
2364:  BTFSS  1F.1
2366:  BRA    236E
....................          flag.update_time = false; 
2368:  BCF    1F.1
....................          print_date_time(); 
236A:  CALL   16DC
....................       } 
....................    } 
236E:  BRA    223C
....................    lcd_gotoxy(12,2); 
2370:  MOVLW  0C
2372:  MOVWF  xEA
2374:  MOVLW  02
2376:  MOVWF  xEB
2378:  CALL   0CC2
....................     printf(lcd_putc,"%4lu",current_act_position); 
237C:  MOVLW  01
237E:  MOVWF  FE9
2380:  MOVFF  6F,E1
2384:  MOVFF  6E,E0
2388:  CALL   0D3C
....................    output_low(EN0); 
238C:  BCF    F93.0
238E:  BCF    F8A.0
....................    output_low(EN1); 
2390:  BCF    F93.1
2392:  BCF    F8A.1
....................    output_low(EN2); 
2394:  BCF    F93.2
2396:  BCF    F8A.2
....................    output_low(EN3); 
2398:  BCF    F93.3
239A:  BCF    F8A.3
....................    PORTD.ps_en=0; 
239C:  BCF    F83.4
239E:  CLRF   18
23A0:  BTFSC  FF2.7
23A2:  BSF    18.7
23A4:  BCF    FF2.7
....................     delay_ms(50); 
23A6:  MOVLW  32
23A8:  MOVWF  xEA
23AA:  CALL   04BC
23AE:  BTFSC  18.7
23B0:  BSF    FF2.7
....................    output_low(CCW); 
23B2:  BCF    F93.4
23B4:  BCF    F8A.4
23B6:  CLRF   18
23B8:  BTFSC  FF2.7
23BA:  BSF    18.7
23BC:  BCF    FF2.7
....................     delay_ms(50); 
23BE:  MOVLW  32
23C0:  MOVWF  xEA
23C2:  CALL   04BC
23C6:  BTFSC  18.7
23C8:  BSF    FF2.7
.................... } 
23CA:  RETLW  00
....................  
.................... int8 task1() { 
....................       int8 sun_angle; 
....................       lcd_init(); 
*
3872:  CALL   09FE
3876:  CLRF   18
3878:  BTFSC  FF2.7
387A:  BSF    18.7
387C:  BCF    FF2.7
....................       if (timer_sec%SEC_IN_4_YEARS >= next_sun_rise) { 
387E:  MOVFF  23,EE
3882:  MOVFF  22,ED
3886:  MOVFF  21,EC
388A:  MOVFF  20,EB
388E:  MOVLW  07
3890:  MOVWF  xF2
3892:  MOVLW  86
3894:  MOVWF  xF1
3896:  MOVLW  1F
3898:  MOVWF  xF0
389A:  MOVLW  80
389C:  MOVWF  xEF
389E:  CALL   0340
38A2:  BTFSC  18.7
38A4:  BSF    FF2.7
38A6:  MOVFF  FEF,D2
38AA:  MOVFF  FEC,D3
38AE:  MOVFF  FEC,D4
38B2:  MOVFF  FEC,D5
38B6:  MOVF   x6D,W
38B8:  SUBWF  xD5,W
38BA:  BTFSS  FD8.0
38BC:  BRA    39A4
38BE:  BNZ   38D6
38C0:  MOVF   x6C,W
38C2:  SUBWF  xD4,W
38C4:  BNC   39A4
38C6:  BNZ   38D6
38C8:  MOVF   x6B,W
38CA:  SUBWF  xD3,W
38CC:  BNC   39A4
38CE:  BNZ   38D6
38D0:  MOVF   x6A,W
38D2:  SUBWF  xD2,W
38D4:  BNC   39A4
....................           next_sun_rise=get_timer_index(find_day_number((next_sun_rise+86400)%SEC_IN_4_YEARS))*450; 
38D6:  MOVLW  80
38D8:  ADDWF  x6A,W
38DA:  MOVWF  xD2
38DC:  MOVLW  51
38DE:  ADDWFC x6B,W
38E0:  MOVWF  xD3
38E2:  MOVLW  01
38E4:  ADDWFC x6C,W
38E6:  MOVWF  xD4
38E8:  MOVLW  00
38EA:  ADDWFC x6D,W
38EC:  MOVWF  xD5
38EE:  CLRF   18
38F0:  BTFSC  FF2.7
38F2:  BSF    18.7
38F4:  BCF    FF2.7
38F6:  MOVWF  xEE
38F8:  MOVFF  D4,ED
38FC:  MOVFF  D3,EC
3900:  MOVFF  D2,EB
3904:  MOVLW  07
3906:  MOVWF  xF2
3908:  MOVLW  86
390A:  MOVWF  xF1
390C:  MOVLW  1F
390E:  MOVWF  xF0
3910:  MOVLW  80
3912:  MOVWF  xEF
3914:  CALL   0340
3918:  BTFSC  18.7
391A:  BSF    FF2.7
391C:  MOVFF  FEF,D3
3920:  MOVFF  FEC,D4
3924:  MOVFF  FEC,D5
3928:  MOVFF  FEC,D6
392C:  MOVFF  D6,E4
3930:  MOVFF  D5,E3
3934:  MOVFF  D4,E2
3938:  MOVFF  D3,E1
393C:  CALL   2BA8
3940:  MOVFF  02,D5
3944:  MOVFF  01,D4
3948:  MOVFF  02,E2
394C:  MOVFF  01,E1
3950:  CALL   2C42
3954:  MOVFF  03,D8
3958:  MOVFF  02,D7
395C:  MOVFF  01,D6
3960:  MOVFF  00,D5
3964:  MOVFF  FEA,DA
3968:  MOVFF  FE9,D9
396C:  MOVFF  03,F8
3970:  MOVFF  02,F7
3974:  MOVFF  01,F6
3978:  MOVFF  00,F5
397C:  CLRF   xFC
397E:  CLRF   xFB
3980:  MOVLW  01
3982:  MOVWF  xFA
3984:  MOVLW  C2
3986:  MOVWF  xF9
3988:  CALL   1330
398C:  MOVFF  DA,FEA
3990:  MOVFF  D9,FE9
3994:  MOVFF  03,6D
3998:  MOVFF  02,6C
399C:  MOVFF  01,6B
39A0:  MOVFF  00,6A
....................       } 
....................         sec_until_sun_rise = (int32) (next_sun_rise-timer_sec); 
39A4:  MOVF   20,W
39A6:  SUBWF  x6A,W
39A8:  MOVWF  00
39AA:  MOVF   21,W
39AC:  SUBWFB x6B,W
39AE:  MOVWF  01
39B0:  MOVF   22,W
39B2:  SUBWFB x6C,W
39B4:  MOVWF  02
39B6:  MOVF   23,W
39B8:  SUBWFB x6D,W
39BA:  MOVWF  xB9
39BC:  MOVFF  02,B8
39C0:  MOVFF  01,B7
39C4:  MOVFF  00,B6
39C8:  CLRF   18
39CA:  BTFSC  FF2.7
39CC:  BSF    18.7
39CE:  BCF    FF2.7
....................       sun_angle=current_sun_angle(timer_sec%SEC_IN_4_YEARS); 
39D0:  MOVFF  23,EE
39D4:  MOVFF  22,ED
39D8:  MOVFF  21,EC
39DC:  MOVFF  20,EB
39E0:  MOVLW  07
39E2:  MOVWF  xF2
39E4:  MOVLW  86
39E6:  MOVWF  xF1
39E8:  MOVLW  1F
39EA:  MOVWF  xF0
39EC:  MOVLW  80
39EE:  MOVWF  xEF
39F0:  CALL   0340
39F4:  BTFSC  18.7
39F6:  BSF    FF2.7
39F8:  MOVFF  FEF,D2
39FC:  MOVFF  FEC,D3
3A00:  MOVFF  FEC,D4
3A04:  MOVFF  FEC,D5
3A08:  MOVFF  D5,D9
3A0C:  MOVFF  D4,D8
3A10:  MOVFF  D3,D7
3A14:  MOVFF  D2,D6
3A18:  BRA    362C
3A1A:  MOVFF  01,D1
....................  
....................       // prepare buffer1 
....................       if (sun_angle==0x00) // sun havent' come up yet, clear buffer1 
3A1E:  MOVF   xD1,F
3A20:  BNZ   3AAC
3A22:  CLRF   18
3A24:  BTFSC  FF2.7
3A26:  BSF    18.7
3A28:  BCF    FF2.7
....................       { 
....................          if(find_day_number(timer_sec%SEC_IN_4_YEARS)%2==0)  
3A2A:  MOVFF  23,EE
3A2E:  MOVFF  22,ED
3A32:  MOVFF  21,EC
3A36:  MOVFF  20,EB
3A3A:  MOVLW  07
3A3C:  MOVWF  xF2
3A3E:  MOVLW  86
3A40:  MOVWF  xF1
3A42:  MOVLW  1F
3A44:  MOVWF  xF0
3A46:  MOVLW  80
3A48:  MOVWF  xEF
3A4A:  CALL   0340
3A4E:  BTFSC  18.7
3A50:  BSF    FF2.7
3A52:  MOVFF  FEF,D2
3A56:  MOVFF  FEC,D3
3A5A:  MOVFF  FEC,D4
3A5E:  MOVFF  FEC,D5
3A62:  MOVFF  D5,E4
3A66:  MOVFF  D4,E3
3A6A:  MOVFF  D3,E2
3A6E:  MOVFF  D2,E1
3A72:  CALL   2BA8
3A76:  MOVFF  02,D4
3A7A:  MOVF   01,W
3A7C:  MOVWF  xD3
3A7E:  ANDLW  01
3A80:  MOVWF  xD5
3A82:  CLRF   xD6
3A84:  MOVF   xD5,F
3A86:  BNZ   3A9C
3A88:  MOVF   xD6,F
3A8A:  BNZ   3A9C
....................             ext_flash_buffer1_write(0xAA,0,255); 
3A8C:  MOVLW  AA
3A8E:  MOVWF  xDC
3A90:  CLRF   xDD
3A92:  MOVLW  FF
3A94:  MOVWF  xDE
3A96:  CALL   2F00
....................          else 
3A9A:  BRA    3AAC
....................             ext_flash_buffer1_write(0xAA,128,127); 
3A9C:  MOVLW  AA
3A9E:  MOVWF  xDC
3AA0:  MOVLW  80
3AA2:  MOVWF  xDD
3AA4:  MOVLW  7F
3AA6:  MOVWF  xDE
3AA8:  CALL   2F00
....................       } 
....................  
....................       if ((sun_angle == 0xFF) || (sun_angle == 0x00)) // sundown 
3AAC:  INCFSZ xD1,W
3AAE:  BRA    3AB2
3AB0:  BRA    3AB6
3AB2:  MOVF   xD1,F
3AB4:  BNZ   3ABA
....................          sun_angle = 180; 
3AB6:  MOVLW  B4
3AB8:  MOVWF  xD1
....................  
....................       if (sun_angle != 180) { 
3ABA:  MOVF   xD1,W
3ABC:  SUBLW  B4
3ABE:  BTFSC  FD8.2
3AC0:  BRA    3C00
....................          ext_flash_buffer1_write((int8)(current_measured/n_avg_current_measured),128*(find_day_number(timer_sec%SEC_IN_4_YEARS)%2)+4+index_in_page,1); 
3AC2:  MOVFF  C4,D4
3AC6:  MOVFF  C3,D3
3ACA:  CLRF   xD6
3ACC:  MOVFF  C5,D5
3AD0:  CALL   2DF4
3AD4:  MOVFF  01,D2
3AD8:  CLRF   18
3ADA:  BTFSC  FF2.7
3ADC:  BSF    18.7
3ADE:  BCF    FF2.7
3AE0:  MOVFF  23,EE
3AE4:  MOVFF  22,ED
3AE8:  MOVFF  21,EC
3AEC:  MOVFF  20,EB
3AF0:  MOVLW  07
3AF2:  MOVWF  xF2
3AF4:  MOVLW  86
3AF6:  MOVWF  xF1
3AF8:  MOVLW  1F
3AFA:  MOVWF  xF0
3AFC:  MOVLW  80
3AFE:  MOVWF  xEF
3B00:  CALL   0340
3B04:  BTFSC  18.7
3B06:  BSF    FF2.7
3B08:  MOVFF  FEF,D3
3B0C:  MOVFF  FEC,D4
3B10:  MOVFF  FEC,D5
3B14:  MOVFF  FEC,D6
3B18:  MOVFF  D6,E4
3B1C:  MOVFF  D5,E3
3B20:  MOVFF  D4,E2
3B24:  MOVFF  D3,E1
3B28:  CALL   2BA8
3B2C:  MOVFF  02,D5
3B30:  MOVF   01,W
3B32:  MOVWF  xD4
3B34:  ANDLW  01
3B36:  MOVWF  00
3B38:  CLRF   03
3B3A:  MOVWF  02
3B3C:  RLCF   00,W
3B3E:  MOVWF  xD6
3B40:  RLCF   03,W
3B42:  MOVWF  xD7
3B44:  RLCF   xD6,F
3B46:  RLCF   xD7,F
3B48:  RLCF   xD6,F
3B4A:  RLCF   xD7,F
3B4C:  RLCF   xD6,F
3B4E:  RLCF   xD7,F
3B50:  RLCF   xD6,F
3B52:  RLCF   xD7,F
3B54:  RLCF   xD6,F
3B56:  RLCF   xD7,F
3B58:  RLCF   xD6,F
3B5A:  RLCF   xD7,F
3B5C:  MOVLW  80
3B5E:  ANDWF  xD6,F
3B60:  MOVLW  04
3B62:  ADDWF  xD6,W
3B64:  MOVWF  xD8
3B66:  MOVLW  00
3B68:  ADDWFC xD7,W
3B6A:  MOVWF  xD9
3B6C:  MOVF   xCA,W
3B6E:  ADDWF  xD8,W
3B70:  MOVWF  xDA
3B72:  MOVLW  00
3B74:  ADDWFC xD9,W
3B76:  MOVWF  xDB
3B78:  MOVFF  D2,DC
3B7C:  MOVFF  DA,DD
3B80:  MOVLW  01
3B82:  MOVWF  xDE
3B84:  CALL   2F00
3B88:  CLRF   18
3B8A:  BTFSC  FF2.7
3B8C:  BSF    18.7
3B8E:  BCF    FF2.7
....................          ext_flash_write_buffer1_to_main_memory(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
3B90:  MOVFF  23,EE
3B94:  MOVFF  22,ED
3B98:  MOVFF  21,EC
3B9C:  MOVFF  20,EB
3BA0:  MOVLW  07
3BA2:  MOVWF  xF2
3BA4:  MOVLW  86
3BA6:  MOVWF  xF1
3BA8:  MOVLW  1F
3BAA:  MOVWF  xF0
3BAC:  MOVLW  80
3BAE:  MOVWF  xEF
3BB0:  CALL   0340
3BB4:  BTFSC  18.7
3BB6:  BSF    FF2.7
3BB8:  MOVFF  FEF,D2
3BBC:  MOVFF  FEC,D3
3BC0:  MOVFF  FEC,D4
3BC4:  MOVFF  FEC,D5
3BC8:  MOVFF  D5,E4
3BCC:  MOVFF  D4,E3
3BD0:  MOVFF  D3,E2
3BD4:  MOVFF  D2,E1
3BD8:  CALL   2BA8
3BDC:  MOVFF  02,D4
3BE0:  MOVFF  01,D3
3BE4:  BCF    FD8.0
3BE6:  RRCF   02,W
3BE8:  MOVWF  03
3BEA:  RRCF   01,W
3BEC:  MOVWF  02
3BEE:  ADDLW  F2
3BF0:  MOVWF  xD5
3BF2:  MOVLW  03
3BF4:  ADDWFC 03,W
3BF6:  MOVWF  xD6
3BF8:  MOVWF  xD8
3BFA:  MOVFF  D5,D7
3BFE:  BRA    383A
....................       } 
....................       strcpy(tmp_str,"#     "); 
3C00:  CLRF   FEA
3C02:  MOVLW  2C
3C04:  MOVWF  FE9
3C06:  MOVFF  FF2,D2
3C0A:  BCF    FF2.7
3C0C:  MOVLW  00
3C0E:  CALL   014E
3C12:  TBLRD*-
3C14:  TBLRD*+
3C16:  MOVF   FF5,W
3C18:  MOVWF  FEE
3C1A:  IORLW  00
3C1C:  BNZ   3C14
3C1E:  BTFSC  xD2.7
3C20:  BSF    FF2.7
3C22:  CLRF   18
3C24:  BTFSC  FF2.7
3C26:  BSF    18.7
3C28:  BCF    FF2.7
....................       itoa((int16)find_day_number(timer_sec%SEC_IN_4_YEARS),10,tmp_str2); 
3C2A:  MOVFF  23,EE
3C2E:  MOVFF  22,ED
3C32:  MOVFF  21,EC
3C36:  MOVFF  20,EB
3C3A:  MOVLW  07
3C3C:  MOVWF  xF2
3C3E:  MOVLW  86
3C40:  MOVWF  xF1
3C42:  MOVLW  1F
3C44:  MOVWF  xF0
3C46:  MOVLW  80
3C48:  MOVWF  xEF
3C4A:  CALL   0340
3C4E:  BTFSC  18.7
3C50:  BSF    FF2.7
3C52:  MOVFF  FEF,D2
3C56:  MOVFF  FEC,D3
3C5A:  MOVFF  FEC,D4
3C5E:  MOVFF  FEC,D5
3C62:  MOVFF  D5,E4
3C66:  MOVFF  D4,E3
3C6A:  MOVFF  D3,E2
3C6E:  MOVFF  D2,E1
3C72:  CALL   2BA8
3C76:  MOVFF  02,D4
3C7A:  MOVFF  01,D3
3C7E:  CLRF   xE9
3C80:  CLRF   xE8
3C82:  MOVFF  02,E7
3C86:  MOVFF  01,E6
3C8A:  MOVLW  0A
3C8C:  MOVWF  xEA
3C8E:  CLRF   xEC
3C90:  MOVLW  40
3C92:  MOVWF  xEB
3C94:  CALL   14A6
....................       memcpy(tmp_str+4-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3C98:  CLRF   xE3
3C9A:  MOVLW  40
3C9C:  MOVWF  xE2
3C9E:  CALL   1682
3CA2:  MOVLW  30
3CA4:  BSF    FD8.0
3CA6:  SUBFWB 01,W
3CA8:  MOVWF  xD2
3CAA:  MOVLW  00
3CAC:  BTFSS  FD8.0
3CAE:  DECF   FE8,F
3CB0:  MOVWF  xD3
3CB2:  CLRF   xE3
3CB4:  MOVLW  40
3CB6:  MOVWF  xE2
3CB8:  CALL   1682
3CBC:  MOVFF  01,D4
3CC0:  MOVFF  D3,FEA
3CC4:  MOVFF  D2,FE9
3CC8:  CLRF   FE2
3CCA:  MOVLW  40
3CCC:  MOVWF  FE1
3CCE:  MOVF   01,W
3CD0:  MOVWF  01
3CD2:  BZ    3CDC
3CD4:  MOVFF  FE6,FEE
3CD8:  DECFSZ 01,F
3CDA:  BRA    3CD4
....................       lcd_gotoxy(10,0); 
3CDC:  MOVLW  0A
3CDE:  MOVWF  xEA
3CE0:  CLRF   xEB
3CE2:  CALL   0CC2
....................       lcd_gotoxy(10,0);       
3CE6:  MOVLW  0A
3CE8:  MOVWF  xEA
3CEA:  CLRF   xEB
3CEC:  CALL   0CC2
....................       lcd_gotoxy(10,0); 
3CF0:  MOVLW  0A
3CF2:  MOVWF  xEA
3CF4:  CLRF   xEB
3CF6:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
3CFA:  CLRF   xE3
3CFC:  MOVLW  2C
3CFE:  MOVWF  xE2
3D00:  CALL   1682
3D04:  MOVFF  01,D2
3D08:  CLRF   xE2
3D0A:  MOVLW  2C
3D0C:  MOVWF  xE1
3D0E:  MOVFF  01,E3
3D12:  CALL   16B4
....................  
....................       strcpy(tmp_str,"   "); 
3D16:  CLRF   FEA
3D18:  MOVLW  2C
3D1A:  MOVWF  FE9
3D1C:  MOVFF  FF2,D2
3D20:  BCF    FF2.7
3D22:  MOVLW  00
3D24:  CALL   0110
3D28:  TBLRD*-
3D2A:  TBLRD*+
3D2C:  MOVF   FF5,W
3D2E:  MOVWF  FEE
3D30:  IORLW  00
3D32:  BNZ   3D2A
3D34:  BTFSC  xD2.7
3D36:  BSF    FF2.7
....................       tmp_str[3]=0xDF; 
3D38:  MOVLW  DF
3D3A:  MOVWF  2F
....................       itoa((int8)sun_angle,10,tmp_str2); 
3D3C:  CLRF   xE9
3D3E:  CLRF   xE8
3D40:  CLRF   xE7
3D42:  MOVFF  D1,E6
3D46:  MOVLW  0A
3D48:  MOVWF  xEA
3D4A:  CLRF   xEC
3D4C:  MOVLW  40
3D4E:  MOVWF  xEB
3D50:  CALL   14A6
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
3D54:  CLRF   xE3
3D56:  MOVLW  40
3D58:  MOVWF  xE2
3D5A:  CALL   1682
3D5E:  MOVF   01,W
3D60:  SUBLW  03
3D62:  BNC   3DA8
3D64:  CLRF   xE3
3D66:  MOVLW  40
3D68:  MOVWF  xE2
3D6A:  CALL   1682
3D6E:  MOVLW  2F
3D70:  BSF    FD8.0
3D72:  SUBFWB 01,W
3D74:  MOVWF  xD2
3D76:  MOVLW  00
3D78:  BTFSS  FD8.0
3D7A:  DECF   FE8,F
3D7C:  MOVWF  xD3
3D7E:  CLRF   xE3
3D80:  MOVLW  40
3D82:  MOVWF  xE2
3D84:  CALL   1682
3D88:  MOVFF  01,D4
3D8C:  MOVFF  D3,FEA
3D90:  MOVFF  D2,FE9
3D94:  CLRF   FE2
3D96:  MOVLW  40
3D98:  MOVWF  FE1
3D9A:  MOVF   01,W
3D9C:  MOVWF  01
3D9E:  BZ    3DA8
3DA0:  MOVFF  FE6,FEE
3DA4:  DECFSZ 01,F
3DA6:  BRA    3DA0
....................        lcd_gotoxy(10,1); 
3DA8:  MOVLW  0A
3DAA:  MOVWF  xEA
3DAC:  MOVLW  01
3DAE:  MOVWF  xEB
3DB0:  CALL   0CC2
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
3DB4:  CLRF   xE3
3DB6:  MOVLW  2C
3DB8:  MOVWF  xE2
3DBA:  CALL   1682
3DBE:  MOVFF  01,D2
3DC2:  CLRF   xE2
3DC4:  MOVLW  2C
3DC6:  MOVWF  xE1
3DC8:  MOVFF  01,E3
3DCC:  CALL   16B4
....................  
....................       return sun_angle; 
3DD0:  MOVFF  D1,01
....................  
.................... } 
3DD4:  RETLW  00
....................  
.................... unsigned int8 get_backtrack_angle(unsigned int8 alpha) { 
....................  
....................    float tan_alpha,ll,dd; 
....................    float beta; 
....................    ll = PANEL_WIDTH; 
*
5986:  CLRF   xDA
5988:  CLRF   xD9
598A:  MOVLW  20
598C:  MOVWF  xD8
598E:  MOVLW  86
5990:  MOVWF  xD7
....................    dd = ROW_SPACING; 
5992:  CLRF   xDE
5994:  CLRF   xDD
5996:  MOVLW  20
5998:  MOVWF  xDC
599A:  MOVLW  87
599C:  MOVWF  xDB
....................    tan_alpha = tan( (float) (alpha) *PI/180.0); 
599E:  MOVLB  1
59A0:  CLRF   x4F
59A2:  MOVFF  D2,14E
59A6:  MOVLB  0
59A8:  CALL   437A
59AC:  MOVFF  00,E3
59B0:  MOVFF  01,E4
59B4:  MOVFF  02,E5
59B8:  MOVFF  03,E6
59BC:  MOVFF  03,151
59C0:  MOVFF  02,150
59C4:  MOVFF  01,14F
59C8:  MOVFF  00,14E
59CC:  MOVLW  DB
59CE:  MOVLB  1
59D0:  MOVWF  x55
59D2:  MOVLW  0F
59D4:  MOVWF  x54
59D6:  MOVLW  49
59D8:  MOVWF  x53
59DA:  MOVLW  80
59DC:  MOVWF  x52
59DE:  MOVLB  0
59E0:  CALL   0E24
59E4:  MOVFF  00,E7
59E8:  MOVFF  01,E8
59EC:  MOVFF  02,E9
59F0:  MOVFF  03,EA
59F4:  MOVFF  03,14D
59F8:  MOVFF  02,14C
59FC:  MOVFF  01,14B
5A00:  MOVFF  00,14A
5A04:  MOVLB  1
5A06:  CLRF   x51
5A08:  CLRF   x50
5A0A:  MOVLW  34
5A0C:  MOVWF  x4F
5A0E:  MOVLW  86
5A10:  MOVWF  x4E
5A12:  MOVLB  0
5A14:  CALL   0F1A
5A18:  MOVFF  00,EB
5A1C:  MOVFF  01,EC
5A20:  MOVFF  02,ED
5A24:  MOVFF  03,EE
5A28:  MOVFF  03,113
5A2C:  MOVFF  02,112
5A30:  MOVFF  01,111
5A34:  MOVFF  00,110
5A38:  CALL   47C2
5A3C:  MOVFF  03,D6
5A40:  MOVFF  02,D5
5A44:  MOVFF  01,D4
5A48:  MOVFF  00,D3
....................  
....................    beta = acos(-1*dd/(ll*sqrt(1.0+tan_alpha*tan_alpha))) -atan(-1.0*tan_alpha); 
5A4C:  MOVLB  1
5A4E:  CLRF   x51
5A50:  CLRF   x50
5A52:  MOVLW  80
5A54:  MOVWF  x4F
5A56:  MOVLW  7F
5A58:  MOVWF  x4E
5A5A:  MOVFF  DE,155
5A5E:  MOVFF  DD,154
5A62:  MOVFF  DC,153
5A66:  MOVFF  DB,152
5A6A:  MOVLB  0
5A6C:  CALL   0E24
5A70:  MOVFF  00,E3
5A74:  MOVFF  01,E4
5A78:  MOVFF  02,E5
5A7C:  MOVFF  03,E6
5A80:  MOVFF  D6,151
5A84:  MOVFF  D5,150
5A88:  MOVFF  D4,14F
5A8C:  MOVFF  D3,14E
5A90:  MOVFF  D6,155
5A94:  MOVFF  D5,154
5A98:  MOVFF  D4,153
5A9C:  MOVFF  D3,152
5AA0:  CALL   0E24
5AA4:  BCF    FD8.1
5AA6:  MOVLB  1
5AA8:  CLRF   x53
5AAA:  CLRF   x52
5AAC:  CLRF   x51
5AAE:  MOVLW  7F
5AB0:  MOVWF  x50
5AB2:  MOVFF  03,157
5AB6:  MOVFF  02,156
5ABA:  MOVFF  01,155
5ABE:  MOVFF  00,154
5AC2:  MOVLB  0
5AC4:  CALL   1078
5AC8:  MOVFF  00,E7
5ACC:  MOVFF  01,E8
5AD0:  MOVFF  02,E9
5AD4:  MOVFF  03,EA
5AD8:  MOVFF  03,115
5ADC:  MOVFF  02,114
5AE0:  MOVFF  01,113
5AE4:  MOVFF  00,112
5AE8:  CALL   4860
5AEC:  MOVFF  DA,151
5AF0:  MOVFF  D9,150
5AF4:  MOVFF  D8,14F
5AF8:  MOVFF  D7,14E
5AFC:  MOVFF  03,155
5B00:  MOVFF  02,154
5B04:  MOVFF  01,153
5B08:  MOVFF  00,152
5B0C:  CALL   0E24
5B10:  MOVFF  E6,14D
5B14:  MOVFF  E5,14C
5B18:  MOVFF  E4,14B
5B1C:  MOVFF  E3,14A
5B20:  MOVFF  03,151
5B24:  MOVFF  02,150
5B28:  MOVFF  01,14F
5B2C:  MOVFF  00,14E
5B30:  CALL   0F1A
5B34:  MOVFF  00,E8
5B38:  MOVFF  01,E9
5B3C:  MOVFF  02,EA
5B40:  MOVFF  03,EB
5B44:  MOVFF  03,EF
5B48:  MOVFF  02,EE
5B4C:  MOVFF  01,ED
5B50:  MOVFF  00,EC
5B54:  BRA    5432
5B56:  MOVFF  00,E9
5B5A:  MOVFF  01,EA
5B5E:  MOVFF  02,EB
5B62:  MOVFF  03,EC
5B66:  MOVLB  1
5B68:  CLRF   x51
5B6A:  CLRF   x50
5B6C:  MOVLW  80
5B6E:  MOVWF  x4F
5B70:  MOVLW  7F
5B72:  MOVWF  x4E
5B74:  MOVFF  D6,155
5B78:  MOVFF  D5,154
5B7C:  MOVFF  D4,153
5B80:  MOVFF  D3,152
5B84:  MOVLB  0
5B86:  CALL   0E24
5B8A:  MOVFF  00,ED
5B8E:  MOVFF  01,EE
5B92:  MOVFF  02,EF
5B96:  MOVFF  03,F0
5B9A:  MOVFF  03,10B
5B9E:  MOVFF  02,10A
5BA2:  MOVFF  01,109
5BA6:  MOVFF  00,108
5BAA:  CALL   3E50
5BAE:  MOVFF  FEA,EF
5BB2:  MOVFF  FE9,EE
5BB6:  BSF    FD8.1
5BB8:  MOVFF  EC,153
5BBC:  MOVFF  EB,152
5BC0:  MOVFF  EA,151
5BC4:  MOVFF  E9,150
5BC8:  MOVFF  03,157
5BCC:  MOVFF  02,156
5BD0:  MOVFF  01,155
5BD4:  MOVFF  00,154
5BD8:  CALL   1078
5BDC:  MOVFF  EF,FEA
5BE0:  MOVFF  EE,FE9
5BE4:  MOVFF  03,E2
5BE8:  MOVFF  02,E1
5BEC:  MOVFF  01,E0
5BF0:  MOVFF  00,DF
....................    return fmod(beta,PI)*180.0/PI; 
5BF4:  MOVFF  E2,E6
5BF8:  MOVFF  E1,E5
5BFC:  MOVFF  E0,E4
5C00:  MOVFF  DF,E3
5C04:  MOVLW  DB
5C06:  MOVWF  xEA
5C08:  MOVLW  0F
5C0A:  MOVWF  xE9
5C0C:  MOVLW  49
5C0E:  MOVWF  xE8
5C10:  MOVLW  80
5C12:  MOVWF  xE7
5C14:  BRA    581C
5C16:  MOVFF  00,E3
5C1A:  MOVFF  01,E4
5C1E:  MOVFF  02,E5
5C22:  MOVFF  03,E6
5C26:  MOVFF  03,151
5C2A:  MOVFF  02,150
5C2E:  MOVFF  01,14F
5C32:  MOVFF  00,14E
5C36:  MOVLB  1
5C38:  CLRF   x55
5C3A:  CLRF   x54
5C3C:  MOVLW  34
5C3E:  MOVWF  x53
5C40:  MOVLW  86
5C42:  MOVWF  x52
5C44:  MOVLB  0
5C46:  CALL   0E24
5C4A:  MOVFF  00,E7
5C4E:  MOVFF  01,E8
5C52:  MOVFF  02,E9
5C56:  MOVFF  03,EA
5C5A:  MOVFF  03,14D
5C5E:  MOVFF  02,14C
5C62:  MOVFF  01,14B
5C66:  MOVFF  00,14A
5C6A:  MOVLW  DB
5C6C:  MOVLB  1
5C6E:  MOVWF  x51
5C70:  MOVLW  0F
5C72:  MOVWF  x50
5C74:  MOVLW  49
5C76:  MOVWF  x4F
5C78:  MOVLW  80
5C7A:  MOVWF  x4E
5C7C:  MOVLB  0
5C7E:  CALL   0F1A
5C82:  MOVFF  03,14D
5C86:  MOVFF  02,14C
5C8A:  MOVFF  01,14B
5C8E:  MOVFF  00,14A
5C92:  CALL   43B0
5C96:  MOVF   01,W
.................... } 
5C98:  RETLW  00
....................  
....................  
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       set_timer1(get_timer1()+0x8000); 
*
03BA:  MOVF   FCE,W
03BC:  MOVFF  FCF,03
03C0:  MOVLB  1
03C2:  MOVWF  x60
03C4:  MOVFF  FCF,161
03C8:  MOVLW  80
03CA:  ADDWF  FCF,W
03CC:  MOVWF  FCF
03CE:  MOVFF  160,FCE
....................       timer_sec+=1;  
03D2:  MOVLW  01
03D4:  ADDWF  20,F
03D6:  MOVLW  00
03D8:  ADDWFC 21,F
03DA:  ADDWFC 22,F
03DC:  ADDWFC 23,F
....................       flag.update_time = true; 
03DE:  BSF    1F.1
....................       restart_wdt(); 
03E0:  CLRWDT
....................       if ((timer_sec%15) ==0) 
03E2:  MOVFF  23,EE
03E6:  MOVFF  22,ED
03EA:  MOVFF  21,EC
03EE:  MOVFF  20,EB
03F2:  MOVLB  0
03F4:  CLRF   xF2
03F6:  CLRF   xF1
03F8:  CLRF   xF0
03FA:  MOVLW  0F
03FC:  MOVWF  xEF
03FE:  RCALL  0340
0400:  MOVFF  FEF,160
0404:  MOVFF  FEC,161
0408:  MOVFF  FEC,162
040C:  MOVFF  FEC,163
0410:  MOVLB  1
0412:  MOVF   x60,F
0414:  BNZ   0424
0416:  MOVF   x61,F
0418:  BNZ   0424
041A:  MOVF   x62,F
041C:  BNZ   0424
041E:  MOVF   x63,F
0420:  BNZ   0424
....................          flag.measured_current=true; 
0422:  BSF    1F.7
....................       if ((timer_sec%450) ==0) 
0424:  MOVFF  23,EE
0428:  MOVFF  22,ED
042C:  MOVFF  21,EC
0430:  MOVFF  20,EB
0434:  MOVLB  0
0436:  CLRF   xF2
0438:  CLRF   xF1
043A:  MOVLW  01
043C:  MOVWF  xF0
043E:  MOVLW  C2
0440:  MOVWF  xEF
0442:  RCALL  0340
0444:  MOVFF  FEF,160
0448:  MOVFF  FEC,161
044C:  MOVFF  FEC,162
0450:  MOVFF  FEC,163
0454:  MOVLB  1
0456:  MOVF   x60,F
0458:  BNZ   0468
045A:  MOVF   x61,F
045C:  BNZ   0468
045E:  MOVF   x62,F
0460:  BNZ   0468
0462:  MOVF   x63,F
0464:  BNZ   0468
....................          flag.task1_armed=true; 
0466:  BSF    1F.0
....................       if (timer_sec%300==30) flag.reset_rs232=true; 
0468:  MOVFF  23,EE
046C:  MOVFF  22,ED
0470:  MOVFF  21,EC
0474:  MOVFF  20,EB
0478:  MOVLB  0
047A:  CLRF   xF2
047C:  CLRF   xF1
047E:  MOVLW  01
0480:  MOVWF  xF0
0482:  MOVLW  2C
0484:  MOVWF  xEF
0486:  RCALL  0340
0488:  MOVFF  FEF,160
048C:  MOVFF  FEC,161
0490:  MOVFF  FEC,162
0494:  MOVFF  FEC,163
0498:  MOVLB  1
049A:  MOVF   x60,W
049C:  SUBLW  1E
049E:  BNZ   04AE
04A0:  MOVF   x61,F
04A2:  BNZ   04AE
04A4:  MOVF   x62,F
04A6:  BNZ   04AE
04A8:  MOVF   x63,F
04AA:  BTFSC  FD8.2
04AC:  BSF    1F.5
....................       if (tx_delay>0) tx_delay--; 
04AE:  MOVLB  0
04B0:  MOVF   xC2,F
04B2:  BTFSS  FD8.2
04B4:  DECF   xC2,F
.................... //       
.................... } 
....................  
....................  
04B6:  BCF    F9E.0
04B8:  GOTO   0064
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................     c=getc(); 
*
04E4:  BTFSS  F9E.5
04E6:  BRA    04E4
04E8:  MOVFF  FAE,160
04EC:  MOVLB  1
....................     PORTE.tx_en=1; 
04EE:  BSF    F84.2
....................    delay_ms(2); 
04F0:  MOVLW  02
04F2:  MOVLB  0
04F4:  MOVWF  xEA
04F6:  RCALL  04BC
....................      if(c==8) {  // Backspace 
04F8:  MOVLB  1
04FA:  MOVF   x60,W
04FC:  SUBLW  08
04FE:  BNZ   0528
....................         if(cmd_len>0) { 
0500:  MOVLB  0
0502:  MOVF   x68,F
0504:  BZ    0524
....................           cmd_len--; 
0506:  DECF   x68,F
....................           printf("%c",c); 
0508:  MOVLB  1
050A:  MOVF   x60,W
050C:  BTFSS  F9E.4
050E:  BRA    050C
0510:  MOVWF  FAD
....................           printf(" "); 
0512:  MOVLW  20
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
....................           printf("%c",c); 
051A:  MOVF   x60,W
051C:  BTFSS  F9E.4
051E:  BRA    051C
0520:  MOVWF  FAD
0522:  MOVLB  0
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0524:  BRA    055A
0526:  MOVLB  1
0528:  MOVF   x60,W
052A:  SUBLW  1F
052C:  BC    055A
052E:  MOVF   x60,W
0530:  SUBLW  7E
0532:  BNC   055A
....................        if(cmd_len<=MAX_CMD_LEN) { 
0534:  MOVLB  0
0536:  MOVF   x68,W
0538:  SUBLW  12
053A:  BNC   055A
....................          cmd_msg[cmd_len++]=c; 
053C:  MOVF   x68,W
053E:  INCF   x68,F
0540:  CLRF   03
0542:  ADDLW  54
0544:  MOVWF  FE9
0546:  MOVLW  00
0548:  ADDWFC 03,W
054A:  MOVWF  FEA
054C:  MOVFF  160,FEF
....................          printf("%c",c); 
0550:  MOVLB  1
0552:  MOVF   x60,W
0554:  BTFSS  F9E.4
0556:  BRA    0554
0558:  MOVWF  FAD
....................        }  
....................     if (c==13) {  
055A:  MOVLB  1
055C:  MOVF   x60,W
055E:  SUBLW  0D
0560:  BNZ   0596
....................    printf("\r\n>"); 
0562:  MOVLW  0D
0564:  BTFSS  F9E.4
0566:  BRA    0564
0568:  MOVWF  FAD
056A:  MOVLW  0A
056C:  BTFSS  F9E.4
056E:  BRA    056C
0570:  MOVWF  FAD
0572:  MOVLW  3E
0574:  BTFSS  F9E.4
0576:  BRA    0574
0578:  MOVWF  FAD
....................     //PORTE.tx_en=0; 
....................    cmd_msg[cmd_len]=0; 
057A:  CLRF   03
057C:  MOVLB  0
057E:  MOVF   x68,W
0580:  ADDLW  54
0582:  MOVWF  FE9
0584:  MOVLW  00
0586:  ADDWFC 03,W
0588:  MOVWF  FEA
058A:  CLRF   FEF
....................    if(cmd_len>1)flag.cmd_posted=true; 
058C:  MOVF   x68,W
058E:  SUBLW  01
0590:  BTFSS  FD8.0
0592:  BSF    1F.3
....................    cmd_len =0; 
0594:  CLRF   x68
....................   } 
....................    tx_delay=TX_DLY_TIME; 
0596:  MOVLW  01
0598:  MOVLB  0
059A:  MOVWF  xC2
....................  
.................... } 
....................  
059C:  BCF    F9E.5
059E:  GOTO   0064
.................... float actuator_length(int8 sun_angle) { 
.................... // return actuator length in cm at given sun_angle 
.................... float len_a,len_b,len_c,len_p,len_m,len_k,len_l; 
.................... float sin_beta,cos_beta,tan_beta; 
.................... float temp1; 
.................... float alpha; 
.................... //if (sun_angle < 30) return; 
.................... //if (sun_angle > 150) return; 
.................... len_a = DIM_A; 
*
498A:  CLRF   xD7
498C:  CLRF   xD6
498E:  MOVLW  57
4990:  MOVWF  xD5
4992:  MOVLW  85
4994:  MOVWF  xD4
.................... len_b = DIM_B; 
4996:  MOVLW  CD
4998:  MOVWF  xDB
499A:  MOVLW  CC
499C:  MOVWF  xDA
499E:  MOVLW  7C
49A0:  MOVWF  xD9
49A2:  MOVLW  82
49A4:  MOVWF  xD8
.................... len_p = DIM_P; 
49A6:  MOVLW  CD
49A8:  MOVWF  xE3
49AA:  MOVLW  CC
49AC:  MOVWF  xE2
49AE:  MOVLW  14
49B0:  MOVWF  xE1
49B2:  MOVLW  82
49B4:  MOVWF  xE0
.................... len_k = DIM_K; 
49B6:  CLRF   xEB
49B8:  CLRF   xEA
49BA:  MOVLW  10
49BC:  MOVWF  xE9
49BE:  MOVLW  84
49C0:  MOVWF  xE8
.................... len_m = DIM_M; 
49C2:  CLRF   xE7
49C4:  CLRF   xE6
49C6:  MOVLW  30
49C8:  MOVWF  xE5
49CA:  MOVLW  81
49CC:  MOVWF  xE4
.................... len_p = DIM_P; 
49CE:  MOVLW  CD
49D0:  MOVWF  xE3
49D2:  MOVLW  CC
49D4:  MOVWF  xE2
49D6:  MOVLW  14
49D8:  MOVWF  xE1
49DA:  MOVLW  82
49DC:  MOVWF  xE0
.................... alpha = atan(len_b/len_k); 
49DE:  MOVFF  DB,14D
49E2:  MOVFF  DA,14C
49E6:  MOVFF  D9,14B
49EA:  MOVFF  D8,14A
49EE:  MOVFF  EB,151
49F2:  MOVFF  EA,150
49F6:  MOVFF  E9,14F
49FA:  MOVFF  E8,14E
49FE:  CALL   0F1A
4A02:  MOVFF  00,104
4A06:  MOVFF  01,105
4A0A:  MOVFF  02,106
4A0E:  MOVFF  03,107
4A12:  MOVFF  03,10B
4A16:  MOVFF  02,10A
4A1A:  MOVFF  01,109
4A1E:  MOVFF  00,108
4A22:  CALL   3E50
4A26:  MOVFF  03,103
4A2A:  MOVFF  02,102
4A2E:  MOVFF  01,101
4A32:  MOVFF  00,100
.................... sin_beta = sin((sun_angle*PI/180.0)-alpha); 
4A36:  MOVLB  1
4A38:  CLRF   x4F
4A3A:  MOVFF  D3,14E
4A3E:  MOVLB  0
4A40:  RCALL  437A
4A42:  MOVFF  03,151
4A46:  MOVFF  02,150
4A4A:  MOVFF  01,14F
4A4E:  MOVFF  00,14E
4A52:  MOVLW  DB
4A54:  MOVLB  1
4A56:  MOVWF  x55
4A58:  MOVLW  0F
4A5A:  MOVWF  x54
4A5C:  MOVLW  49
4A5E:  MOVWF  x53
4A60:  MOVLW  80
4A62:  MOVWF  x52
4A64:  MOVLB  0
4A66:  CALL   0E24
4A6A:  MOVFF  00,104
4A6E:  MOVFF  01,105
4A72:  MOVFF  02,106
4A76:  MOVFF  03,107
4A7A:  MOVFF  03,14D
4A7E:  MOVFF  02,14C
4A82:  MOVFF  01,14B
4A86:  MOVFF  00,14A
4A8A:  MOVLB  1
4A8C:  CLRF   x51
4A8E:  CLRF   x50
4A90:  MOVLW  34
4A92:  MOVWF  x4F
4A94:  MOVLW  86
4A96:  MOVWF  x4E
4A98:  MOVLB  0
4A9A:  CALL   0F1A
4A9E:  MOVFF  00,108
4AA2:  MOVFF  01,109
4AA6:  MOVFF  02,10A
4AAA:  MOVFF  03,10B
4AAE:  BSF    FD8.1
4AB0:  MOVFF  03,153
4AB4:  MOVFF  02,152
4AB8:  MOVFF  01,151
4ABC:  MOVFF  00,150
4AC0:  MOVFF  103,157
4AC4:  MOVFF  102,156
4AC8:  MOVFF  101,155
4ACC:  MOVFF  100,154
4AD0:  CALL   1078
4AD4:  MOVFF  00,10C
4AD8:  MOVFF  01,10D
4ADC:  MOVFF  02,10E
4AE0:  MOVFF  03,10F
4AE4:  MOVFF  03,11F
4AE8:  MOVFF  02,11E
4AEC:  MOVFF  01,11D
4AF0:  MOVFF  00,11C
4AF4:  RCALL  4774
4AF6:  MOVFF  03,F3
4AFA:  MOVFF  02,F2
4AFE:  MOVFF  01,F1
4B02:  MOVFF  00,F0
.................... cos_beta = cos((sun_angle*PI/180.0)-alpha); 
4B06:  MOVLB  1
4B08:  CLRF   x4F
4B0A:  MOVFF  D3,14E
4B0E:  MOVLB  0
4B10:  RCALL  437A
4B12:  MOVFF  03,151
4B16:  MOVFF  02,150
4B1A:  MOVFF  01,14F
4B1E:  MOVFF  00,14E
4B22:  MOVLW  DB
4B24:  MOVLB  1
4B26:  MOVWF  x55
4B28:  MOVLW  0F
4B2A:  MOVWF  x54
4B2C:  MOVLW  49
4B2E:  MOVWF  x53
4B30:  MOVLW  80
4B32:  MOVWF  x52
4B34:  MOVLB  0
4B36:  CALL   0E24
4B3A:  MOVFF  00,104
4B3E:  MOVFF  01,105
4B42:  MOVFF  02,106
4B46:  MOVFF  03,107
4B4A:  MOVFF  03,14D
4B4E:  MOVFF  02,14C
4B52:  MOVFF  01,14B
4B56:  MOVFF  00,14A
4B5A:  MOVLB  1
4B5C:  CLRF   x51
4B5E:  CLRF   x50
4B60:  MOVLW  34
4B62:  MOVWF  x4F
4B64:  MOVLW  86
4B66:  MOVWF  x4E
4B68:  MOVLB  0
4B6A:  CALL   0F1A
4B6E:  MOVFF  00,108
4B72:  MOVFF  01,109
4B76:  MOVFF  02,10A
4B7A:  MOVFF  03,10B
4B7E:  BSF    FD8.1
4B80:  MOVFF  03,153
4B84:  MOVFF  02,152
4B88:  MOVFF  01,151
4B8C:  MOVFF  00,150
4B90:  MOVFF  103,157
4B94:  MOVFF  102,156
4B98:  MOVFF  101,155
4B9C:  MOVFF  100,154
4BA0:  CALL   1078
4BA4:  MOVFF  00,10C
4BA8:  MOVFF  01,10D
4BAC:  MOVFF  02,10E
4BB0:  MOVFF  03,10F
4BB4:  MOVFF  03,127
4BB8:  MOVFF  02,126
4BBC:  MOVFF  01,125
4BC0:  MOVFF  00,124
4BC4:  RCALL  43EC
4BC6:  MOVFF  03,F7
4BCA:  MOVFF  02,F6
4BCE:  MOVFF  01,F5
4BD2:  MOVFF  00,F4
.................... tan_beta = tan((sun_angle*PI/180.0)-alpha); 
4BD6:  MOVLB  1
4BD8:  CLRF   x4F
4BDA:  MOVFF  D3,14E
4BDE:  MOVLB  0
4BE0:  CALL   437A
4BE4:  MOVFF  03,151
4BE8:  MOVFF  02,150
4BEC:  MOVFF  01,14F
4BF0:  MOVFF  00,14E
4BF4:  MOVLW  DB
4BF6:  MOVLB  1
4BF8:  MOVWF  x55
4BFA:  MOVLW  0F
4BFC:  MOVWF  x54
4BFE:  MOVLW  49
4C00:  MOVWF  x53
4C02:  MOVLW  80
4C04:  MOVWF  x52
4C06:  MOVLB  0
4C08:  CALL   0E24
4C0C:  MOVFF  00,104
4C10:  MOVFF  01,105
4C14:  MOVFF  02,106
4C18:  MOVFF  03,107
4C1C:  MOVFF  03,14D
4C20:  MOVFF  02,14C
4C24:  MOVFF  01,14B
4C28:  MOVFF  00,14A
4C2C:  MOVLB  1
4C2E:  CLRF   x51
4C30:  CLRF   x50
4C32:  MOVLW  34
4C34:  MOVWF  x4F
4C36:  MOVLW  86
4C38:  MOVWF  x4E
4C3A:  MOVLB  0
4C3C:  CALL   0F1A
4C40:  MOVFF  00,108
4C44:  MOVFF  01,109
4C48:  MOVFF  02,10A
4C4C:  MOVFF  03,10B
4C50:  BSF    FD8.1
4C52:  MOVFF  03,153
4C56:  MOVFF  02,152
4C5A:  MOVFF  01,151
4C5E:  MOVFF  00,150
4C62:  MOVFF  103,157
4C66:  MOVFF  102,156
4C6A:  MOVFF  101,155
4C6E:  MOVFF  100,154
4C72:  CALL   1078
4C76:  MOVFF  00,10C
4C7A:  MOVFF  01,10D
4C7E:  MOVFF  02,10E
4C82:  MOVFF  03,10F
4C86:  MOVFF  03,113
4C8A:  MOVFF  02,112
4C8E:  MOVFF  01,111
4C92:  MOVFF  00,110
4C96:  RCALL  47C2
4C98:  MOVFF  03,FB
4C9C:  MOVFF  02,FA
4CA0:  MOVFF  01,F9
4CA4:  MOVFF  00,F8
....................  
....................  
.................... len_c = sqrt(len_k*len_k+len_b*len_b)-len_p/sin_beta; 
4CA8:  MOVFF  EB,151
4CAC:  MOVFF  EA,150
4CB0:  MOVFF  E9,14F
4CB4:  MOVFF  E8,14E
4CB8:  MOVFF  EB,155
4CBC:  MOVFF  EA,154
4CC0:  MOVFF  E9,153
4CC4:  MOVFF  E8,152
4CC8:  CALL   0E24
4CCC:  MOVFF  00,104
4CD0:  MOVFF  01,105
4CD4:  MOVFF  02,106
4CD8:  MOVFF  03,107
4CDC:  MOVFF  DB,151
4CE0:  MOVFF  DA,150
4CE4:  MOVFF  D9,14F
4CE8:  MOVFF  D8,14E
4CEC:  MOVFF  DB,155
4CF0:  MOVFF  DA,154
4CF4:  MOVFF  D9,153
4CF8:  MOVFF  D8,152
4CFC:  CALL   0E24
4D00:  BCF    FD8.1
4D02:  MOVFF  107,153
4D06:  MOVFF  106,152
4D0A:  MOVFF  105,151
4D0E:  MOVFF  104,150
4D12:  MOVFF  03,157
4D16:  MOVFF  02,156
4D1A:  MOVFF  01,155
4D1E:  MOVFF  00,154
4D22:  CALL   1078
4D26:  MOVFF  00,108
4D2A:  MOVFF  01,109
4D2E:  MOVFF  02,10A
4D32:  MOVFF  03,10B
4D36:  MOVFF  03,115
4D3A:  MOVFF  02,114
4D3E:  MOVFF  01,113
4D42:  MOVFF  00,112
4D46:  RCALL  4860
4D48:  MOVFF  00,109
4D4C:  MOVFF  01,10A
4D50:  MOVFF  02,10B
4D54:  MOVFF  03,10C
4D58:  MOVFF  E3,14D
4D5C:  MOVFF  E2,14C
4D60:  MOVFF  E1,14B
4D64:  MOVFF  E0,14A
4D68:  MOVFF  F3,151
4D6C:  MOVFF  F2,150
4D70:  MOVFF  F1,14F
4D74:  MOVFF  F0,14E
4D78:  CALL   0F1A
4D7C:  MOVFF  FEA,10E
4D80:  MOVFF  FE9,10D
4D84:  BSF    FD8.1
4D86:  MOVFF  10C,153
4D8A:  MOVFF  10B,152
4D8E:  MOVFF  10A,151
4D92:  MOVFF  109,150
4D96:  MOVFF  03,157
4D9A:  MOVFF  02,156
4D9E:  MOVFF  01,155
4DA2:  MOVFF  00,154
4DA6:  CALL   1078
4DAA:  MOVFF  10E,FEA
4DAE:  MOVFF  10D,FE9
4DB2:  MOVFF  03,DF
4DB6:  MOVFF  02,DE
4DBA:  MOVFF  01,DD
4DBE:  MOVFF  00,DC
.................... temp1 = len_a - (len_p/tan_beta)-len_c*cos_beta; 
4DC2:  MOVFF  E3,14D
4DC6:  MOVFF  E2,14C
4DCA:  MOVFF  E1,14B
4DCE:  MOVFF  E0,14A
4DD2:  MOVFF  FB,151
4DD6:  MOVFF  FA,150
4DDA:  MOVFF  F9,14F
4DDE:  MOVFF  F8,14E
4DE2:  CALL   0F1A
4DE6:  BSF    FD8.1
4DE8:  MOVFF  D7,153
4DEC:  MOVFF  D6,152
4DF0:  MOVFF  D5,151
4DF4:  MOVFF  D4,150
4DF8:  MOVFF  03,157
4DFC:  MOVFF  02,156
4E00:  MOVFF  01,155
4E04:  MOVFF  00,154
4E08:  CALL   1078
4E0C:  MOVFF  00,104
4E10:  MOVFF  01,105
4E14:  MOVFF  02,106
4E18:  MOVFF  03,107
4E1C:  MOVFF  DF,151
4E20:  MOVFF  DE,150
4E24:  MOVFF  DD,14F
4E28:  MOVFF  DC,14E
4E2C:  MOVFF  F7,155
4E30:  MOVFF  F6,154
4E34:  MOVFF  F5,153
4E38:  MOVFF  F4,152
4E3C:  CALL   0E24
4E40:  BSF    FD8.1
4E42:  MOVFF  107,153
4E46:  MOVFF  106,152
4E4A:  MOVFF  105,151
4E4E:  MOVFF  104,150
4E52:  MOVFF  03,157
4E56:  MOVFF  02,156
4E5A:  MOVFF  01,155
4E5E:  MOVFF  00,154
4E62:  CALL   1078
4E66:  MOVFF  03,FF
4E6A:  MOVFF  02,FE
4E6E:  MOVFF  01,FD
4E72:  MOVFF  00,FC
.................... len_l = len_c*sin_beta*len_c*sin_beta+temp1*temp1-len_m*len_m; 
4E76:  MOVFF  DF,151
4E7A:  MOVFF  DE,150
4E7E:  MOVFF  DD,14F
4E82:  MOVFF  DC,14E
4E86:  MOVFF  F3,155
4E8A:  MOVFF  F2,154
4E8E:  MOVFF  F1,153
4E92:  MOVFF  F0,152
4E96:  CALL   0E24
4E9A:  MOVFF  00,104
4E9E:  MOVFF  01,105
4EA2:  MOVFF  02,106
4EA6:  MOVFF  03,107
4EAA:  MOVFF  03,151
4EAE:  MOVFF  02,150
4EB2:  MOVFF  01,14F
4EB6:  MOVFF  00,14E
4EBA:  MOVFF  DF,155
4EBE:  MOVFF  DE,154
4EC2:  MOVFF  DD,153
4EC6:  MOVFF  DC,152
4ECA:  CALL   0E24
4ECE:  MOVFF  00,108
4ED2:  MOVFF  01,109
4ED6:  MOVFF  02,10A
4EDA:  MOVFF  03,10B
4EDE:  MOVFF  03,151
4EE2:  MOVFF  02,150
4EE6:  MOVFF  01,14F
4EEA:  MOVFF  00,14E
4EEE:  MOVFF  F3,155
4EF2:  MOVFF  F2,154
4EF6:  MOVFF  F1,153
4EFA:  MOVFF  F0,152
4EFE:  CALL   0E24
4F02:  MOVFF  00,10C
4F06:  MOVFF  01,10D
4F0A:  MOVFF  02,10E
4F0E:  MOVFF  03,10F
4F12:  MOVFF  FF,151
4F16:  MOVFF  FE,150
4F1A:  MOVFF  FD,14F
4F1E:  MOVFF  FC,14E
4F22:  MOVFF  FF,155
4F26:  MOVFF  FE,154
4F2A:  MOVFF  FD,153
4F2E:  MOVFF  FC,152
4F32:  CALL   0E24
4F36:  BCF    FD8.1
4F38:  MOVFF  10F,153
4F3C:  MOVFF  10E,152
4F40:  MOVFF  10D,151
4F44:  MOVFF  10C,150
4F48:  MOVFF  03,157
4F4C:  MOVFF  02,156
4F50:  MOVFF  01,155
4F54:  MOVFF  00,154
4F58:  CALL   1078
4F5C:  MOVFF  00,110
4F60:  MOVFF  01,111
4F64:  MOVFF  02,112
4F68:  MOVFF  03,113
4F6C:  MOVFF  E7,151
4F70:  MOVFF  E6,150
4F74:  MOVFF  E5,14F
4F78:  MOVFF  E4,14E
4F7C:  MOVFF  E7,155
4F80:  MOVFF  E6,154
4F84:  MOVFF  E5,153
4F88:  MOVFF  E4,152
4F8C:  CALL   0E24
4F90:  BSF    FD8.1
4F92:  MOVFF  113,153
4F96:  MOVFF  112,152
4F9A:  MOVFF  111,151
4F9E:  MOVFF  110,150
4FA2:  MOVFF  03,157
4FA6:  MOVFF  02,156
4FAA:  MOVFF  01,155
4FAE:  MOVFF  00,154
4FB2:  CALL   1078
4FB6:  MOVFF  03,EF
4FBA:  MOVFF  02,EE
4FBE:  MOVFF  01,ED
4FC2:  MOVFF  00,EC
.................... len_l = sqrt(len_l); 
4FC6:  MOVFF  EF,115
4FCA:  MOVFF  EE,114
4FCE:  MOVFF  ED,113
4FD2:  MOVFF  EC,112
4FD6:  RCALL  4860
4FD8:  MOVFF  03,EF
4FDC:  MOVFF  02,EE
4FE0:  MOVFF  01,ED
4FE4:  MOVFF  00,EC
....................  
.................... if (len_l<50.0) 
4FE8:  MOVFF  EF,14D
4FEC:  MOVFF  EE,14C
4FF0:  MOVFF  ED,14B
4FF4:  MOVFF  EC,14A
4FF8:  MOVLB  1
4FFA:  CLRF   x51
4FFC:  CLRF   x50
4FFE:  MOVLW  48
5000:  MOVWF  x4F
5002:  MOVLW  84
5004:  MOVWF  x4E
5006:  MOVLB  0
5008:  CALL   3DD6
500C:  BNC   5018
....................    return 0.0; 
500E:  CLRF   00
5010:  CLRF   01
5012:  CLRF   02
5014:  CLRF   03
5016:  BRA    5028
....................  
.................... return len_l; 
5018:  MOVFF  EC,00
501C:  MOVFF  ED,01
5020:  MOVFF  EE,02
5024:  MOVFF  EF,03
.................... } 
5028:  RETLW  00
....................  
.................... void process_cmd_msg(){ 
....................     flag.cmd_posted =false; 
*
2F5E:  BCF    1F.3
....................    switch (cmd_msg[0]) { 
2F60:  MOVLW  63
2F62:  SUBWF  54,W
2F64:  ADDLW  E9
2F66:  BTFSC  FD8.0
2F68:  BRA    357E
2F6A:  ADDLW  17
2F6C:  GOTO   3580
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
2F70:  CLRF   FEA
2F72:  MOVLW  54
2F74:  MOVWF  FE9
2F76:  CLRF   FE2
2F78:  MOVLW  55
2F7A:  MOVWF  FE1
2F7C:  MOVLW  12
2F7E:  MOVWF  01
2F80:  MOVFF  FE6,FEE
2F84:  DECFSZ 01,F
2F86:  BRA    2F80
....................            if (atol(cmd_msg)==0) break; 
2F88:  CLRF   xD2
2F8A:  MOVLW  54
2F8C:  MOVWF  xD1
2F8E:  CALL   0ADA
2F92:  MOVFF  02,D2
2F96:  MOVFF  01,D1
2F9A:  MOVF   xD1,F
2F9C:  BNZ   2FA4
2F9E:  MOVF   xD2,F
2FA0:  BNZ   2FA4
2FA2:  BRA    357E
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
2FA4:  CLRF   xD2
2FA6:  MOVLW  54
2FA8:  MOVWF  xD1
2FAA:  CALL   0ADA
2FAE:  MOVFF  02,D2
2FB2:  MOVFF  01,D1
2FB6:  MOVFF  02,D4
2FBA:  MOVFF  01,D3
2FBE:  MOVLW  23
2FC0:  MOVWF  xD6
2FC2:  MOVLW  28
2FC4:  MOVWF  xD5
2FC6:  MOVFF  C1,D8
2FCA:  MOVFF  C0,D7
2FCE:  MOVLW  01
2FD0:  MOVWF  xD9
2FD2:  CLRF   xDA
2FD4:  CALL   21A4
....................          break;    } 
2FD8:  BRA    357E
....................  
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
2FDA:  CLRF   FEA
2FDC:  MOVLW  54
2FDE:  MOVWF  FE9
2FE0:  CLRF   FE2
2FE2:  MOVLW  55
2FE4:  MOVWF  FE1
2FE6:  MOVLW  12
2FE8:  MOVWF  01
2FEA:  MOVFF  FE6,FEE
2FEE:  DECFSZ 01,F
2FF0:  BRA    2FEA
....................            if (atol(cmd_msg)==0) break; 
2FF2:  CLRF   xD2
2FF4:  MOVLW  54
2FF6:  MOVWF  xD1
2FF8:  CALL   0ADA
2FFC:  MOVFF  02,D2
3000:  MOVFF  01,D1
3004:  MOVF   xD1,F
3006:  BNZ   300E
3008:  MOVF   xD2,F
300A:  BNZ   300E
300C:  BRA    357E
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
300E:  CLRF   xD2
3010:  MOVLW  54
3012:  MOVWF  xD1
3014:  CALL   0ADA
3018:  MOVFF  02,D2
301C:  MOVFF  01,D1
3020:  MOVFF  02,D4
3024:  MOVFF  01,D3
3028:  MOVLW  23
302A:  MOVWF  xD6
302C:  MOVLW  28
302E:  MOVWF  xD5
3030:  MOVFF  C1,D8
3034:  MOVFF  C0,D7
3038:  CLRF   xD9
303A:  CLRF   xDA
303C:  CALL   21A4
....................          break;    } 
3040:  BRA    357E
.................... /* 
....................       case 'x':{ 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................            if (atol(cmd_msg)==1) { 
....................             setup_timer_0(RTCC_DIV_32); 
....................             move_act_time_out =4; 
....................          } else if(atol(cmd_msg)==2) { 
....................             setup_timer_0(RTCC_DIV_1); 
....................             move_act_time_out =128; 
....................          } 
....................          break;    }    
.................... */    
....................       case 'd':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3042:  CLRF   FEA
3044:  MOVLW  54
3046:  MOVWF  FE9
3048:  CLRF   FE2
304A:  MOVLW  55
304C:  MOVWF  FE1
304E:  MOVLW  12
3050:  MOVWF  01
3052:  MOVFF  FE6,FEE
3056:  DECFSZ 01,F
3058:  BRA    3052
....................            if (atol(cmd_msg)==0) break; 
305A:  CLRF   xD2
305C:  MOVLW  54
305E:  MOVWF  xD1
3060:  CALL   0ADA
3064:  MOVFF  02,D2
3068:  MOVFF  01,D1
306C:  MOVF   xD1,F
306E:  BNZ   3076
3070:  MOVF   xD2,F
3072:  BNZ   3076
3074:  BRA    357E
....................          PORTE.tx_en=1; 
3076:  BSF    F84.2
....................          printf("\r\n DL %ld pages ..",atol(cmd_msg)); 
3078:  CLRF   xD2
307A:  MOVLW  54
307C:  MOVWF  xD1
307E:  CALL   0ADA
3082:  MOVFF  02,D2
3086:  MOVFF  01,D1
308A:  CLRF   xD3
308C:  MOVF   xD3,W
308E:  CALL   0170
3092:  INCF   xD3,F
3094:  MOVWF  00
3096:  MOVF   00,W
3098:  BTFSS  F9E.4
309A:  BRA    3098
309C:  MOVWF  FAD
309E:  MOVLW  06
30A0:  SUBWF  xD3,W
30A2:  BNZ   308C
30A4:  MOVLW  10
30A6:  MOVWF  FE9
30A8:  MOVFF  D2,D5
30AC:  MOVFF  D1,D4
30B0:  CALL   23CC
30B4:  MOVLW  09
30B6:  MOVWF  xD4
30B8:  MOVF   xD4,W
30BA:  CALL   0170
30BE:  INCF   xD4,F
30C0:  MOVWF  00
30C2:  MOVF   00,W
30C4:  BTFSS  F9E.4
30C6:  BRA    30C4
30C8:  MOVWF  FAD
30CA:  MOVLW  12
30CC:  SUBWF  xD4,W
30CE:  BNZ   30B8
....................          tx_delay=TX_DLY_TIME; 
30D0:  MOVLW  01
30D2:  MOVWF  xC2
....................            download_sun_table(atol(cmd_msg)); 
30D4:  CLRF   xD2
30D6:  MOVLW  54
30D8:  MOVWF  xD1
30DA:  CALL   0ADA
30DE:  MOVFF  02,D2
30E2:  MOVFF  01,D1
30E6:  MOVFF  02,D4
30EA:  MOVFF  01,D3
30EE:  GOTO   264C
....................          break;    } 
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
30F2:  BCF    FF2.6
30F4:  BCF    FF2.7
30F6:  BTFSC  FF2.7
30F8:  BRA    30F4
....................          restart_wdt(); 
30FA:  CLRWDT
....................          setup_wdt(WDT_OFF); 
30FC:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
30FE:  CLRF   FEA
3100:  MOVLW  54
3102:  MOVWF  FE9
3104:  CLRF   FE2
3106:  MOVLW  55
3108:  MOVWF  FE1
310A:  MOVLW  12
310C:  MOVWF  01
310E:  MOVFF  FE6,FEE
3112:  DECFSZ 01,F
3114:  BRA    310E
....................          PORTE.tx_en=1; 
3116:  BSF    F84.2
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
3118:  CLRF   xD2
311A:  MOVLW  54
311C:  MOVWF  xD1
311E:  CALL   0ADA
3122:  MOVFF  02,D2
3126:  MOVFF  01,D1
312A:  CLRF   xD3
312C:  MOVF   xD3,W
312E:  CALL   019E
3132:  INCF   xD3,F
3134:  MOVWF  00
3136:  MOVF   00,W
3138:  BTFSS  F9E.4
313A:  BRA    3138
313C:  MOVWF  FAD
313E:  MOVLW  08
3140:  SUBWF  xD3,W
3142:  BNZ   312C
3144:  MOVLW  10
3146:  MOVWF  FE9
3148:  MOVFF  D2,D5
314C:  MOVFF  D1,D4
3150:  CALL   23CC
3154:  MOVLW  3A
3156:  BTFSS  F9E.4
3158:  BRA    3156
315A:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
315C:  MOVLW  01
315E:  MOVWF  xC2
....................          print_page_data(atol(cmd_msg)); 
3160:  CLRF   xD2
3162:  MOVLW  54
3164:  MOVWF  xD1
3166:  CALL   0ADA
316A:  MOVFF  02,D2
316E:  MOVFF  01,D1
3172:  MOVFF  02,D4
3176:  MOVFF  01,D3
317A:  GOTO   2830
....................          enable_interrupts(GLOBAL); 
317E:  MOVLW  C0
3180:  IORWF  FF2,F
....................          restart_wdt(); 
3182:  CLRWDT
....................          setup_wdt(WDT_ON); 
3184:  BSF    FD1.0
....................             break; } 
3186:  BRA    357E
....................         case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3188:  CLRF   FEA
318A:  MOVLW  54
318C:  MOVWF  FE9
318E:  CLRF   FE2
3190:  MOVLW  55
3192:  MOVWF  FE1
3194:  MOVLW  12
3196:  MOVWF  01
3198:  MOVFF  FE6,FEE
319C:  DECFSZ 01,F
319E:  BRA    3198
....................             if (atol(cmd_msg)!=22) break; 
31A0:  CLRF   xD2
31A2:  MOVLW  54
31A4:  MOVWF  xD1
31A6:  CALL   0ADA
31AA:  MOVFF  02,D2
31AE:  MOVF   01,W
31B0:  MOVWF  xD1
31B2:  SUBLW  16
31B4:  BNZ   31BA
31B6:  MOVF   xD2,F
31B8:  BZ    31BC
31BA:  BRA    357E
....................          PORTE.tx_en=1; 
31BC:  BSF    F84.2
....................          printf("\r\ndeleting entire flash data "); 
31BE:  CLRF   xD1
31C0:  MOVF   xD1,W
31C2:  CALL   01C6
31C6:  INCF   xD1,F
31C8:  MOVWF  00
31CA:  MOVF   00,W
31CC:  BTFSS  F9E.4
31CE:  BRA    31CC
31D0:  MOVWF  FAD
31D2:  MOVLW  1D
31D4:  SUBWF  xD1,W
31D6:  BNZ   31C0
....................          tx_delay=TX_DLY_TIME; 
31D8:  MOVLW  01
31DA:  MOVWF  xC2
....................          ext_flash_block_erase(); 
31DC:  GOTO   28CA
....................             break; } 
....................       case 't': { // timer set 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
31E0:  CLRF   FEA
31E2:  MOVLW  54
31E4:  MOVWF  FE9
31E6:  CLRF   FE2
31E8:  MOVLW  55
31EA:  MOVWF  FE1
31EC:  MOVLW  12
31EE:  MOVWF  01
31F0:  MOVFF  FE6,FEE
31F4:  DECFSZ 01,F
31F6:  BRA    31F0
....................          timer_sec=atoi32(cmd_msg); 
31F8:  CLRF   xD2
31FA:  MOVLW  54
31FC:  MOVWF  xD1
31FE:  GOTO   290A
3202:  MOVFF  03,23
3206:  MOVFF  02,22
320A:  MOVFF  01,21
320E:  MOVFF  00,20
....................          lcd_send_cmd(0,0x02); 
3212:  CLRF   xEE
3214:  MOVLW  02
3216:  MOVWF  xEF
3218:  CALL   09D6
321C:  CLRF   18
321E:  BTFSC  FF2.7
3220:  BSF    18.7
3222:  BCF    FF2.7
....................          next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
3224:  MOVFF  23,EE
3228:  MOVFF  22,ED
322C:  MOVFF  21,EC
3230:  MOVFF  20,EB
3234:  MOVLW  07
3236:  MOVWF  xF2
3238:  MOVLW  86
323A:  MOVWF  xF1
323C:  MOVLW  1F
323E:  MOVWF  xF0
3240:  MOVLW  80
3242:  MOVWF  xEF
3244:  CALL   0340
3248:  BTFSC  18.7
324A:  BSF    FF2.7
324C:  MOVFF  FEF,D1
3250:  MOVFF  FEC,D2
3254:  MOVFF  FEC,D3
3258:  MOVFF  FEC,D4
325C:  MOVFF  D4,E4
3260:  MOVFF  D3,E3
3264:  MOVFF  D2,E2
3268:  MOVFF  D1,E1
326C:  RCALL  2BA8
326E:  MOVFF  02,D3
3272:  MOVFF  01,D2
3276:  MOVFF  02,E2
327A:  MOVFF  01,E1
327E:  RCALL  2C42
3280:  MOVFF  03,D6
3284:  MOVFF  02,D5
3288:  MOVFF  01,D4
328C:  MOVFF  00,D3
3290:  MOVFF  FEA,D8
3294:  MOVFF  FE9,D7
3298:  MOVFF  03,F8
329C:  MOVFF  02,F7
32A0:  MOVFF  01,F6
32A4:  MOVFF  00,F5
32A8:  CLRF   xFC
32AA:  CLRF   xFB
32AC:  MOVLW  01
32AE:  MOVWF  xFA
32B0:  MOVLW  C2
32B2:  MOVWF  xF9
32B4:  CALL   1330
32B8:  MOVFF  D8,FEA
32BC:  MOVFF  D7,FE9
32C0:  MOVFF  03,6D
32C4:  MOVFF  02,6C
32C8:  MOVFF  01,6B
32CC:  MOVFF  00,6A
....................          enable_interrupts(INT_TIMER1);    
32D0:  BSF    F9D.0
....................          enable_interrupts(GLOBAL);  
32D2:  MOVLW  C0
32D4:  IORWF  FF2,F
....................          flag.task1_armed=true; 
32D6:  BSF    1F.0
....................          write_eeprom_data(0); // save full_stroke_tick and current_position 
32D8:  CLRF   xD1
32DA:  CALL   0820
....................          flag.setup_required =false; 
32DE:  BCF    1F.4
....................          break; 
32E0:  BRA    357E
....................       } 
....................       case 'h' : { //return home 
....................          move_act(2000,9000,move_act_time_out,1,0); // move actuator to west 
32E2:  MOVLW  07
32E4:  MOVWF  xD4
32E6:  MOVLW  D0
32E8:  MOVWF  xD3
32EA:  MOVLW  23
32EC:  MOVWF  xD6
32EE:  MOVLW  28
32F0:  MOVWF  xD5
32F2:  MOVFF  C1,D8
32F6:  MOVFF  C0,D7
32FA:  MOVLW  01
32FC:  MOVWF  xD9
32FE:  CLRF   xDA
3300:  CALL   21A4
....................          move_act(2000,9000,move_act_time_out,0,0); // move actuator to home position 
3304:  MOVLW  07
3306:  MOVWF  xD4
3308:  MOVLW  D0
330A:  MOVWF  xD3
330C:  MOVLW  23
330E:  MOVWF  xD6
3310:  MOVLW  28
3312:  MOVWF  xD5
3314:  MOVFF  C1,D8
3318:  MOVFF  C0,D7
331C:  CLRF   xD9
331E:  CLRF   xDA
3320:  CALL   21A4
....................          FULL_STROKE_TICK= actuator_pulse; 
3324:  MOVFF  C9,BB
3328:  MOVFF  C8,BA
....................          current_act_position =0; 
332C:  CLRF   x6F
332E:  CLRF   x6E
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
3330:  MOVLW  01
3332:  MOVWF  xD1
3334:  CALL   0820
....................          break; 
3338:  BRA    357E
....................       } 
.................... /* 
....................       case 'g': { 
....................          print_date_time(); 
....................           break; 
....................       } 
....................       case 'a': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          PORTE.tx_en=1; 
....................          printf("\r\n   Sun angle %u, stroke length =%f",atoi(cmd_msg),actuator_length(atoi(cmd_msg))); 
....................          tx_delay=TX_DLY_TIME; 
....................          break; 
....................       } 
.................... */ 
....................       case 's': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
333A:  CLRF   FEA
333C:  MOVLW  54
333E:  MOVWF  FE9
3340:  CLRF   FE2
3342:  MOVLW  55
3344:  MOVWF  FE1
3346:  MOVLW  12
3348:  MOVWF  01
334A:  MOVFF  FE6,FEE
334E:  DECFSZ 01,F
3350:  BRA    334A
....................             if (atol(cmd_msg)!=22) break; 
3352:  CLRF   xD2
3354:  MOVLW  54
3356:  MOVWF  xD1
3358:  CALL   0ADA
335C:  MOVFF  02,D2
3360:  MOVF   01,W
3362:  MOVWF  xD1
3364:  SUBLW  16
3366:  BNZ   336C
3368:  MOVF   xD2,F
336A:  BZ    336E
336C:  BRA    357E
....................          write_eeprom_data(1); 
336E:  MOVLW  01
3370:  MOVWF  xD1
3372:  CALL   0820
....................          break; 
3376:  BRA    357E
....................       } 
....................       case 'y': { //adc conversion 
....................          set_adc_channel( 0 ); 
3378:  MOVLW  00
337A:  MOVWF  01
337C:  MOVF   FC2,W
337E:  ANDLW  C7
3380:  IORWF  01,W
3382:  MOVWF  FC2
....................          delay_us(20); 
3384:  MOVLW  10
3386:  MOVWF  00
3388:  DECFSZ 00,F
338A:  BRA    3388
338C:  NOP   
....................          current_measured = (read_adc()); 
338E:  BSF    FC2.2
3390:  BTFSC  FC2.2
3392:  BRA    3390
3394:  MOVFF  FC3,C3
3398:  MOVFF  FC4,C4
....................          printf("\r\nADC= %lu",current_measured); 
339C:  CLRF   xD1
339E:  MOVF   xD1,W
33A0:  CALL   01FE
33A4:  INCF   xD1,F
33A6:  MOVWF  00
33A8:  MOVF   00,W
33AA:  BTFSS  F9E.4
33AC:  BRA    33AA
33AE:  MOVWF  FAD
33B0:  MOVLW  07
33B2:  SUBWF  xD1,W
33B4:  BNZ   339E
33B6:  MOVLW  10
33B8:  MOVWF  FE9
33BA:  MOVFF  C4,D6
33BE:  MOVFF  C3,D5
33C2:  RCALL  2CCA
....................          break; 
33C4:  BRA    357E
....................       } 
....................       case 'w': { //buffer1 read 
....................          //ext_flash_buffer1_write(0x00,0x00, 1); 
....................          //ext_flash_buffer1_read(); 
....................          //ext_flash_buffer1_write(0x12,0xAA, 0); 
....................          disable_interrupts(GLOBAL); 
33C6:  BCF    FF2.6
33C8:  BCF    FF2.7
33CA:  BTFSC  FF2.7
33CC:  BRA    33C8
....................          restart_wdt(); 
33CE:  CLRWDT
....................          setup_wdt(WDT_OFF); 
33D0:  BCF    FD1.0
....................          ext_flash_buffer1_read(); 
33D2:  BRA    2D6E
....................          enable_interrupts(GLOBAL); 
33D4:  MOVLW  C0
33D6:  IORWF  FF2,F
....................          restart_wdt(); 
33D8:  CLRWDT
....................          setup_wdt(WDT_ON); 
33DA:  BSF    FD1.0
....................  
....................          //ext_flash_write_buffer1_to_main_memory(1024); 
....................          break; 
33DC:  BRA    357E
....................       } 
....................       case 'i': { //adc conversion 
....................          printf("\r\nAct:%lu/%lu",current_act_position,FULL_STROKE_TICK); 
33DE:  CLRF   xD1
33E0:  MOVF   xD1,W
33E2:  CALL   0224
33E6:  INCF   xD1,F
33E8:  MOVWF  00
33EA:  MOVF   00,W
33EC:  BTFSS  F9E.4
33EE:  BRA    33EC
33F0:  MOVWF  FAD
33F2:  MOVLW  06
33F4:  SUBWF  xD1,W
33F6:  BNZ   33E0
33F8:  MOVLW  10
33FA:  MOVWF  FE9
33FC:  MOVFF  6F,D6
3400:  MOVFF  6E,D5
3404:  RCALL  2CCA
3406:  MOVLW  2F
3408:  BTFSS  F9E.4
340A:  BRA    3408
340C:  MOVWF  FAD
340E:  MOVLW  10
3410:  MOVWF  FE9
3412:  MOVFF  BB,D6
3416:  MOVFF  BA,D5
341A:  RCALL  2CCA
....................          printf("\r\nRestart:%lu",startup_counter); 
341C:  CLRF   xD1
341E:  MOVF   xD1,W
3420:  CALL   024C
3424:  INCF   xD1,F
3426:  MOVWF  00
3428:  MOVF   00,W
342A:  BTFSS  F9E.4
342C:  BRA    342A
342E:  MOVWF  FAD
3430:  MOVLW  0A
3432:  SUBWF  xD1,W
3434:  BNZ   341E
3436:  MOVLW  10
3438:  MOVWF  FE9
343A:  MOVFF  C7,D6
343E:  MOVFF  C6,D5
3442:  RCALL  2CCA
....................          printf("\r\nCurrent:%lu (%d)",current_measured/n_avg_current_measured, n_avg_current_measured); 
3444:  MOVFF  C4,D4
3448:  MOVFF  C3,D3
344C:  CLRF   xD6
344E:  MOVFF  C5,D5
3452:  RCALL  2DF4
3454:  MOVFF  02,D2
3458:  MOVFF  01,D1
345C:  CLRF   xD3
345E:  MOVF   xD3,W
3460:  CALL   0274
3464:  INCF   xD3,F
3466:  MOVWF  00
3468:  MOVF   00,W
346A:  BTFSS  F9E.4
346C:  BRA    346A
346E:  MOVWF  FAD
3470:  MOVLW  0A
3472:  SUBWF  xD3,W
3474:  BNZ   345E
3476:  MOVLW  10
3478:  MOVWF  FE9
347A:  MOVFF  D2,D6
347E:  MOVFF  D1,D5
3482:  RCALL  2CCA
3484:  MOVLW  20
3486:  BTFSS  F9E.4
3488:  BRA    3486
348A:  MOVWF  FAD
348C:  MOVLW  28
348E:  BTFSS  F9E.4
3490:  BRA    348E
3492:  MOVWF  FAD
3494:  MOVFF  C5,D4
3498:  MOVLW  1F
349A:  MOVWF  xD5
349C:  CALL   0750
34A0:  MOVLW  29
34A2:  BTFSS  F9E.4
34A4:  BRA    34A2
34A6:  MOVWF  FAD
....................          printf("\r\nTimer:%lu",timer_sec); 
34A8:  CLRF   xD1
34AA:  MOVF   xD1,W
34AC:  CALL   02A2
34B0:  INCF   xD1,F
34B2:  MOVWF  00
34B4:  MOVF   00,W
34B6:  BTFSS  F9E.4
34B8:  BRA    34B6
34BA:  MOVWF  FAD
34BC:  MOVLW  08
34BE:  SUBWF  xD1,W
34C0:  BNZ   34AA
34C2:  MOVLW  41
34C4:  MOVWF  FE9
34C6:  MOVFF  23,D5
34CA:  MOVFF  22,D4
34CE:  MOVFF  21,D3
34D2:  MOVFF  20,D2
34D6:  BRA    2E36
34D8:  CLRF   18
34DA:  BTFSC  FF2.7
34DC:  BSF    18.7
34DE:  BCF    FF2.7
....................          printf("\r\n#Day:%lu",find_day_number((timer_sec)%SEC_IN_4_YEARS)); 
34E0:  MOVFF  23,EE
34E4:  MOVFF  22,ED
34E8:  MOVFF  21,EC
34EC:  MOVFF  20,EB
34F0:  MOVLW  07
34F2:  MOVWF  xF2
34F4:  MOVLW  86
34F6:  MOVWF  xF1
34F8:  MOVLW  1F
34FA:  MOVWF  xF0
34FC:  MOVLW  80
34FE:  MOVWF  xEF
3500:  CALL   0340
3504:  BTFSC  18.7
3506:  BSF    FF2.7
3508:  MOVFF  FEF,D1
350C:  MOVFF  FEC,D2
3510:  MOVFF  FEC,D3
3514:  MOVFF  FEC,D4
3518:  MOVFF  D4,E4
351C:  MOVFF  D3,E3
3520:  MOVFF  D2,E2
3524:  MOVFF  D1,E1
3528:  CALL   2BA8
352C:  MOVFF  02,D3
3530:  MOVFF  01,D2
3534:  CLRF   xD4
3536:  MOVF   xD4,W
3538:  CALL   02C8
353C:  INCF   xD4,F
353E:  MOVWF  00
3540:  MOVF   00,W
3542:  BTFSS  F9E.4
3544:  BRA    3542
3546:  MOVWF  FAD
3548:  MOVLW  07
354A:  SUBWF  xD4,W
354C:  BNZ   3536
354E:  MOVLW  10
3550:  MOVWF  FE9
3552:  MOVFF  D3,D6
3556:  MOVFF  D2,D5
355A:  CALL   2CCA
....................  
....................          break; 
355E:  BRA    357E
....................       } 
....................       case 'c': { //clear write buffer 
....................           ext_flash_buffer1_write(0xAA,0,255); 
3560:  MOVLW  AA
3562:  MOVWF  xDC
3564:  CLRF   xDD
3566:  MOVLW  FF
3568:  MOVWF  xDE
356A:  RCALL  2F00
....................          break; 
356C:  BRA    357E
....................       } 
....................  
....................       case 'x': { //stop timer 
....................          flag.setup_required=true;          
356E:  BSF    1F.4
....................          restart_wdt(); 
3570:  CLRWDT
....................          setup_wdt(WDT_OFF); 
3572:  BCF    FD1.0
....................          break; 
3574:  BRA    357E
....................       } 
....................  
....................       case 'o': { //start timer 
....................          flag.setup_required=false;          
3576:  BCF    1F.4
....................          setup_wdt(WDT_ON); 
3578:  BSF    FD1.0
....................          restart_wdt(); 
357A:  CLRWDT
....................          break; 
357C:  BRA    357E
....................       } 
....................  
....................  
....................       } 
....................        
....................    } 
357E:  RETLW  00
....................  
.................... void print_len_and_tick() 
.................... { 
....................    lcd_gotoxy(0,3); 
*
5C9A:  CLRF   xEA
5C9C:  MOVLW  03
5C9E:  MOVWF  xEB
5CA0:  CALL   0CC2
....................    itoa((int16)(al),10,tmp_str); 
5CA4:  MOVFF  BF,14D
5CA8:  MOVFF  BE,14C
5CAC:  MOVFF  BD,14B
5CB0:  MOVFF  BC,14A
5CB4:  CALL   43B0
5CB8:  MOVFF  02,D2
5CBC:  MOVFF  01,D1
5CC0:  CLRF   xE9
5CC2:  CLRF   xE8
5CC4:  MOVFF  02,E7
5CC8:  MOVFF  01,E6
5CCC:  MOVLW  0A
5CCE:  MOVWF  xEA
5CD0:  CLRF   xEC
5CD2:  MOVLW  2C
5CD4:  MOVWF  xEB
5CD6:  CALL   14A6
....................     printf(lcd_putc,"L=%s.",tmp_str); 
5CDA:  MOVLW  4C
5CDC:  MOVWF  xE9
5CDE:  CALL   0CEA
5CE2:  MOVLW  3D
5CE4:  MOVWF  xE9
5CE6:  CALL   0CEA
5CEA:  CLRF   FEA
5CEC:  MOVLW  2C
5CEE:  MOVWF  FE9
5CF0:  MOVLW  00
5CF2:  IORWF  FEF,W
5CF4:  BZ    5D16
5CF6:  MOVFF  FEA,D2
5CFA:  MOVFF  FE9,D1
5CFE:  MOVFF  FEF,E9
5D02:  CALL   0CEA
5D06:  MOVFF  D2,FEA
5D0A:  MOVFF  D1,FE9
5D0E:  INCF   FE9,F
5D10:  BTFSC  FD8.2
5D12:  INCF   FEA,F
5D14:  BRA    5CF0
5D16:  MOVLW  2E
5D18:  MOVWF  xE9
5D1A:  CALL   0CEA
....................    itoa((int16)(al*100.0)%100,10,tmp_str); 
5D1E:  MOVFF  BF,151
5D22:  MOVFF  BE,150
5D26:  MOVFF  BD,14F
5D2A:  MOVFF  BC,14E
5D2E:  MOVLB  1
5D30:  CLRF   x55
5D32:  CLRF   x54
5D34:  MOVLW  48
5D36:  MOVWF  x53
5D38:  MOVLW  85
5D3A:  MOVWF  x52
5D3C:  MOVLB  0
5D3E:  CALL   0E24
5D42:  MOVFF  03,14D
5D46:  MOVFF  02,14C
5D4A:  MOVFF  01,14B
5D4E:  MOVFF  00,14A
5D52:  CALL   43B0
5D56:  MOVFF  02,D2
5D5A:  MOVFF  01,D1
5D5E:  MOVFF  02,D4
5D62:  MOVFF  01,D3
5D66:  CLRF   xD6
5D68:  MOVLW  64
5D6A:  MOVWF  xD5
5D6C:  CALL   2DF4
5D70:  MOVFF  00,D2
5D74:  MOVFF  03,D3
5D78:  CLRF   xE9
5D7A:  CLRF   xE8
5D7C:  MOVFF  03,E7
5D80:  MOVFF  00,E6
5D84:  MOVLW  0A
5D86:  MOVWF  xEA
5D88:  CLRF   xEC
5D8A:  MOVLW  2C
5D8C:  MOVWF  xEB
5D8E:  CALL   14A6
....................     printf(lcd_putc,"%scm",tmp_str); 
5D92:  CLRF   FEA
5D94:  MOVLW  2C
5D96:  MOVWF  FE9
5D98:  MOVLW  00
5D9A:  IORWF  FEF,W
5D9C:  BZ    5DBE
5D9E:  MOVFF  FEA,D2
5DA2:  MOVFF  FE9,D1
5DA6:  MOVFF  FEF,E9
5DAA:  CALL   0CEA
5DAE:  MOVFF  D2,FEA
5DB2:  MOVFF  D1,FE9
5DB6:  INCF   FE9,F
5DB8:  BTFSC  FD8.2
5DBA:  INCF   FEA,F
5DBC:  BRA    5D98
5DBE:  MOVLW  63
5DC0:  MOVWF  xE9
5DC2:  CALL   0CEA
5DC6:  MOVLW  6D
5DC8:  MOVWF  xE9
5DCA:  CALL   0CEA
....................    lcd_gotoxy(11,3); 
5DCE:  MOVLW  0B
5DD0:  MOVWF  xEA
5DD2:  MOVLW  03
5DD4:  MOVWF  xEB
5DD6:  CALL   0CC2
....................     printf(lcd_putc,"*%4lu",target_act_position); 
5DDA:  MOVLW  2A
5DDC:  MOVWF  xE9
5DDE:  CALL   0CEA
5DE2:  MOVLW  01
5DE4:  MOVWF  FE9
5DE6:  MOVFF  71,E1
5DEA:  MOVFF  70,E0
5DEE:  CALL   0D3C
....................  
.................... } 
5DF2:  RETLW  00
....................  
....................  
.................... void main() { 
5DF4:  CLRF   FF8
5DF6:  BCF    FD0.7
5DF8:  BSF    0D.7
5DFA:  CLRF   FEA
5DFC:  CLRF   FE9
5DFE:  MOVLW  0A
5E00:  MOVWF  FAF
5E02:  MOVLW  A6
5E04:  MOVWF  FAC
5E06:  MOVLW  90
5E08:  MOVWF  FAB
5E0A:  BSF    FC1.0
5E0C:  BSF    FC1.1
5E0E:  BSF    FC1.2
5E10:  BCF    FC1.3
5E12:  MOVLW  07
5E14:  MOVWF  FB4
5E16:  CLRF   19
5E18:  CLRF   1A
5E1A:  CLRF   20
5E1C:  CLRF   21
5E1E:  CLRF   22
5E20:  CLRF   23
5E22:  CLRF   24
5E24:  CLRF   25
5E26:  CLRF   26
5E28:  CLRF   27
5E2A:  CLRF   28
5E2C:  CLRF   29
5E2E:  CLRF   2A
5E30:  CLRF   2B
5E32:  CLRF   x68
5E34:  CLRF   x69
5E36:  CLRF   x6E
5E38:  CLRF   x6F
5E3A:  CLRF   x70
5E3C:  CLRF   x71
5E3E:  CLRF   xBA
5E40:  CLRF   xBB
5E42:  MOVLW  08
5E44:  MOVWF  xC0
5E46:  CLRF   xC1
5E48:  CLRF   xC2
5E4A:  CLRF   xC3
5E4C:  CLRF   xC4
5E4E:  CLRF   xC5
5E50:  CLRF   xC6
5E52:  CLRF   xC7
5E54:  CLRF   xC8
5E56:  CLRF   xC9
....................     unsigned int8 solar_angle; 
....................    int16 tick=0; 
5E58:  CLRF   xCC
5E5A:  CLRF   xCD
....................    int16 temp_mem; 
....................    int8 i; 
....................     set_tris_d(0x00); // all D are output 
5E5C:  MOVLW  00
5E5E:  MOVWF  F95
....................    set_tris_e(0b00000010); // RE1 = emergnecy input 
5E60:  BCF    F96.0
5E62:  BSF    F96.1
5E64:  BCF    F96.2
....................    set_tris_a(0b11111111); // A0 -1 is output 
5E66:  MOVLW  FF
5E68:  MOVWF  F92
....................    set_tris_b(0xA0); 
5E6A:  MOVLW  A0
5E6C:  MOVWF  F93
....................    set_tris_c(0b10010000); 
5E6E:  MOVLW  90
5E70:  MOVWF  F94
....................    timer_sec=0; 
5E72:  CLRF   23
5E74:  CLRF   22
5E76:  CLRF   21
5E78:  CLRF   20
5E7A:  CLRF   18
5E7C:  BTFSC  FF2.7
5E7E:  BSF    18.7
5E80:  BCF    FF2.7
....................    delay_ms(200); 
5E82:  MOVLW  C8
5E84:  MOVWF  xEA
5E86:  CALL   04BC
5E8A:  BTFSC  18.7
5E8C:  BSF    FF2.7
....................    read_eeprom_data(); 
5E8E:  GOTO   05BC
....................    restart_wdt(); 
5E92:  CLRWDT
....................    setup_wdt(WDT_OFF); 
5E94:  BCF    FD1.0
....................    setup_adc_ports(AN0); 
5E96:  BCF    FC1.0
5E98:  BSF    FC1.1
5E9A:  BSF    FC1.2
5E9C:  BSF    FC1.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
5E9E:  BCF    FC1.6
5EA0:  BSF    FC2.6
5EA2:  BSF    FC2.7
5EA4:  BSF    FC1.7
5EA6:  BSF    FC2.0
....................    set_adc_channel( 0 ); 
5EA8:  MOVLW  00
5EAA:  MOVWF  01
5EAC:  MOVF   FC2,W
5EAE:  ANDLW  C7
5EB0:  IORWF  01,W
5EB2:  MOVWF  FC2
....................    current_measured =0; 
5EB4:  CLRF   xC4
5EB6:  CLRF   xC3
....................    startup_counter++; 
5EB8:  INCF   xC6,F
5EBA:  BTFSC  FD8.2
5EBC:  INCF   xC7,F
....................    printf("\r\nVer2.1 Restart Cause:%3d",restart_cause()); 
5EBE:  MOVF   FD0,W
5EC0:  ANDLW  0F
5EC2:  BTFSS  FD0.4
5EC4:  MOVLW  00
5EC6:  BSF    FD0.0
5EC8:  BSF    FD0.1
5ECA:  BSF    FD0.4
5ECC:  BSF    FD8.3
5ECE:  BSF    FD8.4
5ED0:  MOVWF  xD1
5ED2:  CLRF   xD2
5ED4:  MOVF   xD2,W
5ED6:  CALL   02EE
5EDA:  INCF   xD2,F
5EDC:  MOVWF  00
5EDE:  MOVF   00,W
5EE0:  BTFSS  F9E.4
5EE2:  BRA    5EE0
5EE4:  MOVWF  FAD
5EE6:  MOVLW  17
5EE8:  SUBWF  xD2,W
5EEA:  BNZ   5ED4
5EEC:  MOVFF  D1,D4
5EF0:  MOVLW  13
5EF2:  MOVWF  xD5
5EF4:  CALL   0750
....................    write_eeprom_data(0); 
5EF8:  CLRF   xD1
5EFA:  CALL   0820
....................    output_low(CCW); 
5EFE:  BCF    F93.4
5F00:  BCF    F8A.4
....................    output_low(EN0); 
5F02:  BCF    F93.0
5F04:  BCF    F8A.0
....................    output_low(EN1); 
5F06:  BCF    F93.1
5F08:  BCF    F8A.1
....................    output_low(EN2); 
5F0A:  BCF    F93.2
5F0C:  BCF    F8A.2
....................    output_low(EN3); 
5F0E:  BCF    F93.3
5F10:  BCF    F8A.3
....................    PORTD.ps_en=0; 
5F12:  BCF    F83.4
....................    PORTD.disp_en=0;  
5F14:  BCF    F83.7
....................    PORTE.tx_en=1; 
5F16:  BSF    F84.2
....................    lcd_init(); 
5F18:  CALL   09FE
....................    init_ext_flash(); 
5F1C:  GOTO   0AAE
....................    restart_wdt(); 
5F20:  CLRWDT
....................    portd.pwr_ctrl=0; 
5F22:  BCF    F83.6
....................     output_high(FLASH_SELECT); 
5F24:  BCF    F94.2
5F26:  BSF    F8B.2
....................     setup_timer_0(RTCC_DIV_32); 
5F28:  MOVLW  84
5F2A:  MOVWF  FD5
....................    T1CON = 0x8F; 
5F2C:  MOVLW  8F
5F2E:  MOVWF  FCD
....................    //setup_timer_0(RTCC_DIV_1); 
....................     disable_interrupts(INT_TIMER0);   // Setup interrupt on falling edge 
5F30:  BCF    FF2.5
....................     disable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
5F32:  BCF    F9D.0
....................     disable_interrupts(GLOBAL); 
5F34:  BCF    FF2.6
5F36:  BCF    FF2.7
5F38:  BTFSC  FF2.7
5F3A:  BRA    5F36
....................    flag=0; 
5F3C:  CLRF   1F
....................     strcpy(cmd_msg,""); 
5F3E:  CLRF   FEA
5F40:  MOVLW  54
5F42:  MOVWF  FE9
5F44:  MOVFF  FF2,D1
5F48:  BCF    FF2.7
5F4A:  MOVLW  00
5F4C:  CALL   0324
5F50:  TBLRD*-
5F52:  TBLRD*+
5F54:  MOVF   FF5,W
5F56:  MOVWF  FEE
5F58:  IORLW  00
5F5A:  BNZ   5F52
5F5C:  BTFSC  xD1.7
5F5E:  BSF    FF2.7
....................    if (timer_sec ==0x00000000) 
5F60:  MOVF   20,F
5F62:  BNZ   5F74
5F64:  MOVF   21,F
5F66:  BNZ   5F74
5F68:  MOVF   22,F
5F6A:  BNZ   5F74
5F6C:  MOVF   23,F
5F6E:  BNZ   5F74
....................       flag.setup_required = true; 
5F70:  BSF    1F.4
....................    else 
5F72:  BRA    5F76
....................       flag.setup_required = false; 
5F74:  BCF    1F.4
....................  
.................... ///////////////// 
....................    enable_interrupts(INT_RDA); 
5F76:  BSF    F9D.5
....................    enable_interrupts(INT_TIMER1);   
5F78:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);  
5F7A:  MOVLW  C0
5F7C:  IORWF  FF2,F
....................    while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
5F7E:  BTFSS  1F.4
5F80:  BRA    5F8C
5F82:  BTFSS  1F.3
5F84:  BRA    5F8A
5F86:  CALL   2F5E
5F8A:  BRA    5F7E
....................    setup_wdt(WDT_ON); 
5F8C:  BSF    FD1.0
5F8E:  CLRF   18
5F90:  BTFSC  FF2.7
5F92:  BSF    18.7
5F94:  BCF    FF2.7
....................    next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
5F96:  MOVFF  23,EE
5F9A:  MOVFF  22,ED
5F9E:  MOVFF  21,EC
5FA2:  MOVFF  20,EB
5FA6:  MOVLW  07
5FA8:  MOVWF  xF2
5FAA:  MOVLW  86
5FAC:  MOVWF  xF1
5FAE:  MOVLW  1F
5FB0:  MOVWF  xF0
5FB2:  MOVLW  80
5FB4:  MOVWF  xEF
5FB6:  CALL   0340
5FBA:  BTFSC  18.7
5FBC:  BSF    FF2.7
5FBE:  MOVFF  FEF,D1
5FC2:  MOVFF  FEC,D2
5FC6:  MOVFF  FEC,D3
5FCA:  MOVFF  FEC,D4
5FCE:  MOVFF  D4,E4
5FD2:  MOVFF  D3,E3
5FD6:  MOVFF  D2,E2
5FDA:  MOVFF  D1,E1
5FDE:  CALL   2BA8
5FE2:  MOVFF  02,D3
5FE6:  MOVFF  01,D2
5FEA:  MOVFF  02,E2
5FEE:  MOVFF  01,E1
5FF2:  CALL   2C42
5FF6:  MOVFF  03,D6
5FFA:  MOVFF  02,D5
5FFE:  MOVFF  01,D4
6002:  MOVFF  00,D3
6006:  MOVFF  FEA,D8
600A:  MOVFF  FE9,D7
600E:  MOVFF  03,F8
6012:  MOVFF  02,F7
6016:  MOVFF  01,F6
601A:  MOVFF  00,F5
601E:  CLRF   xFC
6020:  CLRF   xFB
6022:  MOVLW  01
6024:  MOVWF  xFA
6026:  MOVLW  C2
6028:  MOVWF  xF9
602A:  CALL   1330
602E:  MOVFF  D8,FEA
6032:  MOVFF  D7,FE9
6036:  MOVFF  03,6D
603A:  MOVFF  02,6C
603E:  MOVFF  01,6B
6042:  MOVFF  00,6A
....................  
.................... ////////////////// 
....................    // take sun angle and calculate the length of actuator needed to push 
....................    // also need counter of reed switch 
....................    flag.task1_armed =true; 
6046:  BSF    1F.0
6048:  CLRF   18
604A:  BTFSC  FF2.7
604C:  BSF    18.7
604E:  BCF    FF2.7
....................    ext_flash_main_memory_to_buffer1(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
6050:  MOVFF  23,EE
6054:  MOVFF  22,ED
6058:  MOVFF  21,EC
605C:  MOVFF  20,EB
6060:  MOVLW  07
6062:  MOVWF  xF2
6064:  MOVLW  86
6066:  MOVWF  xF1
6068:  MOVLW  1F
606A:  MOVWF  xF0
606C:  MOVLW  80
606E:  MOVWF  xEF
6070:  CALL   0340
6074:  BTFSC  18.7
6076:  BSF    FF2.7
6078:  MOVFF  FEF,D1
607C:  MOVFF  FEC,D2
6080:  MOVFF  FEC,D3
6084:  MOVFF  FEC,D4
6088:  MOVFF  D4,E4
608C:  MOVFF  D3,E3
6090:  MOVFF  D2,E2
6094:  MOVFF  D1,E1
6098:  CALL   2BA8
609C:  MOVFF  02,D3
60A0:  MOVFF  01,D2
60A4:  BCF    FD8.0
60A6:  RRCF   02,W
60A8:  MOVWF  03
60AA:  RRCF   01,W
60AC:  MOVWF  02
60AE:  ADDLW  F2
60B0:  MOVWF  xD4
60B2:  MOVLW  03
60B4:  ADDWFC 03,W
60B6:  MOVWF  xD5
60B8:  MOVWF  xD7
60BA:  MOVFF  D4,D6
60BE:  GOTO   35D2
....................  
....................    while(1) { 
....................  
....................       while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
60C2:  BTFSS  1F.4
60C4:  BRA    60D0
60C6:  BTFSS  1F.3
60C8:  BRA    60CE
60CA:  CALL   2F5E
60CE:  BRA    60C2
....................  
....................       if (flag.update_time) { 
60D0:  BTFSS  1F.1
60D2:  BRA    60DA
....................          flag.update_time = false; 
60D4:  BCF    1F.1
....................          print_date_time(); 
60D6:  CALL   16DC
....................       } 
....................  
....................       if (flag.measured_current) {    
60DA:  BTFSS  1F.7
60DC:  BRA    60F0
....................          flag.measured_current = false; 
60DE:  BCF    1F.7
....................          current_measured += (read_adc()); 
60E0:  BSF    FC2.2
60E2:  BTFSC  FC2.2
60E4:  BRA    60E2
60E6:  MOVF   FC3,W
60E8:  ADDWF  xC3,F
60EA:  MOVF   FC4,W
60EC:  ADDWFC xC4,F
....................          n_avg_current_measured++; 
60EE:  INCF   xC5,F
....................       } 
....................  
....................       if (flag.cmd_posted) { 
60F0:  BTFSS  1F.3
60F2:  BRA    60FA
....................          flag.cmd_posted = false; 
60F4:  BCF    1F.3
....................          process_cmd_msg(); 
60F6:  CALL   2F5E
....................       } 
....................       if (flag.reset_rs232) { 
60FA:  BTFSS  1F.5
60FC:  BRA    6104
....................          flag.reset_rs232 =false; 
60FE:  BCF    1F.5
....................           init_rs232(); 
6100:  GOTO   360A
....................       } 
....................       if (input(WALL_PWR)==false) { 
6104:  BSF    F92.5
6106:  BTFSC  F80.5
6108:  BRA    610E
....................          flag.pwr_state = false; 
610A:  BCF    1F.6
....................       } else { 
610C:  BRA    6118
....................          if (flag.pwr_state==false) 
610E:  BTFSC  1F.6
6110:  BRA    6116
....................             lcd_init(); 
6112:  CALL   09FE
....................          flag.pwr_state=true; 
6116:  BSF    1F.6
....................       } 
....................       if (tx_delay==0) PORTE.tx_en=0; 
6118:  MOVF   xC2,F
611A:  BTFSC  FD8.2
611C:  BCF    F84.2
....................       if (flag.task1_armed) { 
611E:  BTFSS  1F.0
6120:  BRA    646A
....................          flag.task1_armed = false; 
6122:  BCF    1F.0
....................          solar_angle= task1(); 
6124:  CALL   3872
6128:  MOVFF  01,CB
....................  
....................          if ((solar_angle>30) && (solar_angle<150)) { 
612C:  MOVF   xCB,W
612E:  SUBLW  1E
6130:  BC    615C
6132:  MOVF   xCB,W
6134:  SUBLW  95
6136:  BNC   615C
....................             lcd_gotoxy(0,3); 
6138:  CLRF   xEA
613A:  MOVLW  03
613C:  MOVWF  xEB
613E:  CALL   0CC2
....................             al=actuator_length(solar_angle); 
6142:  MOVFF  CB,D3
6146:  CALL   498A
614A:  MOVFF  03,BF
614E:  MOVFF  02,BE
6152:  MOVFF  01,BD
6156:  MOVFF  00,BC
....................          } else { 
615A:  BRA    61D0
....................             if ((solar_angle>0) && (solar_angle<=30)) { 
615C:  MOVF   xCB,F
615E:  BZ    6192
6160:  MOVF   xCB,W
6162:  SUBLW  1E
6164:  BNC   6192
....................                al=actuator_length(90-get_backtrack_angle(90-solar_angle)); 
6166:  MOVLW  5A
6168:  BSF    FD8.0
616A:  SUBFWB xCB,W
616C:  MOVWF  xD1
616E:  MOVWF  xD2
6170:  RCALL  5986
6172:  MOVLW  5A
6174:  BSF    FD8.0
6176:  SUBFWB 01,W
6178:  MOVWF  xD2
617A:  MOVWF  xD3
617C:  CALL   498A
6180:  MOVFF  03,BF
6184:  MOVFF  02,BE
6188:  MOVFF  01,BD
618C:  MOVFF  00,BC
....................             } else if ((solar_angle>=150) && (solar_angle<=180)) { 
6190:  BRA    61D0
6192:  MOVF   xCB,W
6194:  SUBLW  95
6196:  BC    61D0
6198:  MOVF   xCB,W
619A:  SUBLW  B4
619C:  BNC   61D0
....................                lcd_gotoxy(0,3); 
619E:  CLRF   xEA
61A0:  MOVLW  03
61A2:  MOVWF  xEB
61A4:  CALL   0CC2
....................                al=actuator_length(90+get_backtrack_angle(solar_angle-90)); 
61A8:  MOVLW  5A
61AA:  SUBWF  xCB,W
61AC:  MOVWF  xD1
61AE:  MOVWF  xD2
61B0:  CALL   5986
61B4:  MOVLW  5A
61B6:  ADDWF  01,W
61B8:  MOVWF  xD2
61BA:  MOVWF  xD3
61BC:  CALL   498A
61C0:  MOVFF  03,BF
61C4:  MOVFF  02,BE
61C8:  MOVFF  01,BD
61CC:  MOVFF  00,BC
....................             } 
....................          } 
....................          if((al >= MIN_STROKE) && (al <=MAX_STROKE)) { 
61D0:  MOVLW  9A
61D2:  MOVLB  1
61D4:  MOVWF  x4D
61D6:  MOVLW  99
61D8:  MOVWF  x4C
61DA:  MOVLW  0C
61DC:  MOVWF  x4B
61DE:  MOVLW  85
61E0:  MOVWF  x4A
61E2:  MOVFF  BF,151
61E6:  MOVFF  BE,150
61EA:  MOVFF  BD,14F
61EE:  MOVFF  BC,14E
61F2:  MOVLB  0
61F4:  CALL   3DD6
61F8:  BC    61FC
61FA:  BNZ   62E0
61FC:  MOVFF  BF,14D
6200:  MOVFF  BE,14C
6204:  MOVFF  BD,14B
6208:  MOVFF  BC,14A
620C:  MOVLB  1
620E:  CLRF   x51
6210:  CLRF   x50
6212:  CLRF   x4F
6214:  MOVLW  86
6216:  MOVWF  x4E
6218:  MOVLB  0
621A:  CALL   3DD6
621E:  BC    6222
6220:  BNZ   62E0
....................             tick = ((al-MIN_STROKE)/(MAX_STROKE-MIN_STROKE))*FULL_STROKE_TICK; 
6222:  BSF    FD8.1
6224:  MOVFF  BF,153
6228:  MOVFF  BE,152
622C:  MOVFF  BD,151
6230:  MOVFF  BC,150
6234:  MOVLW  9A
6236:  MOVLB  1
6238:  MOVWF  x57
623A:  MOVLW  99
623C:  MOVWF  x56
623E:  MOVLW  0C
6240:  MOVWF  x55
6242:  MOVLW  85
6244:  MOVWF  x54
6246:  MOVLB  0
6248:  CALL   1078
624C:  MOVFF  00,D1
6250:  MOVFF  01,D2
6254:  MOVFF  02,D3
6258:  MOVFF  03,D4
625C:  MOVFF  03,14D
6260:  MOVFF  02,14C
6264:  MOVFF  01,14B
6268:  MOVFF  00,14A
626C:  MOVLW  CC
626E:  MOVLB  1
6270:  MOVWF  x51
6272:  MOVWF  x50
6274:  MOVLW  66
6276:  MOVWF  x4F
6278:  MOVLW  84
627A:  MOVWF  x4E
627C:  MOVLB  0
627E:  CALL   0F1A
6282:  MOVFF  00,D5
6286:  MOVFF  01,D6
628A:  MOVFF  02,D7
628E:  MOVFF  03,D8
6292:  MOVFF  BB,14F
6296:  MOVFF  BA,14E
629A:  CALL   437A
629E:  MOVFF  D8,151
62A2:  MOVFF  D7,150
62A6:  MOVFF  D6,14F
62AA:  MOVFF  D5,14E
62AE:  MOVFF  03,155
62B2:  MOVFF  02,154
62B6:  MOVFF  01,153
62BA:  MOVFF  00,152
62BE:  CALL   0E24
62C2:  MOVFF  03,14D
62C6:  MOVFF  02,14C
62CA:  MOVFF  01,14B
62CE:  MOVFF  00,14A
62D2:  CALL   43B0
62D6:  MOVFF  02,CD
62DA:  MOVFF  01,CC
....................          } else if (al<MIN_STROKE) { 
62DE:  BRA    633C
62E0:  MOVFF  BF,14D
62E4:  MOVFF  BE,14C
62E8:  MOVFF  BD,14B
62EC:  MOVFF  BC,14A
62F0:  MOVLW  9A
62F2:  MOVLB  1
62F4:  MOVWF  x51
62F6:  MOVLW  99
62F8:  MOVWF  x50
62FA:  MOVLW  0C
62FC:  MOVWF  x4F
62FE:  MOVLW  85
6300:  MOVWF  x4E
6302:  MOVLB  0
6304:  CALL   3DD6
6308:  BNC   6310
....................             tick = 0; 
630A:  CLRF   xCD
630C:  CLRF   xCC
....................          } else if (al>MAX_STROKE) { 
630E:  BRA    633C
6310:  MOVLB  1
6312:  CLRF   x4D
6314:  CLRF   x4C
6316:  CLRF   x4B
6318:  MOVLW  86
631A:  MOVWF  x4A
631C:  MOVFF  BF,151
6320:  MOVFF  BE,150
6324:  MOVFF  BD,14F
6328:  MOVFF  BC,14E
632C:  MOVLB  0
632E:  CALL   3DD6
6332:  BNC   633C
....................             tick = FULL_STROKE_TICK; 
6334:  MOVFF  BB,CD
6338:  MOVFF  BA,CC
....................          } 
....................          target_act_position = tick; 
633C:  MOVFF  CD,71
6340:  MOVFF  CC,70
....................               write_eeprom_data(0); 
6344:  CLRF   xD1
6346:  CALL   0820
....................          print_len_and_tick(); 
634A:  RCALL  5C9A
....................  
....................          if(current_act_position > (target_act_position+5))// move east 
634C:  MOVLW  05
634E:  ADDWF  x70,W
6350:  MOVWF  01
6352:  MOVLW  00
6354:  ADDWFC x71,W
6356:  MOVWF  03
6358:  MOVF   03,W
635A:  SUBWF  x6F,W
635C:  BNC   6394
635E:  BNZ   6366
6360:  MOVF   x6E,W
6362:  SUBWF  01,W
6364:  BC    6394
....................          { 
....................             move_act(current_act_position-target_act_position,4500,move_act_time_out,0,1); 
6366:  MOVF   x70,W
6368:  SUBWF  x6E,W
636A:  MOVWF  xD1
636C:  MOVF   x71,W
636E:  SUBWFB x6F,W
6370:  MOVWF  xD2
6372:  MOVWF  xD4
6374:  MOVFF  D1,D3
6378:  MOVLW  11
637A:  MOVWF  xD6
637C:  MOVLW  94
637E:  MOVWF  xD5
6380:  MOVFF  C1,D8
6384:  MOVFF  C0,D7
6388:  CLRF   xD9
638A:  MOVLW  01
638C:  MOVWF  xDA
638E:  CALL   21A4
....................          } else if((current_act_position+5) < target_act_position)// move west 
6392:  BRA    6434
6394:  MOVLW  05
6396:  ADDWF  x6E,W
6398:  MOVWF  xD1
639A:  MOVLW  00
639C:  ADDWFC x6F,W
639E:  MOVWF  xD2
63A0:  SUBWF  x71,W
63A2:  BNC   63DA
63A4:  BNZ   63AC
63A6:  MOVF   x70,W
63A8:  SUBWF  xD1,W
63AA:  BC    63DA
....................          { 
....................             move_act(target_act_position-current_act_position,4500,move_act_time_out,1,1); 
63AC:  MOVF   x6E,W
63AE:  SUBWF  x70,W
63B0:  MOVWF  xD1
63B2:  MOVF   x6F,W
63B4:  SUBWFB x71,W
63B6:  MOVWF  xD2
63B8:  MOVWF  xD4
63BA:  MOVFF  D1,D3
63BE:  MOVLW  11
63C0:  MOVWF  xD6
63C2:  MOVLW  94
63C4:  MOVWF  xD5
63C6:  MOVFF  C1,D8
63CA:  MOVFF  C0,D7
63CE:  MOVLW  01
63D0:  MOVWF  xD9
63D2:  MOVWF  xDA
63D4:  CALL   21A4
....................          } else if (target_act_position == 0x00)  // move east all the way 
63D8:  BRA    6434
63DA:  MOVF   x70,F
63DC:  BNZ   6406
63DE:  MOVF   x71,F
63E0:  BNZ   6406
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,0,1); 
63E2:  MOVFF  BB,D4
63E6:  MOVFF  BA,D3
63EA:  MOVLW  11
63EC:  MOVWF  xD6
63EE:  MOVLW  94
63F0:  MOVWF  xD5
63F2:  MOVFF  C1,D8
63F6:  MOVFF  C0,D7
63FA:  CLRF   xD9
63FC:  MOVLW  01
63FE:  MOVWF  xDA
6400:  CALL   21A4
....................          else if (target_act_position == FULL_STROKE_TICK) // move west all the way 
6404:  BRA    6434
6406:  MOVF   xBA,W
6408:  SUBWF  x70,W
640A:  BNZ   6434
640C:  MOVF   xBB,W
640E:  SUBWF  x71,W
6410:  BNZ   6434
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,1,1); 
6412:  MOVFF  BB,D4
6416:  MOVFF  BA,D3
641A:  MOVLW  11
641C:  MOVWF  xD6
641E:  MOVLW  94
6420:  MOVWF  xD5
6422:  MOVFF  C1,D8
6426:  MOVFF  C0,D7
642A:  MOVLW  01
642C:  MOVWF  xD9
642E:  MOVWF  xDA
6430:  CALL   21A4
6434:  CLRF   18
6436:  BTFSC  FF2.7
6438:  BSF    18.7
643A:  BCF    FF2.7
....................          delay_ms(20); 
643C:  MOVLW  14
643E:  MOVWF  xEA
6440:  CALL   04BC
6444:  BTFSC  18.7
6446:  BSF    FF2.7
....................          task1(); 
6448:  CALL   3872
....................          print_len_and_tick(); 
644C:  RCALL  5C9A
....................          write_eeprom_data(0); 
644E:  CLRF   xD1
6450:  CALL   0820
....................          PORTE.tx_en=1; 
6454:  BSF    F84.2
....................          current_measured=0; 
6456:  CLRF   xC4
6458:  CLRF   xC3
....................          n_avg_current_measured=0; 
645A:  CLRF   xC5
....................          printf("."); 
645C:  MOVLW  2E
645E:  BTFSS  F9E.4
6460:  BRA    645E
6462:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
6464:  MOVLW  01
6466:  MOVWF  xC2
....................          sleep(); 
6468:  SLEEP 
....................       } 
....................    } 
646A:  BRA    60C2
....................  
.................... } 
646C:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: B1 05 00 00 00 00 00 00 00 00 
