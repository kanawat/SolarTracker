CCS PCH C Compiler, Version 4.078, 37503               29-¾.¤.-10 16:12

               Filename: G:\Solar_Tracker_Final\Code\Ver2_w_batt\tracker1.lst

               ROM used: 27164 bytes (83%)
                         Largest free fragment is 5600
               RAM used: 269 (18%) at main() level
                         376 (24%) worst case
               Stack:    10 worst case (8 in main + 2 for interrupts)

*
0000:  GOTO   6344
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   03C0
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04EC
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... // 22-may-2010 always enable high voltage power supply (ps_en=1) 
....................  
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
16F2:  MOVFF  118,11A
16F6:  MOVFF  117,119
16FA:  MOVFF  11A,03
16FE:  MOVLB  1
1700:  MOVFF  119,FE9
1704:  MOVFF  11A,FEA
1708:  MOVF   FEF,F
170A:  BZ    1718
170C:  INCF   x19,F
170E:  BTFSC  FD8.2
1710:  INCF   x1A,F
1712:  MOVLB  0
1714:  BRA    16FA
1716:  MOVLB  1
....................    return(sc - s); 
1718:  MOVF   x17,W
171A:  SUBWF  x19,W
171C:  MOVWF  00
171E:  MOVF   x18,W
1720:  SUBWFB x1A,W
1722:  MOVWF  03
1724:  MOVFF  00,01
.................... } 
1728:  MOVLB  0
172A:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B4E:  MOVLB  1
0B50:  CLRF   x0C
....................    sign = 0; 
0B52:  CLRF   x0A
....................    base = 10; 
0B54:  MOVLW  0A
0B56:  MOVWF  x0B
....................    result = 0; 
0B58:  CLRF   x09
0B5A:  CLRF   x08
....................  
....................    if (!s) 
0B5C:  MOVF   x06,W
0B5E:  IORWF  x07,W
0B60:  BNZ   0B6A
....................       return 0; 
0B62:  MOVLW  00
0B64:  MOVWF  01
0B66:  MOVWF  02
0B68:  BRA    0D3A
....................    c = s[index++]; 
0B6A:  MOVF   x0C,W
0B6C:  INCF   x0C,F
0B6E:  CLRF   03
0B70:  ADDWF  x06,W
0B72:  MOVWF  FE9
0B74:  MOVF   x07,W
0B76:  ADDWFC 03,W
0B78:  MOVWF  FEA
0B7A:  MOVFF  FEF,10D
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B7E:  MOVF   x0D,W
0B80:  SUBLW  2D
0B82:  BNZ   0B9E
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B84:  MOVLW  01
0B86:  MOVWF  x0A
....................       c = s[index++]; 
0B88:  MOVF   x0C,W
0B8A:  INCF   x0C,F
0B8C:  CLRF   03
0B8E:  ADDWF  x06,W
0B90:  MOVWF  FE9
0B92:  MOVF   x07,W
0B94:  ADDWFC 03,W
0B96:  MOVWF  FEA
0B98:  MOVFF  FEF,10D
....................    } 
....................    else if (c == '+') 
0B9C:  BRA    0BB8
0B9E:  MOVF   x0D,W
0BA0:  SUBLW  2B
0BA2:  BNZ   0BB8
....................    { 
....................       c = s[index++]; 
0BA4:  MOVF   x0C,W
0BA6:  INCF   x0C,F
0BA8:  CLRF   03
0BAA:  ADDWF  x06,W
0BAC:  MOVWF  FE9
0BAE:  MOVF   x07,W
0BB0:  ADDWFC 03,W
0BB2:  MOVWF  FEA
0BB4:  MOVFF  FEF,10D
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0BB8:  MOVF   x0D,W
0BBA:  SUBLW  2F
0BBC:  BTFSC  FD8.0
0BBE:  BRA    0D1E
0BC0:  MOVF   x0D,W
0BC2:  SUBLW  39
0BC4:  BTFSS  FD8.0
0BC6:  BRA    0D1E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0BC8:  MOVF   x0D,W
0BCA:  SUBLW  30
0BCC:  BNZ   0C10
0BCE:  CLRF   03
0BD0:  MOVF   x0C,W
0BD2:  ADDWF  x06,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x07,W
0BD8:  ADDWFC 03,W
0BDA:  MOVWF  FEA
0BDC:  MOVF   FEF,W
0BDE:  SUBLW  78
0BE0:  BZ    0BF6
0BE2:  CLRF   03
0BE4:  MOVF   x0C,W
0BE6:  ADDWF  x06,W
0BE8:  MOVWF  FE9
0BEA:  MOVF   x07,W
0BEC:  ADDWFC 03,W
0BEE:  MOVWF  FEA
0BF0:  MOVF   FEF,W
0BF2:  SUBLW  58
0BF4:  BNZ   0C10
....................       { 
....................          base = 16; 
0BF6:  MOVLW  10
0BF8:  MOVWF  x0B
....................          index++; 
0BFA:  INCF   x0C,F
....................          c = s[index++]; 
0BFC:  MOVF   x0C,W
0BFE:  INCF   x0C,F
0C00:  CLRF   03
0C02:  ADDWF  x06,W
0C04:  MOVWF  FE9
0C06:  MOVF   x07,W
0C08:  ADDWFC 03,W
0C0A:  MOVWF  FEA
0C0C:  MOVFF  FEF,10D
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0C10:  MOVF   x0B,W
0C12:  SUBLW  0A
0C14:  BNZ   0C5C
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0C16:  MOVF   x0D,W
0C18:  SUBLW  2F
0C1A:  BC    0C5A
0C1C:  MOVF   x0D,W
0C1E:  SUBLW  39
0C20:  BNC   0C5A
....................             result = 10*result + (c - '0'); 
0C22:  CLRF   x0F
0C24:  MOVLW  0A
0C26:  MOVWF  x0E
0C28:  MOVFF  109,111
0C2C:  MOVFF  108,110
0C30:  MOVLB  0
0C32:  BRA    0B2A
0C34:  MOVLW  30
0C36:  MOVLB  1
0C38:  SUBWF  x0D,W
0C3A:  ADDWF  01,W
0C3C:  MOVWF  x08
0C3E:  MOVLW  00
0C40:  ADDWFC 02,W
0C42:  MOVWF  x09
....................             c = s[index++]; 
0C44:  MOVF   x0C,W
0C46:  INCF   x0C,F
0C48:  CLRF   03
0C4A:  ADDWF  x06,W
0C4C:  MOVWF  FE9
0C4E:  MOVF   x07,W
0C50:  ADDWFC 03,W
0C52:  MOVWF  FEA
0C54:  MOVFF  FEF,10D
....................          } 
0C58:  BRA    0C16
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
0C5A:  BRA    0D1E
0C5C:  MOVF   x0B,W
0C5E:  SUBLW  10
0C60:  BNZ   0D1E
....................       { 
....................          c = toupper(c); 
0C62:  MOVF   x0D,W
0C64:  SUBLW  60
0C66:  BC    0C74
0C68:  MOVF   x0D,W
0C6A:  SUBLW  7A
0C6C:  BNC   0C74
0C6E:  MOVF   x0D,W
0C70:  ANDLW  DF
0C72:  BRA    0C76
0C74:  MOVF   x0D,W
0C76:  MOVWF  x0D
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
0C78:  MOVF   x0D,W
0C7A:  SUBLW  2F
0C7C:  BC    0C84
0C7E:  MOVF   x0D,W
0C80:  SUBLW  39
0C82:  BC    0C90
0C84:  MOVF   x0D,W
0C86:  SUBLW  40
0C88:  BC    0D1E
0C8A:  MOVF   x0D,W
0C8C:  SUBLW  46
0C8E:  BNC   0D1E
....................             if (c >= '0' && c <= '9') 
0C90:  MOVF   x0D,W
0C92:  SUBLW  2F
0C94:  BC    0CC8
0C96:  MOVF   x0D,W
0C98:  SUBLW  39
0C9A:  BNC   0CC8
....................                result = (result << 4) + (c - '0'); 
0C9C:  RLCF   x08,W
0C9E:  MOVWF  x0E
0CA0:  RLCF   x09,W
0CA2:  MOVWF  x0F
0CA4:  RLCF   x0E,F
0CA6:  RLCF   x0F,F
0CA8:  RLCF   x0E,F
0CAA:  RLCF   x0F,F
0CAC:  RLCF   x0E,F
0CAE:  RLCF   x0F,F
0CB0:  MOVLW  F0
0CB2:  ANDWF  x0E,F
0CB4:  MOVLW  30
0CB6:  SUBWF  x0D,W
0CB8:  ADDWF  x0E,W
0CBA:  MOVWF  01
0CBC:  MOVLW  00
0CBE:  ADDWFC x0F,W
0CC0:  MOVFF  01,108
0CC4:  MOVWF  x09
....................             else 
0CC6:  BRA    0CF4
....................                result = (result << 4) + (c - 'A' + 10); 
0CC8:  RLCF   x08,W
0CCA:  MOVWF  x0E
0CCC:  RLCF   x09,W
0CCE:  MOVWF  x0F
0CD0:  RLCF   x0E,F
0CD2:  RLCF   x0F,F
0CD4:  RLCF   x0E,F
0CD6:  RLCF   x0F,F
0CD8:  RLCF   x0E,F
0CDA:  RLCF   x0F,F
0CDC:  MOVLW  F0
0CDE:  ANDWF  x0E,F
0CE0:  MOVLW  41
0CE2:  SUBWF  x0D,W
0CE4:  ADDLW  0A
0CE6:  ADDWF  x0E,W
0CE8:  MOVWF  01
0CEA:  MOVLW  00
0CEC:  ADDWFC x0F,W
0CEE:  MOVFF  01,108
0CF2:  MOVWF  x09
....................  
....................             c = s[index++];c = toupper(c); 
0CF4:  MOVF   x0C,W
0CF6:  INCF   x0C,F
0CF8:  CLRF   03
0CFA:  ADDWF  x06,W
0CFC:  MOVWF  FE9
0CFE:  MOVF   x07,W
0D00:  ADDWFC 03,W
0D02:  MOVWF  FEA
0D04:  MOVF   FEF,W
0D06:  MOVWF  x0D
0D08:  SUBLW  60
0D0A:  BC    0D18
0D0C:  MOVF   x0D,W
0D0E:  SUBLW  7A
0D10:  BNC   0D18
0D12:  MOVF   x0D,W
0D14:  ANDLW  DF
0D16:  BRA    0D1A
0D18:  MOVF   x0D,W
0D1A:  MOVWF  x0D
....................          } 
0D1C:  BRA    0C78
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0D1E:  MOVF   x0B,W
0D20:  SUBLW  0A
0D22:  BNZ   0D32
0D24:  DECFSZ x0A,W
0D26:  BRA    0D32
....................       result = -result; 
0D28:  COMF   x08,F
0D2A:  COMF   x09,F
0D2C:  INCF   x08,F
0D2E:  BTFSC  FD8.2
0D30:  INCF   x09,F
....................  
....................    return(result); 
0D32:  MOVFF  108,01
0D36:  MOVFF  109,02
.................... } 
0D3A:  MOVLB  0
0D3C:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
2BFA:  MOVLB  1
2BFC:  CLRF   x0E
....................    sign = 0; 
2BFE:  CLRF   x0C
....................    base = 10; 
2C00:  MOVLW  0A
2C02:  MOVWF  x0D
....................    result = 0; 
2C04:  CLRF   x0B
2C06:  CLRF   x0A
2C08:  CLRF   x09
2C0A:  CLRF   x08
....................  
....................    if (!s) 
2C0C:  MOVF   x06,W
2C0E:  IORWF  x07,W
2C10:  BNZ   2C1C
....................       return 0; 
2C12:  CLRF   00
2C14:  CLRF   01
2C16:  CLRF   02
2C18:  CLRF   03
2C1A:  BRA    2E96
....................    c = s[index++]; 
2C1C:  MOVF   x0E,W
2C1E:  INCF   x0E,F
2C20:  CLRF   03
2C22:  ADDWF  x06,W
2C24:  MOVWF  FE9
2C26:  MOVF   x07,W
2C28:  ADDWFC 03,W
2C2A:  MOVWF  FEA
2C2C:  MOVFF  FEF,10F
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
2C30:  MOVF   x0F,W
2C32:  SUBLW  2D
2C34:  BNZ   2C50
....................    { 
....................       sign = 1;         // Set the sign to negative 
2C36:  MOVLW  01
2C38:  MOVWF  x0C
....................       c = s[index++]; 
2C3A:  MOVF   x0E,W
2C3C:  INCF   x0E,F
2C3E:  CLRF   03
2C40:  ADDWF  x06,W
2C42:  MOVWF  FE9
2C44:  MOVF   x07,W
2C46:  ADDWFC 03,W
2C48:  MOVWF  FEA
2C4A:  MOVFF  FEF,10F
....................    } 
....................    else if (c == '+') 
2C4E:  BRA    2C6A
2C50:  MOVF   x0F,W
2C52:  SUBLW  2B
2C54:  BNZ   2C6A
....................    { 
....................       c = s[index++]; 
2C56:  MOVF   x0E,W
2C58:  INCF   x0E,F
2C5A:  CLRF   03
2C5C:  ADDWF  x06,W
2C5E:  MOVWF  FE9
2C60:  MOVF   x07,W
2C62:  ADDWFC 03,W
2C64:  MOVWF  FEA
2C66:  MOVFF  FEF,10F
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2C6A:  MOVF   x0F,W
2C6C:  SUBLW  2F
2C6E:  BTFSC  FD8.0
2C70:  BRA    2E66
2C72:  MOVF   x0F,W
2C74:  SUBLW  39
2C76:  BTFSS  FD8.0
2C78:  BRA    2E66
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2C7A:  MOVF   x0F,W
2C7C:  SUBLW  30
2C7E:  BNZ   2CC2
2C80:  CLRF   03
2C82:  MOVF   x0E,W
2C84:  ADDWF  x06,W
2C86:  MOVWF  FE9
2C88:  MOVF   x07,W
2C8A:  ADDWFC 03,W
2C8C:  MOVWF  FEA
2C8E:  MOVF   FEF,W
2C90:  SUBLW  78
2C92:  BZ    2CA8
2C94:  CLRF   03
2C96:  MOVF   x0E,W
2C98:  ADDWF  x06,W
2C9A:  MOVWF  FE9
2C9C:  MOVF   x07,W
2C9E:  ADDWFC 03,W
2CA0:  MOVWF  FEA
2CA2:  MOVF   FEF,W
2CA4:  SUBLW  58
2CA6:  BNZ   2CC2
....................       { 
....................          base = 16; 
2CA8:  MOVLW  10
2CAA:  MOVWF  x0D
....................          index++; 
2CAC:  INCF   x0E,F
....................          c = s[index++]; 
2CAE:  MOVF   x0E,W
2CB0:  INCF   x0E,F
2CB2:  CLRF   03
2CB4:  ADDWF  x06,W
2CB6:  MOVWF  FE9
2CB8:  MOVF   x07,W
2CBA:  ADDWFC 03,W
2CBC:  MOVWF  FEA
2CBE:  MOVFF  FEF,10F
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
2CC2:  MOVF   x0D,W
2CC4:  SUBLW  0A
2CC6:  BNZ   2D50
....................       { 
....................          while (c >= '0' && c <= '9') { 
2CC8:  MOVF   x0F,W
2CCA:  SUBLW  2F
2CCC:  BC    2D4E
2CCE:  MOVF   x0F,W
2CD0:  SUBLW  39
2CD2:  BNC   2D4E
....................             result = (result << 1) + (result << 3);  // result *= 10; 
2CD4:  BCF    FD8.0
2CD6:  RLCF   x08,W
2CD8:  MOVWF  x11
2CDA:  RLCF   x09,W
2CDC:  MOVWF  x12
2CDE:  RLCF   x0A,W
2CE0:  MOVWF  x13
2CE2:  RLCF   x0B,W
2CE4:  MOVWF  x14
2CE6:  RLCF   x08,W
2CE8:  MOVWF  00
2CEA:  RLCF   x09,W
2CEC:  MOVWF  01
2CEE:  RLCF   x0A,W
2CF0:  MOVWF  02
2CF2:  RLCF   x0B,W
2CF4:  MOVWF  03
2CF6:  RLCF   00,F
2CF8:  RLCF   01,F
2CFA:  RLCF   02,F
2CFC:  RLCF   03,F
2CFE:  RLCF   00,F
2D00:  RLCF   01,F
2D02:  RLCF   02,F
2D04:  RLCF   03,F
2D06:  MOVLW  F8
2D08:  ANDWF  00,F
2D0A:  MOVF   x11,W
2D0C:  ADDWF  00,F
2D0E:  MOVF   x12,W
2D10:  ADDWFC 01,F
2D12:  MOVF   x13,W
2D14:  ADDWFC 02,F
2D16:  MOVF   x14,W
2D18:  ADDWFC 03,F
2D1A:  MOVFF  03,10B
2D1E:  MOVFF  02,10A
2D22:  MOVFF  01,109
2D26:  MOVFF  00,108
....................             result += (c - '0'); 
2D2A:  MOVLW  30
2D2C:  SUBWF  x0F,W
2D2E:  ADDWF  x08,F
2D30:  MOVLW  00
2D32:  ADDWFC x09,F
2D34:  ADDWFC x0A,F
2D36:  ADDWFC x0B,F
....................             c = s[index++]; 
2D38:  MOVF   x0E,W
2D3A:  INCF   x0E,F
2D3C:  CLRF   03
2D3E:  ADDWF  x06,W
2D40:  MOVWF  FE9
2D42:  MOVF   x07,W
2D44:  ADDWFC 03,W
2D46:  MOVWF  FEA
2D48:  MOVFF  FEF,10F
....................          } 
2D4C:  BRA    2CC8
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2D4E:  BRA    2E66
2D50:  MOVF   x0D,W
2D52:  SUBLW  10
2D54:  BTFSS  FD8.2
2D56:  BRA    2E66
....................       { 
....................          c = toupper(c); 
2D58:  MOVF   x0F,W
2D5A:  SUBLW  60
2D5C:  BC    2D6A
2D5E:  MOVF   x0F,W
2D60:  SUBLW  7A
2D62:  BNC   2D6A
2D64:  MOVF   x0F,W
2D66:  ANDLW  DF
2D68:  BRA    2D6C
2D6A:  MOVF   x0F,W
2D6C:  MOVWF  x0F
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2D6E:  MOVF   x0F,W
2D70:  SUBLW  2F
2D72:  BC    2D7A
2D74:  MOVF   x0F,W
2D76:  SUBLW  39
2D78:  BC    2D88
2D7A:  MOVF   x0F,W
2D7C:  SUBLW  40
2D7E:  BTFSC  FD8.0
2D80:  BRA    2E66
2D82:  MOVF   x0F,W
2D84:  SUBLW  46
2D86:  BNC   2E66
....................             if (c >= '0' && c <= '9') 
2D88:  MOVF   x0F,W
2D8A:  SUBLW  2F
2D8C:  BC    2DE8
2D8E:  MOVF   x0F,W
2D90:  SUBLW  39
2D92:  BNC   2DE8
....................                result = (result << 4) + (c - '0'); 
2D94:  RLCF   x08,W
2D96:  MOVWF  x11
2D98:  RLCF   x09,W
2D9A:  MOVWF  x12
2D9C:  RLCF   x0A,W
2D9E:  MOVWF  x13
2DA0:  RLCF   x0B,W
2DA2:  MOVWF  x14
2DA4:  RLCF   x11,F
2DA6:  RLCF   x12,F
2DA8:  RLCF   x13,F
2DAA:  RLCF   x14,F
2DAC:  RLCF   x11,F
2DAE:  RLCF   x12,F
2DB0:  RLCF   x13,F
2DB2:  RLCF   x14,F
2DB4:  RLCF   x11,F
2DB6:  RLCF   x12,F
2DB8:  RLCF   x13,F
2DBA:  RLCF   x14,F
2DBC:  MOVLW  F0
2DBE:  ANDWF  x11,F
2DC0:  MOVLW  30
2DC2:  SUBWF  x0F,W
2DC4:  ADDWF  x11,W
2DC6:  MOVWF  00
2DC8:  MOVLW  00
2DCA:  ADDWFC x12,W
2DCC:  MOVWF  01
2DCE:  MOVLW  00
2DD0:  ADDWFC x13,W
2DD2:  MOVWF  02
2DD4:  MOVLW  00
2DD6:  ADDWFC x14,W
2DD8:  MOVWF  x0B
2DDA:  MOVFF  02,10A
2DDE:  MOVFF  01,109
2DE2:  MOVFF  00,108
....................             else 
2DE6:  BRA    2E3C
....................                result = (result << 4) + (c - 'A' + 10); 
2DE8:  RLCF   x08,W
2DEA:  MOVWF  x11
2DEC:  RLCF   x09,W
2DEE:  MOVWF  x12
2DF0:  RLCF   x0A,W
2DF2:  MOVWF  x13
2DF4:  RLCF   x0B,W
2DF6:  MOVWF  x14
2DF8:  RLCF   x11,F
2DFA:  RLCF   x12,F
2DFC:  RLCF   x13,F
2DFE:  RLCF   x14,F
2E00:  RLCF   x11,F
2E02:  RLCF   x12,F
2E04:  RLCF   x13,F
2E06:  RLCF   x14,F
2E08:  RLCF   x11,F
2E0A:  RLCF   x12,F
2E0C:  RLCF   x13,F
2E0E:  RLCF   x14,F
2E10:  MOVLW  F0
2E12:  ANDWF  x11,F
2E14:  MOVLW  41
2E16:  SUBWF  x0F,W
2E18:  ADDLW  0A
2E1A:  ADDWF  x11,W
2E1C:  MOVWF  00
2E1E:  MOVLW  00
2E20:  ADDWFC x12,W
2E22:  MOVWF  01
2E24:  MOVLW  00
2E26:  ADDWFC x13,W
2E28:  MOVWF  02
2E2A:  MOVLW  00
2E2C:  ADDWFC x14,W
2E2E:  MOVWF  x0B
2E30:  MOVFF  02,10A
2E34:  MOVFF  01,109
2E38:  MOVFF  00,108
....................  
....................             c = s[index++];c = toupper(c); 
2E3C:  MOVF   x0E,W
2E3E:  INCF   x0E,F
2E40:  CLRF   03
2E42:  ADDWF  x06,W
2E44:  MOVWF  FE9
2E46:  MOVF   x07,W
2E48:  ADDWFC 03,W
2E4A:  MOVWF  FEA
2E4C:  MOVF   FEF,W
2E4E:  MOVWF  x0F
2E50:  SUBLW  60
2E52:  BC    2E60
2E54:  MOVF   x0F,W
2E56:  SUBLW  7A
2E58:  BNC   2E60
2E5A:  MOVF   x0F,W
2E5C:  ANDLW  DF
2E5E:  BRA    2E62
2E60:  MOVF   x0F,W
2E62:  MOVWF  x0F
....................          } 
2E64:  BRA    2D6E
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2E66:  MOVF   x0D,W
2E68:  SUBLW  0A
2E6A:  BNZ   2E86
2E6C:  DECFSZ x0C,W
2E6E:  BRA    2E86
....................       result = -result; 
2E70:  COMF   x08,F
2E72:  COMF   x09,F
2E74:  COMF   x0A,F
2E76:  COMF   x0B,F
2E78:  INCF   x08,F
2E7A:  BTFSC  FD8.2
2E7C:  INCF   x09,F
2E7E:  BTFSC  FD8.2
2E80:  INCF   x0A,F
2E82:  BTFSC  FD8.2
2E84:  INCF   x0B,F
....................  
....................    return(result); 
2E86:  MOVFF  108,00
2E8A:  MOVFF  109,01
2E8E:  MOVFF  10A,02
2E92:  MOVFF  10B,03
.................... } 
2E96:  MOVLB  0
2E98:  GOTO   35C8 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
150E:  MOVLW  01
1510:  MOVLB  1
1512:  MOVWF  x22
1514:  CLRF   x23
1516:  CLRF   x24
1518:  CLRF   x25
....................      unsigned int8 i,sign=0,cnt=0; 
151A:  CLRF   x27
151C:  CLRF   x28
....................      char c; 
....................  
....................      if(num<0) { 
151E:  BTFSC  x1E.7
1520:  BRA    1524
1522:  BRA    1558
....................          sign=1;        // Check for negative number 
1524:  MOVLW  01
1526:  MOVWF  x27
....................          num*=-1; 
1528:  MOVFF  11E,12D
152C:  MOVFF  11D,12C
1530:  MOVFF  11C,12B
1534:  MOVFF  11B,12A
1538:  MOVLW  FF
153A:  MOVWF  x31
153C:  MOVWF  x30
153E:  MOVWF  x2F
1540:  MOVWF  x2E
1542:  MOVLB  0
1544:  RCALL  13DE
1546:  MOVFF  03,11E
154A:  MOVFF  02,11D
154E:  MOVFF  01,11C
1552:  MOVFF  00,11B
1556:  MOVLB  1
....................      } 
....................  
....................      while(temp>0) { 
1558:  MOVF   x22,F
155A:  BNZ   1568
155C:  MOVF   x23,F
155E:  BNZ   1568
1560:  MOVF   x24,F
1562:  BNZ   1568
1564:  MOVF   x25,F
1566:  BZ    1656
....................          temp=(num/base); 
1568:  MOVFF  11E,131
156C:  MOVFF  11D,130
1570:  MOVFF  11C,12F
1574:  MOVFF  11B,12E
1578:  CLRF   x35
157A:  CLRF   x34
157C:  CLRF   x33
157E:  MOVFF  11F,132
1582:  MOVLB  0
1584:  RCALL  1438
1586:  MOVFF  03,125
158A:  MOVFF  02,124
158E:  MOVFF  01,123
1592:  MOVFF  00,122
....................          s[cnt]=(num%base)+'0';    // Conversion 
1596:  CLRF   03
1598:  MOVLB  1
159A:  MOVF   x28,W
159C:  ADDWF  x20,W
159E:  MOVWF  01
15A0:  MOVF   x21,W
15A2:  ADDWFC 03,F
15A4:  MOVFF  01,12A
15A8:  MOVFF  03,12B
15AC:  MOVFF  FEA,12D
15B0:  MOVFF  FE9,12C
15B4:  MOVFF  11E,131
15B8:  MOVFF  11D,130
15BC:  MOVFF  11C,12F
15C0:  MOVFF  11B,12E
15C4:  CLRF   x35
15C6:  CLRF   x34
15C8:  CLRF   x33
15CA:  MOVFF  11F,132
15CE:  MOVLB  0
15D0:  RCALL  1438
15D2:  MOVFF  FEF,00
15D6:  MOVFF  FEC,01
15DA:  MOVFF  FEC,02
15DE:  MOVFF  FEC,03
15E2:  MOVFF  12D,FEA
15E6:  MOVFF  12C,FE9
15EA:  MOVFF  03,131
15EE:  MOVFF  02,130
15F2:  MOVFF  01,12F
15F6:  MOVFF  00,12E
15FA:  MOVLW  30
15FC:  MOVLB  1
15FE:  ADDWF  00,W
1600:  MOVWF  00
1602:  MOVLW  00
1604:  ADDWFC 01,W
1606:  MOVLW  00
1608:  ADDWFC 02,W
160A:  MOVLW  00
160C:  ADDWFC 03,W
160E:  MOVFF  12B,FEA
1612:  MOVFF  12A,FE9
1616:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
161A:  CLRF   03
161C:  MOVF   x28,W
161E:  ADDWF  x20,W
1620:  MOVWF  FE9
1622:  MOVF   x21,W
1624:  ADDWFC 03,W
1626:  MOVWF  FEA
1628:  MOVF   FEF,W
162A:  SUBLW  39
162C:  BC    1642
....................             s[cnt]+=0x7; 
162E:  CLRF   03
1630:  MOVF   x28,W
1632:  ADDWF  x20,W
1634:  MOVWF  FE9
1636:  MOVF   x21,W
1638:  ADDWFC 03,W
163A:  MOVWF  FEA
163C:  MOVLW  07
163E:  ADDWF  FEF,W
1640:  MOVWF  FEF
....................  
....................          cnt++; 
1642:  INCF   x28,F
....................          num=temp; 
1644:  MOVFF  125,11E
1648:  MOVFF  124,11D
164C:  MOVFF  123,11C
1650:  MOVFF  122,11B
....................      } 
1654:  BRA    1558
....................  
....................      if(sign==1) { 
1656:  DECFSZ x27,W
1658:  BRA    166E
....................          s[cnt]=0x2D;      // Negative sign 
165A:  CLRF   03
165C:  MOVF   x28,W
165E:  ADDWF  x20,W
1660:  MOVWF  FE9
1662:  MOVF   x21,W
1664:  ADDWFC 03,W
1666:  MOVWF  FEA
1668:  MOVLW  2D
166A:  MOVWF  FEF
....................          cnt++; 
166C:  INCF   x28,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
166E:  CLRF   x26
1670:  BCF    FD8.0
1672:  RRCF   x28,W
1674:  SUBWF  x26,W
1676:  BC    16D6
....................  
....................          c=s[i]; 
1678:  CLRF   03
167A:  MOVF   x26,W
167C:  ADDWF  x20,W
167E:  MOVWF  FE9
1680:  MOVF   x21,W
1682:  ADDWFC 03,W
1684:  MOVWF  FEA
1686:  MOVFF  FEF,129
....................          s[i]=s[cnt-i-1];        // Reverse the number 
168A:  CLRF   03
168C:  MOVF   x26,W
168E:  ADDWF  x20,W
1690:  MOVWF  01
1692:  MOVF   x21,W
1694:  ADDWFC 03,F
1696:  MOVFF  03,12B
169A:  MOVF   x26,W
169C:  SUBWF  x28,W
169E:  ADDLW  FF
16A0:  CLRF   03
16A2:  ADDWF  x20,W
16A4:  MOVWF  FE9
16A6:  MOVF   x21,W
16A8:  ADDWFC 03,W
16AA:  MOVWF  FEA
16AC:  MOVFF  FEF,12E
16B0:  MOVFF  12B,FEA
16B4:  MOVFF  01,FE9
16B8:  MOVFF  12E,FEF
....................          s[cnt-i-1]=c; 
16BC:  MOVF   x26,W
16BE:  SUBWF  x28,W
16C0:  ADDLW  FF
16C2:  CLRF   03
16C4:  ADDWF  x20,W
16C6:  MOVWF  FE9
16C8:  MOVF   x21,W
16CA:  ADDWFC 03,W
16CC:  MOVWF  FEA
16CE:  MOVFF  129,FEF
....................      } 
16D2:  INCF   x26,F
16D4:  BRA    1670
....................      s[cnt]='\0';     // End the string 
16D6:  CLRF   03
16D8:  MOVF   x28,W
16DA:  ADDWF  x20,W
16DC:  MOVWF  FE9
16DE:  MOVF   x21,W
16E0:  ADDWFC 03,W
16E2:  MOVWF  FEA
16E4:  CLRF   FEF
....................      return s; 
16E6:  MOVFF  120,01
16EA:  MOVFF  121,02
.................... } 
16EE:  MOVLB  0
16F0:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
598C:  MOVLB  1
598E:  BCF    x40.0
....................    y = x; 
5990:  MOVFF  134,139
5994:  MOVFF  133,138
5998:  MOVFF  132,137
599C:  MOVFF  131,136
....................  
....................    if (x < 0) 
59A0:  MOVFF  134,161
59A4:  MOVFF  133,160
59A8:  MOVFF  132,15F
59AC:  MOVFF  131,15E
59B0:  CLRF   x65
59B2:  CLRF   x64
59B4:  CLRF   x63
59B6:  CLRF   x62
59B8:  MOVLB  0
59BA:  CALL   42F2
59BE:  BNC   59CA
....................    { 
....................       s = 1; 
59C0:  MOVLB  1
59C2:  BSF    x40.0
....................       y = -y; 
59C4:  MOVF   x37,W
59C6:  XORLW  80
59C8:  MOVWF  x37
....................    } 
....................  
....................    if (y <= 32768.0) 
59CA:  MOVFF  139,161
59CE:  MOVFF  138,160
59D2:  MOVFF  137,15F
59D6:  MOVFF  136,15E
59DA:  MOVLB  1
59DC:  CLRF   x65
59DE:  CLRF   x64
59E0:  CLRF   x63
59E2:  MOVLW  8E
59E4:  MOVWF  x62
59E6:  MOVLB  0
59E8:  CALL   42F2
59EC:  BC    59F0
59EE:  BNZ   5A22
....................   res = (float32)(unsigned int16)y; 
59F0:  MOVFF  139,161
59F4:  MOVFF  138,160
59F8:  MOVFF  137,15F
59FC:  MOVFF  136,15E
5A00:  CALL   48CC
5A04:  MOVFF  02,163
5A08:  MOVFF  01,162
5A0C:  CALL   4896
5A10:  MOVFF  03,13D
5A14:  MOVFF  02,13C
5A18:  MOVFF  01,13B
5A1C:  MOVFF  00,13A
....................  
....................  else if (y < 10000000.0) 
5A20:  BRA    5BC8
5A22:  MOVFF  139,161
5A26:  MOVFF  138,160
5A2A:  MOVFF  137,15F
5A2E:  MOVFF  136,15E
5A32:  MOVLW  80
5A34:  MOVLB  1
5A36:  MOVWF  x65
5A38:  MOVLW  96
5A3A:  MOVWF  x64
5A3C:  MOVLW  18
5A3E:  MOVWF  x63
5A40:  MOVLW  96
5A42:  MOVWF  x62
5A44:  MOVLB  0
5A46:  CALL   42F2
5A4A:  BTFSS  FD8.0
5A4C:  BRA    5BB8
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
5A4E:  MOVFF  139,161
5A52:  MOVFF  138,160
5A56:  MOVFF  137,15F
5A5A:  MOVFF  136,15E
5A5E:  MOVLB  1
5A60:  CLRF   x65
5A62:  CLRF   x64
5A64:  CLRF   x63
5A66:  MOVLW  8E
5A68:  MOVWF  x62
5A6A:  MOVLB  0
5A6C:  CALL   0FC4
5A70:  MOVFF  03,161
5A74:  MOVFF  02,160
5A78:  MOVFF  01,15F
5A7C:  MOVFF  00,15E
5A80:  CALL   48CC
5A84:  MOVFF  02,13F
5A88:  MOVFF  01,13E
....................       y = 32768.0*(y/32768.0 - (float32)l); 
5A8C:  MOVFF  139,161
5A90:  MOVFF  138,160
5A94:  MOVFF  137,15F
5A98:  MOVFF  136,15E
5A9C:  MOVLB  1
5A9E:  CLRF   x65
5AA0:  CLRF   x64
5AA2:  CLRF   x63
5AA4:  MOVLW  8E
5AA6:  MOVWF  x62
5AA8:  MOVLB  0
5AAA:  CALL   0FC4
5AAE:  MOVFF  00,141
5AB2:  MOVFF  01,142
5AB6:  MOVFF  02,143
5ABA:  MOVFF  03,144
5ABE:  MOVFF  13F,163
5AC2:  MOVFF  13E,162
5AC6:  CALL   4896
5ACA:  BSF    FD8.1
5ACC:  MOVFF  144,167
5AD0:  MOVFF  143,166
5AD4:  MOVFF  142,165
5AD8:  MOVFF  141,164
5ADC:  MOVFF  03,16B
5AE0:  MOVFF  02,16A
5AE4:  MOVFF  01,169
5AE8:  MOVFF  00,168
5AEC:  CALL   1122
5AF0:  MOVLB  1
5AF2:  CLRF   x65
5AF4:  CLRF   x64
5AF6:  CLRF   x63
5AF8:  MOVLW  8E
5AFA:  MOVWF  x62
5AFC:  MOVFF  03,169
5B00:  MOVFF  02,168
5B04:  MOVFF  01,167
5B08:  MOVFF  00,166
5B0C:  MOVLB  0
5B0E:  CALL   0ECE
5B12:  MOVFF  03,139
5B16:  MOVFF  02,138
5B1A:  MOVFF  01,137
5B1E:  MOVFF  00,136
....................   res = 32768.0*(float32)l; 
5B22:  MOVFF  13F,163
5B26:  MOVFF  13E,162
5B2A:  CALL   4896
5B2E:  MOVLB  1
5B30:  CLRF   x65
5B32:  CLRF   x64
5B34:  CLRF   x63
5B36:  MOVLW  8E
5B38:  MOVWF  x62
5B3A:  MOVFF  03,169
5B3E:  MOVFF  02,168
5B42:  MOVFF  01,167
5B46:  MOVFF  00,166
5B4A:  MOVLB  0
5B4C:  CALL   0ECE
5B50:  MOVFF  03,13D
5B54:  MOVFF  02,13C
5B58:  MOVFF  01,13B
5B5C:  MOVFF  00,13A
....................   res += (float32)(unsigned int16)y; 
5B60:  MOVFF  139,161
5B64:  MOVFF  138,160
5B68:  MOVFF  137,15F
5B6C:  MOVFF  136,15E
5B70:  CALL   48CC
5B74:  MOVFF  02,163
5B78:  MOVFF  01,162
5B7C:  CALL   4896
5B80:  BCF    FD8.1
5B82:  MOVFF  13D,167
5B86:  MOVFF  13C,166
5B8A:  MOVFF  13B,165
5B8E:  MOVFF  13A,164
5B92:  MOVFF  03,16B
5B96:  MOVFF  02,16A
5B9A:  MOVFF  01,169
5B9E:  MOVFF  00,168
5BA2:  CALL   1122
5BA6:  MOVFF  03,13D
5BAA:  MOVFF  02,13C
5BAE:  MOVFF  01,13B
5BB2:  MOVFF  00,13A
....................  } 
....................  
....................  else 
5BB6:  BRA    5BC8
....................   res = y; 
5BB8:  MOVFF  139,13D
5BBC:  MOVFF  138,13C
5BC0:  MOVFF  137,13B
5BC4:  MOVFF  136,13A
....................  
....................  y = y - (float32)(unsigned int16)y; 
5BC8:  MOVFF  139,161
5BCC:  MOVFF  138,160
5BD0:  MOVFF  137,15F
5BD4:  MOVFF  136,15E
5BD8:  CALL   48CC
5BDC:  MOVFF  02,163
5BE0:  MOVFF  01,162
5BE4:  CALL   4896
5BE8:  BSF    FD8.1
5BEA:  MOVFF  139,167
5BEE:  MOVFF  138,166
5BF2:  MOVFF  137,165
5BF6:  MOVFF  136,164
5BFA:  MOVFF  03,16B
5BFE:  MOVFF  02,16A
5C02:  MOVFF  01,169
5C06:  MOVFF  00,168
5C0A:  CALL   1122
5C0E:  MOVFF  03,139
5C12:  MOVFF  02,138
5C16:  MOVFF  01,137
5C1A:  MOVFF  00,136
....................  
....................  if (s) 
5C1E:  MOVLB  1
5C20:  BTFSS  x40.0
5C22:  BRA    5C2A
....................   res = -res; 
5C24:  MOVF   x3B,W
5C26:  XORLW  80
5C28:  MOVWF  x3B
....................  
....................  if (y != 0) 
5C2A:  MOVFF  139,161
5C2E:  MOVFF  138,160
5C32:  MOVFF  137,15F
5C36:  MOVFF  136,15E
5C3A:  CLRF   x65
5C3C:  CLRF   x64
5C3E:  CLRF   x63
5C40:  CLRF   x62
5C42:  MOVLB  0
5C44:  CALL   42F2
5C48:  BZ    5CC2
....................  { 
....................   if (s == 1 && n == 0) 
5C4A:  MOVLB  1
5C4C:  BTFSS  x40.0
5C4E:  BRA    5C88
5C50:  MOVF   x35,F
5C52:  BNZ   5C88
....................    res -= 1.0; 
5C54:  BSF    FD8.1
5C56:  MOVFF  13D,167
5C5A:  MOVFF  13C,166
5C5E:  MOVFF  13B,165
5C62:  MOVFF  13A,164
5C66:  CLRF   x6B
5C68:  CLRF   x6A
5C6A:  CLRF   x69
5C6C:  MOVLW  7F
5C6E:  MOVWF  x68
5C70:  MOVLB  0
5C72:  CALL   1122
5C76:  MOVFF  03,13D
5C7A:  MOVFF  02,13C
5C7E:  MOVFF  01,13B
5C82:  MOVFF  00,13A
5C86:  MOVLB  1
....................  
....................   if (s == 0 && n == 1) 
5C88:  BTFSC  x40.0
5C8A:  BRA    5CC4
5C8C:  DECFSZ x35,W
5C8E:  BRA    5CC4
....................    res += 1.0; 
5C90:  BCF    FD8.1
5C92:  MOVFF  13D,167
5C96:  MOVFF  13C,166
5C9A:  MOVFF  13B,165
5C9E:  MOVFF  13A,164
5CA2:  CLRF   x6B
5CA4:  CLRF   x6A
5CA6:  CLRF   x69
5CA8:  MOVLW  7F
5CAA:  MOVWF  x68
5CAC:  MOVLB  0
5CAE:  CALL   1122
5CB2:  MOVFF  03,13D
5CB6:  MOVFF  02,13C
5CBA:  MOVFF  01,13B
5CBE:  MOVFF  00,13A
5CC2:  MOVLB  1
....................  } 
....................  if (x == 0) 
5CC4:  MOVFF  134,161
5CC8:  MOVFF  133,160
5CCC:  MOVFF  132,15F
5CD0:  MOVFF  131,15E
5CD4:  CLRF   x65
5CD6:  CLRF   x64
5CD8:  CLRF   x63
5CDA:  CLRF   x62
5CDC:  MOVLB  0
5CDE:  CALL   42F2
5CE2:  BNZ   5CF0
....................     res = 0; 
5CE4:  MOVLB  1
5CE6:  CLRF   x3D
5CE8:  CLRF   x3C
5CEA:  CLRF   x3B
5CEC:  CLRF   x3A
5CEE:  MOVLB  0
....................  
....................  return (res); 
5CF0:  MOVFF  13A,00
5CF4:  MOVFF  13B,01
5CF8:  MOVFF  13C,02
5CFC:  MOVFF  13D,03
.................... } 
5D00:  RETLW  00
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
5D20:  MOVFF  130,134
5D24:  MOVFF  12F,133
5D28:  MOVFF  12E,132
5D2C:  MOVFF  12D,131
5D30:  MOVLB  1
5D32:  CLRF   x35
5D34:  MOVLB  0
5D36:  RCALL  598C
.................... } 
5D38:  GOTO   5E44 (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
5D02:  MOVFF  12F,134
5D06:  MOVFF  12E,133
5D0A:  MOVFF  12D,132
5D0E:  MOVFF  12C,131
5D12:  MOVLW  01
5D14:  MOVLB  1
5D16:  MOVWF  x35
5D18:  MOVLB  0
5D1A:  RCALL  598C
.................... } 
5D1C:  GOTO   5DFC (RETURN)
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
5D3C:  MOVFF  11F,161
5D40:  MOVFF  11E,160
5D44:  MOVFF  11D,15F
5D48:  MOVFF  11C,15E
5D4C:  MOVLB  1
5D4E:  CLRF   x65
5D50:  CLRF   x64
5D52:  CLRF   x63
5D54:  CLRF   x62
5D56:  MOVLB  0
5D58:  CALL   42F2
5D5C:  BTFSC  FD8.2
5D5E:  BRA    5EA2
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
5D60:  MOVFF  11B,161
5D64:  MOVFF  11A,160
5D68:  MOVFF  119,15F
5D6C:  MOVFF  118,15E
5D70:  MOVFF  11F,165
5D74:  MOVFF  11E,164
5D78:  MOVFF  11D,163
5D7C:  MOVFF  11C,162
5D80:  CALL   0FC4
5D84:  MOVFF  00,124
5D88:  MOVFF  01,125
5D8C:  MOVFF  02,126
5D90:  MOVFF  03,127
5D94:  MOVFF  03,161
5D98:  MOVFF  02,160
5D9C:  MOVFF  01,15F
5DA0:  MOVFF  00,15E
5DA4:  MOVLB  1
5DA6:  CLRF   x65
5DA8:  CLRF   x64
5DAA:  CLRF   x63
5DAC:  CLRF   x62
5DAE:  MOVLB  0
5DB0:  CALL   42F2
5DB4:  BNC   5DFE
5DB6:  MOVFF  11B,161
5DBA:  MOVFF  11A,160
5DBE:  MOVFF  119,15F
5DC2:  MOVFF  118,15E
5DC6:  MOVFF  11F,165
5DCA:  MOVFF  11E,164
5DCE:  MOVFF  11D,163
5DD2:  MOVFF  11C,162
5DD6:  CALL   0FC4
5DDA:  MOVFF  00,128
5DDE:  MOVFF  01,129
5DE2:  MOVFF  02,12A
5DE6:  MOVFF  03,12B
5DEA:  MOVFF  03,12F
5DEE:  MOVFF  02,12E
5DF2:  MOVFF  01,12D
5DF6:  MOVFF  00,12C
5DFA:  BRA    5D02
5DFC:  BRA    5E44
5DFE:  MOVFF  11B,161
5E02:  MOVFF  11A,160
5E06:  MOVFF  119,15F
5E0A:  MOVFF  118,15E
5E0E:  MOVFF  11F,165
5E12:  MOVFF  11E,164
5E16:  MOVFF  11D,163
5E1A:  MOVFF  11C,162
5E1E:  CALL   0FC4
5E22:  MOVFF  00,129
5E26:  MOVFF  01,12A
5E2A:  MOVFF  02,12B
5E2E:  MOVFF  03,12C
5E32:  MOVFF  03,130
5E36:  MOVFF  02,12F
5E3A:  MOVFF  01,12E
5E3E:  MOVFF  00,12D
5E42:  BRA    5D20
5E44:  MOVFF  03,123
5E48:  MOVFF  02,122
5E4C:  MOVFF  01,121
5E50:  MOVFF  00,120
....................       return(x-(i*y)); 
5E54:  MOVFF  123,165
5E58:  MOVFF  122,164
5E5C:  MOVFF  121,163
5E60:  MOVFF  120,162
5E64:  MOVFF  11F,169
5E68:  MOVFF  11E,168
5E6C:  MOVFF  11D,167
5E70:  MOVFF  11C,166
5E74:  CALL   0ECE
5E78:  BSF    FD8.1
5E7A:  MOVFF  11B,167
5E7E:  MOVFF  11A,166
5E82:  MOVFF  119,165
5E86:  MOVFF  118,164
5E8A:  MOVFF  03,16B
5E8E:  MOVFF  02,16A
5E92:  MOVFF  01,169
5E96:  MOVFF  00,168
5E9A:  CALL   1122
5E9E:  BRA    5EA2
....................    } 
....................    else 
5EA0:  BRA    5EA2
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
5EA2:  GOTO   613A (RETURN)
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
4D7C:  MOVFF  14A,161
4D80:  MOVFF  149,160
4D84:  MOVFF  148,15F
4D88:  MOVFF  147,15E
4D8C:  MOVLB  1
4D8E:  CLRF   x65
4D90:  CLRF   x64
4D92:  CLRF   x63
4D94:  CLRF   x62
4D96:  MOVLB  0
4D98:  CALL   42F2
4D9C:  BC    4DA0
4D9E:  BNZ   4DAA
....................       return(0.0); 
4DA0:  CLRF   00
4DA2:  CLRF   01
4DA4:  CLRF   02
4DA6:  CLRF   03
4DA8:  BRA    4EA4
....................  
....................    y=x; 
4DAA:  MOVFF  14A,14E
4DAE:  MOVFF  149,14D
4DB2:  MOVFF  148,14C
4DB6:  MOVFF  147,14B
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
4DBA:  MOVLW  01
4DBC:  MOVLB  1
4DBE:  MOVWF  x54
4DC0:  MOVLW  4B
4DC2:  MOVWF  x53
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
4DC4:  MOVFF  153,FE9
4DC8:  MOVFF  154,FEA
4DCC:  MOVF   FEF,W
4DCE:  CLRF   x58
4DD0:  MOVWF  x57
4DD2:  MOVLW  7F
4DD4:  ADDWF  x57,W
4DD6:  MOVWF  x59
4DD8:  MOVLW  00
4DDA:  ADDWFC x58,W
4DDC:  MOVWF  x5A
4DDE:  BCF    FD8.0
4DE0:  RRCF   x5A,W
4DE2:  RRCF   x59,W
4DE4:  MOVFF  154,FEA
4DE8:  MOVFF  153,FE9
4DEC:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
4DEE:  MOVFF  14E,152
4DF2:  MOVFF  14D,151
4DF6:  MOVFF  14C,150
4DFA:  MOVFF  14B,14F
....................       y+=(x/y); 
4DFE:  MOVFF  14A,161
4E02:  MOVFF  149,160
4E06:  MOVFF  148,15F
4E0A:  MOVFF  147,15E
4E0E:  MOVFF  14E,165
4E12:  MOVFF  14D,164
4E16:  MOVFF  14C,163
4E1A:  MOVFF  14B,162
4E1E:  MOVLB  0
4E20:  CALL   0FC4
4E24:  BCF    FD8.1
4E26:  MOVFF  14E,167
4E2A:  MOVFF  14D,166
4E2E:  MOVFF  14C,165
4E32:  MOVFF  14B,164
4E36:  MOVFF  03,16B
4E3A:  MOVFF  02,16A
4E3E:  MOVFF  01,169
4E42:  MOVFF  00,168
4E46:  CALL   1122
4E4A:  MOVFF  03,14E
4E4E:  MOVFF  02,14D
4E52:  MOVFF  01,14C
4E56:  MOVFF  00,14B
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
4E5A:  MOVLB  1
4E5C:  MOVFF  153,FE9
4E60:  MOVFF  154,FEA
4E64:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
4E66:  MOVFF  152,161
4E6A:  MOVFF  151,160
4E6E:  MOVFF  150,15F
4E72:  MOVFF  14F,15E
4E76:  MOVFF  14E,165
4E7A:  MOVFF  14D,164
4E7E:  MOVFF  14C,163
4E82:  MOVFF  14B,162
4E86:  MOVLB  0
4E88:  CALL   42F2
4E8C:  BTFSC  FD8.2
4E8E:  BRA    4E94
4E90:  MOVLB  1
4E92:  BRA    4DEE
....................  
....................    return(res); 
4E94:  MOVFF  14F,00
4E98:  MOVFF  150,01
4E9C:  MOVFF  151,02
4EA0:  MOVFF  152,03
.................... } 
4EA4:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
4908:  MOVLW  7F
490A:  MOVLB  1
490C:  MOVWF  x44
490E:  CLRF   x45
4910:  CLRF   x46
4912:  CLRF   x47
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
4914:  MOVLW  7E
4916:  MOVWF  x4E
4918:  MOVLW  80
491A:  MOVWF  x4F
491C:  CLRF   x50
491E:  CLRF   x51
4920:  MOVLW  7A
4922:  MOVWF  x52
4924:  MOVLW  2A
4926:  MOVWF  x53
4928:  MOVLW  AA
492A:  MOVWF  x54
492C:  MOVLW  A3
492E:  MOVWF  x55
4930:  MOVLW  75
4932:  MOVWF  x56
4934:  MOVLW  B6
4936:  MOVWF  x57
4938:  MOVLW  09
493A:  MOVWF  x58
493C:  MOVLW  9C
493E:  MOVWF  x59
4940:  MOVLW  6F
4942:  MOVWF  x5A
4944:  MOVLW  4F
4946:  MOVWF  x5B
4948:  MOVLW  B4
494A:  MOVWF  x5C
494C:  MOVLW  0B
494E:  MOVWF  x5D
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
4950:  MOVFF  13B,161
4954:  MOVFF  13A,160
4958:  MOVFF  139,15F
495C:  MOVFF  138,15E
4960:  CLRF   x65
4962:  CLRF   x64
4964:  CLRF   x63
4966:  CLRF   x62
4968:  MOVLB  0
496A:  RCALL  42F2
496C:  BNC   4976
496E:  MOVLB  1
4970:  MOVF   x39,W
4972:  XORLW  80
4974:  MOVWF  x39
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
4976:  MOVFF  13B,161
497A:  MOVFF  13A,160
497E:  MOVFF  139,15F
4982:  MOVFF  138,15E
4986:  MOVLW  DB
4988:  MOVLB  1
498A:  MOVWF  x65
498C:  MOVLW  0F
498E:  MOVWF  x64
4990:  MOVLW  49
4992:  MOVWF  x63
4994:  MOVLW  7F
4996:  MOVWF  x62
4998:  MOVLB  0
499A:  CALL   0FC4
499E:  MOVFF  03,161
49A2:  MOVFF  02,160
49A6:  MOVFF  01,15F
49AA:  MOVFF  00,15E
49AE:  RCALL  48CC
49B0:  MOVFF  01,148
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
49B4:  MOVFF  13B,161
49B8:  MOVFF  13A,160
49BC:  MOVFF  139,15F
49C0:  MOVFF  138,15E
49C4:  MOVLW  DB
49C6:  MOVLB  1
49C8:  MOVWF  x65
49CA:  MOVLW  0F
49CC:  MOVWF  x64
49CE:  MOVLW  49
49D0:  MOVWF  x63
49D2:  MOVLW  7F
49D4:  MOVWF  x62
49D6:  MOVLB  0
49D8:  CALL   0FC4
49DC:  MOVFF  00,15E
49E0:  MOVFF  01,15F
49E4:  MOVFF  02,160
49E8:  MOVFF  03,161
49EC:  MOVLB  1
49EE:  CLRF   x63
49F0:  MOVFF  148,162
49F4:  MOVLB  0
49F6:  RCALL  4896
49F8:  BSF    FD8.1
49FA:  MOVFF  161,167
49FE:  MOVFF  160,166
4A02:  MOVFF  15F,165
4A06:  MOVFF  15E,164
4A0A:  MOVFF  03,16B
4A0E:  MOVFF  02,16A
4A12:  MOVFF  01,169
4A16:  MOVFF  00,168
4A1A:  CALL   1122
4A1E:  MOVFF  03,14D
4A22:  MOVFF  02,14C
4A26:  MOVFF  01,14B
4A2A:  MOVFF  00,14A
....................    quad = quad % 4;                    // quadrant (0 to 3) 
4A2E:  MOVLW  03
4A30:  MOVLB  1
4A32:  ANDWF  x48,F
....................  
....................    if (quad == 0 || quad == 2) 
4A34:  MOVF   x48,F
4A36:  BZ    4A3E
4A38:  MOVF   x48,W
4A3A:  SUBLW  02
4A3C:  BNZ   4A78
....................       t = frac * PI_DIV_BY_TWO; 
4A3E:  MOVFF  14D,165
4A42:  MOVFF  14C,164
4A46:  MOVFF  14B,163
4A4A:  MOVFF  14A,162
4A4E:  MOVLW  DB
4A50:  MOVWF  x69
4A52:  MOVLW  0F
4A54:  MOVWF  x68
4A56:  MOVLW  49
4A58:  MOVWF  x67
4A5A:  MOVLW  7F
4A5C:  MOVWF  x66
4A5E:  MOVLB  0
4A60:  CALL   0ECE
4A64:  MOVFF  03,143
4A68:  MOVFF  02,142
4A6C:  MOVFF  01,141
4A70:  MOVFF  00,140
....................    else if (quad == 1) 
4A74:  BRA    4B54
4A76:  MOVLB  1
4A78:  DECFSZ x48,W
4A7A:  BRA    4AEA
....................       t = (1-frac) * PI_DIV_BY_TWO; 
4A7C:  BSF    FD8.1
4A7E:  CLRF   x67
4A80:  CLRF   x66
4A82:  CLRF   x65
4A84:  MOVLW  7F
4A86:  MOVWF  x64
4A88:  MOVFF  14D,16B
4A8C:  MOVFF  14C,16A
4A90:  MOVFF  14B,169
4A94:  MOVFF  14A,168
4A98:  MOVLB  0
4A9A:  CALL   1122
4A9E:  MOVFF  00,15E
4AA2:  MOVFF  01,15F
4AA6:  MOVFF  02,160
4AAA:  MOVFF  03,161
4AAE:  MOVFF  03,165
4AB2:  MOVFF  02,164
4AB6:  MOVFF  01,163
4ABA:  MOVFF  00,162
4ABE:  MOVLW  DB
4AC0:  MOVLB  1
4AC2:  MOVWF  x69
4AC4:  MOVLW  0F
4AC6:  MOVWF  x68
4AC8:  MOVLW  49
4ACA:  MOVWF  x67
4ACC:  MOVLW  7F
4ACE:  MOVWF  x66
4AD0:  MOVLB  0
4AD2:  CALL   0ECE
4AD6:  MOVFF  03,143
4ADA:  MOVFF  02,142
4ADE:  MOVFF  01,141
4AE2:  MOVFF  00,140
....................    else // should be 3 
4AE6:  BRA    4B54
4AE8:  MOVLB  1
....................       t = (frac-1) * PI_DIV_BY_TWO; 
4AEA:  BSF    FD8.1
4AEC:  MOVFF  14D,167
4AF0:  MOVFF  14C,166
4AF4:  MOVFF  14B,165
4AF8:  MOVFF  14A,164
4AFC:  CLRF   x6B
4AFE:  CLRF   x6A
4B00:  CLRF   x69
4B02:  MOVLW  7F
4B04:  MOVWF  x68
4B06:  MOVLB  0
4B08:  CALL   1122
4B0C:  MOVFF  00,15E
4B10:  MOVFF  01,15F
4B14:  MOVFF  02,160
4B18:  MOVFF  03,161
4B1C:  MOVFF  03,165
4B20:  MOVFF  02,164
4B24:  MOVFF  01,163
4B28:  MOVFF  00,162
4B2C:  MOVLW  DB
4B2E:  MOVLB  1
4B30:  MOVWF  x69
4B32:  MOVLW  0F
4B34:  MOVWF  x68
4B36:  MOVLW  49
4B38:  MOVWF  x67
4B3A:  MOVLW  7F
4B3C:  MOVWF  x66
4B3E:  MOVLB  0
4B40:  CALL   0ECE
4B44:  MOVFF  03,143
4B48:  MOVFF  02,142
4B4C:  MOVFF  01,141
4B50:  MOVFF  00,140
....................  
....................    y = 0.999999999781; 
4B54:  MOVLB  1
4B56:  CLRF   x3F
4B58:  CLRF   x3E
4B5A:  CLRF   x3D
4B5C:  MOVLW  7F
4B5E:  MOVWF  x3C
....................    t = t * t; 
4B60:  MOVFF  143,165
4B64:  MOVFF  142,164
4B68:  MOVFF  141,163
4B6C:  MOVFF  140,162
4B70:  MOVFF  143,169
4B74:  MOVFF  142,168
4B78:  MOVFF  141,167
4B7C:  MOVFF  140,166
4B80:  MOVLB  0
4B82:  CALL   0ECE
4B86:  MOVFF  03,143
4B8A:  MOVFF  02,142
4B8E:  MOVFF  01,141
4B92:  MOVFF  00,140
....................    for (i = 0; i <= 3; i++) 
4B96:  MOVLB  1
4B98:  CLRF   x49
4B9A:  MOVF   x49,W
4B9C:  SUBLW  03
4B9E:  BNC   4C6C
....................    { 
....................       t2 = t2 * t; 
4BA0:  MOVFF  147,165
4BA4:  MOVFF  146,164
4BA8:  MOVFF  145,163
4BAC:  MOVFF  144,162
4BB0:  MOVFF  143,169
4BB4:  MOVFF  142,168
4BB8:  MOVFF  141,167
4BBC:  MOVFF  140,166
4BC0:  MOVLB  0
4BC2:  CALL   0ECE
4BC6:  MOVFF  03,147
4BCA:  MOVFF  02,146
4BCE:  MOVFF  01,145
4BD2:  MOVFF  00,144
....................       y = y + p[i] * t2; 
4BD6:  MOVLB  1
4BD8:  MOVF   x49,W
4BDA:  MULLW  04
4BDC:  MOVF   FF3,W
4BDE:  CLRF   03
4BE0:  ADDLW  4E
4BE2:  MOVWF  FE9
4BE4:  MOVLW  01
4BE6:  ADDWFC 03,W
4BE8:  MOVWF  FEA
4BEA:  MOVFF  FEF,15E
4BEE:  MOVFF  FEC,15F
4BF2:  MOVFF  FEC,160
4BF6:  MOVFF  FEC,161
4BFA:  MOVFF  161,165
4BFE:  MOVFF  160,164
4C02:  MOVFF  15F,163
4C06:  MOVFF  15E,162
4C0A:  MOVFF  147,169
4C0E:  MOVFF  146,168
4C12:  MOVFF  145,167
4C16:  MOVFF  144,166
4C1A:  MOVLB  0
4C1C:  CALL   0ECE
4C20:  MOVFF  FEA,163
4C24:  MOVFF  FE9,162
4C28:  BCF    FD8.1
4C2A:  MOVFF  13F,167
4C2E:  MOVFF  13E,166
4C32:  MOVFF  13D,165
4C36:  MOVFF  13C,164
4C3A:  MOVFF  03,16B
4C3E:  MOVFF  02,16A
4C42:  MOVFF  01,169
4C46:  MOVFF  00,168
4C4A:  CALL   1122
4C4E:  MOVFF  163,FEA
4C52:  MOVFF  162,FE9
4C56:  MOVFF  03,13F
4C5A:  MOVFF  02,13E
4C5E:  MOVFF  01,13D
4C62:  MOVFF  00,13C
....................    } 
4C66:  MOVLB  1
4C68:  INCF   x49,F
4C6A:  BRA    4B9A
....................  
....................    if (quad == 2 || quad == 1) 
4C6C:  MOVF   x48,W
4C6E:  SUBLW  02
4C70:  BZ    4C76
4C72:  DECFSZ x48,W
4C74:  BRA    4C7C
....................       y = -y;  // correct sign 
4C76:  MOVF   x3D,W
4C78:  XORLW  80
4C7A:  MOVWF  x3D
....................  
....................    return (y); 
4C7C:  MOVFF  13C,00
4C80:  MOVFF  13D,01
4C84:  MOVFF  13E,02
4C88:  MOVFF  13F,03
.................... } 
4C8C:  MOVLB  0
4C8E:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
4C90:  BSF    FD8.1
4C92:  MOVFF  133,167
4C96:  MOVFF  132,166
4C9A:  MOVFF  131,165
4C9E:  MOVFF  130,164
4CA2:  MOVLW  DB
4CA4:  MOVLB  1
4CA6:  MOVWF  x6B
4CA8:  MOVLW  0F
4CAA:  MOVWF  x6A
4CAC:  MOVLW  49
4CAE:  MOVWF  x69
4CB0:  MOVLW  7F
4CB2:  MOVWF  x68
4CB4:  MOVLB  0
4CB6:  CALL   1122
4CBA:  MOVFF  00,134
4CBE:  MOVFF  01,135
4CC2:  MOVFF  02,136
4CC6:  MOVFF  03,137
4CCA:  MOVFF  03,13B
4CCE:  MOVFF  02,13A
4CD2:  MOVFF  01,139
4CD6:  MOVFF  00,138
4CDA:  RCALL  4908
.................... } 
4CDC:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
4CDE:  MOVFF  127,13B
4CE2:  MOVFF  126,13A
4CE6:  MOVFF  125,139
4CEA:  MOVFF  124,138
4CEE:  RCALL  4908
4CF0:  MOVFF  03,12B
4CF4:  MOVFF  02,12A
4CF8:  MOVFF  01,129
4CFC:  MOVFF  00,128
....................    if (c == 0.0) 
4D00:  MOVFF  12B,161
4D04:  MOVFF  12A,160
4D08:  MOVFF  129,15F
4D0C:  MOVFF  128,15E
4D10:  MOVLB  1
4D12:  CLRF   x65
4D14:  CLRF   x64
4D16:  CLRF   x63
4D18:  CLRF   x62
4D1A:  MOVLB  0
4D1C:  CALL   42F2
4D20:  BNZ   4D34
....................       return (1.0e+36); 
4D22:  MOVLW  F6
4D24:  MOVWF  00
4D26:  MOVLW  40
4D28:  MOVWF  01
4D2A:  MOVLW  97
4D2C:  MOVWF  02
4D2E:  MOVLW  CE
4D30:  MOVWF  03
4D32:  BRA    4D7A
....................  
....................    s = sin(x); 
4D34:  MOVFF  127,133
4D38:  MOVFF  126,132
4D3C:  MOVFF  125,131
4D40:  MOVFF  124,130
4D44:  RCALL  4C90
4D46:  MOVFF  03,12F
4D4A:  MOVFF  02,12E
4D4E:  MOVFF  01,12D
4D52:  MOVFF  00,12C
....................    return(s/c); 
4D56:  MOVFF  12F,161
4D5A:  MOVFF  12E,160
4D5E:  MOVFF  12D,15F
4D62:  MOVFF  12C,15E
4D66:  MOVFF  12B,165
4D6A:  MOVFF  12A,164
4D6E:  MOVFF  129,163
4D72:  MOVFF  128,162
4D76:  CALL   0FC4
.................... } 
4D7A:  RETLW  00
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
*
5546:  MOVLB  1
5548:  BCF    x3E.0
....................    y = x; 
554A:  MOVFF  12C,131
554E:  MOVFF  12B,130
5552:  MOVFF  12A,12F
5556:  MOVFF  129,12E
....................  
....................    if (x < 0) 
555A:  MOVFF  12C,161
555E:  MOVFF  12B,160
5562:  MOVFF  12A,15F
5566:  MOVFF  129,15E
556A:  CLRF   x65
556C:  CLRF   x64
556E:  CLRF   x63
5570:  CLRF   x62
5572:  MOVLB  0
5574:  CALL   42F2
5578:  BNC   5584
....................    { 
....................       s = 1; 
557A:  MOVLB  1
557C:  BSF    x3E.0
....................       y = -y; 
557E:  MOVF   x2F,W
5580:  XORLW  80
5582:  MOVWF  x2F
....................    } 
....................  
....................    if (y > 0.5) 
5584:  MOVLB  1
5586:  CLRF   x61
5588:  CLRF   x60
558A:  CLRF   x5F
558C:  MOVLW  7E
558E:  MOVWF  x5E
5590:  MOVFF  131,165
5594:  MOVFF  130,164
5598:  MOVFF  12F,163
559C:  MOVFF  12E,162
55A0:  MOVLB  0
55A2:  CALL   42F2
55A6:  BNC   563A
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
55A8:  BSF    FD8.1
55AA:  MOVLB  1
55AC:  CLRF   x67
55AE:  CLRF   x66
55B0:  CLRF   x65
55B2:  MOVLW  7F
55B4:  MOVWF  x64
55B6:  MOVFF  131,16B
55BA:  MOVFF  130,16A
55BE:  MOVFF  12F,169
55C2:  MOVFF  12E,168
55C6:  MOVLB  0
55C8:  CALL   1122
55CC:  MOVFF  00,13F
55D0:  MOVFF  01,140
55D4:  MOVFF  02,141
55D8:  MOVFF  03,142
55DC:  MOVFF  03,161
55E0:  MOVFF  02,160
55E4:  MOVFF  01,15F
55E8:  MOVFF  00,15E
55EC:  MOVLB  1
55EE:  CLRF   x65
55F0:  CLRF   x64
55F2:  CLRF   x63
55F4:  MOVLW  80
55F6:  MOVWF  x62
55F8:  MOVLB  0
55FA:  CALL   0FC4
55FE:  MOVFF  00,143
5602:  MOVFF  01,144
5606:  MOVFF  02,145
560A:  MOVFF  03,146
560E:  MOVFF  03,14A
5612:  MOVFF  02,149
5616:  MOVFF  01,148
561A:  MOVFF  00,147
561E:  CALL   4D7C
5622:  MOVFF  03,131
5626:  MOVFF  02,130
562A:  MOVFF  01,12F
562E:  MOVFF  00,12E
....................       n += 2; 
5632:  MOVLW  02
5634:  MOVLB  1
5636:  ADDWF  x2D,F
5638:  MOVLB  0
....................    } 
....................  
....................    y2=y*y; 
563A:  MOVFF  131,165
563E:  MOVFF  130,164
5642:  MOVFF  12F,163
5646:  MOVFF  12E,162
564A:  MOVFF  131,169
564E:  MOVFF  130,168
5652:  MOVFF  12F,167
5656:  MOVFF  12E,166
565A:  CALL   0ECE
565E:  MOVFF  03,13D
5662:  MOVFF  02,13C
5666:  MOVFF  01,13B
566A:  MOVFF  00,13A
....................  
....................    res = pas[0]*y2 + pas[1]; 
566E:  MOVLW  37
5670:  MOVLB  1
5672:  MOVWF  x65
5674:  MOVLW  BF
5676:  MOVWF  x64
5678:  MOVLW  7D
567A:  MOVWF  x63
567C:  MOVWF  x62
567E:  MOVFF  13D,169
5682:  MOVFF  13C,168
5686:  MOVFF  13B,167
568A:  MOVFF  13A,166
568E:  MOVLB  0
5690:  CALL   0ECE
5694:  MOVFF  00,13F
5698:  MOVFF  01,140
569C:  MOVFF  02,141
56A0:  MOVFF  03,142
56A4:  BCF    FD8.1
56A6:  MOVFF  03,167
56AA:  MOVFF  02,166
56AE:  MOVFF  01,165
56B2:  MOVFF  00,164
56B6:  MOVLW  3D
56B8:  MOVLB  1
56BA:  MOVWF  x6B
56BC:  MOVLW  AA
56BE:  MOVWF  x6A
56C0:  MOVLW  93
56C2:  MOVWF  x69
56C4:  MOVLW  81
56C6:  MOVWF  x68
56C8:  MOVLB  0
56CA:  CALL   1122
56CE:  MOVFF  03,135
56D2:  MOVFF  02,134
56D6:  MOVFF  01,133
56DA:  MOVFF  00,132
....................    res = res*y2 + pas[2]; 
56DE:  MOVFF  135,165
56E2:  MOVFF  134,164
56E6:  MOVFF  133,163
56EA:  MOVFF  132,162
56EE:  MOVFF  13D,169
56F2:  MOVFF  13C,168
56F6:  MOVFF  13B,167
56FA:  MOVFF  13A,166
56FE:  CALL   0ECE
5702:  MOVFF  00,13F
5706:  MOVFF  01,140
570A:  MOVFF  02,141
570E:  MOVFF  03,142
5712:  BCF    FD8.1
5714:  MOVFF  03,167
5718:  MOVFF  02,166
571C:  MOVFF  01,165
5720:  MOVFF  00,164
5724:  MOVLW  EE
5726:  MOVLB  1
5728:  MOVWF  x6B
572A:  MOVLW  50
572C:  MOVWF  x6A
572E:  MOVLW  33
5730:  MOVWF  x69
5732:  MOVLW  81
5734:  MOVWF  x68
5736:  MOVLB  0
5738:  CALL   1122
573C:  MOVFF  03,135
5740:  MOVFF  02,134
5744:  MOVFF  01,133
5748:  MOVFF  00,132
....................  
....................    r = qas[0]*y2 + qas[1]; 
574C:  MOVLB  1
574E:  CLRF   x65
5750:  CLRF   x64
5752:  CLRF   x63
5754:  MOVLW  7F
5756:  MOVWF  x62
5758:  MOVFF  13D,169
575C:  MOVFF  13C,168
5760:  MOVFF  13B,167
5764:  MOVFF  13A,166
5768:  MOVLB  0
576A:  CALL   0ECE
576E:  MOVFF  00,13F
5772:  MOVFF  01,140
5776:  MOVFF  02,141
577A:  MOVFF  03,142
577E:  BCF    FD8.1
5780:  MOVFF  03,167
5784:  MOVFF  02,166
5788:  MOVFF  01,165
578C:  MOVFF  00,164
5790:  MOVLW  0A
5792:  MOVLB  1
5794:  MOVWF  x6B
5796:  MOVLW  8D
5798:  MOVWF  x6A
579A:  MOVLW  B1
579C:  MOVWF  x69
579E:  MOVLW  81
57A0:  MOVWF  x68
57A2:  MOVLB  0
57A4:  CALL   1122
57A8:  MOVFF  03,139
57AC:  MOVFF  02,138
57B0:  MOVFF  01,137
57B4:  MOVFF  00,136
....................    r = r*y2 + qas[2]; 
57B8:  MOVFF  139,165
57BC:  MOVFF  138,164
57C0:  MOVFF  137,163
57C4:  MOVFF  136,162
57C8:  MOVFF  13D,169
57CC:  MOVFF  13C,168
57D0:  MOVFF  13B,167
57D4:  MOVFF  13A,166
57D8:  CALL   0ECE
57DC:  MOVFF  00,13F
57E0:  MOVFF  01,140
57E4:  MOVFF  02,141
57E8:  MOVFF  03,142
57EC:  BCF    FD8.1
57EE:  MOVFF  03,167
57F2:  MOVFF  02,166
57F6:  MOVFF  01,165
57FA:  MOVFF  00,164
57FE:  MOVLW  EE
5800:  MOVLB  1
5802:  MOVWF  x6B
5804:  MOVLW  50
5806:  MOVWF  x6A
5808:  MOVLW  33
580A:  MOVWF  x69
580C:  MOVLW  81
580E:  MOVWF  x68
5810:  MOVLB  0
5812:  CALL   1122
5816:  MOVFF  03,139
581A:  MOVFF  02,138
581E:  MOVFF  01,137
5822:  MOVFF  00,136
....................  
....................    res = y*res/r; 
5826:  MOVFF  131,165
582A:  MOVFF  130,164
582E:  MOVFF  12F,163
5832:  MOVFF  12E,162
5836:  MOVFF  135,169
583A:  MOVFF  134,168
583E:  MOVFF  133,167
5842:  MOVFF  132,166
5846:  CALL   0ECE
584A:  MOVFF  00,13F
584E:  MOVFF  01,140
5852:  MOVFF  02,141
5856:  MOVFF  03,142
585A:  MOVFF  03,161
585E:  MOVFF  02,160
5862:  MOVFF  01,15F
5866:  MOVFF  00,15E
586A:  MOVFF  139,165
586E:  MOVFF  138,164
5872:  MOVFF  137,163
5876:  MOVFF  136,162
587A:  CALL   0FC4
587E:  MOVFF  03,135
5882:  MOVFF  02,134
5886:  MOVFF  01,133
588A:  MOVFF  00,132
....................  
....................    if (n & 2)     // |x| > 0.5 
588E:  MOVLB  1
5890:  BTFSS  x2D.1
5892:  BRA    58F0
....................       res = PI_DIV_BY_TWO - 2.0*res; 
5894:  CLRF   x65
5896:  CLRF   x64
5898:  CLRF   x63
589A:  MOVLW  80
589C:  MOVWF  x62
589E:  MOVFF  135,169
58A2:  MOVFF  134,168
58A6:  MOVFF  133,167
58AA:  MOVFF  132,166
58AE:  MOVLB  0
58B0:  CALL   0ECE
58B4:  BSF    FD8.1
58B6:  MOVLW  DB
58B8:  MOVLB  1
58BA:  MOVWF  x67
58BC:  MOVLW  0F
58BE:  MOVWF  x66
58C0:  MOVLW  49
58C2:  MOVWF  x65
58C4:  MOVLW  7F
58C6:  MOVWF  x64
58C8:  MOVFF  03,16B
58CC:  MOVFF  02,16A
58D0:  MOVFF  01,169
58D4:  MOVFF  00,168
58D8:  MOVLB  0
58DA:  CALL   1122
58DE:  MOVFF  03,135
58E2:  MOVFF  02,134
58E6:  MOVFF  01,133
58EA:  MOVFF  00,132
58EE:  MOVLB  1
....................    if (s) 
58F0:  BTFSS  x3E.0
58F2:  BRA    58FA
....................       res = -res; 
58F4:  MOVF   x33,W
58F6:  XORLW  80
58F8:  MOVWF  x33
....................    if (n & 1)           // take arccos 
58FA:  BTFSS  x2D.0
58FC:  BRA    5938
....................       res = PI_DIV_BY_TWO - res; 
58FE:  BSF    FD8.1
5900:  MOVLW  DB
5902:  MOVWF  x67
5904:  MOVLW  0F
5906:  MOVWF  x66
5908:  MOVLW  49
590A:  MOVWF  x65
590C:  MOVLW  7F
590E:  MOVWF  x64
5910:  MOVFF  135,16B
5914:  MOVFF  134,16A
5918:  MOVFF  133,169
591C:  MOVFF  132,168
5920:  MOVLB  0
5922:  CALL   1122
5926:  MOVFF  03,135
592A:  MOVFF  02,134
592E:  MOVFF  01,133
5932:  MOVFF  00,132
5936:  MOVLB  1
....................  
....................    return(res); 
5938:  MOVFF  132,00
593C:  MOVFF  133,01
5940:  MOVFF  134,02
5944:  MOVFF  135,03
.................... } 
5948:  MOVLB  0
594A:  GOTO   5968 (RETURN)
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
594E:  MOVFF  124,12C
5952:  MOVFF  123,12B
5956:  MOVFF  122,12A
595A:  MOVFF  121,129
595E:  MOVLW  01
5960:  MOVLB  1
5962:  MOVWF  x2D
5964:  MOVLB  0
5966:  BRA    5546
5968:  MOVFF  03,128
596C:  MOVFF  02,127
5970:  MOVFF  01,126
5974:  MOVFF  00,125
....................    return(r); 
5978:  MOVFF  125,00
597C:  MOVFF  126,01
5980:  MOVFF  127,02
5984:  MOVFF  128,03
.................... } 
5988:  GOTO   6076 (RETURN)
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
436C:  MOVLB  1
436E:  BCF    x36.0
....................    flag = 0; 
4370:  BCF    x36.1
....................    y = x; 
4372:  MOVFF  129,12D
4376:  MOVFF  128,12C
437A:  MOVFF  127,12B
437E:  MOVFF  126,12A
....................  
....................    if (x < 0) 
4382:  MOVFF  129,161
4386:  MOVFF  128,160
438A:  MOVFF  127,15F
438E:  MOVFF  126,15E
4392:  CLRF   x65
4394:  CLRF   x64
4396:  CLRF   x63
4398:  CLRF   x62
439A:  MOVLB  0
439C:  RCALL  42F2
439E:  BNC   43AA
....................    { 
....................       s = 1; 
43A0:  MOVLB  1
43A2:  BSF    x36.0
....................       y = -y; 
43A4:  MOVF   x2B,W
43A6:  XORLW  80
43A8:  MOVWF  x2B
....................    } 
....................  
....................    if (y > 1.0) 
43AA:  MOVLB  1
43AC:  CLRF   x61
43AE:  CLRF   x60
43B0:  CLRF   x5F
43B2:  MOVLW  7F
43B4:  MOVWF  x5E
43B6:  MOVFF  12D,165
43BA:  MOVFF  12C,164
43BE:  MOVFF  12B,163
43C2:  MOVFF  12A,162
43C6:  MOVLB  0
43C8:  RCALL  42F2
43CA:  BNC   4402
....................    { 
....................       y = 1.0/y; 
43CC:  MOVLB  1
43CE:  CLRF   x61
43D0:  CLRF   x60
43D2:  CLRF   x5F
43D4:  MOVLW  7F
43D6:  MOVWF  x5E
43D8:  MOVFF  12D,165
43DC:  MOVFF  12C,164
43E0:  MOVFF  12B,163
43E4:  MOVFF  12A,162
43E8:  MOVLB  0
43EA:  CALL   0FC4
43EE:  MOVFF  03,12D
43F2:  MOVFF  02,12C
43F6:  MOVFF  01,12B
43FA:  MOVFF  00,12A
....................       flag = 1; 
43FE:  MOVLB  1
4400:  BSF    x36.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
4402:  MOVLW  0A
4404:  MOVLB  1
4406:  MOVWF  x65
4408:  MOVLW  89
440A:  MOVWF  x64
440C:  MOVLW  34
440E:  MOVWF  x63
4410:  MOVLW  7C
4412:  MOVWF  x62
4414:  MOVFF  12D,169
4418:  MOVFF  12C,168
441C:  MOVFF  12B,167
4420:  MOVFF  12A,166
4424:  MOVLB  0
4426:  CALL   0ECE
442A:  MOVFF  00,137
442E:  MOVFF  01,138
4432:  MOVFF  02,139
4436:  MOVFF  03,13A
443A:  MOVFF  03,165
443E:  MOVFF  02,164
4442:  MOVFF  01,163
4446:  MOVFF  00,162
444A:  MOVFF  12D,169
444E:  MOVFF  12C,168
4452:  MOVFF  12B,167
4456:  MOVFF  12A,166
445A:  CALL   0ECE
445E:  MOVFF  00,13B
4462:  MOVFF  01,13C
4466:  MOVFF  02,13D
446A:  MOVFF  03,13E
446E:  BCF    FD8.1
4470:  MOVFF  03,167
4474:  MOVFF  02,166
4478:  MOVFF  01,165
447C:  MOVFF  00,164
4480:  MOVLW  7C
4482:  MOVLB  1
4484:  MOVWF  x6B
4486:  MOVLW  79
4488:  MOVWF  x6A
448A:  MOVLW  35
448C:  MOVWF  x69
448E:  MOVLW  81
4490:  MOVWF  x68
4492:  MOVLB  0
4494:  CALL   1122
4498:  MOVFF  03,131
449C:  MOVFF  02,130
44A0:  MOVFF  01,12F
44A4:  MOVFF  00,12E
....................    res = res*y*y + pat[2]; 
44A8:  MOVFF  131,165
44AC:  MOVFF  130,164
44B0:  MOVFF  12F,163
44B4:  MOVFF  12E,162
44B8:  MOVFF  12D,169
44BC:  MOVFF  12C,168
44C0:  MOVFF  12B,167
44C4:  MOVFF  12A,166
44C8:  CALL   0ECE
44CC:  MOVFF  00,137
44D0:  MOVFF  01,138
44D4:  MOVFF  02,139
44D8:  MOVFF  03,13A
44DC:  MOVFF  03,165
44E0:  MOVFF  02,164
44E4:  MOVFF  01,163
44E8:  MOVFF  00,162
44EC:  MOVFF  12D,169
44F0:  MOVFF  12C,168
44F4:  MOVFF  12B,167
44F8:  MOVFF  12A,166
44FC:  CALL   0ECE
4500:  MOVFF  00,13B
4504:  MOVFF  01,13C
4508:  MOVFF  02,13D
450C:  MOVFF  03,13E
4510:  BCF    FD8.1
4512:  MOVFF  03,167
4516:  MOVFF  02,166
451A:  MOVFF  01,165
451E:  MOVFF  00,164
4522:  MOVLW  3F
4524:  MOVLB  1
4526:  MOVWF  x6B
4528:  MOVLW  02
452A:  MOVWF  x6A
452C:  MOVLW  33
452E:  MOVWF  x69
4530:  MOVLW  83
4532:  MOVWF  x68
4534:  MOVLB  0
4536:  CALL   1122
453A:  MOVFF  03,131
453E:  MOVFF  02,130
4542:  MOVFF  01,12F
4546:  MOVFF  00,12E
....................    res = res*y*y + pat[3]; 
454A:  MOVFF  131,165
454E:  MOVFF  130,164
4552:  MOVFF  12F,163
4556:  MOVFF  12E,162
455A:  MOVFF  12D,169
455E:  MOVFF  12C,168
4562:  MOVFF  12B,167
4566:  MOVFF  12A,166
456A:  CALL   0ECE
456E:  MOVFF  00,137
4572:  MOVFF  01,138
4576:  MOVFF  02,139
457A:  MOVFF  03,13A
457E:  MOVFF  03,165
4582:  MOVFF  02,164
4586:  MOVFF  01,163
458A:  MOVFF  00,162
458E:  MOVFF  12D,169
4592:  MOVFF  12C,168
4596:  MOVFF  12B,167
459A:  MOVFF  12A,166
459E:  CALL   0ECE
45A2:  MOVFF  00,13B
45A6:  MOVFF  01,13C
45AA:  MOVFF  02,13D
45AE:  MOVFF  03,13E
45B2:  BCF    FD8.1
45B4:  MOVFF  03,167
45B8:  MOVFF  02,166
45BC:  MOVFF  01,165
45C0:  MOVFF  00,164
45C4:  MOVLW  33
45C6:  MOVLB  1
45C8:  MOVWF  x6B
45CA:  MOVLW  8C
45CC:  MOVWF  x6A
45CE:  MOVLW  1E
45D0:  MOVWF  x69
45D2:  MOVLW  83
45D4:  MOVWF  x68
45D6:  MOVLB  0
45D8:  CALL   1122
45DC:  MOVFF  03,131
45E0:  MOVFF  02,130
45E4:  MOVFF  01,12F
45E8:  MOVFF  00,12E
....................  
....................    r = qat[0]*y*y + qat[1]; 
45EC:  MOVLB  1
45EE:  CLRF   x65
45F0:  CLRF   x64
45F2:  CLRF   x63
45F4:  MOVLW  7F
45F6:  MOVWF  x62
45F8:  MOVFF  12D,169
45FC:  MOVFF  12C,168
4600:  MOVFF  12B,167
4604:  MOVFF  12A,166
4608:  MOVLB  0
460A:  CALL   0ECE
460E:  MOVFF  00,137
4612:  MOVFF  01,138
4616:  MOVFF  02,139
461A:  MOVFF  03,13A
461E:  MOVFF  03,165
4622:  MOVFF  02,164
4626:  MOVFF  01,163
462A:  MOVFF  00,162
462E:  MOVFF  12D,169
4632:  MOVFF  12C,168
4636:  MOVFF  12B,167
463A:  MOVFF  12A,166
463E:  CALL   0ECE
4642:  MOVFF  00,13B
4646:  MOVFF  01,13C
464A:  MOVFF  02,13D
464E:  MOVFF  03,13E
4652:  BCF    FD8.1
4654:  MOVFF  03,167
4658:  MOVFF  02,166
465C:  MOVFF  01,165
4660:  MOVFF  00,164
4664:  MOVLW  1B
4666:  MOVLB  1
4668:  MOVWF  x6B
466A:  MOVLW  E4
466C:  MOVWF  x6A
466E:  MOVLW  35
4670:  MOVWF  x69
4672:  MOVLW  82
4674:  MOVWF  x68
4676:  MOVLB  0
4678:  CALL   1122
467C:  MOVFF  03,135
4680:  MOVFF  02,134
4684:  MOVFF  01,133
4688:  MOVFF  00,132
....................    r = r*y*y + qat[2]; 
468C:  MOVFF  135,165
4690:  MOVFF  134,164
4694:  MOVFF  133,163
4698:  MOVFF  132,162
469C:  MOVFF  12D,169
46A0:  MOVFF  12C,168
46A4:  MOVFF  12B,167
46A8:  MOVFF  12A,166
46AC:  CALL   0ECE
46B0:  MOVFF  00,137
46B4:  MOVFF  01,138
46B8:  MOVFF  02,139
46BC:  MOVFF  03,13A
46C0:  MOVFF  03,165
46C4:  MOVFF  02,164
46C8:  MOVFF  01,163
46CC:  MOVFF  00,162
46D0:  MOVFF  12D,169
46D4:  MOVFF  12C,168
46D8:  MOVFF  12B,167
46DC:  MOVFF  12A,166
46E0:  CALL   0ECE
46E4:  MOVFF  00,13B
46E8:  MOVFF  01,13C
46EC:  MOVFF  02,13D
46F0:  MOVFF  03,13E
46F4:  BCF    FD8.1
46F6:  MOVFF  03,167
46FA:  MOVFF  02,166
46FE:  MOVFF  01,165
4702:  MOVFF  00,164
4706:  MOVLW  A4
4708:  MOVLB  1
470A:  MOVWF  x6B
470C:  MOVLW  DB
470E:  MOVWF  x6A
4710:  MOVLW  67
4712:  MOVWF  x69
4714:  MOVLW  83
4716:  MOVWF  x68
4718:  MOVLB  0
471A:  CALL   1122
471E:  MOVFF  03,135
4722:  MOVFF  02,134
4726:  MOVFF  01,133
472A:  MOVFF  00,132
....................    r = r*y*y + qat[3]; 
472E:  MOVFF  135,165
4732:  MOVFF  134,164
4736:  MOVFF  133,163
473A:  MOVFF  132,162
473E:  MOVFF  12D,169
4742:  MOVFF  12C,168
4746:  MOVFF  12B,167
474A:  MOVFF  12A,166
474E:  CALL   0ECE
4752:  MOVFF  00,137
4756:  MOVFF  01,138
475A:  MOVFF  02,139
475E:  MOVFF  03,13A
4762:  MOVFF  03,165
4766:  MOVFF  02,164
476A:  MOVFF  01,163
476E:  MOVFF  00,162
4772:  MOVFF  12D,169
4776:  MOVFF  12C,168
477A:  MOVFF  12B,167
477E:  MOVFF  12A,166
4782:  CALL   0ECE
4786:  MOVFF  00,13B
478A:  MOVFF  01,13C
478E:  MOVFF  02,13D
4792:  MOVFF  03,13E
4796:  BCF    FD8.1
4798:  MOVFF  03,167
479C:  MOVFF  02,166
47A0:  MOVFF  01,165
47A4:  MOVFF  00,164
47A8:  MOVLW  33
47AA:  MOVLB  1
47AC:  MOVWF  x6B
47AE:  MOVLW  8C
47B0:  MOVWF  x6A
47B2:  MOVLW  1E
47B4:  MOVWF  x69
47B6:  MOVLW  83
47B8:  MOVWF  x68
47BA:  MOVLB  0
47BC:  CALL   1122
47C0:  MOVFF  03,135
47C4:  MOVFF  02,134
47C8:  MOVFF  01,133
47CC:  MOVFF  00,132
....................  
....................    res = y*res/r; 
47D0:  MOVFF  12D,165
47D4:  MOVFF  12C,164
47D8:  MOVFF  12B,163
47DC:  MOVFF  12A,162
47E0:  MOVFF  131,169
47E4:  MOVFF  130,168
47E8:  MOVFF  12F,167
47EC:  MOVFF  12E,166
47F0:  CALL   0ECE
47F4:  MOVFF  00,137
47F8:  MOVFF  01,138
47FC:  MOVFF  02,139
4800:  MOVFF  03,13A
4804:  MOVFF  03,161
4808:  MOVFF  02,160
480C:  MOVFF  01,15F
4810:  MOVFF  00,15E
4814:  MOVFF  135,165
4818:  MOVFF  134,164
481C:  MOVFF  133,163
4820:  MOVFF  132,162
4824:  CALL   0FC4
4828:  MOVFF  03,131
482C:  MOVFF  02,130
4830:  MOVFF  01,12F
4834:  MOVFF  00,12E
....................  
....................  
....................    if (flag)                              // for |x| > 1 
4838:  MOVLB  1
483A:  BTFSS  x36.1
483C:  BRA    4878
....................       res = PI_DIV_BY_TWO - res; 
483E:  BSF    FD8.1
4840:  MOVLW  DB
4842:  MOVWF  x67
4844:  MOVLW  0F
4846:  MOVWF  x66
4848:  MOVLW  49
484A:  MOVWF  x65
484C:  MOVLW  7F
484E:  MOVWF  x64
4850:  MOVFF  131,16B
4854:  MOVFF  130,16A
4858:  MOVFF  12F,169
485C:  MOVFF  12E,168
4860:  MOVLB  0
4862:  CALL   1122
4866:  MOVFF  03,131
486A:  MOVFF  02,130
486E:  MOVFF  01,12F
4872:  MOVFF  00,12E
4876:  MOVLB  1
....................    if (s) 
4878:  BTFSS  x36.0
487A:  BRA    4882
....................       res = -res; 
487C:  MOVF   x2F,W
487E:  XORLW  80
4880:  MOVWF  x2F
....................  
....................    return(res); 
4882:  MOVFF  12E,00
4886:  MOVFF  12F,01
488A:  MOVFF  130,02
488E:  MOVFF  131,03
.................... } 
4892:  MOVLB  0
4894:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,NOBROWNOUT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
04C2:  MOVLW  01
04C4:  MOVWF  FEA
04C6:  MOVLW  20
04C8:  MOVWF  FE9
04CA:  MOVF   FEF,W
04CC:  BZ    04EA
04CE:  MOVLW  03
04D0:  MOVWF  01
04D2:  CLRF   00
04D4:  DECFSZ 00,F
04D6:  BRA    04D4
04D8:  DECFSZ 01,F
04DA:  BRA    04D2
04DC:  MOVLW  3C
04DE:  MOVWF  00
04E0:  DECFSZ 00,F
04E2:  BRA    04E0
04E4:  BRA    04E6
04E6:  DECFSZ FEF,F
04E8:  BRA    04CE
04EA:  RETLW  00
.................... #use rs232(baud=57600, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N) 
....................  
....................  
....................  
....................  
....................  
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct port_d_map{ 
....................    int8 lcd_nibble:4; //0:3 
....................    boolean ps_en;     //4 
....................    boolean meas_rly;  //5 
....................    boolean pwr_ctrl;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... struct port_e_map{ 
....................    boolean rs; //0 
....................    boolean emgcy; //1 
....................    boolean tx_en; //2 
....................     int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
.................... #byte PORTA =0xF80 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... ////////////// actuator parameter ///////// 
.................... #define DIM_A 107.5 
.................... #define DIM_P 9.3 
.................... #define DIM_M 5.5 
.................... #define DIM_K 36.0 
.................... #define DIM_B 15.8 
.................... #define MIN_STROKE 70.3  
.................... #define MAX_STROKE 128.0 
.................... #define ROW_SPACING 320.00 
.................... #define PANEL_WIDTH 160.00 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1   PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3   PIN_B3 
.................... #define CCW PIN_B4 
.................... #define FLASH_SELECT PIN_C2 // output 
.................... #define FLASH_CLOCK  PIN_C3 // output 
.................... #define FLASH_DI     PIN_C5 // output 
.................... #define FLASH_DO     PIN_C4 // input 
.................... #define SENSE_0       PIN_A1 
.................... #define SENSE_1       PIN_A2 
.................... #define SENSE_2       PIN_A3 
.................... #define SENSE_3       PIN_A4 
.................... #define WALL_PWR    PIN_A5 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00002 
.................... #define ADDR_TIME           0xf00004 
.................... #define ADDR_START_COUNTER  0xf00008 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x05B1} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000} 
.................... #rom ADDR_TIME={0x0000,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... //#rom ADDR_TIME={0x1C20,0x0000} 
....................  
.................... const int8 line[4] = {0,0x40,0x10,0x50}; 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... char tmp_str[20],tmp_str2[20]; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... unsigned int8 timer_ms=0; 
.................... unsigned int32 next_sun_rise; 
.................... unsigned int16 current_act_position=0; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int32 JDN,jj,g; 
.................... unsigned int32 dg,c,dc,b,db,a,da,y,m,d; 
.................... unsigned int32 YY,MM,DD,time_of_day; 
.................... unsigned int32 sec_until_sun_rise; 
.................... int16 FULL_STROKE_TICK=0; 
.................... float al; 
.................... int16 move_act_time_out=3; 
.................... int8 tx_delay=0; 
.................... int16 current_measured=0; 
.................... int8 n_avg_current_measured=0; 
.................... int16 startup_counter=0; 
.................... int16 actuator_pulse=0; 
.................... unsigned int8 index_in_page; 
.................... float len_a,len_b,len_c,len_p,len_m,len_k,len_l; 
.................... float sin_beta,cos_beta,tan_beta; 
.................... float temp1; 
.................... float alpha; 
.................... float act_len; 
....................  
....................  
.................... void init_ext_flash(void); 
.................... void ext_flash_startContinuousRead(int pageAddress); 
.................... void ext_flash_sendData(int data, int size); 
.................... void ext_flash_send16Data(int16 data, int size); 
.................... void ext_flash_sendBytes(char* data, int size); 
.................... void ext_flash_getBytes(char* data, int16 size); 
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size); 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size); 
.................... int ext_flash_getByte(void); 
.................... void ext_flash_waitUntilReady(void); 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
3A4E:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
3A50:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
3A52:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
3A54:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
3A56:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
3A58:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
3A5A:  BCF    FAC.5
....................    delay_cycles(10); 
3A5C:  MOVLW  03
3A5E:  MOVWF  00
3A60:  DECFSZ 00,F
3A62:  BRA    3A60
....................    bit_set(RCSTA,4); //CREN=1 
3A64:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
3A66:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
3A68:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
3A6A:  BSF    F9D.5
....................  
.................... } 
3A6C:  GOTO   6678 (RETURN)
....................  
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int i; 
....................    int16 temp_mem;    
....................    temp_mem= &timer_sec; 
*
05C8:  MOVLB  1
05CA:  CLRF   x08
05CC:  MOVLW  20
05CE:  MOVWF  x07
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
05D0:  CLRF   x06
05D2:  MOVF   x06,W
05D4:  SUBLW  03
05D6:  BNC   061E
05D8:  MOVF   x06,W
05DA:  ADDWF  x07,W
05DC:  MOVWF  x09
05DE:  MOVLW  00
05E0:  ADDWFC x08,W
05E2:  MOVWF  x0A
05E4:  MOVLW  04
05E6:  ADDWF  x06,W
05E8:  MOVWF  x0B
05EA:  MOVFF  FF2,10C
05EE:  BCF    FF2.7
05F0:  MOVFF  10B,FA9
05F4:  BCF    FA6.6
05F6:  BCF    FA6.7
05F8:  BSF    FA6.0
05FA:  MOVF   FA8,W
05FC:  BTFSC  x0C.7
05FE:  BSF    FF2.7
0600:  MOVWF  x0C
0602:  MOVFF  10A,FEA
0606:  MOVFF  109,FE9
060A:  MOVFF  10C,10D
060E:  CLRF   x0F
0610:  MOVLW  01
0612:  MOVWF  x0E
0614:  MOVLB  0
0616:  RCALL  05AA
0618:  MOVLB  1
061A:  INCF   x06,F
061C:  BRA    05D2
....................    temp_mem= &FULL_STROKE_TICK; 
061E:  CLRF   x08
0620:  MOVLW  BA
0622:  MOVWF  x07
....................    if (FULL_STROKE_TICK > MAX_FULL_STROKE) FULL_STROKE_TICK = MAX_FULL_STROKE; 
0624:  MOVLB  0
0626:  MOVF   xBB,W
0628:  SUBLW  06
062A:  BC    063E
062C:  XORLW  FF
062E:  BNZ   0636
0630:  MOVF   xBA,W
0632:  SUBLW  D0
0634:  BC    063E
0636:  MOVLW  07
0638:  MOVWF  xBB
063A:  MOVLW  D0
063C:  MOVWF  xBA
....................    if (FULL_STROKE_TICK <0) FULL_STROKE_TICK = 0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i),1); 
063E:  MOVLB  1
0640:  CLRF   x06
0642:  MOVF   x06,W
0644:  SUBLW  01
0646:  BNC   0688
0648:  MOVF   x06,W
064A:  ADDWF  x07,W
064C:  MOVWF  x09
064E:  MOVLW  00
0650:  ADDWFC x08,W
0652:  MOVWF  x0A
0654:  MOVFF  FF2,10B
0658:  BCF    FF2.7
065A:  MOVFF  106,FA9
065E:  BCF    FA6.6
0660:  BCF    FA6.7
0662:  BSF    FA6.0
0664:  MOVF   FA8,W
0666:  BTFSC  x0B.7
0668:  BSF    FF2.7
066A:  MOVWF  x0C
066C:  MOVFF  10A,FEA
0670:  MOVFF  109,FE9
0674:  MOVFF  10C,10D
0678:  CLRF   x0F
067A:  MOVLW  01
067C:  MOVWF  x0E
067E:  MOVLB  0
0680:  RCALL  05AA
0682:  MOVLB  1
0684:  INCF   x06,F
0686:  BRA    0642
....................    temp_mem= &current_act_position; 
0688:  CLRF   x08
068A:  MOVLW  6E
068C:  MOVWF  x07
....................    if (current_act_position > FULL_STROKE_TICK) current_act_position = FULL_STROKE_TICK; 
068E:  MOVLB  0
0690:  MOVF   xBB,W
0692:  SUBWF  x6F,W
0694:  BNC   06A6
0696:  BNZ   069E
0698:  MOVF   x6E,W
069A:  SUBWF  xBA,W
069C:  BC    06A6
069E:  MOVFF  BB,6F
06A2:  MOVFF  BA,6E
....................    if (current_act_position < 0) current_act_position =0; 
....................  
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i),1); 
06A6:  MOVLB  1
06A8:  CLRF   x06
06AA:  MOVF   x06,W
06AC:  SUBLW  01
06AE:  BNC   06F6
06B0:  MOVF   x06,W
06B2:  ADDWF  x07,W
06B4:  MOVWF  x09
06B6:  MOVLW  00
06B8:  ADDWFC x08,W
06BA:  MOVWF  x0A
06BC:  MOVLW  02
06BE:  ADDWF  x06,W
06C0:  MOVWF  x0B
06C2:  MOVFF  FF2,10C
06C6:  BCF    FF2.7
06C8:  MOVFF  10B,FA9
06CC:  BCF    FA6.6
06CE:  BCF    FA6.7
06D0:  BSF    FA6.0
06D2:  MOVF   FA8,W
06D4:  BTFSC  x0C.7
06D6:  BSF    FF2.7
06D8:  MOVWF  x0C
06DA:  MOVFF  10A,FEA
06DE:  MOVFF  109,FE9
06E2:  MOVFF  10C,10D
06E6:  CLRF   x0F
06E8:  MOVLW  01
06EA:  MOVWF  x0E
06EC:  MOVLB  0
06EE:  RCALL  05AA
06F0:  MOVLB  1
06F2:  INCF   x06,F
06F4:  BRA    06AA
....................    temp_mem= &startup_counter; 
06F6:  CLRF   x08
06F8:  MOVLW  C6
06FA:  MOVWF  x07
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
06FC:  CLRF   x06
06FE:  MOVF   x06,W
0700:  SUBLW  01
0702:  BNC   074A
0704:  MOVF   x06,W
0706:  ADDWF  x07,W
0708:  MOVWF  x09
070A:  MOVLW  00
070C:  ADDWFC x08,W
070E:  MOVWF  x0A
0710:  MOVLW  08
0712:  ADDWF  x06,W
0714:  MOVWF  x0B
0716:  MOVFF  FF2,10C
071A:  BCF    FF2.7
071C:  MOVFF  10B,FA9
0720:  BCF    FA6.6
0722:  BCF    FA6.7
0724:  BSF    FA6.0
0726:  MOVF   FA8,W
0728:  BTFSC  x0C.7
072A:  BSF    FF2.7
072C:  MOVWF  x0C
072E:  MOVFF  10A,FEA
0732:  MOVFF  109,FE9
0736:  MOVFF  10C,10D
073A:  CLRF   x0F
073C:  MOVLW  01
073E:  MOVWF  x0E
0740:  MOVLB  0
0742:  RCALL  05AA
0744:  MOVLB  1
0746:  INCF   x06,F
0748:  BRA    06FE
.................... } 
074A:  MOVLB  0
074C:  GOTO   63E6 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0858:  MOVLB  1
085A:  CLRF   x07
085C:  MOVF   x07,W
085E:  SUBLW  03
0860:  BNC   08C2
0862:  MOVLW  04
0864:  ADDWF  x07,W
0866:  MOVWF  x08
0868:  MOVF   x07,W
086A:  MULLW  08
086C:  MOVFF  FF3,109
0870:  MOVFF  23,10D
0874:  MOVFF  22,10C
0878:  MOVFF  21,10B
087C:  MOVFF  20,10A
0880:  MOVF   x09,F
0882:  BZ    0892
0884:  BCF    FD8.0
0886:  RRCF   x0D,F
0888:  RRCF   x0C,F
088A:  RRCF   x0B,F
088C:  RRCF   x0A,F
088E:  DECFSZ x09,F
0890:  BRA    0884
0892:  MOVFF  108,FA9
0896:  MOVFF  10A,FA8
089A:  BCF    FA6.6
089C:  BCF    FA6.7
089E:  BSF    FA6.2
08A0:  MOVFF  FF2,00
08A4:  BCF    FF2.7
08A6:  MOVLB  F
08A8:  MOVLW  55
08AA:  MOVWF  FA7
08AC:  MOVLW  AA
08AE:  MOVWF  FA7
08B0:  BSF    FA6.1
08B2:  BTFSC  FA6.1
08B4:  BRA    08B2
08B6:  BCF    FA6.2
08B8:  MOVF   00,W
08BA:  IORWF  FF2,F
08BC:  MOVLB  1
08BE:  INCF   x07,F
08C0:  BRA    085C
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i,current_act_position>>(i*8)); 
08C2:  CLRF   x07
08C4:  MOVF   x07,W
08C6:  SUBLW  01
08C8:  BNC   091E
08CA:  MOVLW  02
08CC:  ADDWF  x07,W
08CE:  MOVWF  x08
08D0:  MOVF   x07,W
08D2:  MULLW  08
08D4:  MOVFF  FF3,00
08D8:  MOVFF  6F,10A
08DC:  MOVFF  6E,109
08E0:  MOVF   00,F
08E2:  BZ    08EE
08E4:  BCF    FD8.0
08E6:  RRCF   x0A,F
08E8:  RRCF   x09,F
08EA:  DECFSZ 00,F
08EC:  BRA    08E4
08EE:  MOVFF  108,FA9
08F2:  MOVFF  109,FA8
08F6:  BCF    FA6.6
08F8:  BCF    FA6.7
08FA:  BSF    FA6.2
08FC:  MOVFF  FF2,00
0900:  BCF    FF2.7
0902:  MOVLB  F
0904:  MOVLW  55
0906:  MOVWF  FA7
0908:  MOVLW  AA
090A:  MOVWF  FA7
090C:  BSF    FA6.1
090E:  BTFSC  FA6.1
0910:  BRA    090E
0912:  BCF    FA6.2
0914:  MOVF   00,W
0916:  IORWF  FF2,F
0918:  MOVLB  1
091A:  INCF   x07,F
091C:  BRA    08C4
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
091E:  CLRF   x07
0920:  MOVF   x07,W
0922:  SUBLW  01
0924:  BNC   097A
0926:  MOVLW  08
0928:  ADDWF  x07,W
092A:  MOVWF  x08
092C:  MOVF   x07,W
092E:  MULLW  08
0930:  MOVFF  FF3,00
0934:  MOVFF  C7,10A
0938:  MOVFF  C6,109
093C:  MOVF   00,F
093E:  BZ    094A
0940:  BCF    FD8.0
0942:  RRCF   x0A,F
0944:  RRCF   x09,F
0946:  DECFSZ 00,F
0948:  BRA    0940
094A:  MOVFF  108,FA9
094E:  MOVFF  109,FA8
0952:  BCF    FA6.6
0954:  BCF    FA6.7
0956:  BSF    FA6.2
0958:  MOVFF  FF2,00
095C:  BCF    FF2.7
095E:  MOVLB  F
0960:  MOVLW  55
0962:  MOVWF  FA7
0964:  MOVLW  AA
0966:  MOVWF  FA7
0968:  BSF    FA6.1
096A:  BTFSC  FA6.1
096C:  BRA    096A
096E:  BCF    FA6.2
0970:  MOVF   00,W
0972:  IORWF  FF2,F
0974:  MOVLB  1
0976:  INCF   x07,F
0978:  BRA    0920
....................    if (write_cal ==1) 
097A:  DECFSZ x06,W
097C:  BRA    09D4
....................       for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i,FULL_STROKE_TICK>>(i*8)); 
097E:  CLRF   x07
0980:  MOVF   x07,W
0982:  SUBLW  01
0984:  BNC   09D4
0986:  MOVF   x07,W
0988:  MULLW  08
098A:  MOVFF  FF3,00
098E:  MOVFF  BB,109
0992:  MOVFF  BA,108
0996:  MOVF   00,F
0998:  BZ    09A4
099A:  BCF    FD8.0
099C:  RRCF   x09,F
099E:  RRCF   x08,F
09A0:  DECFSZ 00,F
09A2:  BRA    099A
09A4:  MOVFF  107,FA9
09A8:  MOVFF  108,FA8
09AC:  BCF    FA6.6
09AE:  BCF    FA6.7
09B0:  BSF    FA6.2
09B2:  MOVFF  FF2,00
09B6:  BCF    FF2.7
09B8:  MOVLB  F
09BA:  MOVLW  55
09BC:  MOVWF  FA7
09BE:  MOVLW  AA
09C0:  MOVWF  FA7
09C2:  BSF    FA6.1
09C4:  BTFSC  FA6.1
09C6:  BRA    09C4
09C8:  BCF    FA6.2
09CA:  MOVF   00,W
09CC:  IORWF  FF2,F
09CE:  MOVLB  1
09D0:  INCF   x07,F
09D2:  BRA    0980
.................... } 
09D4:  MOVLB  0
09D6:  RETLW  00
....................  
....................  
.................... void init_ext_flash(void) { 
....................   output_low(FLASH_CLOCK); 
*
0B1E:  BCF    F94.3
0B20:  BCF    F8B.3
....................   output_high(FLASH_SELECT); 
0B22:  BCF    F94.2
0B24:  BSF    F8B.2
.................... } 
0B26:  GOTO   6480 (RETURN)
....................  
.................... /* 
.................... void ext_flash_startContinuousRead(int pageAddress) { 
....................   ext_flash_waitUntilReady(); 
....................   output_low(FLASH_SELECT); 
....................   ext_flash_sendData(0xE8, 8); 
....................   ext_flash_sendData(pageAddress, 14); 
....................   ext_flash_sendData(0, 10); 
....................   ext_flash_sendData(0, 16); 
....................   ext_flash_sendData(0, 16); 
.................... } 
....................  
.................... */ 
....................  
.................... int ext_flash_getByte(void) { 
....................   int flashData = 0; 
....................   output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
....................   return(flashData); 
.................... } 
....................  
.................... void ext_flash_getBytes(char* data, int16 size) { 
....................    int16 i, j; 
....................    for(i = 0; i < size; i++) { 
*
2A26:  MOVLB  1
2A28:  CLRF   x34
2A2A:  CLRF   x33
2A2C:  MOVF   x34,W
2A2E:  SUBWF  x32,W
2A30:  BNC   2A82
2A32:  BNZ   2A3A
2A34:  MOVF   x31,W
2A36:  SUBWF  x33,W
2A38:  BC    2A82
....................       for(j = 0; j < 8; j++) { 
2A3A:  CLRF   x36
2A3C:  CLRF   x35
2A3E:  MOVF   x36,F
2A40:  BNZ   2A7A
2A42:  MOVF   x35,W
2A44:  SUBLW  07
2A46:  BNC   2A7A
....................          output_high(FLASH_CLOCK); 
2A48:  BCF    F94.3
2A4A:  BSF    F8B.3
....................          shift_left(data + i, 1, input(FLASH_DO)); 
2A4C:  MOVF   x33,W
2A4E:  ADDWF  x2F,W
2A50:  MOVWF  x37
2A52:  MOVF   x34,W
2A54:  ADDWFC x30,W
2A56:  MOVWF  x38
2A58:  BSF    F94.4
2A5A:  BTFSC  F82.4
2A5C:  BRA    2A62
2A5E:  BCF    FD8.0
2A60:  BRA    2A64
2A62:  BSF    FD8.0
2A64:  MOVFF  138,FEA
2A68:  MOVFF  137,FE9
2A6C:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
2A6E:  BCF    F94.3
2A70:  BCF    F8B.3
....................       } 
2A72:  INCF   x35,F
2A74:  BTFSC  FD8.2
2A76:  INCF   x36,F
2A78:  BRA    2A3E
....................    } 
2A7A:  INCF   x33,F
2A7C:  BTFSC  FD8.2
2A7E:  INCF   x34,F
2A80:  BRA    2A2C
.................... } 
2A82:  MOVLB  0
2A84:  RETLW  00
....................  
.................... void ext_flash_readPage(int16 pageAddress, int pageIndex, char* data, int16 size) { 
....................    ext_flash_waitUntilReady(); 
2A86:  RCALL  272A
....................    output_low(FLASH_SELECT); 
2A88:  BCF    F94.2
2A8A:  BCF    F8B.2
....................    ext_flash_sendData(0xD2, 8); 
2A8C:  MOVLW  D2
2A8E:  MOVLB  1
2A90:  MOVWF  x2F
2A92:  MOVLW  08
2A94:  MOVWF  x30
2A96:  MOVLB  0
2A98:  RCALL  2864
....................    ext_flash_send16Data(pageAddress, 15); 
2A9A:  MOVFF  129,130
2A9E:  MOVFF  128,12F
2AA2:  MOVLW  0F
2AA4:  MOVLB  1
2AA6:  MOVWF  x31
2AA8:  MOVLB  0
2AAA:  RCALL  2898
....................    ext_flash_sendData(0, 1); 
2AAC:  MOVLB  1
2AAE:  CLRF   x2F
2AB0:  MOVLW  01
2AB2:  MOVWF  x30
2AB4:  MOVLB  0
2AB6:  RCALL  2864
....................    ext_flash_sendData(pageIndex, 8); 
2AB8:  MOVFF  12A,12F
2ABC:  MOVLW  08
2ABE:  MOVLB  1
2AC0:  MOVWF  x30
2AC2:  MOVLB  0
2AC4:  RCALL  2864
....................    ext_flash_sendData(0, 16); 
2AC6:  MOVLB  1
2AC8:  CLRF   x2F
2ACA:  MOVLW  10
2ACC:  MOVWF  x30
2ACE:  MOVLB  0
2AD0:  RCALL  2864
....................    ext_flash_sendData(0, 16); 
2AD2:  MOVLB  1
2AD4:  CLRF   x2F
2AD6:  MOVLW  10
2AD8:  MOVWF  x30
2ADA:  MOVLB  0
2ADC:  RCALL  2864
....................    ext_flash_getBytes(data, size); 
2ADE:  MOVFF  12C,130
2AE2:  MOVFF  12B,12F
2AE6:  MOVFF  12E,132
2AEA:  MOVFF  12D,131
2AEE:  RCALL  2A26
....................    output_high(FLASH_SELECT); 
2AF0:  BCF    F94.2
2AF2:  BSF    F8B.2
.................... } 
2AF4:  RETLW  00
....................  
.................... /* 
.................... void ext_flash_writePageThroughBuffer(int pageAddress, char* data, int size) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
....................    output_low(FLASH_SELECT); 
....................    ext_flash_sendData(0x82, 8); 
....................    ext_flash_sendData(pageAddress, 14); 
....................    ext_flash_sendData(0, 10); 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
....................    output_high(FLASH_SELECT); 
.................... } 
.................... */ 
....................  
....................  
.................... void ext_flash_sendData(int data, int size) { 
....................    do { 
....................       size--; 
*
2864:  MOVLB  1
2866:  DECF   x30,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
2868:  MOVFF  12F,00
286C:  MOVF   x30,W
286E:  MOVWF  01
2870:  BZ    287A
2872:  BCF    FD8.0
2874:  RRCF   00,F
2876:  DECFSZ 01,F
2878:  BRA    2872
287A:  MOVF   00,W
287C:  ANDLW  01
287E:  BNZ   2884
2880:  BCF    F8B.5
2882:  BRA    2886
2884:  BSF    F8B.5
2886:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
2888:  BCF    F94.3
288A:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
288C:  BCF    F94.3
288E:  BCF    F8B.3
....................    } while(size > 0); 
2890:  MOVF   x30,F
2892:  BNZ   2866
.................... } 
2894:  MOVLB  0
2896:  RETLW  00
....................  
.................... void ext_flash_send16Data(int16 data, int size) { 
....................    do { 
....................       size--; 
2898:  MOVLB  1
289A:  DECF   x31,F
....................       output_bit(FLASH_DI, (data >> size) & 1); 
289C:  MOVFF  130,133
28A0:  MOVFF  12F,132
28A4:  MOVF   x31,W
28A6:  MOVWF  00
28A8:  BZ    28B4
28AA:  BCF    FD8.0
28AC:  RRCF   x33,F
28AE:  RRCF   x32,F
28B0:  DECFSZ 00,F
28B2:  BRA    28AA
28B4:  MOVF   x32,W
28B6:  ANDLW  01
28B8:  MOVWF  00
28BA:  CLRF   03
28BC:  MOVF   00,W
28BE:  IORWF  03,W
28C0:  BNZ   28C6
28C2:  BCF    F8B.5
28C4:  BRA    28C8
28C6:  BSF    F8B.5
28C8:  BCF    F94.5
....................       output_high(FLASH_CLOCK); 
28CA:  BCF    F94.3
28CC:  BSF    F8B.3
....................       output_low(FLASH_CLOCK); 
28CE:  BCF    F94.3
28D0:  BCF    F8B.3
....................    } while(size > 0); 
28D2:  MOVF   x31,F
28D4:  BNZ   289A
.................... } 
28D6:  MOVLB  0
28D8:  RETLW  00
....................  
.................... void ext_flash_sendBytes(char* data, int size) { 
....................    int i; 
....................    for (i = 0; i < size; i++) 
....................      ext_flash_sendData((int)data[i], 8); 
.................... } 
....................  
.................... void ext_flash_waitUntilReady(void) { 
.................... // this function read status register 
.................... // Bit7 : 1=RDY, 0=BUSY 
.................... // Bit6 : COMP, 1=Recent Main memory page compare, 0 == match 
.................... // Bit 5-2 : 0b0111 , density code for 4MBit 
.................... // Bit 1: Protect 
.................... // Bit 0: Page size. 0= 264 byte, 1=256 byte 
....................  
....................   int flashData; 
....................   int i; 
....................   output_low(FLASH_SELECT); 
*
272A:  BCF    F94.2
272C:  BCF    F8B.2
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
272E:  BSF    F8B.5
2730:  BCF    F94.5
2732:  BCF    F94.3
2734:  BSF    F8B.3
2736:  BCF    F94.3
2738:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
273A:  BSF    F8B.5
273C:  BCF    F94.5
273E:  BCF    F94.3
2740:  BSF    F8B.3
2742:  BCF    F94.3
2744:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2746:  BCF    F8B.5
2748:  BCF    F94.5
274A:  BCF    F94.3
274C:  BSF    F8B.3
274E:  BCF    F94.3
2750:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2752:  BSF    F8B.5
2754:  BCF    F94.5
2756:  BCF    F94.3
2758:  BSF    F8B.3
275A:  BCF    F94.3
275C:  BCF    F8B.3
....................   output_bit(FLASH_DI, 0); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
275E:  BCF    F8B.5
2760:  BCF    F94.5
2762:  BCF    F94.3
2764:  BSF    F8B.3
2766:  BCF    F94.3
2768:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
276A:  BSF    F8B.5
276C:  BCF    F94.5
276E:  BCF    F94.3
2770:  BSF    F8B.3
2772:  BCF    F94.3
2774:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2776:  BSF    F8B.5
2778:  BCF    F94.5
277A:  BCF    F94.3
277C:  BSF    F8B.3
277E:  BCF    F94.3
2780:  BCF    F8B.3
....................   output_bit(FLASH_DI, 1); output_high(FLASH_CLOCK); output_low(FLASH_CLOCK); 
2782:  BSF    F8B.5
2784:  BCF    F94.5
2786:  BCF    F94.3
2788:  BSF    F8B.3
278A:  BCF    F94.3
278C:  BCF    F8B.3
....................   for(i=0;i<255;i++) { 
278E:  MOVLB  1
2790:  CLRF   x30
2792:  INCFSZ x30,W
2794:  BRA    2798
2796:  BRA    285C
....................     flashData = 0; 
2798:  CLRF   x2F
....................     output_high(FLASH_CLOCK); flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
279A:  BCF    F94.3
279C:  BSF    F8B.3
279E:  BSF    F94.4
27A0:  MOVLW  00
27A2:  BTFSC  F82.4
27A4:  MOVLW  01
27A6:  ADDWF  x2F,F
27A8:  BCF    F94.3
27AA:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
27AC:  BCF    F94.3
27AE:  BSF    F8B.3
27B0:  BCF    FD8.0
27B2:  RLCF   x2F,F
27B4:  BSF    F94.4
27B6:  MOVLW  00
27B8:  BTFSC  F82.4
27BA:  MOVLW  01
27BC:  ADDWF  x2F,F
27BE:  BCF    F94.3
27C0:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
27C2:  BCF    F94.3
27C4:  BSF    F8B.3
27C6:  BCF    FD8.0
27C8:  RLCF   x2F,F
27CA:  BSF    F94.4
27CC:  MOVLW  00
27CE:  BTFSC  F82.4
27D0:  MOVLW  01
27D2:  ADDWF  x2F,F
27D4:  BCF    F94.3
27D6:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
27D8:  BCF    F94.3
27DA:  BSF    F8B.3
27DC:  BCF    FD8.0
27DE:  RLCF   x2F,F
27E0:  BSF    F94.4
27E2:  MOVLW  00
27E4:  BTFSC  F82.4
27E6:  MOVLW  01
27E8:  ADDWF  x2F,F
27EA:  BCF    F94.3
27EC:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
27EE:  BCF    F94.3
27F0:  BSF    F8B.3
27F2:  BCF    FD8.0
27F4:  RLCF   x2F,F
27F6:  BSF    F94.4
27F8:  MOVLW  00
27FA:  BTFSC  F82.4
27FC:  MOVLW  01
27FE:  ADDWF  x2F,F
2800:  BCF    F94.3
2802:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2804:  BCF    F94.3
2806:  BSF    F8B.3
2808:  BCF    FD8.0
280A:  RLCF   x2F,F
280C:  BSF    F94.4
280E:  MOVLW  00
2810:  BTFSC  F82.4
2812:  MOVLW  01
2814:  ADDWF  x2F,F
2816:  BCF    F94.3
2818:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
281A:  BCF    F94.3
281C:  BSF    F8B.3
281E:  BCF    FD8.0
2820:  RLCF   x2F,F
2822:  BSF    F94.4
2824:  MOVLW  00
2826:  BTFSC  F82.4
2828:  MOVLW  01
282A:  ADDWF  x2F,F
282C:  BCF    F94.3
282E:  BCF    F8B.3
....................     output_high(FLASH_CLOCK); flashData *= 2; flashData += input(FLASH_DO); output_low(FLASH_CLOCK); 
2830:  BCF    F94.3
2832:  BSF    F8B.3
2834:  BCF    FD8.0
2836:  RLCF   x2F,F
2838:  BSF    F94.4
283A:  MOVLW  00
283C:  BTFSC  F82.4
283E:  MOVLW  01
2840:  ADDWF  x2F,F
2842:  BCF    F94.3
2844:  BCF    F8B.3
....................     if (bit_test(flashData,7) == 1) break; // device is not busy 
2846:  BTFSS  x2F.7
2848:  BRA    284C
284A:  BRA    285C
....................    delay_cycles(50); 
284C:  MOVLW  10
284E:  MOVWF  00
2850:  DECFSZ 00,F
2852:  BRA    2850
2854:  NOP   
....................    restart_wdt(); 
2856:  CLRWDT
....................   } 
2858:  INCF   x30,F
285A:  BRA    2792
....................   output_high(FLASH_SELECT); 
285C:  BCF    F94.2
285E:  BSF    F8B.2
.................... } 
2860:  MOVLB  0
2862:  RETLW  00
....................  
.................... void ext_flash_block_erase() { 
....................    int i; 
....................    for(i=0;i<0xFF;i++) { 
*
2BA2:  MOVLB  1
2BA4:  CLRF   x06
2BA6:  INCFSZ x06,W
2BA8:  BRA    2BAC
2BAA:  BRA    2BF2
....................    ext_flash_waitUntilReady(); 
2BAC:  MOVLB  0
2BAE:  RCALL  272A
....................    output_low(FLASH_SELECT); 
2BB0:  BCF    F94.2
2BB2:  BCF    F8B.2
....................    ext_flash_sendData(0x50, 8); 
2BB4:  MOVLW  50
2BB6:  MOVLB  1
2BB8:  MOVWF  x2F
2BBA:  MOVLW  08
2BBC:  MOVWF  x30
2BBE:  MOVLB  0
2BC0:  RCALL  2864
....................    ext_flash_sendData(0, 4); 
2BC2:  MOVLB  1
2BC4:  CLRF   x2F
2BC6:  MOVLW  04
2BC8:  MOVWF  x30
2BCA:  MOVLB  0
2BCC:  RCALL  2864
....................    ext_flash_sendData(i, 8); 
2BCE:  MOVFF  106,12F
2BD2:  MOVLW  08
2BD4:  MOVLB  1
2BD6:  MOVWF  x30
2BD8:  MOVLB  0
2BDA:  RCALL  2864
....................    ext_flash_sendData(0, 12); 
2BDC:  MOVLB  1
2BDE:  CLRF   x2F
2BE0:  MOVLW  0C
2BE2:  MOVWF  x30
2BE4:  MOVLB  0
2BE6:  RCALL  2864
....................    output_high(FLASH_SELECT); 
2BE8:  BCF    F94.2
2BEA:  BSF    F8B.2
....................    } 
2BEC:  MOVLB  1
2BEE:  INCF   x06,F
2BF0:  BRA    2BA6
....................    ext_flash_waitUntilReady(); 
2BF2:  MOVLB  0
2BF4:  RCALL  272A
.................... } 
2BF6:  GOTO   39B6 (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_read() { 
....................    char data; 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
307A:  CALL   272A
....................    output_low(FLASH_SELECT); 
307E:  BCF    F94.2
3080:  BCF    F8B.2
....................    ext_flash_sendData(0xD1, 8); 
3082:  MOVLW  D1
3084:  MOVLB  1
3086:  MOVWF  x2F
3088:  MOVLW  08
308A:  MOVWF  x30
308C:  MOVLB  0
308E:  CALL   2864
....................    ext_flash_send16Data(0, 16); 
3092:  MOVLB  1
3094:  CLRF   x30
3096:  CLRF   x2F
3098:  MOVLW  10
309A:  MOVWF  x31
309C:  MOVLB  0
309E:  CALL   2898
....................    ext_flash_sendData(0, 8); 
30A2:  MOVLB  1
30A4:  CLRF   x2F
30A6:  MOVLW  08
30A8:  MOVWF  x30
30AA:  MOVLB  0
30AC:  CALL   2864
....................    i=255; 
30B0:  MOVLW  FF
30B2:  MOVLB  1
30B4:  MOVWF  x07
....................    do { 
....................      ext_flash_getBytes(&data,1); 
30B6:  MOVLW  01
30B8:  MOVWF  x30
30BA:  MOVLW  06
30BC:  MOVWF  x2F
30BE:  CLRF   x32
30C0:  MOVLW  01
30C2:  MOVWF  x31
30C4:  MOVLB  0
30C6:  RCALL  2A26
....................      i++; 
30C8:  MOVLB  1
30CA:  INCF   x07,F
....................      if (i%16==0) printf("\r\n %02X:", i); 
30CC:  MOVF   x07,W
30CE:  ANDLW  0F
30D0:  BNZ   3100
30D2:  MOVLW  0D
30D4:  BTFSS  F9E.4
30D6:  BRA    30D4
30D8:  MOVWF  FAD
30DA:  MOVLW  0A
30DC:  BTFSS  F9E.4
30DE:  BRA    30DC
30E0:  MOVWF  FAD
30E2:  MOVLW  20
30E4:  BTFSS  F9E.4
30E6:  BRA    30E4
30E8:  MOVWF  FAD
30EA:  MOVFF  107,11E
30EE:  MOVLW  37
30F0:  MOVWF  x1F
30F2:  MOVLB  0
30F4:  RCALL  29E0
30F6:  MOVLW  3A
30F8:  BTFSS  F9E.4
30FA:  BRA    30F8
30FC:  MOVWF  FAD
30FE:  MOVLB  1
....................       printf("%02X ",data); 
3100:  MOVFF  106,11E
3104:  MOVLW  37
3106:  MOVWF  x1F
3108:  MOVLB  0
310A:  RCALL  29E0
310C:  MOVLW  20
310E:  BTFSS  F9E.4
3110:  BRA    310E
3112:  MOVWF  FAD
....................  
....................    } while (i<255); 
3114:  MOVLB  1
3116:  INCFSZ x07,W
3118:  BRA    30B6
....................    output_high(FLASH_SELECT);    
311A:  BCF    F94.2
311C:  BSF    F8B.2
.................... } 
311E:  MOVLB  0
3120:  GOTO   37CC (RETURN)
....................  
....................  
.................... void ext_flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    ext_flash_waitUntilReady(); 
*
3248:  CALL   272A
....................    output_low(FLASH_SELECT); 
324C:  BCF    F94.2
324E:  BCF    F8B.2
....................    ext_flash_sendData(0x84, 8); 
3250:  MOVLW  84
3252:  MOVLB  1
3254:  MOVWF  x2F
3256:  MOVLW  08
3258:  MOVWF  x30
325A:  MOVLB  0
325C:  CALL   2864
....................    ext_flash_send16Data(0, 16); 
3260:  MOVLB  1
3262:  CLRF   x30
3264:  CLRF   x2F
3266:  MOVLW  10
3268:  MOVWF  x31
326A:  MOVLB  0
326C:  CALL   2898
....................    ext_flash_sendData(PageIndex, 8); 
3270:  MOVFF  112,12F
3274:  MOVLW  08
3276:  MOVLB  1
3278:  MOVWF  x30
327A:  MOVLB  0
327C:  CALL   2864
....................    if (nData>1) { 
3280:  MOVLB  1
3282:  MOVF   x13,W
3284:  SUBLW  01
3286:  BC    32A6
....................    i=255; 
3288:  MOVLW  FF
328A:  MOVWF  x14
....................    do { 
....................       ext_flash_sendData(data,8); 
328C:  MOVFF  111,12F
3290:  MOVLW  08
3292:  MOVWF  x30
3294:  MOVLB  0
3296:  CALL   2864
....................       i++; 
329A:  MOVLB  1
329C:  INCF   x14,F
....................    } while(i<nData); 
329E:  MOVF   x13,W
32A0:  SUBWF  x14,W
32A2:  BNC   328C
....................    } else 
32A4:  BRA    32B6
....................          ext_flash_sendData(data,8); 
32A6:  MOVFF  111,12F
32AA:  MOVLW  08
32AC:  MOVWF  x30
32AE:  MOVLB  0
32B0:  CALL   2864
32B4:  MOVLB  1
....................    output_high(FLASH_SELECT); 
32B6:  BCF    F94.2
32B8:  BSF    F8B.2
.................... } 
32BA:  MOVLB  0
32BC:  RETLW  00
....................  
.................... void ext_flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
3CA8:  CALL   272A
....................    output_low(FLASH_SELECT); 
3CAC:  BCF    F94.2
3CAE:  BCF    F8B.2
....................    ext_flash_sendData(0x83, 8); 
3CB0:  MOVLW  83
3CB2:  MOVLB  1
3CB4:  MOVWF  x2F
3CB6:  MOVLW  08
3CB8:  MOVWF  x30
3CBA:  MOVLB  0
3CBC:  CALL   2864
....................    ext_flash_send16Data(pageAddress, 15); 
3CC0:  MOVFF  10D,130
3CC4:  MOVFF  10C,12F
3CC8:  MOVLW  0F
3CCA:  MOVLB  1
3CCC:  MOVWF  x31
3CCE:  MOVLB  0
3CD0:  CALL   2898
....................    ext_flash_send16Data(0, 9); 
3CD4:  MOVLB  1
3CD6:  CLRF   x30
3CD8:  CLRF   x2F
3CDA:  MOVLW  09
3CDC:  MOVWF  x31
3CDE:  MOVLB  0
3CE0:  CALL   2898
....................    output_high(FLASH_SELECT); 
3CE4:  BCF    F94.2
3CE6:  BSF    F8B.2
.................... } 
3CE8:  GOTO   40D0 (RETURN)
....................  
.................... void ext_flash_main_memory_to_buffer1(int16 pageAddress) { 
....................    ext_flash_waitUntilReady(); 
*
3A0A:  CALL   272A
....................    output_low(FLASH_SELECT); 
3A0E:  BCF    F94.2
3A10:  BCF    F8B.2
....................    ext_flash_sendData(0x53, 8); 
3A12:  MOVLW  53
3A14:  MOVLB  1
3A16:  MOVWF  x2F
3A18:  MOVLW  08
3A1A:  MOVWF  x30
3A1C:  MOVLB  0
3A1E:  CALL   2864
....................    ext_flash_send16Data(pageAddress, 15); 
3A22:  MOVFF  10C,130
3A26:  MOVFF  10B,12F
3A2A:  MOVLW  0F
3A2C:  MOVLB  1
3A2E:  MOVWF  x31
3A30:  MOVLB  0
3A32:  CALL   2898
....................    ext_flash_send16Data(0, 9); 
3A36:  MOVLB  1
3A38:  CLRF   x30
3A3A:  CLRF   x2F
3A3C:  MOVLW  09
3A3E:  MOVWF  x31
3A40:  MOVLB  0
3A42:  CALL   2898
....................    output_high(FLASH_SELECT); 
3A46:  BCF    F94.2
3A48:  BSF    F8B.2
.................... } 
3A4A:  GOTO   6636 (RETURN)
....................  
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD.lcd_nibble=n>>4; 
*
09D8:  MOVLB  1
09DA:  SWAPF  x27,W
09DC:  MOVWF  00
09DE:  MOVLW  0F
09E0:  ANDWF  00,F
09E2:  MOVF   00,W
09E4:  ANDLW  0F
09E6:  MOVWF  00
09E8:  MOVLW  F0
09EA:  ANDWF  F83,W
09EC:  IORWF  00,W
09EE:  MOVWF  F83
....................       delay_us(50); 
09F0:  MOVLW  29
09F2:  MOVWF  00
09F4:  DECFSZ 00,F
09F6:  BRA    09F4
09F8:  NOP   
....................       PORTD.disp_en=1; 
09FA:  BSF    F83.7
....................       delay_us(50); 
09FC:  MOVLW  29
09FE:  MOVWF  00
0A00:  DECFSZ 00,F
0A02:  BRA    0A00
0A04:  NOP   
....................       PORTD.disp_en=0; 
0A06:  BCF    F83.7
....................      delay_us(50); 
0A08:  MOVLW  29
0A0A:  MOVWF  00
0A0C:  DECFSZ 00,F
0A0E:  BRA    0A0C
0A10:  NOP   
.................... } 
0A12:  MOVLB  0
0A14:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
....................    PORTE.rs=rs; 
0A16:  MOVLB  1
0A18:  BTFSS  x23.0
0A1A:  BCF    F84.0
0A1C:  BTFSC  x23.0
0A1E:  BSF    F84.0
....................    lcd_send_nibble(dat&0xF0); 
0A20:  MOVF   x24,W
0A22:  ANDLW  F0
0A24:  MOVWF  x25
0A26:  MOVWF  x27
0A28:  MOVLB  0
0A2A:  RCALL  09D8
....................    lcd_send_nibble((dat<<4)&0xF0); 
0A2C:  MOVLB  1
0A2E:  SWAPF  x24,W
0A30:  MOVWF  00
0A32:  MOVLW  F0
0A34:  ANDWF  00,F
0A36:  MOVF   00,W
0A38:  ANDLW  F0
0A3A:  MOVWF  x26
0A3C:  MOVWF  x27
0A3E:  MOVLB  0
0A40:  RCALL  09D8
....................    PORTE.rs=1; 
0A42:  BSF    F84.0
.................... } 
0A44:  RETLW  00
....................  
.................... void lcd_init() { 
....................    int8 i; 
....................     PORTE.rs = 0; 
0A46:  BCF    F84.0
....................     PORTD.disp_en=0; 
0A48:  BCF    F83.7
0A4A:  CLRF   18
0A4C:  BTFSC  FF2.7
0A4E:  BSF    18.7
0A50:  BCF    FF2.7
....................    delay_ms(15); 
0A52:  MOVLW  0F
0A54:  MOVLB  1
0A56:  MOVWF  x20
0A58:  MOVLB  0
0A5A:  RCALL  04C2
0A5C:  BTFSC  18.7
0A5E:  BSF    FF2.7
....................     for(i=1;i<=3;++i) { 
0A60:  MOVLW  01
0A62:  MOVLB  1
0A64:  MOVWF  x06
0A66:  MOVF   x06,W
0A68:  SUBLW  03
0A6A:  BNC   0A90
....................        lcd_send_nibble(0x30);  
0A6C:  MOVLW  30
0A6E:  MOVWF  x27
0A70:  MOVLB  0
0A72:  RCALL  09D8
0A74:  CLRF   18
0A76:  BTFSC  FF2.7
0A78:  BSF    18.7
0A7A:  BCF    FF2.7
....................        delay_ms(15); 
0A7C:  MOVLW  0F
0A7E:  MOVLB  1
0A80:  MOVWF  x20
0A82:  MOVLB  0
0A84:  RCALL  04C2
0A86:  BTFSC  18.7
0A88:  BSF    FF2.7
....................     } 
0A8A:  MOVLB  1
0A8C:  INCF   x06,F
0A8E:  BRA    0A66
....................     lcd_send_nibble(0x20);  
0A90:  MOVLW  20
0A92:  MOVWF  x27
0A94:  MOVLB  0
0A96:  RCALL  09D8
0A98:  CLRF   18
0A9A:  BTFSC  FF2.7
0A9C:  BSF    18.7
0A9E:  BCF    FF2.7
....................     delay_ms(15); 
0AA0:  MOVLW  0F
0AA2:  MOVLB  1
0AA4:  MOVWF  x20
0AA6:  MOVLB  0
0AA8:  RCALL  04C2
0AAA:  BTFSC  18.7
0AAC:  BSF    FF2.7
....................     lcd_send_cmd(0,0x06); 
0AAE:  MOVLB  1
0AB0:  CLRF   x23
0AB2:  MOVLW  06
0AB4:  MOVWF  x24
0AB6:  MOVLB  0
0AB8:  RCALL  0A16
....................     delay_us(50); 
0ABA:  MOVLW  29
0ABC:  MOVWF  00
0ABE:  DECFSZ 00,F
0AC0:  BRA    0ABE
0AC2:  NOP   
....................     lcd_send_cmd(0,0x0c); 
0AC4:  MOVLB  1
0AC6:  CLRF   x23
0AC8:  MOVLW  0C
0ACA:  MOVWF  x24
0ACC:  MOVLB  0
0ACE:  RCALL  0A16
....................     delay_us(50); 
0AD0:  MOVLW  29
0AD2:  MOVWF  00
0AD4:  DECFSZ 00,F
0AD6:  BRA    0AD4
0AD8:  NOP   
....................     lcd_send_cmd(0,0x10); 
0ADA:  MOVLB  1
0ADC:  CLRF   x23
0ADE:  MOVLW  10
0AE0:  MOVWF  x24
0AE2:  MOVLB  0
0AE4:  RCALL  0A16
....................     delay_us(50); 
0AE6:  MOVLW  29
0AE8:  MOVWF  00
0AEA:  DECFSZ 00,F
0AEC:  BRA    0AEA
0AEE:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
0AF0:  MOVLB  1
0AF2:  CLRF   x23
0AF4:  MOVLW  2C
0AF6:  MOVWF  x24
0AF8:  MOVLB  0
0AFA:  RCALL  0A16
....................     delay_us(50); 
0AFC:  MOVLW  29
0AFE:  MOVWF  00
0B00:  DECFSZ 00,F
0B02:  BRA    0B00
0B04:  NOP   
....................     lcd_send_cmd(0,0x01); 
0B06:  MOVLB  1
0B08:  CLRF   x23
0B0A:  MOVLW  01
0B0C:  MOVWF  x24
0B0E:  MOVLB  0
0B10:  RCALL  0A16
....................     delay_us(50); 
0B12:  MOVLW  29
0B14:  MOVWF  00
0B16:  DECFSZ 00,F
0B18:  BRA    0B16
0B1A:  NOP   
....................  
.................... } 
0B1C:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
0D3E:  MOVLB  1
0D40:  MOVF   x20,W
0D42:  ANDLW  03
0D44:  CLRF   03
0D46:  MOVFF  FF2,123
0D4A:  BCF    FF2.7
0D4C:  MOVLB  0
0D4E:  CALL   00AA
0D52:  MOVLB  1
0D54:  BTFSC  x23.7
0D56:  BSF    FF2.7
0D58:  MOVWF  x21
....................    address+=x; 
0D5A:  MOVF   x1F,W
0D5C:  ADDWF  x21,F
....................    lcd_send_cmd(0,0x80|address); 
0D5E:  MOVF   x21,W
0D60:  IORLW  80
0D62:  MOVWF  x22
0D64:  CLRF   x23
0D66:  MOVWF  x24
0D68:  MOVLB  0
0D6A:  RCALL  0A16
.................... } 
0D6C:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0D6E:  MOVLB  1
0D70:  MOVF   x1E,W
0D72:  XORLW  0C
0D74:  MOVLB  0
0D76:  BZ    0D82
0D78:  XORLW  06
0D7A:  BZ    0DA8
0D7C:  XORLW  02
0D7E:  BZ    0DB8
0D80:  BRA    0DC6
....................      case '\f'   : lcd_send_cmd(0,1); 
0D82:  MOVLB  1
0D84:  CLRF   x23
0D86:  MOVLW  01
0D88:  MOVWF  x24
0D8A:  MOVLB  0
0D8C:  RCALL  0A16
0D8E:  CLRF   18
0D90:  BTFSC  FF2.7
0D92:  BSF    18.7
0D94:  BCF    FF2.7
....................                    delay_ms(2); 
0D96:  MOVLW  02
0D98:  MOVLB  1
0D9A:  MOVWF  x20
0D9C:  MOVLB  0
0D9E:  CALL   04C2
0DA2:  BTFSC  18.7
0DA4:  BSF    FF2.7
....................                                            break; 
0DA6:  BRA    0DD6
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0DA8:  MOVLW  01
0DAA:  MOVLB  1
0DAC:  MOVWF  x1F
0DAE:  MOVLW  02
0DB0:  MOVWF  x20
0DB2:  MOVLB  0
0DB4:  RCALL  0D3E
0DB6:  BRA    0DD6
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
0DB8:  MOVLB  1
0DBA:  CLRF   x23
0DBC:  MOVLW  10
0DBE:  MOVWF  x24
0DC0:  MOVLB  0
0DC2:  RCALL  0A16
0DC4:  BRA    0DD6
....................      default     : lcd_send_cmd(1,c);     break; 
0DC6:  MOVLW  01
0DC8:  MOVLB  1
0DCA:  MOVWF  x23
0DCC:  MOVFF  11E,124
0DD0:  MOVLB  0
0DD2:  RCALL  0A16
0DD4:  BRA    0DD6
....................    } 
.................... } 
0DD6:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<size;i++)   lcd_putc(c[i]); 
*
172C:  MOVLB  1
172E:  CLRF   x19
1730:  MOVF   x18,W
1732:  SUBWF  x19,W
1734:  BC    1758
1736:  CLRF   03
1738:  MOVF   x19,W
173A:  ADDWF  x16,W
173C:  MOVWF  FE9
173E:  MOVF   x17,W
1740:  ADDWFC 03,W
1742:  MOVWF  FEA
1744:  MOVFF  FEF,11A
1748:  MOVFF  11A,11E
174C:  MOVLB  0
174E:  CALL   0D6E
1752:  MOVLB  1
1754:  INCF   x19,F
1756:  BRA    1730
.................... } 
1758:  MOVLB  0
175A:  RETLW  00
....................     
....................  
.................... void print_date_time() { 
....................  
....................       JDN = (unsigned int32)((float) (Y2010_JDN*1.0+ 0.5+ (float)(UTC*1.0)/24.0 + (timer_sec)*1.0/86400.0)); 
175C:  MOVFF  23,118
1760:  MOVFF  22,117
1764:  MOVFF  21,116
1768:  MOVFF  20,115
176C:  GOTO   0E94
1770:  MOVFF  03,165
1774:  MOVFF  02,164
1778:  MOVFF  01,163
177C:  MOVFF  00,162
1780:  MOVLB  1
1782:  CLRF   x69
1784:  CLRF   x68
1786:  CLRF   x67
1788:  MOVLW  7F
178A:  MOVWF  x66
178C:  MOVLB  0
178E:  CALL   0ECE
1792:  MOVFF  00,115
1796:  MOVFF  01,116
179A:  MOVFF  02,117
179E:  MOVFF  03,118
17A2:  MOVFF  03,161
17A6:  MOVFF  02,160
17AA:  MOVFF  01,15F
17AE:  MOVFF  00,15E
17B2:  MOVLB  1
17B4:  CLRF   x65
17B6:  MOVLW  C0
17B8:  MOVWF  x64
17BA:  MOVLW  28
17BC:  MOVWF  x63
17BE:  MOVLW  8F
17C0:  MOVWF  x62
17C2:  MOVLB  0
17C4:  CALL   0FC4
17C8:  BCF    FD8.1
17CA:  MOVLW  79
17CC:  MOVLB  1
17CE:  MOVWF  x67
17D0:  MOVLW  DA
17D2:  MOVWF  x66
17D4:  MOVLW  15
17D6:  MOVWF  x65
17D8:  MOVLW  94
17DA:  MOVWF  x64
17DC:  MOVFF  03,16B
17E0:  MOVFF  02,16A
17E4:  MOVFF  01,169
17E8:  MOVFF  00,168
17EC:  MOVLB  0
17EE:  RCALL  1122
17F0:  MOVFF  03,11C
17F4:  MOVFF  02,11B
17F8:  MOVFF  01,11A
17FC:  MOVFF  00,119
1800:  BRA    139A
1802:  MOVFF  03,75
1806:  MOVFF  02,74
180A:  MOVFF  01,73
180E:  MOVFF  00,72
....................       jj = JDN +32044; 
1812:  MOVLW  2C
1814:  ADDWF  x72,W
1816:  MOVWF  x76
1818:  MOVLW  7D
181A:  ADDWFC x73,W
181C:  MOVWF  x77
181E:  MOVLW  00
1820:  ADDWFC x74,W
1822:  MOVWF  x78
1824:  MOVLW  00
1826:  ADDWFC x75,W
1828:  MOVWF  x79
182A:  CLRF   18
182C:  BTFSC  FF2.7
182E:  BSF    18.7
1830:  BCF    FF2.7
....................       g=jj/146097; 
1832:  MOVFF  79,124
1836:  MOVFF  78,123
183A:  MOVFF  77,122
183E:  MOVFF  76,121
1842:  MOVLB  1
1844:  CLRF   x28
1846:  MOVLW  02
1848:  MOVWF  x27
184A:  MOVLW  3A
184C:  MOVWF  x26
184E:  MOVLW  B1
1850:  MOVWF  x25
1852:  MOVLB  0
1854:  CALL   0340
1858:  BTFSC  18.7
185A:  BSF    FF2.7
185C:  MOVFF  03,7D
1860:  MOVFF  02,7C
1864:  MOVFF  01,7B
1868:  MOVFF  00,7A
186C:  CLRF   18
186E:  BTFSC  FF2.7
1870:  BSF    18.7
1872:  BCF    FF2.7
....................       dg=jj%146097; 
1874:  MOVFF  79,124
1878:  MOVFF  78,123
187C:  MOVFF  77,122
1880:  MOVFF  76,121
1884:  MOVLB  1
1886:  CLRF   x28
1888:  MOVLW  02
188A:  MOVWF  x27
188C:  MOVLW  3A
188E:  MOVWF  x26
1890:  MOVLW  B1
1892:  MOVWF  x25
1894:  MOVLB  0
1896:  CALL   0340
189A:  BTFSC  18.7
189C:  BSF    FF2.7
189E:  MOVFF  FEF,7E
18A2:  MOVFF  FEC,7F
18A6:  MOVFF  FEC,80
18AA:  MOVFF  FEC,81
18AE:  CLRF   18
18B0:  BTFSC  FF2.7
18B2:  BSF    18.7
18B4:  BCF    FF2.7
....................       c=(dg/36524+1)*3/4; 
18B6:  MOVFF  81,124
18BA:  MOVFF  80,123
18BE:  MOVFF  7F,122
18C2:  MOVFF  7E,121
18C6:  MOVLB  1
18C8:  CLRF   x28
18CA:  CLRF   x27
18CC:  MOVLW  8E
18CE:  MOVWF  x26
18D0:  MOVLW  AC
18D2:  MOVWF  x25
18D4:  MOVLB  0
18D6:  CALL   0340
18DA:  BTFSC  18.7
18DC:  BSF    FF2.7
18DE:  MOVFF  03,118
18E2:  MOVFF  02,117
18E6:  MOVFF  01,116
18EA:  MOVFF  00,115
18EE:  MOVLW  01
18F0:  MOVLB  1
18F2:  ADDWF  00,W
18F4:  MOVWF  x19
18F6:  MOVLW  00
18F8:  ADDWFC 01,W
18FA:  MOVWF  x1A
18FC:  MOVLW  00
18FE:  ADDWFC 02,W
1900:  MOVWF  x1B
1902:  MOVLW  00
1904:  ADDWFC 03,W
1906:  MOVWF  x1C
1908:  MOVWF  x2D
190A:  MOVFF  11B,12C
190E:  MOVFF  11A,12B
1912:  MOVFF  119,12A
1916:  CLRF   x31
1918:  CLRF   x30
191A:  CLRF   x2F
191C:  MOVLW  03
191E:  MOVWF  x2E
1920:  MOVLB  0
1922:  RCALL  13DE
1924:  MOVLB  1
1926:  RRCF   03,W
1928:  MOVLB  0
192A:  MOVWF  x85
192C:  MOVLB  1
192E:  RRCF   02,W
1930:  MOVLB  0
1932:  MOVWF  x84
1934:  MOVLB  1
1936:  RRCF   01,W
1938:  MOVLB  0
193A:  MOVWF  x83
193C:  MOVLB  1
193E:  RRCF   00,W
1940:  MOVLB  0
1942:  MOVWF  x82
1944:  RRCF   x85,F
1946:  RRCF   x84,F
1948:  RRCF   x83,F
194A:  RRCF   x82,F
194C:  MOVLW  3F
194E:  ANDWF  x85,F
....................       dc=dg-c*36524; 
1950:  MOVFF  85,12D
1954:  MOVFF  84,12C
1958:  MOVFF  83,12B
195C:  MOVFF  82,12A
1960:  MOVLB  1
1962:  CLRF   x31
1964:  CLRF   x30
1966:  MOVLW  8E
1968:  MOVWF  x2F
196A:  MOVLW  AC
196C:  MOVWF  x2E
196E:  MOVLB  0
1970:  RCALL  13DE
1972:  MOVF   00,W
1974:  SUBWF  x7E,W
1976:  MOVWF  x86
1978:  MOVF   01,W
197A:  SUBWFB x7F,W
197C:  MOVWF  x87
197E:  MOVF   02,W
1980:  SUBWFB x80,W
1982:  MOVWF  x88
1984:  MOVF   03,W
1986:  SUBWFB x81,W
1988:  MOVWF  x89
198A:  CLRF   18
198C:  BTFSC  FF2.7
198E:  BSF    18.7
1990:  BCF    FF2.7
....................       b=dc/1461; 
1992:  MOVFF  89,124
1996:  MOVFF  88,123
199A:  MOVFF  87,122
199E:  MOVFF  86,121
19A2:  MOVLB  1
19A4:  CLRF   x28
19A6:  CLRF   x27
19A8:  MOVLW  05
19AA:  MOVWF  x26
19AC:  MOVLW  B5
19AE:  MOVWF  x25
19B0:  MOVLB  0
19B2:  CALL   0340
19B6:  BTFSC  18.7
19B8:  BSF    FF2.7
19BA:  MOVFF  03,8D
19BE:  MOVFF  02,8C
19C2:  MOVFF  01,8B
19C6:  MOVFF  00,8A
19CA:  CLRF   18
19CC:  BTFSC  FF2.7
19CE:  BSF    18.7
19D0:  BCF    FF2.7
....................       db=dc%1461; 
19D2:  MOVFF  89,124
19D6:  MOVFF  88,123
19DA:  MOVFF  87,122
19DE:  MOVFF  86,121
19E2:  MOVLB  1
19E4:  CLRF   x28
19E6:  CLRF   x27
19E8:  MOVLW  05
19EA:  MOVWF  x26
19EC:  MOVLW  B5
19EE:  MOVWF  x25
19F0:  MOVLB  0
19F2:  CALL   0340
19F6:  BTFSC  18.7
19F8:  BSF    FF2.7
19FA:  MOVFF  FEF,8E
19FE:  MOVFF  FEC,8F
1A02:  MOVFF  FEC,90
1A06:  MOVFF  FEC,91
1A0A:  CLRF   18
1A0C:  BTFSC  FF2.7
1A0E:  BSF    18.7
1A10:  BCF    FF2.7
....................       a=(db/365+1)*3/4; 
1A12:  MOVFF  91,124
1A16:  MOVFF  90,123
1A1A:  MOVFF  8F,122
1A1E:  MOVFF  8E,121
1A22:  MOVLB  1
1A24:  CLRF   x28
1A26:  CLRF   x27
1A28:  MOVLW  01
1A2A:  MOVWF  x26
1A2C:  MOVLW  6D
1A2E:  MOVWF  x25
1A30:  MOVLB  0
1A32:  CALL   0340
1A36:  BTFSC  18.7
1A38:  BSF    FF2.7
1A3A:  MOVFF  03,118
1A3E:  MOVFF  02,117
1A42:  MOVFF  01,116
1A46:  MOVFF  00,115
1A4A:  MOVLW  01
1A4C:  MOVLB  1
1A4E:  ADDWF  00,W
1A50:  MOVWF  x19
1A52:  MOVLW  00
1A54:  ADDWFC 01,W
1A56:  MOVWF  x1A
1A58:  MOVLW  00
1A5A:  ADDWFC 02,W
1A5C:  MOVWF  x1B
1A5E:  MOVLW  00
1A60:  ADDWFC 03,W
1A62:  MOVWF  x1C
1A64:  MOVWF  x2D
1A66:  MOVFF  11B,12C
1A6A:  MOVFF  11A,12B
1A6E:  MOVFF  119,12A
1A72:  CLRF   x31
1A74:  CLRF   x30
1A76:  CLRF   x2F
1A78:  MOVLW  03
1A7A:  MOVWF  x2E
1A7C:  MOVLB  0
1A7E:  RCALL  13DE
1A80:  MOVLB  1
1A82:  RRCF   03,W
1A84:  MOVLB  0
1A86:  MOVWF  x95
1A88:  MOVLB  1
1A8A:  RRCF   02,W
1A8C:  MOVLB  0
1A8E:  MOVWF  x94
1A90:  MOVLB  1
1A92:  RRCF   01,W
1A94:  MOVLB  0
1A96:  MOVWF  x93
1A98:  MOVLB  1
1A9A:  RRCF   00,W
1A9C:  MOVLB  0
1A9E:  MOVWF  x92
1AA0:  RRCF   x95,F
1AA2:  RRCF   x94,F
1AA4:  RRCF   x93,F
1AA6:  RRCF   x92,F
1AA8:  MOVLW  3F
1AAA:  ANDWF  x95,F
....................       da=db-a*365; 
1AAC:  MOVFF  95,12D
1AB0:  MOVFF  94,12C
1AB4:  MOVFF  93,12B
1AB8:  MOVFF  92,12A
1ABC:  MOVLB  1
1ABE:  CLRF   x31
1AC0:  CLRF   x30
1AC2:  MOVLW  01
1AC4:  MOVWF  x2F
1AC6:  MOVLW  6D
1AC8:  MOVWF  x2E
1ACA:  MOVLB  0
1ACC:  RCALL  13DE
1ACE:  MOVF   00,W
1AD0:  SUBWF  x8E,W
1AD2:  MOVWF  x96
1AD4:  MOVF   01,W
1AD6:  SUBWFB x8F,W
1AD8:  MOVWF  x97
1ADA:  MOVF   02,W
1ADC:  SUBWFB x90,W
1ADE:  MOVWF  x98
1AE0:  MOVF   03,W
1AE2:  SUBWFB x91,W
1AE4:  MOVWF  x99
....................       y=g*400+c*100+b*4+a; 
1AE6:  MOVFF  7D,12D
1AEA:  MOVFF  7C,12C
1AEE:  MOVFF  7B,12B
1AF2:  MOVFF  7A,12A
1AF6:  MOVLB  1
1AF8:  CLRF   x31
1AFA:  CLRF   x30
1AFC:  MOVLW  01
1AFE:  MOVWF  x2F
1B00:  MOVLW  90
1B02:  MOVWF  x2E
1B04:  MOVLB  0
1B06:  RCALL  13DE
1B08:  MOVFF  03,118
1B0C:  MOVFF  02,117
1B10:  MOVFF  01,116
1B14:  MOVFF  00,115
1B18:  MOVFF  85,12D
1B1C:  MOVFF  84,12C
1B20:  MOVFF  83,12B
1B24:  MOVFF  82,12A
1B28:  MOVLB  1
1B2A:  CLRF   x31
1B2C:  CLRF   x30
1B2E:  CLRF   x2F
1B30:  MOVLW  64
1B32:  MOVWF  x2E
1B34:  MOVLB  0
1B36:  RCALL  13DE
1B38:  MOVF   00,W
1B3A:  MOVLB  1
1B3C:  ADDWF  x15,W
1B3E:  MOVWF  x19
1B40:  MOVF   01,W
1B42:  ADDWFC x16,W
1B44:  MOVWF  x1A
1B46:  MOVF   02,W
1B48:  ADDWFC x17,W
1B4A:  MOVWF  x1B
1B4C:  MOVF   03,W
1B4E:  ADDWFC x18,W
1B50:  MOVWF  x1C
1B52:  MOVLB  0
1B54:  RLCF   x8A,W
1B56:  MOVWF  00
1B58:  RLCF   x8B,W
1B5A:  MOVWF  01
1B5C:  RLCF   x8C,W
1B5E:  MOVWF  02
1B60:  RLCF   x8D,W
1B62:  MOVWF  03
1B64:  RLCF   00,F
1B66:  RLCF   01,F
1B68:  RLCF   02,F
1B6A:  RLCF   03,F
1B6C:  MOVLW  FC
1B6E:  ANDWF  00,F
1B70:  MOVF   00,W
1B72:  MOVLB  1
1B74:  ADDWF  x19,W
1B76:  MOVWF  x1D
1B78:  MOVF   01,W
1B7A:  ADDWFC x1A,W
1B7C:  MOVWF  x1E
1B7E:  MOVF   02,W
1B80:  ADDWFC x1B,W
1B82:  MOVWF  x1F
1B84:  MOVF   03,W
1B86:  ADDWFC x1C,W
1B88:  MOVWF  x20
1B8A:  MOVLB  0
1B8C:  MOVF   x92,W
1B8E:  MOVLB  1
1B90:  ADDWF  x1D,W
1B92:  MOVLB  0
1B94:  MOVWF  x9A
1B96:  MOVF   x93,W
1B98:  MOVLB  1
1B9A:  ADDWFC x1E,W
1B9C:  MOVLB  0
1B9E:  MOVWF  x9B
1BA0:  MOVF   x94,W
1BA2:  MOVLB  1
1BA4:  ADDWFC x1F,W
1BA6:  MOVLB  0
1BA8:  MOVWF  x9C
1BAA:  MOVF   x95,W
1BAC:  MOVLB  1
1BAE:  ADDWFC x20,W
1BB0:  MOVLB  0
1BB2:  MOVWF  x9D
....................       m=(da*5+308)/153-2; 
1BB4:  MOVFF  99,12D
1BB8:  MOVFF  98,12C
1BBC:  MOVFF  97,12B
1BC0:  MOVFF  96,12A
1BC4:  MOVLB  1
1BC6:  CLRF   x31
1BC8:  CLRF   x30
1BCA:  CLRF   x2F
1BCC:  MOVLW  05
1BCE:  MOVWF  x2E
1BD0:  MOVLB  0
1BD2:  RCALL  13DE
1BD4:  MOVFF  03,118
1BD8:  MOVFF  02,117
1BDC:  MOVFF  01,116
1BE0:  MOVFF  00,115
1BE4:  MOVLW  34
1BE6:  MOVLB  1
1BE8:  ADDWF  00,W
1BEA:  MOVWF  x19
1BEC:  MOVLW  01
1BEE:  ADDWFC 01,W
1BF0:  MOVWF  x1A
1BF2:  MOVLW  00
1BF4:  ADDWFC 02,W
1BF6:  MOVWF  x1B
1BF8:  MOVLW  00
1BFA:  ADDWFC 03,W
1BFC:  MOVWF  x1C
1BFE:  CLRF   18
1C00:  BTFSC  FF2.7
1C02:  BSF    18.7
1C04:  BCF    FF2.7
1C06:  MOVWF  x24
1C08:  MOVFF  11B,123
1C0C:  MOVFF  11A,122
1C10:  MOVFF  119,121
1C14:  CLRF   x28
1C16:  CLRF   x27
1C18:  CLRF   x26
1C1A:  MOVLW  99
1C1C:  MOVWF  x25
1C1E:  MOVLB  0
1C20:  CALL   0340
1C24:  BTFSC  18.7
1C26:  BSF    FF2.7
1C28:  MOVLW  02
1C2A:  MOVLB  1
1C2C:  SUBWF  00,W
1C2E:  MOVLB  0
1C30:  MOVWF  x9E
1C32:  MOVLW  00
1C34:  MOVLB  1
1C36:  SUBWFB 01,W
1C38:  MOVLB  0
1C3A:  MOVWF  x9F
1C3C:  MOVLW  00
1C3E:  MOVLB  1
1C40:  SUBWFB 02,W
1C42:  MOVLB  0
1C44:  MOVWF  xA0
1C46:  MOVLW  00
1C48:  MOVLB  1
1C4A:  SUBWFB 03,W
1C4C:  MOVLB  0
1C4E:  MOVWF  xA1
....................       d=da-(m+4)*153/5+122; 
1C50:  MOVLW  04
1C52:  ADDWF  x9E,W
1C54:  MOVLB  1
1C56:  MOVWF  x15
1C58:  MOVLW  00
1C5A:  MOVLB  0
1C5C:  ADDWFC x9F,W
1C5E:  MOVLB  1
1C60:  MOVWF  x16
1C62:  MOVLW  00
1C64:  MOVLB  0
1C66:  ADDWFC xA0,W
1C68:  MOVLB  1
1C6A:  MOVWF  x17
1C6C:  MOVLW  00
1C6E:  MOVLB  0
1C70:  ADDWFC xA1,W
1C72:  MOVLB  1
1C74:  MOVWF  x18
1C76:  MOVWF  x2D
1C78:  MOVFF  117,12C
1C7C:  MOVFF  116,12B
1C80:  MOVFF  115,12A
1C84:  CLRF   x31
1C86:  CLRF   x30
1C88:  CLRF   x2F
1C8A:  MOVLW  99
1C8C:  MOVWF  x2E
1C8E:  MOVLB  0
1C90:  CALL   13DE
1C94:  MOVFF  03,119
1C98:  MOVFF  02,118
1C9C:  MOVFF  01,117
1CA0:  MOVFF  00,116
1CA4:  CLRF   18
1CA6:  BTFSC  FF2.7
1CA8:  BSF    18.7
1CAA:  BCF    FF2.7
1CAC:  MOVFF  03,124
1CB0:  MOVFF  02,123
1CB4:  MOVFF  01,122
1CB8:  MOVFF  00,121
1CBC:  MOVLB  1
1CBE:  CLRF   x28
1CC0:  CLRF   x27
1CC2:  CLRF   x26
1CC4:  MOVLW  05
1CC6:  MOVWF  x25
1CC8:  MOVLB  0
1CCA:  CALL   0340
1CCE:  BTFSC  18.7
1CD0:  BSF    FF2.7
1CD2:  MOVF   00,W
1CD4:  SUBWF  x96,W
1CD6:  MOVLB  1
1CD8:  MOVWF  x17
1CDA:  MOVF   01,W
1CDC:  MOVLB  0
1CDE:  SUBWFB x97,W
1CE0:  MOVLB  1
1CE2:  MOVWF  x18
1CE4:  MOVF   02,W
1CE6:  MOVLB  0
1CE8:  SUBWFB x98,W
1CEA:  MOVLB  1
1CEC:  MOVWF  x19
1CEE:  MOVF   03,W
1CF0:  MOVLB  0
1CF2:  SUBWFB x99,W
1CF4:  MOVLB  1
1CF6:  MOVWF  x1A
1CF8:  MOVLW  7A
1CFA:  ADDWF  x17,W
1CFC:  MOVLB  0
1CFE:  MOVWF  xA2
1D00:  MOVLW  00
1D02:  MOVLB  1
1D04:  ADDWFC x18,W
1D06:  MOVLB  0
1D08:  MOVWF  xA3
1D0A:  MOVLW  00
1D0C:  MOVLB  1
1D0E:  ADDWFC x19,W
1D10:  MOVLB  0
1D12:  MOVWF  xA4
1D14:  MOVLW  00
1D16:  MOVLB  1
1D18:  ADDWFC x1A,W
1D1A:  MOVLB  0
1D1C:  MOVWF  xA5
....................       YY=y-4800+(m+2)/12; 
1D1E:  MOVLW  C0
1D20:  SUBWF  x9A,W
1D22:  MOVLB  1
1D24:  MOVWF  x15
1D26:  MOVLW  12
1D28:  MOVLB  0
1D2A:  SUBWFB x9B,W
1D2C:  MOVLB  1
1D2E:  MOVWF  x16
1D30:  MOVLW  00
1D32:  MOVLB  0
1D34:  SUBWFB x9C,W
1D36:  MOVLB  1
1D38:  MOVWF  x17
1D3A:  MOVLW  00
1D3C:  MOVLB  0
1D3E:  SUBWFB x9D,W
1D40:  MOVLB  1
1D42:  MOVWF  x18
1D44:  MOVLW  02
1D46:  MOVLB  0
1D48:  ADDWF  x9E,W
1D4A:  MOVLB  1
1D4C:  MOVWF  x19
1D4E:  MOVLW  00
1D50:  MOVLB  0
1D52:  ADDWFC x9F,W
1D54:  MOVLB  1
1D56:  MOVWF  x1A
1D58:  MOVLW  00
1D5A:  MOVLB  0
1D5C:  ADDWFC xA0,W
1D5E:  MOVLB  1
1D60:  MOVWF  x1B
1D62:  MOVLW  00
1D64:  MOVLB  0
1D66:  ADDWFC xA1,W
1D68:  MOVLB  1
1D6A:  MOVWF  x1C
1D6C:  CLRF   18
1D6E:  BTFSC  FF2.7
1D70:  BSF    18.7
1D72:  BCF    FF2.7
1D74:  MOVWF  x24
1D76:  MOVFF  11B,123
1D7A:  MOVFF  11A,122
1D7E:  MOVFF  119,121
1D82:  CLRF   x28
1D84:  CLRF   x27
1D86:  CLRF   x26
1D88:  MOVLW  0C
1D8A:  MOVWF  x25
1D8C:  MOVLB  0
1D8E:  CALL   0340
1D92:  BTFSC  18.7
1D94:  BSF    FF2.7
1D96:  MOVF   00,W
1D98:  MOVLB  1
1D9A:  ADDWF  x15,W
1D9C:  MOVLB  0
1D9E:  MOVWF  xA6
1DA0:  MOVF   01,W
1DA2:  MOVLB  1
1DA4:  ADDWFC x16,W
1DA6:  MOVLB  0
1DA8:  MOVWF  xA7
1DAA:  MOVF   02,W
1DAC:  MOVLB  1
1DAE:  ADDWFC x17,W
1DB0:  MOVLB  0
1DB2:  MOVWF  xA8
1DB4:  MOVF   03,W
1DB6:  MOVLB  1
1DB8:  ADDWFC x18,W
1DBA:  MOVLB  0
1DBC:  MOVWF  xA9
....................       MM=(m+2)%12+1; 
1DBE:  MOVLW  02
1DC0:  ADDWF  x9E,W
1DC2:  MOVLB  1
1DC4:  MOVWF  x15
1DC6:  MOVLW  00
1DC8:  MOVLB  0
1DCA:  ADDWFC x9F,W
1DCC:  MOVLB  1
1DCE:  MOVWF  x16
1DD0:  MOVLW  00
1DD2:  MOVLB  0
1DD4:  ADDWFC xA0,W
1DD6:  MOVLB  1
1DD8:  MOVWF  x17
1DDA:  MOVLW  00
1DDC:  MOVLB  0
1DDE:  ADDWFC xA1,W
1DE0:  MOVLB  1
1DE2:  MOVWF  x18
1DE4:  CLRF   18
1DE6:  BTFSC  FF2.7
1DE8:  BSF    18.7
1DEA:  BCF    FF2.7
1DEC:  MOVWF  x24
1DEE:  MOVFF  117,123
1DF2:  MOVFF  116,122
1DF6:  MOVFF  115,121
1DFA:  CLRF   x28
1DFC:  CLRF   x27
1DFE:  CLRF   x26
1E00:  MOVLW  0C
1E02:  MOVWF  x25
1E04:  MOVLB  0
1E06:  CALL   0340
1E0A:  BTFSC  18.7
1E0C:  BSF    FF2.7
1E0E:  MOVFF  FEF,116
1E12:  MOVFF  FEC,117
1E16:  MOVFF  FEC,118
1E1A:  MOVFF  FEC,119
1E1E:  MOVLW  01
1E20:  MOVLB  1
1E22:  ADDWF  x16,W
1E24:  MOVLB  0
1E26:  MOVWF  xAA
1E28:  MOVLW  00
1E2A:  MOVLB  1
1E2C:  ADDWFC x17,W
1E2E:  MOVLB  0
1E30:  MOVWF  xAB
1E32:  MOVLW  00
1E34:  MOVLB  1
1E36:  ADDWFC x18,W
1E38:  MOVLB  0
1E3A:  MOVWF  xAC
1E3C:  MOVLW  00
1E3E:  MOVLB  1
1E40:  ADDWFC x19,W
1E42:  MOVLB  0
1E44:  MOVWF  xAD
....................       DD=d+1; 
1E46:  MOVLW  01
1E48:  ADDWF  xA2,W
1E4A:  MOVWF  xAE
1E4C:  MOVLW  00
1E4E:  ADDWFC xA3,W
1E50:  MOVWF  xAF
1E52:  MOVLW  00
1E54:  ADDWFC xA4,W
1E56:  MOVWF  xB0
1E58:  MOVLW  00
1E5A:  ADDWFC xA5,W
1E5C:  MOVWF  xB1
....................       time_of_day = (timer_sec+((int8)UTC)*3600)%86400; 
1E5E:  MOVLW  70
1E60:  ADDWF  20,W
1E62:  MOVLB  1
1E64:  MOVWF  x15
1E66:  MOVLW  62
1E68:  ADDWFC 21,W
1E6A:  MOVWF  x16
1E6C:  MOVLW  00
1E6E:  ADDWFC 22,W
1E70:  MOVWF  x17
1E72:  MOVLW  00
1E74:  ADDWFC 23,W
1E76:  MOVWF  x18
1E78:  CLRF   18
1E7A:  BTFSC  FF2.7
1E7C:  BSF    18.7
1E7E:  BCF    FF2.7
1E80:  MOVWF  x24
1E82:  MOVFF  117,123
1E86:  MOVFF  116,122
1E8A:  MOVFF  115,121
1E8E:  CLRF   x28
1E90:  MOVLW  01
1E92:  MOVWF  x27
1E94:  MOVLW  51
1E96:  MOVWF  x26
1E98:  MOVLW  80
1E9A:  MOVWF  x25
1E9C:  MOVLB  0
1E9E:  CALL   0340
1EA2:  BTFSC  18.7
1EA4:  BSF    FF2.7
1EA6:  MOVFF  FEF,B2
1EAA:  MOVFF  FEC,B3
1EAE:  MOVFF  FEC,B4
1EB2:  MOVFF  FEC,B5
....................  
....................       strcpy(tmp_str,"00/00/00"); 
1EB6:  CLRF   FEA
1EB8:  MOVLW  2C
1EBA:  MOVWF  FE9
1EBC:  MOVFF  FF2,115
1EC0:  BCF    FF2.7
1EC2:  MOVLW  00
1EC4:  CALL   00C8
1EC8:  TBLRD*-
1ECA:  TBLRD*+
1ECC:  MOVF   FF5,W
1ECE:  MOVWF  FEE
1ED0:  IORLW  00
1ED2:  BNZ   1ECA
1ED4:  MOVLB  1
1ED6:  BTFSC  x15.7
1ED8:  BSF    FF2.7
....................       itoa((int8)DD,10,tmp_str2); 
1EDA:  CLRF   x1E
1EDC:  CLRF   x1D
1EDE:  CLRF   x1C
1EE0:  MOVFF  AE,11B
1EE4:  MOVLW  0A
1EE6:  MOVWF  x1F
1EE8:  CLRF   x21
1EEA:  MOVLW  40
1EEC:  MOVWF  x20
1EEE:  MOVLB  0
1EF0:  CALL   150E
....................       if (strlen(tmp_str2)==1) tmp_str[1]=tmp_str2[0]; else memcpy(tmp_str,tmp_str2,2); 
1EF4:  MOVLB  1
1EF6:  CLRF   x18
1EF8:  MOVLW  40
1EFA:  MOVWF  x17
1EFC:  MOVLB  0
1EFE:  CALL   16F2
1F02:  DECFSZ 01,W
1F04:  BRA    1F0C
1F06:  MOVFF  40,2D
1F0A:  BRA    1F24
1F0C:  CLRF   FEA
1F0E:  MOVLW  2C
1F10:  MOVWF  FE9
1F12:  CLRF   FE2
1F14:  MOVLW  40
1F16:  MOVWF  FE1
1F18:  MOVLW  02
1F1A:  MOVWF  01
1F1C:  MOVFF  FE6,FEE
1F20:  DECFSZ 01,F
1F22:  BRA    1F1C
....................       itoa((int8)MM,10,tmp_str2); 
1F24:  MOVLB  1
1F26:  CLRF   x1E
1F28:  CLRF   x1D
1F2A:  CLRF   x1C
1F2C:  MOVFF  AA,11B
1F30:  MOVLW  0A
1F32:  MOVWF  x1F
1F34:  CLRF   x21
1F36:  MOVLW  40
1F38:  MOVWF  x20
1F3A:  MOVLB  0
1F3C:  CALL   150E
....................       if (strlen(tmp_str2)==1) tmp_str[4]=tmp_str2[0]; else memcpy(tmp_str+3,tmp_str2,2); 
1F40:  MOVLB  1
1F42:  CLRF   x18
1F44:  MOVLW  40
1F46:  MOVWF  x17
1F48:  MOVLB  0
1F4A:  CALL   16F2
1F4E:  DECFSZ 01,W
1F50:  BRA    1F58
1F52:  MOVFF  40,30
1F56:  BRA    1F70
1F58:  CLRF   FEA
1F5A:  MOVLW  2F
1F5C:  MOVWF  FE9
1F5E:  CLRF   FE2
1F60:  MOVLW  40
1F62:  MOVWF  FE1
1F64:  MOVLW  02
1F66:  MOVWF  01
1F68:  MOVFF  FE6,FEE
1F6C:  DECFSZ 01,F
1F6E:  BRA    1F68
1F70:  CLRF   18
1F72:  BTFSC  FF2.7
1F74:  BSF    18.7
1F76:  BCF    FF2.7
....................       itoa((int8)(YY%2000),10,tmp_str2); 
1F78:  MOVFF  A9,124
1F7C:  MOVFF  A8,123
1F80:  MOVFF  A7,122
1F84:  MOVFF  A6,121
1F88:  MOVLB  1
1F8A:  CLRF   x28
1F8C:  CLRF   x27
1F8E:  MOVLW  07
1F90:  MOVWF  x26
1F92:  MOVLW  D0
1F94:  MOVWF  x25
1F96:  MOVLB  0
1F98:  CALL   0340
1F9C:  BTFSC  18.7
1F9E:  BSF    FF2.7
1FA0:  MOVFF  FEF,00
1FA4:  MOVFF  FEC,01
1FA8:  MOVFF  FEC,02
1FAC:  MOVFF  FEC,03
1FB0:  MOVFF  00,115
1FB4:  MOVLB  1
1FB6:  CLRF   x1E
1FB8:  CLRF   x1D
1FBA:  CLRF   x1C
1FBC:  MOVFF  00,11B
1FC0:  MOVLW  0A
1FC2:  MOVWF  x1F
1FC4:  CLRF   x21
1FC6:  MOVLW  40
1FC8:  MOVWF  x20
1FCA:  MOVLB  0
1FCC:  CALL   150E
....................       if (strlen(tmp_str2)==1) tmp_str[7]=tmp_str2[0]; else memcpy(tmp_str+6,tmp_str2,2); 
1FD0:  MOVLB  1
1FD2:  CLRF   x18
1FD4:  MOVLW  40
1FD6:  MOVWF  x17
1FD8:  MOVLB  0
1FDA:  CALL   16F2
1FDE:  DECFSZ 01,W
1FE0:  BRA    1FE8
1FE2:  MOVFF  40,33
1FE6:  BRA    2000
1FE8:  CLRF   FEA
1FEA:  MOVLW  32
1FEC:  MOVWF  FE9
1FEE:  CLRF   FE2
1FF0:  MOVLW  40
1FF2:  MOVWF  FE1
1FF4:  MOVLW  02
1FF6:  MOVWF  01
1FF8:  MOVFF  FE6,FEE
1FFC:  DECFSZ 01,F
1FFE:  BRA    1FF8
....................       lcd_gotoxy(0,0); 
2000:  MOVLB  1
2002:  CLRF   x1F
2004:  CLRF   x20
2006:  MOVLB  0
2008:  CALL   0D3E
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
200C:  MOVLB  1
200E:  CLRF   x18
2010:  MOVLW  2C
2012:  MOVWF  x17
2014:  MOVLB  0
2016:  CALL   16F2
201A:  MOVFF  01,115
201E:  MOVLB  1
2020:  CLRF   x17
2022:  MOVLW  2C
2024:  MOVWF  x16
2026:  MOVFF  01,118
202A:  MOVLB  0
202C:  CALL   172C
....................       strcpy(tmp_str,"00:00:00"); 
2030:  CLRF   FEA
2032:  MOVLW  2C
2034:  MOVWF  FE9
2036:  MOVFF  FF2,115
203A:  BCF    FF2.7
203C:  MOVLW  00
203E:  CALL   00EC
2042:  TBLRD*-
2044:  TBLRD*+
2046:  MOVF   FF5,W
2048:  MOVWF  FEE
204A:  IORLW  00
204C:  BNZ   2044
204E:  MOVLB  1
2050:  BTFSC  x15.7
2052:  BSF    FF2.7
2054:  CLRF   18
2056:  BTFSC  FF2.7
2058:  BSF    18.7
205A:  BCF    FF2.7
....................       itoa((int8) (time_of_day/3600),10,tmp_str2); 
205C:  MOVFF  B5,124
2060:  MOVFF  B4,123
2064:  MOVFF  B3,122
2068:  MOVFF  B2,121
206C:  CLRF   x28
206E:  CLRF   x27
2070:  MOVLW  0E
2072:  MOVWF  x26
2074:  MOVLW  10
2076:  MOVWF  x25
2078:  MOVLB  0
207A:  CALL   0340
207E:  BTFSC  18.7
2080:  BSF    FF2.7
2082:  MOVFF  00,115
2086:  MOVLB  1
2088:  CLRF   x1E
208A:  CLRF   x1D
208C:  CLRF   x1C
208E:  MOVFF  00,11B
2092:  MOVLW  0A
2094:  MOVWF  x1F
2096:  CLRF   x21
2098:  MOVLW  40
209A:  MOVWF  x20
209C:  MOVLB  0
209E:  CALL   150E
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
20A2:  MOVLB  1
20A4:  CLRF   x18
20A6:  MOVLW  40
20A8:  MOVWF  x17
20AA:  MOVLB  0
20AC:  CALL   16F2
20B0:  MOVF   01,W
20B2:  SUBLW  02
20B4:  BNC   2106
20B6:  MOVLB  1
20B8:  CLRF   x18
20BA:  MOVLW  40
20BC:  MOVWF  x17
20BE:  MOVLB  0
20C0:  CALL   16F2
20C4:  MOVLW  2E
20C6:  BSF    FD8.0
20C8:  SUBFWB 01,W
20CA:  MOVLB  1
20CC:  MOVWF  x15
20CE:  MOVLW  00
20D0:  BTFSS  FD8.0
20D2:  DECF   FE8,F
20D4:  MOVWF  x16
20D6:  CLRF   x18
20D8:  MOVLW  40
20DA:  MOVWF  x17
20DC:  MOVLB  0
20DE:  CALL   16F2
20E2:  MOVFF  01,117
20E6:  MOVFF  116,FEA
20EA:  MOVFF  115,FE9
20EE:  CLRF   FE2
20F0:  MOVLW  40
20F2:  MOVWF  FE1
20F4:  MOVLB  1
20F6:  MOVF   01,W
20F8:  MOVWF  01
20FA:  BZ    2104
20FC:  MOVFF  FE6,FEE
2100:  DECFSZ 01,F
2102:  BRA    20FC
2104:  MOVLB  0
2106:  CLRF   18
2108:  BTFSC  FF2.7
210A:  BSF    18.7
210C:  BCF    FF2.7
....................       itoa((int8) ((time_of_day%3600)/60),10,tmp_str2); 
210E:  MOVFF  B5,124
2112:  MOVFF  B4,123
2116:  MOVFF  B3,122
211A:  MOVFF  B2,121
211E:  MOVLB  1
2120:  CLRF   x28
2122:  CLRF   x27
2124:  MOVLW  0E
2126:  MOVWF  x26
2128:  MOVLW  10
212A:  MOVWF  x25
212C:  MOVLB  0
212E:  CALL   0340
2132:  BTFSC  18.7
2134:  BSF    FF2.7
2136:  MOVFF  FEF,115
213A:  MOVFF  FEC,116
213E:  MOVFF  FEC,117
2142:  MOVFF  FEC,118
2146:  MOVFF  FEA,11A
214A:  MOVFF  FE9,119
214E:  CLRF   18
2150:  BTFSC  FF2.7
2152:  BSF    18.7
2154:  BCF    FF2.7
2156:  MOVFF  118,124
215A:  MOVFF  117,123
215E:  MOVFF  116,122
2162:  MOVFF  115,121
2166:  MOVLB  1
2168:  CLRF   x28
216A:  CLRF   x27
216C:  CLRF   x26
216E:  MOVLW  3C
2170:  MOVWF  x25
2172:  MOVLB  0
2174:  CALL   0340
2178:  BTFSC  18.7
217A:  BSF    FF2.7
217C:  MOVFF  11A,FEA
2180:  MOVFF  119,FE9
2184:  MOVFF  00,116
2188:  MOVLB  1
218A:  CLRF   x1E
218C:  CLRF   x1D
218E:  CLRF   x1C
2190:  MOVFF  00,11B
2194:  MOVLW  0A
2196:  MOVWF  x1F
2198:  CLRF   x21
219A:  MOVLW  40
219C:  MOVWF  x20
219E:  MOVLB  0
21A0:  CALL   150E
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
21A4:  MOVLB  1
21A6:  CLRF   x18
21A8:  MOVLW  40
21AA:  MOVWF  x17
21AC:  MOVLB  0
21AE:  CALL   16F2
21B2:  MOVF   01,W
21B4:  SUBLW  02
21B6:  BNC   2208
21B8:  MOVLB  1
21BA:  CLRF   x18
21BC:  MOVLW  40
21BE:  MOVWF  x17
21C0:  MOVLB  0
21C2:  CALL   16F2
21C6:  MOVLW  31
21C8:  BSF    FD8.0
21CA:  SUBFWB 01,W
21CC:  MOVLB  1
21CE:  MOVWF  x15
21D0:  MOVLW  00
21D2:  BTFSS  FD8.0
21D4:  DECF   FE8,F
21D6:  MOVWF  x16
21D8:  CLRF   x18
21DA:  MOVLW  40
21DC:  MOVWF  x17
21DE:  MOVLB  0
21E0:  CALL   16F2
21E4:  MOVFF  01,117
21E8:  MOVFF  116,FEA
21EC:  MOVFF  115,FE9
21F0:  CLRF   FE2
21F2:  MOVLW  40
21F4:  MOVWF  FE1
21F6:  MOVLB  1
21F8:  MOVF   01,W
21FA:  MOVWF  01
21FC:  BZ    2206
21FE:  MOVFF  FE6,FEE
2202:  DECFSZ 01,F
2204:  BRA    21FE
2206:  MOVLB  0
2208:  CLRF   18
220A:  BTFSC  FF2.7
220C:  BSF    18.7
220E:  BCF    FF2.7
....................       itoa((int8) (time_of_day%60),10,tmp_str2); 
2210:  MOVFF  B5,124
2214:  MOVFF  B4,123
2218:  MOVFF  B3,122
221C:  MOVFF  B2,121
2220:  MOVLB  1
2222:  CLRF   x28
2224:  CLRF   x27
2226:  CLRF   x26
2228:  MOVLW  3C
222A:  MOVWF  x25
222C:  MOVLB  0
222E:  CALL   0340
2232:  BTFSC  18.7
2234:  BSF    FF2.7
2236:  MOVFF  FEF,00
223A:  MOVFF  FEC,01
223E:  MOVFF  FEC,02
2242:  MOVFF  FEC,03
2246:  MOVFF  00,115
224A:  MOVLB  1
224C:  CLRF   x1E
224E:  CLRF   x1D
2250:  CLRF   x1C
2252:  MOVFF  00,11B
2256:  MOVLW  0A
2258:  MOVWF  x1F
225A:  CLRF   x21
225C:  MOVLW  40
225E:  MOVWF  x20
2260:  MOVLB  0
2262:  CALL   150E
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2266:  MOVLB  1
2268:  CLRF   x18
226A:  MOVLW  40
226C:  MOVWF  x17
226E:  MOVLB  0
2270:  CALL   16F2
2274:  MOVF   01,W
2276:  SUBLW  02
2278:  BNC   22C8
227A:  MOVLB  1
227C:  CLRF   x18
227E:  MOVLW  40
2280:  MOVWF  x17
2282:  MOVLB  0
2284:  CALL   16F2
2288:  MOVLW  34
228A:  BSF    FD8.0
228C:  SUBFWB 01,W
228E:  MOVLB  1
2290:  MOVWF  x15
2292:  MOVLW  00
2294:  BTFSS  FD8.0
2296:  DECF   FE8,F
2298:  MOVWF  x16
229A:  CLRF   x18
229C:  MOVLW  40
229E:  MOVWF  x17
22A0:  MOVLB  0
22A2:  CALL   16F2
22A6:  MOVFF  01,117
22AA:  MOVFF  116,FEA
22AE:  MOVFF  115,FE9
22B2:  CLRF   FE2
22B4:  MOVLW  40
22B6:  MOVWF  FE1
22B8:  MOVLB  1
22BA:  MOVF   01,W
22BC:  MOVWF  01
22BE:  BZ    22C8
22C0:  MOVFF  FE6,FEE
22C4:  DECFSZ 01,F
22C6:  BRA    22C0
....................       lcd_gotoxy(0,1); 
22C8:  MOVLB  1
22CA:  CLRF   x1F
22CC:  MOVLW  01
22CE:  MOVWF  x20
22D0:  MOVLB  0
22D2:  CALL   0D3E
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
22D6:  MOVLB  1
22D8:  CLRF   x18
22DA:  MOVLW  2C
22DC:  MOVWF  x17
22DE:  MOVLB  0
22E0:  CALL   16F2
22E4:  MOVFF  01,115
22E8:  MOVLB  1
22EA:  CLRF   x17
22EC:  MOVLW  2C
22EE:  MOVWF  x16
22F0:  MOVFF  01,118
22F4:  MOVLB  0
22F6:  CALL   172C
....................  
....................       strcpy(tmp_str,"   "); 
22FA:  CLRF   FEA
22FC:  MOVLW  2C
22FE:  MOVWF  FE9
2300:  MOVFF  FF2,115
2304:  BCF    FF2.7
2306:  MOVLW  00
2308:  CALL   0110
230C:  TBLRD*-
230E:  TBLRD*+
2310:  MOVF   FF5,W
2312:  MOVWF  FEE
2314:  IORLW  00
2316:  BNZ   230E
2318:  MOVLB  1
231A:  BTFSC  x15.7
231C:  BSF    FF2.7
....................       itoa((int8)startup_counter,10,tmp_str2); 
231E:  CLRF   x1E
2320:  CLRF   x1D
2322:  CLRF   x1C
2324:  MOVFF  C6,11B
2328:  MOVLW  0A
232A:  MOVWF  x1F
232C:  CLRF   x21
232E:  MOVLW  40
2330:  MOVWF  x20
2332:  MOVLB  0
2334:  CALL   150E
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2338:  MOVLB  1
233A:  CLRF   x18
233C:  MOVLW  40
233E:  MOVWF  x17
2340:  MOVLB  0
2342:  CALL   16F2
2346:  MOVF   01,W
2348:  SUBLW  03
234A:  BNC   239A
234C:  MOVLB  1
234E:  CLRF   x18
2350:  MOVLW  40
2352:  MOVWF  x17
2354:  MOVLB  0
2356:  CALL   16F2
235A:  MOVLW  2F
235C:  BSF    FD8.0
235E:  SUBFWB 01,W
2360:  MOVLB  1
2362:  MOVWF  x15
2364:  MOVLW  00
2366:  BTFSS  FD8.0
2368:  DECF   FE8,F
236A:  MOVWF  x16
236C:  CLRF   x18
236E:  MOVLW  40
2370:  MOVWF  x17
2372:  MOVLB  0
2374:  CALL   16F2
2378:  MOVFF  01,117
237C:  MOVFF  116,FEA
2380:  MOVFF  115,FE9
2384:  CLRF   FE2
2386:  MOVLW  40
2388:  MOVWF  FE1
238A:  MOVLB  1
238C:  MOVF   01,W
238E:  MOVWF  01
2390:  BZ    239A
2392:  MOVFF  FE6,FEE
2396:  DECFSZ 01,F
2398:  BRA    2392
....................        lcd_gotoxy(0,2); 
239A:  MOVLB  1
239C:  CLRF   x1F
239E:  MOVLW  02
23A0:  MOVWF  x20
23A2:  MOVLB  0
23A4:  CALL   0D3E
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
23A8:  MOVLB  1
23AA:  CLRF   x18
23AC:  MOVLW  2C
23AE:  MOVWF  x17
23B0:  MOVLB  0
23B2:  CALL   16F2
23B6:  MOVFF  01,115
23BA:  MOVLB  1
23BC:  CLRF   x17
23BE:  MOVLW  2C
23C0:  MOVWF  x16
23C2:  MOVFF  01,118
23C6:  MOVLB  0
23C8:  CALL   172C
....................  
....................  
.................... } 
23CC:  RETLW  00
....................  
.................... void download_sun_table(int16 nPage) { 
....................     int16 i,j; 
....................    disable_interrupts(GLOBAL); 
*
28DA:  BCF    FF2.6
28DC:  BCF    FF2.7
28DE:  BTFSC  FF2.7
28E0:  BRA    28DC
....................    restart_wdt(); 
28E2:  CLRWDT
....................    setup_wdt(WDT_OFF); 
28E4:  BCF    FD1.0
....................     output_high(FLASH_SELECT); 
28E6:  BCF    F94.2
28E8:  BSF    F8B.2
....................     while(kbhit()) getc(); 
28EA:  BTFSS  F9E.5
28EC:  BRA    28F6
28EE:  BTFSS  F9E.5
28F0:  BRA    28EE
28F2:  MOVF   FAE,W
28F4:  BRA    28EA
....................     for (j=0;j<nPage+1;j++) { 
28F6:  MOVLB  1
28F8:  CLRF   x0D
28FA:  CLRF   x0C
28FC:  MOVLW  01
28FE:  ADDWF  x08,W
2900:  MOVWF  01
2902:  MOVLW  00
2904:  ADDWFC x09,W
2906:  MOVWF  03
2908:  MOVF   x0D,W
290A:  SUBWF  03,W
290C:  BNC   29D2
290E:  BNZ   2916
2910:  MOVF   01,W
2912:  SUBWF  x0C,W
2914:  BC    29D2
....................         ext_flash_waitUntilReady(); 
2916:  MOVLB  0
2918:  RCALL  272A
....................       PORTE.tx_en=1; 
291A:  BSF    F84.2
....................         printf("OK\r\n"); 
291C:  MOVLB  1
291E:  CLRF   x0E
2920:  MOVF   x0E,W
2922:  MOVLB  0
2924:  CALL   012E
2928:  MOVLB  1
292A:  INCF   x0E,F
292C:  MOVWF  00
292E:  MOVF   00,W
2930:  BTFSS  F9E.4
2932:  BRA    2930
2934:  MOVWF  FAD
2936:  MOVLW  04
2938:  SUBWF  x0E,W
293A:  BNZ   2920
....................       tx_delay=TX_DLY_TIME; 
293C:  MOVLW  01
293E:  MOVLB  0
2940:  MOVWF  xC2
....................       //PORTE.tx_en=0; 
....................          output_low(FLASH_SELECT); 
2942:  BCF    F94.2
2944:  BCF    F8B.2
....................         if (j%2) ext_flash_sendData(0x82, 8); else ext_flash_sendData(0x85, 8); 
2946:  MOVLB  1
2948:  MOVF   x0C,W
294A:  ANDLW  01
294C:  MOVWF  00
294E:  CLRF   03
2950:  MOVF   00,W
2952:  IORWF  03,W
2954:  BZ    2966
2956:  MOVLW  82
2958:  MOVWF  x2F
295A:  MOVLW  08
295C:  MOVWF  x30
295E:  MOVLB  0
2960:  RCALL  2864
2962:  BRA    2972
2964:  MOVLB  1
2966:  MOVLW  85
2968:  MOVWF  x2F
296A:  MOVLW  08
296C:  MOVWF  x30
296E:  MOVLB  0
2970:  RCALL  2864
....................          ext_flash_send16Data(j+10, 15); // page address 
2972:  MOVLW  0A
2974:  MOVLB  1
2976:  ADDWF  x0C,W
2978:  MOVWF  x0E
297A:  MOVLW  00
297C:  ADDWFC x0D,W
297E:  MOVWF  x0F
2980:  MOVWF  x30
2982:  MOVFF  10E,12F
2986:  MOVLW  0F
2988:  MOVWF  x31
298A:  MOVLB  0
298C:  RCALL  2898
....................       ext_flash_send16Data(0, 9); 
298E:  MOVLB  1
2990:  CLRF   x30
2992:  CLRF   x2F
2994:  MOVLW  09
2996:  MOVWF  x31
2998:  MOVLB  0
299A:  RCALL  2898
....................       for (i=0;i<256;i++) { 
299C:  MOVLB  1
299E:  CLRF   x0B
29A0:  CLRF   x0A
29A2:  MOVF   x0B,W
29A4:  SUBLW  00
29A6:  BNC   29C6
....................             ext_flash_sendData(getc(), 8); 
29A8:  BTFSS  F9E.5
29AA:  BRA    29A8
29AC:  MOVFF  FAE,10E
29B0:  MOVFF  10E,12F
29B4:  MOVLW  08
29B6:  MOVWF  x30
29B8:  MOVLB  0
29BA:  RCALL  2864
....................       } 
29BC:  MOVLB  1
29BE:  INCF   x0A,F
29C0:  BTFSC  FD8.2
29C2:  INCF   x0B,F
29C4:  BRA    29A2
....................        output_high(FLASH_SELECT); 
29C6:  BCF    F94.2
29C8:  BSF    F8B.2
....................    } 
29CA:  INCF   x0C,F
29CC:  BTFSC  FD8.2
29CE:  INCF   x0D,F
29D0:  BRA    28FC
....................    enable_interrupts(GLOBAL); 
29D2:  MOVLW  C0
29D4:  IORWF  FF2,F
....................    restart_wdt(); 
29D6:  CLRWDT
....................    setup_wdt(WDT_ON); 
29D8:  BSF    FD1.0
....................  
.................... } 
29DA:  MOVLB  0
29DC:  GOTO   39B6 (RETURN)
....................  
.................... /* 
.................... void print_page_data(int16 nPage) { 
....................     char temp[256]; 
....................     int16 i; 
....................     int32 time_index; 
....................  
....................    ext_flash_readPage(nPage,0,temp,264); 
....................     for(i=0;i<264;i++) { 
....................       PORTE.tx_en=1; 
....................       if((i%16) ==0) printf("\r\n%02X : ",i); 
....................       printf("%02X ",temp[i]); 
....................    } 
....................    memcpy(&time_index,temp,4); 
....................     printf("\r\n Timer Index: %Lu",time_index);    
....................     
....................  
....................  
.................... } 
.................... */ 
.................... void print_page_data(int16 nPage) { 
....................     char temp[17]; 
....................     int8 i; 
....................    int8 j; 
....................     PORTE.tx_en=1; 
*
2AF6:  BSF    F84.2
....................     for(i=0;i<16;i++) { 
2AF8:  MOVLB  1
2AFA:  CLRF   x1B
2AFC:  MOVF   x1B,W
2AFE:  SUBLW  0F
2B00:  BNC   2B98
....................       printf("\r\n%02X : ",i); 
2B02:  MOVLW  0D
2B04:  BTFSS  F9E.4
2B06:  BRA    2B04
2B08:  MOVWF  FAD
2B0A:  MOVLW  0A
2B0C:  BTFSS  F9E.4
2B0E:  BRA    2B0C
2B10:  MOVWF  FAD
2B12:  MOVFF  11B,11E
2B16:  MOVLW  37
2B18:  MOVWF  x1F
2B1A:  MOVLB  0
2B1C:  RCALL  29E0
2B1E:  MOVLW  20
2B20:  BTFSS  F9E.4
2B22:  BRA    2B20
2B24:  MOVWF  FAD
2B26:  MOVLW  3A
2B28:  BTFSS  F9E.4
2B2A:  BRA    2B28
2B2C:  MOVWF  FAD
2B2E:  MOVLW  20
2B30:  BTFSS  F9E.4
2B32:  BRA    2B30
2B34:  MOVWF  FAD
....................       ext_flash_readPage(nPage,i*16,temp,16); 
2B36:  MOVLB  1
2B38:  MOVF   x1B,W
2B3A:  MULLW  10
2B3C:  MOVFF  FF3,11D
2B40:  MOVFF  109,129
2B44:  MOVFF  108,128
2B48:  MOVFF  11D,12A
2B4C:  MOVLW  01
2B4E:  MOVWF  x2C
2B50:  MOVLW  0A
2B52:  MOVWF  x2B
2B54:  CLRF   x2E
2B56:  MOVLW  10
2B58:  MOVWF  x2D
2B5A:  MOVLB  0
2B5C:  RCALL  2A86
....................       for (j=0;j<16;j++) printf("%02X ",temp[j]); 
2B5E:  MOVLB  1
2B60:  CLRF   x1C
2B62:  MOVF   x1C,W
2B64:  SUBLW  0F
2B66:  BNC   2B94
2B68:  CLRF   03
2B6A:  MOVF   x1C,W
2B6C:  ADDLW  0A
2B6E:  MOVWF  FE9
2B70:  MOVLW  01
2B72:  ADDWFC 03,W
2B74:  MOVWF  FEA
2B76:  MOVFF  FEF,11D
2B7A:  MOVFF  11D,11E
2B7E:  MOVLW  37
2B80:  MOVWF  x1F
2B82:  MOVLB  0
2B84:  RCALL  29E0
2B86:  MOVLW  20
2B88:  BTFSS  F9E.4
2B8A:  BRA    2B88
2B8C:  MOVWF  FAD
2B8E:  MOVLB  1
2B90:  INCF   x1C,F
2B92:  BRA    2B62
....................    } 
2B94:  INCF   x1B,F
2B96:  BRA    2AFC
....................    tx_delay=TX_DLY_TIME; 
2B98:  MOVLW  01
2B9A:  MOVLB  0
2B9C:  MOVWF  xC2
.................... } 
2B9E:  GOTO   352E (RETURN)
....................  
.................... int32 get_timer_index(int16 nDay) { // 1 page contain 2 subpage 
....................     char temp[6]; 
....................     int32 time_index; 
....................    ext_flash_readPage((nDay/2)+10,128*(nDay%2),temp,4); 
*
2F3E:  BCF    FD8.0
2F40:  MOVLB  1
2F42:  RRCF   x17,W
2F44:  MOVWF  x23
2F46:  RRCF   x16,W
2F48:  MOVWF  x22
2F4A:  MOVLW  0A
2F4C:  ADDWF  x22,W
2F4E:  MOVWF  x24
2F50:  MOVLW  00
2F52:  ADDWFC x23,W
2F54:  MOVWF  x25
2F56:  MOVF   x16,W
2F58:  ANDLW  01
2F5A:  MOVWF  00
2F5C:  CLRF   03
2F5E:  MOVWF  02
2F60:  RLCF   00,W
2F62:  MOVWF  x26
2F64:  RLCF   03,W
2F66:  MOVWF  x27
2F68:  RLCF   x26,F
2F6A:  RLCF   x27,F
2F6C:  RLCF   x26,F
2F6E:  RLCF   x27,F
2F70:  RLCF   x26,F
2F72:  RLCF   x27,F
2F74:  RLCF   x26,F
2F76:  RLCF   x27,F
2F78:  RLCF   x26,F
2F7A:  RLCF   x27,F
2F7C:  RLCF   x26,F
2F7E:  RLCF   x27,F
2F80:  MOVLW  80
2F82:  ANDWF  x26,F
2F84:  MOVFF  125,129
2F88:  MOVFF  124,128
2F8C:  MOVFF  126,12A
2F90:  MOVLW  01
2F92:  MOVWF  x2C
2F94:  MOVLW  18
2F96:  MOVWF  x2B
2F98:  CLRF   x2E
2F9A:  MOVLW  04
2F9C:  MOVWF  x2D
2F9E:  MOVLB  0
2FA0:  RCALL  2A86
....................    memcpy(&time_index,temp,4); 
2FA2:  MOVLW  01
2FA4:  MOVWF  FEA
2FA6:  MOVLW  1E
2FA8:  MOVWF  FE9
2FAA:  MOVLW  01
2FAC:  MOVWF  FE2
2FAE:  MOVLW  18
2FB0:  MOVWF  FE1
2FB2:  MOVLW  04
2FB4:  MOVWF  01
2FB6:  MOVFF  FE6,FEE
2FBA:  DECFSZ 01,F
2FBC:  BRA    2FB6
....................    return time_index; 
2FBE:  MOVFF  11E,00
2FC2:  MOVFF  11F,01
2FC6:  MOVFF  120,02
2FCA:  MOVFF  121,03
.................... } 
2FCE:  RETLW  00
....................  
.................... int16 find_day_number(int32 tsec) // return day number after 1-jan-2010, we use this to search for sun angle in flash memory page 
.................... { 
....................    return (((tsec+((int8)UTC)*3600)/86400)%1461); 
*
2E9C:  MOVLW  70
2E9E:  MOVLB  1
2EA0:  ADDWF  x16,W
2EA2:  MOVWF  x1A
2EA4:  MOVLW  62
2EA6:  ADDWFC x17,W
2EA8:  MOVWF  x1B
2EAA:  MOVLW  00
2EAC:  ADDWFC x18,W
2EAE:  MOVWF  x1C
2EB0:  MOVLW  00
2EB2:  ADDWFC x19,W
2EB4:  MOVWF  x1D
2EB6:  CLRF   18
2EB8:  BTFSC  FF2.7
2EBA:  BSF    18.7
2EBC:  BCF    FF2.7
2EBE:  MOVWF  x24
2EC0:  MOVFF  11C,123
2EC4:  MOVFF  11B,122
2EC8:  MOVFF  11A,121
2ECC:  CLRF   x28
2ECE:  MOVLW  01
2ED0:  MOVWF  x27
2ED2:  MOVLW  51
2ED4:  MOVWF  x26
2ED6:  MOVLW  80
2ED8:  MOVWF  x25
2EDA:  MOVLB  0
2EDC:  CALL   0340
2EE0:  BTFSC  18.7
2EE2:  BSF    FF2.7
2EE4:  MOVFF  03,11E
2EE8:  MOVFF  02,11D
2EEC:  MOVFF  01,11C
2EF0:  MOVFF  00,11B
2EF4:  CLRF   18
2EF6:  BTFSC  FF2.7
2EF8:  BSF    18.7
2EFA:  BCF    FF2.7
2EFC:  MOVFF  03,124
2F00:  MOVFF  02,123
2F04:  MOVFF  01,122
2F08:  MOVFF  00,121
2F0C:  MOVLB  1
2F0E:  CLRF   x28
2F10:  CLRF   x27
2F12:  MOVLW  05
2F14:  MOVWF  x26
2F16:  MOVLW  B5
2F18:  MOVWF  x25
2F1A:  MOVLB  0
2F1C:  CALL   0340
2F20:  BTFSC  18.7
2F22:  BSF    FF2.7
2F24:  MOVFF  FEF,00
2F28:  MOVFF  FEC,01
2F2C:  MOVFF  FEC,02
2F30:  MOVFF  FEC,03
2F34:  MOVFF  01,02
2F38:  MOVFF  00,01
.................... } 
2F3C:  RETLW  00
....................  
.................... unsigned int8 current_sun_angle(unsigned int32 t_sec) { 
....................    unsigned int16 today;  // current day (count after epoch) 
....................    unsigned int32 sun_rise_t_sec; // time of day . compensated for time zone 
....................    unsigned int8 sun_data; 
....................    today = find_day_number(t_sec); // day after epoch 
*
3A70:  MOVFF  10E,119
3A74:  MOVFF  10D,118
3A78:  MOVFF  10C,117
3A7C:  MOVFF  10B,116
3A80:  CALL   2E9C
3A84:  MOVFF  02,110
3A88:  MOVFF  01,10F
....................     sun_rise_t_sec = get_timer_index(today)*450; 
3A8C:  MOVFF  110,117
3A90:  MOVFF  10F,116
3A94:  CALL   2F3E
3A98:  MOVFF  03,119
3A9C:  MOVFF  02,118
3AA0:  MOVFF  01,117
3AA4:  MOVFF  00,116
3AA8:  MOVFF  FEA,11B
3AAC:  MOVFF  FE9,11A
3AB0:  MOVFF  03,12D
3AB4:  MOVFF  02,12C
3AB8:  MOVFF  01,12B
3ABC:  MOVFF  00,12A
3AC0:  MOVLB  1
3AC2:  CLRF   x31
3AC4:  CLRF   x30
3AC6:  MOVLW  01
3AC8:  MOVWF  x2F
3ACA:  MOVLW  C2
3ACC:  MOVWF  x2E
3ACE:  MOVLB  0
3AD0:  CALL   13DE
3AD4:  MOVFF  11B,FEA
3AD8:  MOVFF  11A,FE9
3ADC:  MOVFF  03,114
3AE0:  MOVFF  02,113
3AE4:  MOVFF  01,112
3AE8:  MOVFF  00,111
3AEC:  CLRF   18
3AEE:  BTFSC  FF2.7
3AF0:  BSF    18.7
3AF2:  BCF    FF2.7
....................     if (sun_rise_t_sec > t_sec%SEC_IN_4_YEARS) return 0x0; // sun havent up yet, angle is 0 
3AF4:  MOVFF  10E,124
3AF8:  MOVFF  10D,123
3AFC:  MOVFF  10C,122
3B00:  MOVFF  10B,121
3B04:  MOVLW  07
3B06:  MOVLB  1
3B08:  MOVWF  x28
3B0A:  MOVLW  86
3B0C:  MOVWF  x27
3B0E:  MOVLW  1F
3B10:  MOVWF  x26
3B12:  MOVLW  80
3B14:  MOVWF  x25
3B16:  MOVLB  0
3B18:  CALL   0340
3B1C:  BTFSC  18.7
3B1E:  BSF    FF2.7
3B20:  MOVFF  FEF,00
3B24:  MOVFF  FEC,01
3B28:  MOVFF  FEC,02
3B2C:  MOVFF  FEC,03
3B30:  MOVF   03,W
3B32:  MOVLB  1
3B34:  SUBWF  x14,W
3B36:  BNC   3B56
3B38:  BNZ   3B50
3B3A:  MOVF   02,W
3B3C:  SUBWF  x13,W
3B3E:  BNC   3B56
3B40:  BNZ   3B50
3B42:  MOVF   01,W
3B44:  SUBWF  x12,W
3B46:  BNC   3B56
3B48:  BNZ   3B50
3B4A:  MOVF   x11,W
3B4C:  SUBWF  00,W
3B4E:  BC    3B56
3B50:  MOVLW  00
3B52:  MOVWF  01
3B54:  BRA    3CA2
3B56:  CLRF   18
3B58:  BTFSC  FF2.7
3B5A:  BSF    18.7
3B5C:  BCF    FF2.7
....................    index_in_page = (t_sec%SEC_IN_4_YEARS-sun_rise_t_sec)/450; 
3B5E:  MOVFF  10E,124
3B62:  MOVFF  10D,123
3B66:  MOVFF  10C,122
3B6A:  MOVFF  10B,121
3B6E:  MOVLW  07
3B70:  MOVWF  x28
3B72:  MOVLW  86
3B74:  MOVWF  x27
3B76:  MOVLW  1F
3B78:  MOVWF  x26
3B7A:  MOVLW  80
3B7C:  MOVWF  x25
3B7E:  MOVLB  0
3B80:  CALL   0340
3B84:  BTFSC  18.7
3B86:  BSF    FF2.7
3B88:  MOVFF  FEF,116
3B8C:  MOVFF  FEC,117
3B90:  MOVFF  FEC,118
3B94:  MOVFF  FEC,119
3B98:  MOVLB  1
3B9A:  MOVF   x11,W
3B9C:  SUBWF  x16,W
3B9E:  MOVWF  x1A
3BA0:  MOVF   x12,W
3BA2:  SUBWFB x17,W
3BA4:  MOVWF  x1B
3BA6:  MOVF   x13,W
3BA8:  SUBWFB x18,W
3BAA:  MOVWF  x1C
3BAC:  MOVF   x14,W
3BAE:  SUBWFB x19,W
3BB0:  MOVWF  x1D
3BB2:  MOVFF  FEA,11F
3BB6:  MOVFF  FE9,11E
3BBA:  CLRF   18
3BBC:  BTFSC  FF2.7
3BBE:  BSF    18.7
3BC0:  BCF    FF2.7
3BC2:  MOVWF  x24
3BC4:  MOVFF  11C,123
3BC8:  MOVFF  11B,122
3BCC:  MOVFF  11A,121
3BD0:  CLRF   x28
3BD2:  CLRF   x27
3BD4:  MOVLW  01
3BD6:  MOVWF  x26
3BD8:  MOVLW  C2
3BDA:  MOVWF  x25
3BDC:  MOVLB  0
3BDE:  CALL   0340
3BE2:  BTFSC  18.7
3BE4:  BSF    FF2.7
3BE6:  MOVFF  11F,FEA
3BEA:  MOVFF  11E,FE9
3BEE:  MOVFF  00,CA
....................     if (index_in_page>=124) return 0xFF; // exceed page size , sun went down 
3BF2:  MOVF   xCA,W
3BF4:  SUBLW  7B
3BF6:  BC    3C02
3BF8:  MOVLW  FF
3BFA:  MOVWF  01
3BFC:  MOVLB  1
3BFE:  BRA    3CA2
3C00:  MOVLB  0
....................     ext_flash_readPage((today/2)+10,128*(today%2)+4+index_in_page,&sun_data,1); 
3C02:  BCF    FD8.0
3C04:  MOVLB  1
3C06:  RRCF   x10,W
3C08:  MOVWF  x17
3C0A:  RRCF   x0F,W
3C0C:  MOVWF  x16
3C0E:  MOVLW  0A
3C10:  ADDWF  x16,W
3C12:  MOVWF  x18
3C14:  MOVLW  00
3C16:  ADDWFC x17,W
3C18:  MOVWF  x19
3C1A:  MOVF   x0F,W
3C1C:  ANDLW  01
3C1E:  MOVWF  00
3C20:  CLRF   03
3C22:  MOVWF  02
3C24:  RLCF   00,W
3C26:  MOVWF  x1A
3C28:  RLCF   03,W
3C2A:  MOVWF  x1B
3C2C:  RLCF   x1A,F
3C2E:  RLCF   x1B,F
3C30:  RLCF   x1A,F
3C32:  RLCF   x1B,F
3C34:  RLCF   x1A,F
3C36:  RLCF   x1B,F
3C38:  RLCF   x1A,F
3C3A:  RLCF   x1B,F
3C3C:  RLCF   x1A,F
3C3E:  RLCF   x1B,F
3C40:  RLCF   x1A,F
3C42:  RLCF   x1B,F
3C44:  MOVLW  80
3C46:  ANDWF  x1A,F
3C48:  MOVLW  04
3C4A:  ADDWF  x1A,W
3C4C:  MOVWF  x1C
3C4E:  MOVLW  00
3C50:  ADDWFC x1B,W
3C52:  MOVWF  x1D
3C54:  MOVLB  0
3C56:  MOVF   xCA,W
3C58:  MOVLB  1
3C5A:  ADDWF  x1C,W
3C5C:  MOVWF  x1E
3C5E:  MOVLW  00
3C60:  ADDWFC x1D,W
3C62:  MOVWF  x1F
3C64:  MOVFF  119,129
3C68:  MOVFF  118,128
3C6C:  MOVFF  11E,12A
3C70:  MOVLW  01
3C72:  MOVWF  x2C
3C74:  MOVLW  15
3C76:  MOVWF  x2B
3C78:  CLRF   x2E
3C7A:  MOVLW  01
3C7C:  MOVWF  x2D
3C7E:  MOVLB  0
3C80:  CALL   2A86
....................    if ((index_in_page>5) && (sun_data==0)) return 0xFF; // sun went down 
3C84:  MOVF   xCA,W
3C86:  SUBLW  05
3C88:  BC    3C9C
3C8A:  MOVLB  1
3C8C:  MOVF   x15,F
3C8E:  BTFSC  FD8.2
3C90:  BRA    3C96
3C92:  MOVLB  0
3C94:  BRA    3C9C
3C96:  MOVLW  FF
3C98:  MOVWF  01
3C9A:  BRA    3CA2
....................    return sun_data; 
3C9C:  MOVLB  1
3C9E:  MOVFF  115,01
....................     
.................... } 
3CA2:  MOVLB  0
3CA4:  GOTO   3EC2 (RETURN)
....................  
....................  
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,boolean direction,boolean abort_when_task_armed) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
23CE:  MOVLB  1
23D0:  CLRF   x10
23D2:  CLRF   x11
....................    unsigned int16 yyy=0;    
23D4:  CLRF   x12
23D6:  CLRF   x13
....................    int8 rt=5; 
23D8:  MOVLW  05
23DA:  MOVWF  x14
....................    output_low(CCW); 
23DC:  BCF    F93.4
23DE:  BCF    F8A.4
....................    output_low(EN0); 
23E0:  BCF    F93.0
23E2:  BCF    F8A.0
....................    output_low(EN1); 
23E4:  BCF    F93.1
23E6:  BCF    F8A.1
....................    output_low(EN2); 
23E8:  BCF    F93.2
23EA:  BCF    F8A.2
....................    output_low(EN3); 
23EC:  BCF    F93.3
23EE:  BCF    F8A.3
....................    PORTD.ps_en=1; 
23F0:  BSF    F83.4
23F2:  CLRF   18
23F4:  BTFSC  FF2.7
23F6:  BSF    18.7
23F8:  BCF    FF2.7
....................     delay_ms(20); 
23FA:  MOVLW  14
23FC:  MOVWF  x20
23FE:  MOVLB  0
2400:  CALL   04C2
2404:  BTFSC  18.7
2406:  BSF    FF2.7
....................  
....................    if (!direction)   { 
2408:  MOVLB  1
240A:  MOVF   x0E,F
240C:  BNZ   2412
....................       output_high(CCW); 
240E:  BCF    F93.4
2410:  BSF    F8A.4
....................    } 
....................  
....................    PORTD.ps_en=1; 
2412:  BSF    F83.4
2414:  CLRF   18
2416:  BTFSC  FF2.7
2418:  BSF    18.7
241A:  BCF    FF2.7
....................     delay_ms(20); 
241C:  MOVLW  14
241E:  MOVWF  x20
2420:  MOVLB  0
2422:  CALL   04C2
2426:  BTFSC  18.7
2428:  BSF    FF2.7
....................    output_high(EN0); 
242A:  BCF    F93.0
242C:  BSF    F8A.0
242E:  CLRF   18
2430:  BTFSC  FF2.7
2432:  BSF    18.7
2434:  BCF    FF2.7
....................     delay_ms(10); 
2436:  MOVLW  0A
2438:  MOVLB  1
243A:  MOVWF  x20
243C:  MOVLB  0
243E:  CALL   04C2
2442:  BTFSC  18.7
2444:  BSF    FF2.7
....................  
....................    flag.prev_pulse_state = input(PIN_A2); //A2 = sensor wire for actuator 1 
2446:  BSF    F92.2
2448:  BCF    1F.2
244A:  BTFSC  F80.2
244C:  BSF    1F.2
....................    tick = timer_sec; 
244E:  MOVFF  23,27
2452:  MOVFF  22,26
2456:  MOVFF  21,25
245A:  MOVFF  20,24
....................    tick2 = timer_sec; 
245E:  MOVFF  23,2B
2462:  MOVFF  22,2A
2466:  MOVFF  21,29
246A:  MOVFF  20,28
....................    actuator_pulse =0; 
246E:  CLRF   xC9
2470:  CLRF   xC8
....................    while(1) { 
....................       xxx = (int16) (timer_sec-tick); 
2472:  MOVF   24,W
2474:  SUBWF  20,W
2476:  MOVWF  00
2478:  MOVF   25,W
247A:  SUBWFB 21,W
247C:  MOVWF  01
247E:  MOVF   26,W
2480:  SUBWFB 22,W
2482:  MOVF   27,W
2484:  SUBWFB 23,W
2486:  MOVFF  01,111
248A:  MOVFF  00,110
....................       yyy = (int16) (timer_sec-tick2); 
248E:  MOVF   28,W
2490:  SUBWF  20,W
2492:  MOVWF  00
2494:  MOVF   29,W
2496:  SUBWFB 21,W
2498:  MOVWF  01
249A:  MOVF   2A,W
249C:  SUBWFB 22,W
249E:  MOVF   2B,W
24A0:  SUBWFB 23,W
24A2:  MOVFF  01,113
24A6:  MOVFF  00,112
....................       if ( xxx>= time_out_sec)  
24AA:  MOVLB  1
24AC:  MOVF   x0B,W
24AE:  SUBWF  x11,W
24B0:  BNC   24BC
24B2:  BNZ   24BA
24B4:  MOVF   x0A,W
24B6:  SUBWF  x10,W
24B8:  BNC   24BC
....................          break; 
24BA:  BRA    25E2
....................        if (actuator_pulse >= nPulse) 
24BC:  MOVF   x09,W
24BE:  MOVLB  0
24C0:  SUBWF  xC9,W
24C2:  BNC   24D4
24C4:  BNZ   24D0
24C6:  MOVLB  1
24C8:  MOVF   x08,W
24CA:  MOVLB  0
24CC:  SUBWF  xC8,W
24CE:  BNC   24D4
....................          output_low(EN0); 
24D0:  BCF    F93.0
24D2:  BCF    F8A.0
....................       if ( yyy >=stuck_sec) 
24D4:  MOVLB  1
24D6:  MOVF   x0D,W
24D8:  SUBWF  x13,W
24DA:  BNC   24E6
24DC:  BNZ   24E4
24DE:  MOVF   x0C,W
24E0:  SUBWF  x12,W
24E2:  BNC   24E6
....................          break; 
24E4:  BRA    25E2
....................       if (abort_when_task_armed && (flag.task1_armed||flag.cmd_posted)) 
24E6:  MOVF   x0F,F
24E8:  BZ    24F4
24EA:  BTFSC  1F.0
24EC:  BRA    24F2
24EE:  BTFSS  1F.3
24F0:  BRA    24F4
....................          break; 
24F2:  BRA    25E2
....................       if (flag.prev_pulse_state != input(SENSE_0)) { 
24F4:  MOVLW  00
24F6:  BTFSC  1F.2
24F8:  MOVLW  01
24FA:  MOVWF  x15
24FC:  BSF    F92.1
24FE:  MOVLW  00
2500:  BTFSC  F80.1
2502:  MOVLW  01
2504:  SUBWF  x15,W
2506:  BZ    25D0
....................          tick2 = timer_sec; 
2508:  MOVFF  23,2B
250C:  MOVFF  22,2A
2510:  MOVFF  21,29
2514:  MOVFF  20,28
....................          flag.prev_pulse_state = input(SENSE_0); 
2518:  BSF    F92.1
251A:  BCF    1F.2
251C:  BTFSC  F80.1
251E:  BSF    1F.2
....................          if (!direction && (current_act_position >0)) current_act_position--; 
2520:  MOVF   x0E,F
2522:  BNZ   253E
2524:  MOVLB  0
2526:  MOVF   x6E,F
2528:  BNZ   2534
252A:  MOVF   x6F,F
252C:  BTFSS  FD8.2
252E:  BRA    2534
2530:  MOVLB  1
2532:  BRA    253E
2534:  MOVF   x6E,W
2536:  BTFSC  FD8.2
2538:  DECF   x6F,F
253A:  DECF   x6E,F
253C:  MOVLB  1
....................          if (direction && (current_act_position < FULL_STROKE_TICK)) current_act_position++; 
253E:  MOVF   x0E,F
2540:  BZ    2564
2542:  MOVLB  0
2544:  MOVF   x6F,W
2546:  SUBWF  xBB,W
2548:  BTFSC  FD8.0
254A:  BRA    2550
254C:  MOVLB  1
254E:  BRA    2564
2550:  BNZ   255E
2552:  MOVF   xBA,W
2554:  SUBWF  x6E,W
2556:  BTFSS  FD8.0
2558:  BRA    255E
255A:  MOVLB  1
255C:  BRA    2564
255E:  INCF   x6E,F
2560:  BTFSC  FD8.2
2562:  INCF   x6F,F
....................          actuator_pulse=actuator_pulse+1; 
2564:  MOVLW  01
2566:  MOVLB  0
2568:  ADDWF  xC8,F
256A:  MOVLW  00
256C:  ADDWFC xC9,F
....................          lcd_gotoxy(11,2); 
256E:  MOVLW  0B
2570:  MOVLB  1
2572:  MOVWF  x1F
2574:  MOVLW  02
2576:  MOVWF  x20
2578:  MOVLB  0
257A:  CALL   0D3E
....................          if (actuator_pulse%2==0)   lcd_putc('*'); else  lcd_putc('.'); 
257E:  MOVF   xC8,W
2580:  ANDLW  01
2582:  MOVLB  1
2584:  MOVWF  x15
2586:  CLRF   x16
2588:  MOVF   x15,F
258A:  BNZ   259E
258C:  MOVF   x16,F
258E:  BNZ   259E
2590:  MOVLW  2A
2592:  MOVWF  x1E
2594:  MOVLB  0
2596:  CALL   0D6E
259A:  BRA    25A8
259C:  MOVLB  1
259E:  MOVLW  2E
25A0:  MOVWF  x1E
25A2:  MOVLB  0
25A4:  CALL   0D6E
....................          lcd_gotoxy(12,2); 
25A8:  MOVLW  0C
25AA:  MOVLB  1
25AC:  MOVWF  x1F
25AE:  MOVLW  02
25B0:  MOVWF  x20
25B2:  MOVLB  0
25B4:  CALL   0D3E
....................          printf(lcd_putc,"%4lu",current_act_position); 
25B8:  MOVLW  01
25BA:  MOVWF  FE9
25BC:  MOVFF  6F,116
25C0:  MOVFF  6E,115
25C4:  CALL   0DD8
....................          PORTE.tx_en=1; 
25C8:  BSF    F84.2
....................          //printf("\r%4lu",actuator_pulse); 
....................          tx_delay=TX_DLY_TIME; 
25CA:  MOVLW  01
25CC:  MOVWF  xC2
25CE:  MOVLB  1
....................  
....................       } 
....................       if (flag.update_time) { 
25D0:  BTFSS  1F.1
25D2:  BRA    25DC
....................          flag.update_time = false; 
25D4:  BCF    1F.1
....................          print_date_time(); 
25D6:  MOVLB  0
25D8:  CALL   175C
....................       } 
....................    } 
25DC:  MOVLB  0
25DE:  BRA    2472
25E0:  MOVLB  1
....................    lcd_gotoxy(12,2); 
25E2:  MOVLW  0C
25E4:  MOVWF  x1F
25E6:  MOVLW  02
25E8:  MOVWF  x20
25EA:  MOVLB  0
25EC:  CALL   0D3E
....................     printf(lcd_putc,"%4lu",current_act_position); 
25F0:  MOVLW  01
25F2:  MOVWF  FE9
25F4:  MOVFF  6F,116
25F8:  MOVFF  6E,115
25FC:  CALL   0DD8
....................    output_low(EN0); 
2600:  BCF    F93.0
2602:  BCF    F8A.0
....................    output_low(EN1); 
2604:  BCF    F93.1
2606:  BCF    F8A.1
....................    output_low(EN2); 
2608:  BCF    F93.2
260A:  BCF    F8A.2
....................    output_low(EN3); 
260C:  BCF    F93.3
260E:  BCF    F8A.3
....................    PORTD.ps_en=1; 
2610:  BSF    F83.4
2612:  CLRF   18
2614:  BTFSC  FF2.7
2616:  BSF    18.7
2618:  BCF    FF2.7
....................     delay_ms(50); 
261A:  MOVLW  32
261C:  MOVLB  1
261E:  MOVWF  x20
2620:  MOVLB  0
2622:  CALL   04C2
2626:  BTFSC  18.7
2628:  BSF    FF2.7
....................    output_low(CCW); 
262A:  BCF    F93.4
262C:  BCF    F8A.4
262E:  CLRF   18
2630:  BTFSC  FF2.7
2632:  BSF    18.7
2634:  BCF    FF2.7
....................     delay_ms(50); 
2636:  MOVLW  32
2638:  MOVLB  1
263A:  MOVWF  x20
263C:  MOVLB  0
263E:  CALL   04C2
2642:  BTFSC  18.7
2644:  BSF    FF2.7
.................... } 
2646:  RETLW  00
....................  
.................... int8 task1() { 
*
3CEC:  CLRF   18
3CEE:  BTFSC  FF2.7
3CF0:  BSF    18.7
3CF2:  BCF    FF2.7
....................       int8 sun_angle; 
....................       //lcd_init(); 
....................       if (timer_sec%SEC_IN_4_YEARS >= next_sun_rise) { 
3CF4:  MOVFF  23,124
3CF8:  MOVFF  22,123
3CFC:  MOVFF  21,122
3D00:  MOVFF  20,121
3D04:  MOVLW  07
3D06:  MOVLB  1
3D08:  MOVWF  x28
3D0A:  MOVLW  86
3D0C:  MOVWF  x27
3D0E:  MOVLW  1F
3D10:  MOVWF  x26
3D12:  MOVLW  80
3D14:  MOVWF  x25
3D16:  MOVLB  0
3D18:  CALL   0340
3D1C:  BTFSC  18.7
3D1E:  BSF    FF2.7
3D20:  MOVFF  FEF,107
3D24:  MOVFF  FEC,108
3D28:  MOVFF  FEC,109
3D2C:  MOVFF  FEC,10A
3D30:  MOVF   x6D,W
3D32:  MOVLB  1
3D34:  SUBWF  x0A,W
3D36:  BTFSS  FD8.0
3D38:  BRA    3E46
3D3A:  BNZ   3D60
3D3C:  MOVLB  0
3D3E:  MOVF   x6C,W
3D40:  MOVLB  1
3D42:  SUBWF  x09,W
3D44:  BTFSS  FD8.0
3D46:  BRA    3E46
3D48:  BNZ   3D60
3D4A:  MOVLB  0
3D4C:  MOVF   x6B,W
3D4E:  MOVLB  1
3D50:  SUBWF  x08,W
3D52:  BNC   3E46
3D54:  BNZ   3D60
3D56:  MOVLB  0
3D58:  MOVF   x6A,W
3D5A:  MOVLB  1
3D5C:  SUBWF  x07,W
3D5E:  BNC   3E46
....................           next_sun_rise=get_timer_index(find_day_number((next_sun_rise+86400)%SEC_IN_4_YEARS))*450; 
3D60:  MOVLW  80
3D62:  MOVLB  0
3D64:  ADDWF  x6A,W
3D66:  MOVLB  1
3D68:  MOVWF  x07
3D6A:  MOVLW  51
3D6C:  MOVLB  0
3D6E:  ADDWFC x6B,W
3D70:  MOVLB  1
3D72:  MOVWF  x08
3D74:  MOVLW  01
3D76:  MOVLB  0
3D78:  ADDWFC x6C,W
3D7A:  MOVLB  1
3D7C:  MOVWF  x09
3D7E:  MOVLW  00
3D80:  MOVLB  0
3D82:  ADDWFC x6D,W
3D84:  MOVLB  1
3D86:  MOVWF  x0A
3D88:  CLRF   18
3D8A:  BTFSC  FF2.7
3D8C:  BSF    18.7
3D8E:  BCF    FF2.7
3D90:  MOVWF  x24
3D92:  MOVFF  109,123
3D96:  MOVFF  108,122
3D9A:  MOVFF  107,121
3D9E:  MOVLW  07
3DA0:  MOVWF  x28
3DA2:  MOVLW  86
3DA4:  MOVWF  x27
3DA6:  MOVLW  1F
3DA8:  MOVWF  x26
3DAA:  MOVLW  80
3DAC:  MOVWF  x25
3DAE:  MOVLB  0
3DB0:  CALL   0340
3DB4:  BTFSC  18.7
3DB6:  BSF    FF2.7
3DB8:  MOVFF  FEF,108
3DBC:  MOVFF  FEC,109
3DC0:  MOVFF  FEC,10A
3DC4:  MOVFF  FEC,10B
3DC8:  MOVFF  10B,119
3DCC:  MOVFF  10A,118
3DD0:  MOVFF  109,117
3DD4:  MOVFF  108,116
3DD8:  CALL   2E9C
3DDC:  MOVFF  02,10A
3DE0:  MOVFF  01,109
3DE4:  MOVFF  02,117
3DE8:  MOVFF  01,116
3DEC:  CALL   2F3E
3DF0:  MOVFF  03,10D
3DF4:  MOVFF  02,10C
3DF8:  MOVFF  01,10B
3DFC:  MOVFF  00,10A
3E00:  MOVFF  FEA,10F
3E04:  MOVFF  FE9,10E
3E08:  MOVFF  03,12D
3E0C:  MOVFF  02,12C
3E10:  MOVFF  01,12B
3E14:  MOVFF  00,12A
3E18:  MOVLB  1
3E1A:  CLRF   x31
3E1C:  CLRF   x30
3E1E:  MOVLW  01
3E20:  MOVWF  x2F
3E22:  MOVLW  C2
3E24:  MOVWF  x2E
3E26:  MOVLB  0
3E28:  CALL   13DE
3E2C:  MOVFF  10F,FEA
3E30:  MOVFF  10E,FE9
3E34:  MOVFF  03,6D
3E38:  MOVFF  02,6C
3E3C:  MOVFF  01,6B
3E40:  MOVFF  00,6A
3E44:  MOVLB  1
....................       } 
....................         sec_until_sun_rise = (int32) (next_sun_rise-timer_sec); 
3E46:  MOVF   20,W
3E48:  MOVLB  0
3E4A:  SUBWF  x6A,W
3E4C:  MOVWF  00
3E4E:  MOVF   21,W
3E50:  SUBWFB x6B,W
3E52:  MOVWF  01
3E54:  MOVF   22,W
3E56:  SUBWFB x6C,W
3E58:  MOVWF  02
3E5A:  MOVF   23,W
3E5C:  SUBWFB x6D,W
3E5E:  MOVWF  xB9
3E60:  MOVFF  02,B8
3E64:  MOVFF  01,B7
3E68:  MOVFF  00,B6
3E6C:  CLRF   18
3E6E:  BTFSC  FF2.7
3E70:  BSF    18.7
3E72:  BCF    FF2.7
....................       sun_angle=current_sun_angle(timer_sec%SEC_IN_4_YEARS); 
3E74:  MOVFF  23,124
3E78:  MOVFF  22,123
3E7C:  MOVFF  21,122
3E80:  MOVFF  20,121
3E84:  MOVLW  07
3E86:  MOVLB  1
3E88:  MOVWF  x28
3E8A:  MOVLW  86
3E8C:  MOVWF  x27
3E8E:  MOVLW  1F
3E90:  MOVWF  x26
3E92:  MOVLW  80
3E94:  MOVWF  x25
3E96:  MOVLB  0
3E98:  CALL   0340
3E9C:  BTFSC  18.7
3E9E:  BSF    FF2.7
3EA0:  MOVFF  FEF,107
3EA4:  MOVFF  FEC,108
3EA8:  MOVFF  FEC,109
3EAC:  MOVFF  FEC,10A
3EB0:  MOVFF  10A,10E
3EB4:  MOVFF  109,10D
3EB8:  MOVFF  108,10C
3EBC:  MOVFF  107,10B
3EC0:  BRA    3A70
3EC2:  MOVFF  01,106
....................  
....................       // prepare buffer1 
....................       if (sun_angle==0x00) // sun havent' come up yet, clear buffer1 
3EC6:  MOVLB  1
3EC8:  MOVF   x06,F
3ECA:  BNZ   3F64
3ECC:  CLRF   18
3ECE:  BTFSC  FF2.7
3ED0:  BSF    18.7
3ED2:  BCF    FF2.7
....................       { 
....................          if(find_day_number(timer_sec%SEC_IN_4_YEARS)%2==0)  
3ED4:  MOVFF  23,124
3ED8:  MOVFF  22,123
3EDC:  MOVFF  21,122
3EE0:  MOVFF  20,121
3EE4:  MOVLW  07
3EE6:  MOVWF  x28
3EE8:  MOVLW  86
3EEA:  MOVWF  x27
3EEC:  MOVLW  1F
3EEE:  MOVWF  x26
3EF0:  MOVLW  80
3EF2:  MOVWF  x25
3EF4:  MOVLB  0
3EF6:  CALL   0340
3EFA:  BTFSC  18.7
3EFC:  BSF    FF2.7
3EFE:  MOVFF  FEF,107
3F02:  MOVFF  FEC,108
3F06:  MOVFF  FEC,109
3F0A:  MOVFF  FEC,10A
3F0E:  MOVFF  10A,119
3F12:  MOVFF  109,118
3F16:  MOVFF  108,117
3F1A:  MOVFF  107,116
3F1E:  CALL   2E9C
3F22:  MOVFF  02,109
3F26:  MOVFF  01,108
3F2A:  MOVLB  1
3F2C:  MOVF   01,W
3F2E:  ANDLW  01
3F30:  MOVWF  x0A
3F32:  CLRF   x0B
3F34:  MOVF   x0A,F
3F36:  BNZ   3F50
3F38:  MOVF   x0B,F
3F3A:  BNZ   3F50
....................             ext_flash_buffer1_write(0xAA,0,255); 
3F3C:  MOVLW  AA
3F3E:  MOVWF  x11
3F40:  CLRF   x12
3F42:  MOVLW  FF
3F44:  MOVWF  x13
3F46:  MOVLB  0
3F48:  CALL   3248
....................          else 
3F4C:  BRA    3F62
3F4E:  MOVLB  1
....................             ext_flash_buffer1_write(0xAA,128,127); 
3F50:  MOVLW  AA
3F52:  MOVWF  x11
3F54:  MOVLW  80
3F56:  MOVWF  x12
3F58:  MOVLW  7F
3F5A:  MOVWF  x13
3F5C:  MOVLB  0
3F5E:  CALL   3248
3F62:  MOVLB  1
....................       } 
....................  
....................       if ((sun_angle == 0xFF) || (sun_angle == 0x00)) // sundown 
3F64:  INCFSZ x06,W
3F66:  BRA    3F6A
3F68:  BRA    3F6E
3F6A:  MOVF   x06,F
3F6C:  BNZ   3F72
....................          sun_angle = 180; 
3F6E:  MOVLW  B4
3F70:  MOVWF  x06
....................  
....................       if (sun_angle != 180) { 
3F72:  MOVF   x06,W
3F74:  SUBLW  B4
3F76:  BTFSC  FD8.2
3F78:  BRA    40D2
....................          ext_flash_buffer1_write((int8)(current_measured/n_avg_current_measured),128*(find_day_number(timer_sec%SEC_IN_4_YEARS)%2)+4+index_in_page,1); 
3F7A:  MOVFF  C4,109
3F7E:  MOVFF  C3,108
3F82:  CLRF   x0B
3F84:  MOVFF  C5,10A
3F88:  MOVLB  0
3F8A:  CALL   3124
3F8E:  MOVFF  01,107
3F92:  CLRF   18
3F94:  BTFSC  FF2.7
3F96:  BSF    18.7
3F98:  BCF    FF2.7
3F9A:  MOVFF  23,124
3F9E:  MOVFF  22,123
3FA2:  MOVFF  21,122
3FA6:  MOVFF  20,121
3FAA:  MOVLW  07
3FAC:  MOVLB  1
3FAE:  MOVWF  x28
3FB0:  MOVLW  86
3FB2:  MOVWF  x27
3FB4:  MOVLW  1F
3FB6:  MOVWF  x26
3FB8:  MOVLW  80
3FBA:  MOVWF  x25
3FBC:  MOVLB  0
3FBE:  CALL   0340
3FC2:  BTFSC  18.7
3FC4:  BSF    FF2.7
3FC6:  MOVFF  FEF,108
3FCA:  MOVFF  FEC,109
3FCE:  MOVFF  FEC,10A
3FD2:  MOVFF  FEC,10B
3FD6:  MOVFF  10B,119
3FDA:  MOVFF  10A,118
3FDE:  MOVFF  109,117
3FE2:  MOVFF  108,116
3FE6:  CALL   2E9C
3FEA:  MOVFF  02,10A
3FEE:  MOVFF  01,109
3FF2:  MOVLB  1
3FF4:  MOVF   01,W
3FF6:  ANDLW  01
3FF8:  MOVWF  00
3FFA:  CLRF   03
3FFC:  MOVWF  02
3FFE:  RLCF   00,W
4000:  MOVWF  x0B
4002:  RLCF   03,W
4004:  MOVWF  x0C
4006:  RLCF   x0B,F
4008:  RLCF   x0C,F
400A:  RLCF   x0B,F
400C:  RLCF   x0C,F
400E:  RLCF   x0B,F
4010:  RLCF   x0C,F
4012:  RLCF   x0B,F
4014:  RLCF   x0C,F
4016:  RLCF   x0B,F
4018:  RLCF   x0C,F
401A:  RLCF   x0B,F
401C:  RLCF   x0C,F
401E:  MOVLW  80
4020:  ANDWF  x0B,F
4022:  MOVLW  04
4024:  ADDWF  x0B,W
4026:  MOVWF  x0D
4028:  MOVLW  00
402A:  ADDWFC x0C,W
402C:  MOVWF  x0E
402E:  MOVLB  0
4030:  MOVF   xCA,W
4032:  MOVLB  1
4034:  ADDWF  x0D,W
4036:  MOVWF  x0F
4038:  MOVLW  00
403A:  ADDWFC x0E,W
403C:  MOVWF  x10
403E:  MOVFF  107,111
4042:  MOVFF  10F,112
4046:  MOVLW  01
4048:  MOVWF  x13
404A:  MOVLB  0
404C:  CALL   3248
4050:  CLRF   18
4052:  BTFSC  FF2.7
4054:  BSF    18.7
4056:  BCF    FF2.7
....................          ext_flash_write_buffer1_to_main_memory(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
4058:  MOVFF  23,124
405C:  MOVFF  22,123
4060:  MOVFF  21,122
4064:  MOVFF  20,121
4068:  MOVLW  07
406A:  MOVLB  1
406C:  MOVWF  x28
406E:  MOVLW  86
4070:  MOVWF  x27
4072:  MOVLW  1F
4074:  MOVWF  x26
4076:  MOVLW  80
4078:  MOVWF  x25
407A:  MOVLB  0
407C:  CALL   0340
4080:  BTFSC  18.7
4082:  BSF    FF2.7
4084:  MOVFF  FEF,107
4088:  MOVFF  FEC,108
408C:  MOVFF  FEC,109
4090:  MOVFF  FEC,10A
4094:  MOVFF  10A,119
4098:  MOVFF  109,118
409C:  MOVFF  108,117
40A0:  MOVFF  107,116
40A4:  CALL   2E9C
40A8:  MOVFF  02,109
40AC:  MOVFF  01,108
40B0:  BCF    FD8.0
40B2:  MOVLB  1
40B4:  RRCF   02,W
40B6:  MOVWF  03
40B8:  RRCF   01,W
40BA:  MOVWF  02
40BC:  ADDLW  F2
40BE:  MOVWF  x0A
40C0:  MOVLW  03
40C2:  ADDWFC 03,W
40C4:  MOVWF  x0B
40C6:  MOVWF  x0D
40C8:  MOVFF  10A,10C
40CC:  MOVLB  0
40CE:  BRA    3CA8
40D0:  MOVLB  1
....................       } 
....................       strcpy(tmp_str,"#     "); 
40D2:  CLRF   FEA
40D4:  MOVLW  2C
40D6:  MOVWF  FE9
40D8:  MOVFF  FF2,107
40DC:  BCF    FF2.7
40DE:  MOVLW  00
40E0:  MOVLB  0
40E2:  CALL   014E
40E6:  TBLRD*-
40E8:  TBLRD*+
40EA:  MOVF   FF5,W
40EC:  MOVWF  FEE
40EE:  IORLW  00
40F0:  BNZ   40E8
40F2:  MOVLB  1
40F4:  BTFSC  x07.7
40F6:  BSF    FF2.7
40F8:  CLRF   18
40FA:  BTFSC  FF2.7
40FC:  BSF    18.7
40FE:  BCF    FF2.7
....................       itoa((int16)find_day_number(timer_sec%SEC_IN_4_YEARS),10,tmp_str2); 
4100:  MOVFF  23,124
4104:  MOVFF  22,123
4108:  MOVFF  21,122
410C:  MOVFF  20,121
4110:  MOVLW  07
4112:  MOVWF  x28
4114:  MOVLW  86
4116:  MOVWF  x27
4118:  MOVLW  1F
411A:  MOVWF  x26
411C:  MOVLW  80
411E:  MOVWF  x25
4120:  MOVLB  0
4122:  CALL   0340
4126:  BTFSC  18.7
4128:  BSF    FF2.7
412A:  MOVFF  FEF,107
412E:  MOVFF  FEC,108
4132:  MOVFF  FEC,109
4136:  MOVFF  FEC,10A
413A:  MOVFF  10A,119
413E:  MOVFF  109,118
4142:  MOVFF  108,117
4146:  MOVFF  107,116
414A:  CALL   2E9C
414E:  MOVFF  02,109
4152:  MOVFF  01,108
4156:  MOVLB  1
4158:  CLRF   x1E
415A:  CLRF   x1D
415C:  MOVFF  02,11C
4160:  MOVFF  01,11B
4164:  MOVLW  0A
4166:  MOVWF  x1F
4168:  CLRF   x21
416A:  MOVLW  40
416C:  MOVWF  x20
416E:  MOVLB  0
4170:  CALL   150E
....................       memcpy(tmp_str+4-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
4174:  MOVLB  1
4176:  CLRF   x18
4178:  MOVLW  40
417A:  MOVWF  x17
417C:  MOVLB  0
417E:  CALL   16F2
4182:  MOVLW  30
4184:  BSF    FD8.0
4186:  SUBFWB 01,W
4188:  MOVLB  1
418A:  MOVWF  x07
418C:  MOVLW  00
418E:  BTFSS  FD8.0
4190:  DECF   FE8,F
4192:  MOVWF  x08
4194:  CLRF   x18
4196:  MOVLW  40
4198:  MOVWF  x17
419A:  MOVLB  0
419C:  CALL   16F2
41A0:  MOVFF  01,109
41A4:  MOVFF  108,FEA
41A8:  MOVFF  107,FE9
41AC:  CLRF   FE2
41AE:  MOVLW  40
41B0:  MOVWF  FE1
41B2:  MOVLB  1
41B4:  MOVF   01,W
41B6:  MOVWF  01
41B8:  BZ    41C2
41BA:  MOVFF  FE6,FEE
41BE:  DECFSZ 01,F
41C0:  BRA    41BA
....................       lcd_gotoxy(10,0); 
41C2:  MOVLW  0A
41C4:  MOVWF  x1F
41C6:  CLRF   x20
41C8:  MOVLB  0
41CA:  CALL   0D3E
....................       lcd_gotoxy(10,0);       
41CE:  MOVLW  0A
41D0:  MOVLB  1
41D2:  MOVWF  x1F
41D4:  CLRF   x20
41D6:  MOVLB  0
41D8:  CALL   0D3E
....................       lcd_gotoxy(10,0); 
41DC:  MOVLW  0A
41DE:  MOVLB  1
41E0:  MOVWF  x1F
41E2:  CLRF   x20
41E4:  MOVLB  0
41E6:  CALL   0D3E
....................       lcd_put_str(tmp_str,strlen(tmp_str)); 
41EA:  MOVLB  1
41EC:  CLRF   x18
41EE:  MOVLW  2C
41F0:  MOVWF  x17
41F2:  MOVLB  0
41F4:  CALL   16F2
41F8:  MOVFF  01,107
41FC:  MOVLB  1
41FE:  CLRF   x17
4200:  MOVLW  2C
4202:  MOVWF  x16
4204:  MOVFF  01,118
4208:  MOVLB  0
420A:  CALL   172C
....................  
....................       strcpy(tmp_str,"   "); 
420E:  CLRF   FEA
4210:  MOVLW  2C
4212:  MOVWF  FE9
4214:  MOVFF  FF2,107
4218:  BCF    FF2.7
421A:  MOVLW  00
421C:  CALL   0110
4220:  TBLRD*-
4222:  TBLRD*+
4224:  MOVF   FF5,W
4226:  MOVWF  FEE
4228:  IORLW  00
422A:  BNZ   4222
422C:  MOVLB  1
422E:  BTFSC  x07.7
4230:  BSF    FF2.7
....................       tmp_str[3]=0xDF; 
4232:  MOVLW  DF
4234:  MOVWF  2F
....................       itoa((int8)sun_angle,10,tmp_str2); 
4236:  CLRF   x1E
4238:  CLRF   x1D
423A:  CLRF   x1C
423C:  MOVFF  106,11B
4240:  MOVLW  0A
4242:  MOVWF  x1F
4244:  CLRF   x21
4246:  MOVLW  40
4248:  MOVWF  x20
424A:  MOVLB  0
424C:  CALL   150E
....................       if (strlen(tmp_str2)<=3) memcpy(tmp_str+3-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
4250:  MOVLB  1
4252:  CLRF   x18
4254:  MOVLW  40
4256:  MOVWF  x17
4258:  MOVLB  0
425A:  CALL   16F2
425E:  MOVF   01,W
4260:  SUBLW  03
4262:  BNC   42B2
4264:  MOVLB  1
4266:  CLRF   x18
4268:  MOVLW  40
426A:  MOVWF  x17
426C:  MOVLB  0
426E:  CALL   16F2
4272:  MOVLW  2F
4274:  BSF    FD8.0
4276:  SUBFWB 01,W
4278:  MOVLB  1
427A:  MOVWF  x07
427C:  MOVLW  00
427E:  BTFSS  FD8.0
4280:  DECF   FE8,F
4282:  MOVWF  x08
4284:  CLRF   x18
4286:  MOVLW  40
4288:  MOVWF  x17
428A:  MOVLB  0
428C:  CALL   16F2
4290:  MOVFF  01,109
4294:  MOVFF  108,FEA
4298:  MOVFF  107,FE9
429C:  CLRF   FE2
429E:  MOVLW  40
42A0:  MOVWF  FE1
42A2:  MOVLB  1
42A4:  MOVF   01,W
42A6:  MOVWF  01
42A8:  BZ    42B2
42AA:  MOVFF  FE6,FEE
42AE:  DECFSZ 01,F
42B0:  BRA    42AA
....................        lcd_gotoxy(10,1); 
42B2:  MOVLW  0A
42B4:  MOVLB  1
42B6:  MOVWF  x1F
42B8:  MOVLW  01
42BA:  MOVWF  x20
42BC:  MOVLB  0
42BE:  CALL   0D3E
....................       lcd_put_str(tmp_str,strlen(tmp_str));          
42C2:  MOVLB  1
42C4:  CLRF   x18
42C6:  MOVLW  2C
42C8:  MOVWF  x17
42CA:  MOVLB  0
42CC:  CALL   16F2
42D0:  MOVFF  01,107
42D4:  MOVLB  1
42D6:  CLRF   x17
42D8:  MOVLW  2C
42DA:  MOVWF  x16
42DC:  MOVFF  01,118
42E0:  MOVLB  0
42E2:  CALL   172C
....................  
....................       return sun_angle; 
42E6:  MOVLB  1
42E8:  MOVFF  106,01
....................  
.................... } 
42EC:  MOVLB  0
42EE:  GOTO   669C (RETURN)
....................  
.................... unsigned int8 get_backtrack_angle(unsigned int8 alpha) { 
....................  
....................    float tan_alpha,ll,dd; 
....................    float beta; 
....................    ll = PANEL_WIDTH; 
*
5EA6:  MOVLB  1
5EA8:  CLRF   x0F
5EAA:  CLRF   x0E
5EAC:  MOVLW  20
5EAE:  MOVWF  x0D
5EB0:  MOVLW  86
5EB2:  MOVWF  x0C
....................    dd = ROW_SPACING; 
5EB4:  CLRF   x13
5EB6:  CLRF   x12
5EB8:  MOVLW  20
5EBA:  MOVWF  x11
5EBC:  MOVLW  87
5EBE:  MOVWF  x10
....................    tan_alpha = tan( (float) (alpha) *PI/180.0); 
5EC0:  CLRF   x63
5EC2:  MOVFF  107,162
5EC6:  MOVLB  0
5EC8:  CALL   4896
5ECC:  MOVFF  00,118
5ED0:  MOVFF  01,119
5ED4:  MOVFF  02,11A
5ED8:  MOVFF  03,11B
5EDC:  MOVFF  03,165
5EE0:  MOVFF  02,164
5EE4:  MOVFF  01,163
5EE8:  MOVFF  00,162
5EEC:  MOVLW  DB
5EEE:  MOVLB  1
5EF0:  MOVWF  x69
5EF2:  MOVLW  0F
5EF4:  MOVWF  x68
5EF6:  MOVLW  49
5EF8:  MOVWF  x67
5EFA:  MOVLW  80
5EFC:  MOVWF  x66
5EFE:  MOVLB  0
5F00:  CALL   0ECE
5F04:  MOVFF  00,11C
5F08:  MOVFF  01,11D
5F0C:  MOVFF  02,11E
5F10:  MOVFF  03,11F
5F14:  MOVFF  03,161
5F18:  MOVFF  02,160
5F1C:  MOVFF  01,15F
5F20:  MOVFF  00,15E
5F24:  MOVLB  1
5F26:  CLRF   x65
5F28:  CLRF   x64
5F2A:  MOVLW  34
5F2C:  MOVWF  x63
5F2E:  MOVLW  86
5F30:  MOVWF  x62
5F32:  MOVLB  0
5F34:  CALL   0FC4
5F38:  MOVFF  00,120
5F3C:  MOVFF  01,121
5F40:  MOVFF  02,122
5F44:  MOVFF  03,123
5F48:  MOVFF  03,127
5F4C:  MOVFF  02,126
5F50:  MOVFF  01,125
5F54:  MOVFF  00,124
5F58:  CALL   4CDE
5F5C:  MOVFF  03,10B
5F60:  MOVFF  02,10A
5F64:  MOVFF  01,109
5F68:  MOVFF  00,108
....................  
....................    beta = acos(-1*dd/(ll*sqrt(1.0+tan_alpha*tan_alpha))) -atan(-1.0*tan_alpha); 
5F6C:  MOVLB  1
5F6E:  CLRF   x65
5F70:  CLRF   x64
5F72:  MOVLW  80
5F74:  MOVWF  x63
5F76:  MOVLW  7F
5F78:  MOVWF  x62
5F7A:  MOVFF  113,169
5F7E:  MOVFF  112,168
5F82:  MOVFF  111,167
5F86:  MOVFF  110,166
5F8A:  MOVLB  0
5F8C:  CALL   0ECE
5F90:  MOVFF  00,118
5F94:  MOVFF  01,119
5F98:  MOVFF  02,11A
5F9C:  MOVFF  03,11B
5FA0:  MOVFF  10B,165
5FA4:  MOVFF  10A,164
5FA8:  MOVFF  109,163
5FAC:  MOVFF  108,162
5FB0:  MOVFF  10B,169
5FB4:  MOVFF  10A,168
5FB8:  MOVFF  109,167
5FBC:  MOVFF  108,166
5FC0:  CALL   0ECE
5FC4:  BCF    FD8.1
5FC6:  MOVLB  1
5FC8:  CLRF   x67
5FCA:  CLRF   x66
5FCC:  CLRF   x65
5FCE:  MOVLW  7F
5FD0:  MOVWF  x64
5FD2:  MOVFF  03,16B
5FD6:  MOVFF  02,16A
5FDA:  MOVFF  01,169
5FDE:  MOVFF  00,168
5FE2:  MOVLB  0
5FE4:  CALL   1122
5FE8:  MOVFF  00,11C
5FEC:  MOVFF  01,11D
5FF0:  MOVFF  02,11E
5FF4:  MOVFF  03,11F
5FF8:  MOVFF  03,14A
5FFC:  MOVFF  02,149
6000:  MOVFF  01,148
6004:  MOVFF  00,147
6008:  CALL   4D7C
600C:  MOVFF  10F,165
6010:  MOVFF  10E,164
6014:  MOVFF  10D,163
6018:  MOVFF  10C,162
601C:  MOVFF  03,169
6020:  MOVFF  02,168
6024:  MOVFF  01,167
6028:  MOVFF  00,166
602C:  CALL   0ECE
6030:  MOVFF  11B,161
6034:  MOVFF  11A,160
6038:  MOVFF  119,15F
603C:  MOVFF  118,15E
6040:  MOVFF  03,165
6044:  MOVFF  02,164
6048:  MOVFF  01,163
604C:  MOVFF  00,162
6050:  CALL   0FC4
6054:  MOVFF  00,11D
6058:  MOVFF  01,11E
605C:  MOVFF  02,11F
6060:  MOVFF  03,120
6064:  MOVFF  03,124
6068:  MOVFF  02,123
606C:  MOVFF  01,122
6070:  MOVFF  00,121
6074:  BRA    594E
6076:  MOVFF  00,11E
607A:  MOVFF  01,11F
607E:  MOVFF  02,120
6082:  MOVFF  03,121
6086:  MOVLB  1
6088:  CLRF   x65
608A:  CLRF   x64
608C:  MOVLW  80
608E:  MOVWF  x63
6090:  MOVLW  7F
6092:  MOVWF  x62
6094:  MOVFF  10B,169
6098:  MOVFF  10A,168
609C:  MOVFF  109,167
60A0:  MOVFF  108,166
60A4:  MOVLB  0
60A6:  CALL   0ECE
60AA:  MOVFF  00,122
60AE:  MOVFF  01,123
60B2:  MOVFF  02,124
60B6:  MOVFF  03,125
60BA:  MOVFF  03,129
60BE:  MOVFF  02,128
60C2:  MOVFF  01,127
60C6:  MOVFF  00,126
60CA:  CALL   436C
60CE:  MOVFF  FEA,124
60D2:  MOVFF  FE9,123
60D6:  BSF    FD8.1
60D8:  MOVFF  121,167
60DC:  MOVFF  120,166
60E0:  MOVFF  11F,165
60E4:  MOVFF  11E,164
60E8:  MOVFF  03,16B
60EC:  MOVFF  02,16A
60F0:  MOVFF  01,169
60F4:  MOVFF  00,168
60F8:  CALL   1122
60FC:  MOVFF  124,FEA
6100:  MOVFF  123,FE9
6104:  MOVFF  03,117
6108:  MOVFF  02,116
610C:  MOVFF  01,115
6110:  MOVFF  00,114
....................    return fmod(beta,PI)*180.0/PI; 
6114:  MOVFF  117,11B
6118:  MOVFF  116,11A
611C:  MOVFF  115,119
6120:  MOVFF  114,118
6124:  MOVLW  DB
6126:  MOVLB  1
6128:  MOVWF  x1F
612A:  MOVLW  0F
612C:  MOVWF  x1E
612E:  MOVLW  49
6130:  MOVWF  x1D
6132:  MOVLW  80
6134:  MOVWF  x1C
6136:  MOVLB  0
6138:  BRA    5D3C
613A:  MOVFF  00,118
613E:  MOVFF  01,119
6142:  MOVFF  02,11A
6146:  MOVFF  03,11B
614A:  MOVFF  03,165
614E:  MOVFF  02,164
6152:  MOVFF  01,163
6156:  MOVFF  00,162
615A:  MOVLB  1
615C:  CLRF   x69
615E:  CLRF   x68
6160:  MOVLW  34
6162:  MOVWF  x67
6164:  MOVLW  86
6166:  MOVWF  x66
6168:  MOVLB  0
616A:  CALL   0ECE
616E:  MOVFF  00,11C
6172:  MOVFF  01,11D
6176:  MOVFF  02,11E
617A:  MOVFF  03,11F
617E:  MOVFF  03,161
6182:  MOVFF  02,160
6186:  MOVFF  01,15F
618A:  MOVFF  00,15E
618E:  MOVLW  DB
6190:  MOVLB  1
6192:  MOVWF  x65
6194:  MOVLW  0F
6196:  MOVWF  x64
6198:  MOVLW  49
619A:  MOVWF  x63
619C:  MOVLW  80
619E:  MOVWF  x62
61A0:  MOVLB  0
61A2:  CALL   0FC4
61A6:  MOVFF  03,161
61AA:  MOVFF  02,160
61AE:  MOVFF  01,15F
61B2:  MOVFF  00,15E
61B6:  CALL   48CC
61BA:  MOVF   01,W
.................... } 
61BC:  RETLW  00
....................  
....................  
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       set_timer1(get_timer1()+0x8000); 
*
03C0:  MOVF   FCE,W
03C2:  MOVFF  FCF,03
03C6:  MOVLB  1
03C8:  MOVWF  x74
03CA:  MOVFF  FCF,175
03CE:  MOVLW  80
03D0:  ADDWF  FCF,W
03D2:  MOVWF  FCF
03D4:  MOVFF  174,FCE
....................       timer_sec+=1;  
03D8:  MOVLW  01
03DA:  ADDWF  20,F
03DC:  MOVLW  00
03DE:  ADDWFC 21,F
03E0:  ADDWFC 22,F
03E2:  ADDWFC 23,F
....................       flag.update_time = true; 
03E4:  BSF    1F.1
....................       restart_wdt(); 
03E6:  CLRWDT
....................       if ((timer_sec%15) ==0) 
03E8:  MOVFF  23,124
03EC:  MOVFF  22,123
03F0:  MOVFF  21,122
03F4:  MOVFF  20,121
03F8:  CLRF   x28
03FA:  CLRF   x27
03FC:  CLRF   x26
03FE:  MOVLW  0F
0400:  MOVWF  x25
0402:  MOVLB  0
0404:  RCALL  0340
0406:  MOVFF  FEF,174
040A:  MOVFF  FEC,175
040E:  MOVFF  FEC,176
0412:  MOVFF  FEC,177
0416:  MOVLB  1
0418:  MOVF   x74,F
041A:  BNZ   042A
041C:  MOVF   x75,F
041E:  BNZ   042A
0420:  MOVF   x76,F
0422:  BNZ   042A
0424:  MOVF   x77,F
0426:  BNZ   042A
....................          flag.measured_current=true; 
0428:  BSF    1F.7
....................       if ((timer_sec%450) ==0) 
042A:  MOVFF  23,124
042E:  MOVFF  22,123
0432:  MOVFF  21,122
0436:  MOVFF  20,121
043A:  CLRF   x28
043C:  CLRF   x27
043E:  MOVLW  01
0440:  MOVWF  x26
0442:  MOVLW  C2
0444:  MOVWF  x25
0446:  MOVLB  0
0448:  RCALL  0340
044A:  MOVFF  FEF,174
044E:  MOVFF  FEC,175
0452:  MOVFF  FEC,176
0456:  MOVFF  FEC,177
045A:  MOVLB  1
045C:  MOVF   x74,F
045E:  BNZ   046E
0460:  MOVF   x75,F
0462:  BNZ   046E
0464:  MOVF   x76,F
0466:  BNZ   046E
0468:  MOVF   x77,F
046A:  BNZ   046E
....................          flag.task1_armed=true; 
046C:  BSF    1F.0
....................       if (timer_sec%300==30) flag.reset_rs232=true; 
046E:  MOVFF  23,124
0472:  MOVFF  22,123
0476:  MOVFF  21,122
047A:  MOVFF  20,121
047E:  CLRF   x28
0480:  CLRF   x27
0482:  MOVLW  01
0484:  MOVWF  x26
0486:  MOVLW  2C
0488:  MOVWF  x25
048A:  MOVLB  0
048C:  RCALL  0340
048E:  MOVFF  FEF,174
0492:  MOVFF  FEC,175
0496:  MOVFF  FEC,176
049A:  MOVFF  FEC,177
049E:  MOVLB  1
04A0:  MOVF   x74,W
04A2:  SUBLW  1E
04A4:  BNZ   04B4
04A6:  MOVF   x75,F
04A8:  BNZ   04B4
04AA:  MOVF   x76,F
04AC:  BNZ   04B4
04AE:  MOVF   x77,F
04B0:  BTFSC  FD8.2
04B2:  BSF    1F.5
....................       if (tx_delay>0) tx_delay--; 
04B4:  MOVLB  0
04B6:  MOVF   xC2,F
04B8:  BTFSS  FD8.2
04BA:  DECF   xC2,F
.................... //       
.................... } 
....................  
....................  
04BC:  BCF    F9E.0
04BE:  GOTO   0064
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................     c=getc(); 
*
04EC:  BTFSS  F9E.5
04EE:  BRA    04EC
04F0:  MOVFF  FAE,174
04F4:  MOVLB  1
....................     PORTE.tx_en=1; 
04F6:  BSF    F84.2
....................    delay_ms(2); 
04F8:  MOVLW  02
04FA:  MOVWF  x20
04FC:  MOVLB  0
04FE:  RCALL  04C2
....................      if(c==8) {  // Backspace 
0500:  MOVLB  1
0502:  MOVF   x74,W
0504:  SUBLW  08
0506:  BNZ   0530
....................         if(cmd_len>0) { 
0508:  MOVLB  0
050A:  MOVF   x68,F
050C:  BZ    052C
....................           cmd_len--; 
050E:  DECF   x68,F
....................           printf("%c",c); 
0510:  MOVLB  1
0512:  MOVF   x74,W
0514:  BTFSS  F9E.4
0516:  BRA    0514
0518:  MOVWF  FAD
....................           printf(" "); 
051A:  MOVLW  20
051C:  BTFSS  F9E.4
051E:  BRA    051C
0520:  MOVWF  FAD
....................           printf("%c",c); 
0522:  MOVF   x74,W
0524:  BTFSS  F9E.4
0526:  BRA    0524
0528:  MOVWF  FAD
052A:  MOVLB  0
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
052C:  BRA    0562
052E:  MOVLB  1
0530:  MOVF   x74,W
0532:  SUBLW  1F
0534:  BC    0562
0536:  MOVF   x74,W
0538:  SUBLW  7E
053A:  BNC   0562
....................        if(cmd_len<=MAX_CMD_LEN) { 
053C:  MOVLB  0
053E:  MOVF   x68,W
0540:  SUBLW  12
0542:  BNC   0562
....................          cmd_msg[cmd_len++]=c; 
0544:  MOVF   x68,W
0546:  INCF   x68,F
0548:  CLRF   03
054A:  ADDLW  54
054C:  MOVWF  FE9
054E:  MOVLW  00
0550:  ADDWFC 03,W
0552:  MOVWF  FEA
0554:  MOVFF  174,FEF
....................          printf("%c",c); 
0558:  MOVLB  1
055A:  MOVF   x74,W
055C:  BTFSS  F9E.4
055E:  BRA    055C
0560:  MOVWF  FAD
....................        }  
....................     if (c==13) {  
0562:  MOVLB  1
0564:  MOVF   x74,W
0566:  SUBLW  0D
0568:  BNZ   059E
....................    printf("\r\n>"); 
056A:  MOVLW  0D
056C:  BTFSS  F9E.4
056E:  BRA    056C
0570:  MOVWF  FAD
0572:  MOVLW  0A
0574:  BTFSS  F9E.4
0576:  BRA    0574
0578:  MOVWF  FAD
057A:  MOVLW  3E
057C:  BTFSS  F9E.4
057E:  BRA    057C
0580:  MOVWF  FAD
....................     //PORTE.tx_en=0; 
....................    cmd_msg[cmd_len]=0; 
0582:  CLRF   03
0584:  MOVLB  0
0586:  MOVF   x68,W
0588:  ADDLW  54
058A:  MOVWF  FE9
058C:  MOVLW  00
058E:  ADDWFC 03,W
0590:  MOVWF  FEA
0592:  CLRF   FEF
....................    if(cmd_len>1)flag.cmd_posted=true; 
0594:  MOVF   x68,W
0596:  SUBLW  01
0598:  BTFSS  FD8.0
059A:  BSF    1F.3
....................    cmd_len =0; 
059C:  CLRF   x68
....................   } 
....................    tx_delay=TX_DLY_TIME; 
059E:  MOVLW  01
05A0:  MOVLB  0
05A2:  MOVWF  xC2
....................  
.................... } 
....................  
05A4:  BCF    F9E.5
05A6:  GOTO   0064
.................... void actuator_length(int8 sun_angle) { 
.................... // return actuator length in cm at given sun_angle 
.................... //if (sun_angle < 30) return; 
.................... //if (sun_angle > 150) return; 
.................... len_a = DIM_A; 
*
4EA6:  CLRF   xCE
4EA8:  CLRF   xCD
4EAA:  MOVLW  57
4EAC:  MOVWF  xCC
4EAE:  MOVLW  85
4EB0:  MOVWF  xCB
.................... len_b = DIM_B; 
4EB2:  MOVLW  CD
4EB4:  MOVWF  xD2
4EB6:  MOVLW  CC
4EB8:  MOVWF  xD1
4EBA:  MOVLW  7C
4EBC:  MOVWF  xD0
4EBE:  MOVLW  82
4EC0:  MOVWF  xCF
.................... len_p = DIM_P; 
4EC2:  MOVLW  CD
4EC4:  MOVWF  xDA
4EC6:  MOVLW  CC
4EC8:  MOVWF  xD9
4ECA:  MOVLW  14
4ECC:  MOVWF  xD8
4ECE:  MOVLW  82
4ED0:  MOVWF  xD7
.................... len_k = DIM_K; 
4ED2:  CLRF   xE2
4ED4:  CLRF   xE1
4ED6:  MOVLW  10
4ED8:  MOVWF  xE0
4EDA:  MOVLW  84
4EDC:  MOVWF  xDF
.................... len_m = DIM_M; 
4EDE:  CLRF   xDE
4EE0:  CLRF   xDD
4EE2:  MOVLW  30
4EE4:  MOVWF  xDC
4EE6:  MOVLW  81
4EE8:  MOVWF  xDB
.................... len_p = DIM_P; 
4EEA:  MOVLW  CD
4EEC:  MOVWF  xDA
4EEE:  MOVLW  CC
4EF0:  MOVWF  xD9
4EF2:  MOVLW  14
4EF4:  MOVWF  xD8
4EF6:  MOVLW  82
4EF8:  MOVWF  xD7
.................... alpha = atan(len_b/len_k); 
4EFA:  MOVFF  D2,161
4EFE:  MOVFF  D1,160
4F02:  MOVFF  D0,15F
4F06:  MOVFF  CF,15E
4F0A:  MOVFF  E2,165
4F0E:  MOVFF  E1,164
4F12:  MOVFF  E0,163
4F16:  MOVFF  DF,162
4F1A:  CALL   0FC4
4F1E:  MOVFF  00,109
4F22:  MOVFF  01,10A
4F26:  MOVFF  02,10B
4F2A:  MOVFF  03,10C
4F2E:  MOVFF  03,129
4F32:  MOVFF  02,128
4F36:  MOVFF  01,127
4F3A:  MOVFF  00,126
4F3E:  CALL   436C
4F42:  MOVFF  03,FA
4F46:  MOVFF  02,F9
4F4A:  MOVFF  01,F8
4F4E:  MOVFF  00,F7
.................... sin_beta = sin((sun_angle*PI/180.0)-alpha); 
4F52:  MOVLB  1
4F54:  CLRF   x63
4F56:  MOVFF  108,162
4F5A:  MOVLB  0
4F5C:  RCALL  4896
4F5E:  MOVFF  03,165
4F62:  MOVFF  02,164
4F66:  MOVFF  01,163
4F6A:  MOVFF  00,162
4F6E:  MOVLW  DB
4F70:  MOVLB  1
4F72:  MOVWF  x69
4F74:  MOVLW  0F
4F76:  MOVWF  x68
4F78:  MOVLW  49
4F7A:  MOVWF  x67
4F7C:  MOVLW  80
4F7E:  MOVWF  x66
4F80:  MOVLB  0
4F82:  CALL   0ECE
4F86:  MOVFF  00,109
4F8A:  MOVFF  01,10A
4F8E:  MOVFF  02,10B
4F92:  MOVFF  03,10C
4F96:  MOVFF  03,161
4F9A:  MOVFF  02,160
4F9E:  MOVFF  01,15F
4FA2:  MOVFF  00,15E
4FA6:  MOVLB  1
4FA8:  CLRF   x65
4FAA:  CLRF   x64
4FAC:  MOVLW  34
4FAE:  MOVWF  x63
4FB0:  MOVLW  86
4FB2:  MOVWF  x62
4FB4:  MOVLB  0
4FB6:  CALL   0FC4
4FBA:  MOVFF  00,10D
4FBE:  MOVFF  01,10E
4FC2:  MOVFF  02,10F
4FC6:  MOVFF  03,110
4FCA:  BSF    FD8.1
4FCC:  MOVFF  03,167
4FD0:  MOVFF  02,166
4FD4:  MOVFF  01,165
4FD8:  MOVFF  00,164
4FDC:  MOVFF  FA,16B
4FE0:  MOVFF  F9,16A
4FE4:  MOVFF  F8,169
4FE8:  MOVFF  F7,168
4FEC:  CALL   1122
4FF0:  MOVFF  00,111
4FF4:  MOVFF  01,112
4FF8:  MOVFF  02,113
4FFC:  MOVFF  03,114
5000:  MOVFF  03,133
5004:  MOVFF  02,132
5008:  MOVFF  01,131
500C:  MOVFF  00,130
5010:  RCALL  4C90
5012:  MOVFF  03,EA
5016:  MOVFF  02,E9
501A:  MOVFF  01,E8
501E:  MOVFF  00,E7
.................... cos_beta = cos((sun_angle*PI/180.0)-alpha); 
5022:  MOVLB  1
5024:  CLRF   x63
5026:  MOVFF  108,162
502A:  MOVLB  0
502C:  RCALL  4896
502E:  MOVFF  03,165
5032:  MOVFF  02,164
5036:  MOVFF  01,163
503A:  MOVFF  00,162
503E:  MOVLW  DB
5040:  MOVLB  1
5042:  MOVWF  x69
5044:  MOVLW  0F
5046:  MOVWF  x68
5048:  MOVLW  49
504A:  MOVWF  x67
504C:  MOVLW  80
504E:  MOVWF  x66
5050:  MOVLB  0
5052:  CALL   0ECE
5056:  MOVFF  00,109
505A:  MOVFF  01,10A
505E:  MOVFF  02,10B
5062:  MOVFF  03,10C
5066:  MOVFF  03,161
506A:  MOVFF  02,160
506E:  MOVFF  01,15F
5072:  MOVFF  00,15E
5076:  MOVLB  1
5078:  CLRF   x65
507A:  CLRF   x64
507C:  MOVLW  34
507E:  MOVWF  x63
5080:  MOVLW  86
5082:  MOVWF  x62
5084:  MOVLB  0
5086:  CALL   0FC4
508A:  MOVFF  00,10D
508E:  MOVFF  01,10E
5092:  MOVFF  02,10F
5096:  MOVFF  03,110
509A:  BSF    FD8.1
509C:  MOVFF  03,167
50A0:  MOVFF  02,166
50A4:  MOVFF  01,165
50A8:  MOVFF  00,164
50AC:  MOVFF  FA,16B
50B0:  MOVFF  F9,16A
50B4:  MOVFF  F8,169
50B8:  MOVFF  F7,168
50BC:  CALL   1122
50C0:  MOVFF  00,111
50C4:  MOVFF  01,112
50C8:  MOVFF  02,113
50CC:  MOVFF  03,114
50D0:  MOVFF  03,13B
50D4:  MOVFF  02,13A
50D8:  MOVFF  01,139
50DC:  MOVFF  00,138
50E0:  RCALL  4908
50E2:  MOVFF  03,EE
50E6:  MOVFF  02,ED
50EA:  MOVFF  01,EC
50EE:  MOVFF  00,EB
.................... tan_beta = tan((sun_angle*PI/180.0)-alpha); 
50F2:  MOVLB  1
50F4:  CLRF   x63
50F6:  MOVFF  108,162
50FA:  MOVLB  0
50FC:  CALL   4896
5100:  MOVFF  03,165
5104:  MOVFF  02,164
5108:  MOVFF  01,163
510C:  MOVFF  00,162
5110:  MOVLW  DB
5112:  MOVLB  1
5114:  MOVWF  x69
5116:  MOVLW  0F
5118:  MOVWF  x68
511A:  MOVLW  49
511C:  MOVWF  x67
511E:  MOVLW  80
5120:  MOVWF  x66
5122:  MOVLB  0
5124:  CALL   0ECE
5128:  MOVFF  00,109
512C:  MOVFF  01,10A
5130:  MOVFF  02,10B
5134:  MOVFF  03,10C
5138:  MOVFF  03,161
513C:  MOVFF  02,160
5140:  MOVFF  01,15F
5144:  MOVFF  00,15E
5148:  MOVLB  1
514A:  CLRF   x65
514C:  CLRF   x64
514E:  MOVLW  34
5150:  MOVWF  x63
5152:  MOVLW  86
5154:  MOVWF  x62
5156:  MOVLB  0
5158:  CALL   0FC4
515C:  MOVFF  00,10D
5160:  MOVFF  01,10E
5164:  MOVFF  02,10F
5168:  MOVFF  03,110
516C:  BSF    FD8.1
516E:  MOVFF  03,167
5172:  MOVFF  02,166
5176:  MOVFF  01,165
517A:  MOVFF  00,164
517E:  MOVFF  FA,16B
5182:  MOVFF  F9,16A
5186:  MOVFF  F8,169
518A:  MOVFF  F7,168
518E:  CALL   1122
5192:  MOVFF  00,111
5196:  MOVFF  01,112
519A:  MOVFF  02,113
519E:  MOVFF  03,114
51A2:  MOVFF  03,127
51A6:  MOVFF  02,126
51AA:  MOVFF  01,125
51AE:  MOVFF  00,124
51B2:  RCALL  4CDE
51B4:  MOVFF  03,F2
51B8:  MOVFF  02,F1
51BC:  MOVFF  01,F0
51C0:  MOVFF  00,EF
....................  
....................  
.................... len_c = sqrt(len_k*len_k+len_b*len_b)-len_p/sin_beta; 
51C4:  MOVFF  E2,165
51C8:  MOVFF  E1,164
51CC:  MOVFF  E0,163
51D0:  MOVFF  DF,162
51D4:  MOVFF  E2,169
51D8:  MOVFF  E1,168
51DC:  MOVFF  E0,167
51E0:  MOVFF  DF,166
51E4:  CALL   0ECE
51E8:  MOVFF  00,109
51EC:  MOVFF  01,10A
51F0:  MOVFF  02,10B
51F4:  MOVFF  03,10C
51F8:  MOVFF  D2,165
51FC:  MOVFF  D1,164
5200:  MOVFF  D0,163
5204:  MOVFF  CF,162
5208:  MOVFF  D2,169
520C:  MOVFF  D1,168
5210:  MOVFF  D0,167
5214:  MOVFF  CF,166
5218:  CALL   0ECE
521C:  BCF    FD8.1
521E:  MOVFF  10C,167
5222:  MOVFF  10B,166
5226:  MOVFF  10A,165
522A:  MOVFF  109,164
522E:  MOVFF  03,16B
5232:  MOVFF  02,16A
5236:  MOVFF  01,169
523A:  MOVFF  00,168
523E:  CALL   1122
5242:  MOVFF  00,10D
5246:  MOVFF  01,10E
524A:  MOVFF  02,10F
524E:  MOVFF  03,110
5252:  MOVFF  03,14A
5256:  MOVFF  02,149
525A:  MOVFF  01,148
525E:  MOVFF  00,147
5262:  RCALL  4D7C
5264:  MOVFF  00,10E
5268:  MOVFF  01,10F
526C:  MOVFF  02,110
5270:  MOVFF  03,111
5274:  MOVFF  DA,161
5278:  MOVFF  D9,160
527C:  MOVFF  D8,15F
5280:  MOVFF  D7,15E
5284:  MOVFF  EA,165
5288:  MOVFF  E9,164
528C:  MOVFF  E8,163
5290:  MOVFF  E7,162
5294:  CALL   0FC4
5298:  MOVFF  FEA,113
529C:  MOVFF  FE9,112
52A0:  BSF    FD8.1
52A2:  MOVFF  111,167
52A6:  MOVFF  110,166
52AA:  MOVFF  10F,165
52AE:  MOVFF  10E,164
52B2:  MOVFF  03,16B
52B6:  MOVFF  02,16A
52BA:  MOVFF  01,169
52BE:  MOVFF  00,168
52C2:  CALL   1122
52C6:  MOVFF  113,FEA
52CA:  MOVFF  112,FE9
52CE:  MOVFF  03,D6
52D2:  MOVFF  02,D5
52D6:  MOVFF  01,D4
52DA:  MOVFF  00,D3
.................... temp1 = len_a - (len_p/tan_beta)-len_c*cos_beta; 
52DE:  MOVFF  DA,161
52E2:  MOVFF  D9,160
52E6:  MOVFF  D8,15F
52EA:  MOVFF  D7,15E
52EE:  MOVFF  F2,165
52F2:  MOVFF  F1,164
52F6:  MOVFF  F0,163
52FA:  MOVFF  EF,162
52FE:  CALL   0FC4
5302:  BSF    FD8.1
5304:  MOVFF  CE,167
5308:  MOVFF  CD,166
530C:  MOVFF  CC,165
5310:  MOVFF  CB,164
5314:  MOVFF  03,16B
5318:  MOVFF  02,16A
531C:  MOVFF  01,169
5320:  MOVFF  00,168
5324:  CALL   1122
5328:  MOVFF  00,109
532C:  MOVFF  01,10A
5330:  MOVFF  02,10B
5334:  MOVFF  03,10C
5338:  MOVFF  D6,165
533C:  MOVFF  D5,164
5340:  MOVFF  D4,163
5344:  MOVFF  D3,162
5348:  MOVFF  EE,169
534C:  MOVFF  ED,168
5350:  MOVFF  EC,167
5354:  MOVFF  EB,166
5358:  CALL   0ECE
535C:  BSF    FD8.1
535E:  MOVFF  10C,167
5362:  MOVFF  10B,166
5366:  MOVFF  10A,165
536A:  MOVFF  109,164
536E:  MOVFF  03,16B
5372:  MOVFF  02,16A
5376:  MOVFF  01,169
537A:  MOVFF  00,168
537E:  CALL   1122
5382:  MOVFF  03,F6
5386:  MOVFF  02,F5
538A:  MOVFF  01,F4
538E:  MOVFF  00,F3
.................... len_l = len_c*sin_beta*len_c*sin_beta+temp1*temp1-len_m*len_m; 
5392:  MOVFF  D6,165
5396:  MOVFF  D5,164
539A:  MOVFF  D4,163
539E:  MOVFF  D3,162
53A2:  MOVFF  EA,169
53A6:  MOVFF  E9,168
53AA:  MOVFF  E8,167
53AE:  MOVFF  E7,166
53B2:  CALL   0ECE
53B6:  MOVFF  00,109
53BA:  MOVFF  01,10A
53BE:  MOVFF  02,10B
53C2:  MOVFF  03,10C
53C6:  MOVFF  03,165
53CA:  MOVFF  02,164
53CE:  MOVFF  01,163
53D2:  MOVFF  00,162
53D6:  MOVFF  D6,169
53DA:  MOVFF  D5,168
53DE:  MOVFF  D4,167
53E2:  MOVFF  D3,166
53E6:  CALL   0ECE
53EA:  MOVFF  00,10D
53EE:  MOVFF  01,10E
53F2:  MOVFF  02,10F
53F6:  MOVFF  03,110
53FA:  MOVFF  03,165
53FE:  MOVFF  02,164
5402:  MOVFF  01,163
5406:  MOVFF  00,162
540A:  MOVFF  EA,169
540E:  MOVFF  E9,168
5412:  MOVFF  E8,167
5416:  MOVFF  E7,166
541A:  CALL   0ECE
541E:  MOVFF  00,111
5422:  MOVFF  01,112
5426:  MOVFF  02,113
542A:  MOVFF  03,114
542E:  MOVFF  F6,165
5432:  MOVFF  F5,164
5436:  MOVFF  F4,163
543A:  MOVFF  F3,162
543E:  MOVFF  F6,169
5442:  MOVFF  F5,168
5446:  MOVFF  F4,167
544A:  MOVFF  F3,166
544E:  CALL   0ECE
5452:  BCF    FD8.1
5454:  MOVFF  114,167
5458:  MOVFF  113,166
545C:  MOVFF  112,165
5460:  MOVFF  111,164
5464:  MOVFF  03,16B
5468:  MOVFF  02,16A
546C:  MOVFF  01,169
5470:  MOVFF  00,168
5474:  CALL   1122
5478:  MOVFF  00,115
547C:  MOVFF  01,116
5480:  MOVFF  02,117
5484:  MOVFF  03,118
5488:  MOVFF  DE,165
548C:  MOVFF  DD,164
5490:  MOVFF  DC,163
5494:  MOVFF  DB,162
5498:  MOVFF  DE,169
549C:  MOVFF  DD,168
54A0:  MOVFF  DC,167
54A4:  MOVFF  DB,166
54A8:  CALL   0ECE
54AC:  BSF    FD8.1
54AE:  MOVFF  118,167
54B2:  MOVFF  117,166
54B6:  MOVFF  116,165
54BA:  MOVFF  115,164
54BE:  MOVFF  03,16B
54C2:  MOVFF  02,16A
54C6:  MOVFF  01,169
54CA:  MOVFF  00,168
54CE:  CALL   1122
54D2:  MOVFF  03,E6
54D6:  MOVFF  02,E5
54DA:  MOVFF  01,E4
54DE:  MOVFF  00,E3
.................... len_l = sqrt(len_l); 
54E2:  MOVFF  E6,14A
54E6:  MOVFF  E5,149
54EA:  MOVFF  E4,148
54EE:  MOVFF  E3,147
54F2:  RCALL  4D7C
54F4:  MOVFF  03,E6
54F8:  MOVFF  02,E5
54FC:  MOVFF  01,E4
5500:  MOVFF  00,E3
....................  
.................... if (len_l<50.0) { 
5504:  MOVFF  E6,161
5508:  MOVFF  E5,160
550C:  MOVFF  E4,15F
5510:  MOVFF  E3,15E
5514:  MOVLB  1
5516:  CLRF   x65
5518:  CLRF   x64
551A:  MOVLW  48
551C:  MOVWF  x63
551E:  MOVLW  84
5520:  MOVWF  x62
5522:  MOVLB  0
5524:  CALL   42F2
5528:  BNC   5534
....................    act_len=0.0; 
552A:  CLRF   xFE
552C:  CLRF   xFD
552E:  CLRF   xFC
5530:  CLRF   xFB
....................    return; 
5532:  BRA    5544
.................... } 
....................  
.................... act_len= len_l; 
5534:  MOVFF  E6,FE
5538:  MOVFF  E5,FD
553C:  MOVFF  E4,FC
5540:  MOVFF  E3,FB
.................... } 
5544:  RETLW  00
....................  
.................... void process_cmd_msg(){ 
....................     flag.cmd_posted =false; 
*
32BE:  BCF    1F.3
....................    switch (cmd_msg[0]) { 
32C0:  MOVLW  63
32C2:  SUBWF  54,W
32C4:  ADDLW  E9
32C6:  BTFSC  FD8.0
32C8:  BRA    39B6
32CA:  ADDLW  17
32CC:  GOTO   39B8
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
32D0:  CLRF   FEA
32D2:  MOVLW  54
32D4:  MOVWF  FE9
32D6:  CLRF   FE2
32D8:  MOVLW  55
32DA:  MOVWF  FE1
32DC:  MOVLW  12
32DE:  MOVWF  01
32E0:  MOVFF  FE6,FEE
32E4:  DECFSZ 01,F
32E6:  BRA    32E0
....................            if (atol(cmd_msg)==0) break; 
32E8:  MOVLB  1
32EA:  CLRF   x07
32EC:  MOVLW  54
32EE:  MOVWF  x06
32F0:  MOVLB  0
32F2:  CALL   0B4E
32F6:  MOVFF  02,107
32FA:  MOVFF  01,106
32FE:  MOVLB  1
3300:  MOVF   x06,F
3302:  BNZ   330E
3304:  MOVF   x07,F
3306:  BNZ   330E
3308:  MOVLB  0
330A:  BRA    39B6
330C:  MOVLB  1
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
330E:  CLRF   x07
3310:  MOVLW  54
3312:  MOVWF  x06
3314:  MOVLB  0
3316:  CALL   0B4E
331A:  MOVFF  02,107
331E:  MOVFF  01,106
3322:  MOVFF  02,109
3326:  MOVFF  01,108
332A:  MOVLW  23
332C:  MOVLB  1
332E:  MOVWF  x0B
3330:  MOVLW  28
3332:  MOVWF  x0A
3334:  MOVFF  C1,10D
3338:  MOVFF  C0,10C
333C:  MOVLW  01
333E:  MOVWF  x0E
3340:  CLRF   x0F
3342:  MOVLB  0
3344:  CALL   23CE
....................          break;    } 
3348:  BRA    39B6
....................  
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
334A:  CLRF   FEA
334C:  MOVLW  54
334E:  MOVWF  FE9
3350:  CLRF   FE2
3352:  MOVLW  55
3354:  MOVWF  FE1
3356:  MOVLW  12
3358:  MOVWF  01
335A:  MOVFF  FE6,FEE
335E:  DECFSZ 01,F
3360:  BRA    335A
....................            if (atol(cmd_msg)==0) break; 
3362:  MOVLB  1
3364:  CLRF   x07
3366:  MOVLW  54
3368:  MOVWF  x06
336A:  MOVLB  0
336C:  CALL   0B4E
3370:  MOVFF  02,107
3374:  MOVFF  01,106
3378:  MOVLB  1
337A:  MOVF   x06,F
337C:  BNZ   3388
337E:  MOVF   x07,F
3380:  BNZ   3388
3382:  MOVLB  0
3384:  BRA    39B6
3386:  MOVLB  1
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
3388:  CLRF   x07
338A:  MOVLW  54
338C:  MOVWF  x06
338E:  MOVLB  0
3390:  CALL   0B4E
3394:  MOVFF  02,107
3398:  MOVFF  01,106
339C:  MOVFF  02,109
33A0:  MOVFF  01,108
33A4:  MOVLW  23
33A6:  MOVLB  1
33A8:  MOVWF  x0B
33AA:  MOVLW  28
33AC:  MOVWF  x0A
33AE:  MOVFF  C1,10D
33B2:  MOVFF  C0,10C
33B6:  CLRF   x0E
33B8:  CLRF   x0F
33BA:  MOVLB  0
33BC:  CALL   23CE
....................          break;    } 
33C0:  BRA    39B6
.................... /* 
....................       case 'x':{ 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................            if (atol(cmd_msg)==1) { 
....................             setup_timer_0(RTCC_DIV_32); 
....................             move_act_time_out =4; 
....................          } else if(atol(cmd_msg)==2) { 
....................             setup_timer_0(RTCC_DIV_1); 
....................             move_act_time_out =128; 
....................          } 
....................          break;    }    
.................... */    
....................       case 'd':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
33C2:  CLRF   FEA
33C4:  MOVLW  54
33C6:  MOVWF  FE9
33C8:  CLRF   FE2
33CA:  MOVLW  55
33CC:  MOVWF  FE1
33CE:  MOVLW  12
33D0:  MOVWF  01
33D2:  MOVFF  FE6,FEE
33D6:  DECFSZ 01,F
33D8:  BRA    33D2
....................            if (atol(cmd_msg)==0) break; 
33DA:  MOVLB  1
33DC:  CLRF   x07
33DE:  MOVLW  54
33E0:  MOVWF  x06
33E2:  MOVLB  0
33E4:  CALL   0B4E
33E8:  MOVFF  02,107
33EC:  MOVFF  01,106
33F0:  MOVLB  1
33F2:  MOVF   x06,F
33F4:  BNZ   3400
33F6:  MOVF   x07,F
33F8:  BNZ   3400
33FA:  MOVLB  0
33FC:  BRA    39B6
33FE:  MOVLB  1
....................          PORTE.tx_en=1; 
3400:  BSF    F84.2
....................          printf("\r\n DL %ld pages ..",atol(cmd_msg)); 
3402:  CLRF   x07
3404:  MOVLW  54
3406:  MOVWF  x06
3408:  MOVLB  0
340A:  CALL   0B4E
340E:  MOVFF  02,107
3412:  MOVFF  01,106
3416:  MOVLB  1
3418:  CLRF   x08
341A:  MOVF   x08,W
341C:  MOVLB  0
341E:  CALL   0170
3422:  MOVLB  1
3424:  INCF   x08,F
3426:  MOVWF  00
3428:  MOVF   00,W
342A:  BTFSS  F9E.4
342C:  BRA    342A
342E:  MOVWF  FAD
3430:  MOVLW  06
3432:  SUBWF  x08,W
3434:  BNZ   341A
3436:  MOVLW  10
3438:  MOVWF  FE9
343A:  MOVFF  107,10A
343E:  MOVFF  106,109
3442:  MOVLB  0
3444:  CALL   2648
3448:  MOVLW  09
344A:  MOVLB  1
344C:  MOVWF  x09
344E:  MOVF   x09,W
3450:  MOVLB  0
3452:  CALL   0170
3456:  MOVLB  1
3458:  INCF   x09,F
345A:  MOVWF  00
345C:  MOVF   00,W
345E:  BTFSS  F9E.4
3460:  BRA    345E
3462:  MOVWF  FAD
3464:  MOVLW  12
3466:  SUBWF  x09,W
3468:  BNZ   344E
....................          tx_delay=TX_DLY_TIME; 
346A:  MOVLW  01
346C:  MOVLB  0
346E:  MOVWF  xC2
....................            download_sun_table(atol(cmd_msg)); 
3470:  MOVLB  1
3472:  CLRF   x07
3474:  MOVLW  54
3476:  MOVWF  x06
3478:  MOVLB  0
347A:  CALL   0B4E
347E:  MOVFF  02,107
3482:  MOVFF  01,106
3486:  MOVFF  02,109
348A:  MOVFF  01,108
348E:  GOTO   28DA
....................          break;    } 
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
3492:  BCF    FF2.6
3494:  BCF    FF2.7
3496:  BTFSC  FF2.7
3498:  BRA    3494
....................          restart_wdt(); 
349A:  CLRWDT
....................          setup_wdt(WDT_OFF); 
349C:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
349E:  CLRF   FEA
34A0:  MOVLW  54
34A2:  MOVWF  FE9
34A4:  CLRF   FE2
34A6:  MOVLW  55
34A8:  MOVWF  FE1
34AA:  MOVLW  12
34AC:  MOVWF  01
34AE:  MOVFF  FE6,FEE
34B2:  DECFSZ 01,F
34B4:  BRA    34AE
....................          PORTE.tx_en=1; 
34B6:  BSF    F84.2
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
34B8:  MOVLB  1
34BA:  CLRF   x07
34BC:  MOVLW  54
34BE:  MOVWF  x06
34C0:  MOVLB  0
34C2:  CALL   0B4E
34C6:  MOVFF  02,107
34CA:  MOVFF  01,106
34CE:  MOVLB  1
34D0:  CLRF   x08
34D2:  MOVF   x08,W
34D4:  MOVLB  0
34D6:  CALL   019E
34DA:  MOVLB  1
34DC:  INCF   x08,F
34DE:  MOVWF  00
34E0:  MOVF   00,W
34E2:  BTFSS  F9E.4
34E4:  BRA    34E2
34E6:  MOVWF  FAD
34E8:  MOVLW  08
34EA:  SUBWF  x08,W
34EC:  BNZ   34D2
34EE:  MOVLW  10
34F0:  MOVWF  FE9
34F2:  MOVFF  107,10A
34F6:  MOVFF  106,109
34FA:  MOVLB  0
34FC:  CALL   2648
3500:  MOVLW  3A
3502:  BTFSS  F9E.4
3504:  BRA    3502
3506:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
3508:  MOVLW  01
350A:  MOVWF  xC2
....................          print_page_data(atol(cmd_msg)); 
350C:  MOVLB  1
350E:  CLRF   x07
3510:  MOVLW  54
3512:  MOVWF  x06
3514:  MOVLB  0
3516:  CALL   0B4E
351A:  MOVFF  02,107
351E:  MOVFF  01,106
3522:  MOVFF  02,109
3526:  MOVFF  01,108
352A:  GOTO   2AF6
....................          enable_interrupts(GLOBAL); 
352E:  MOVLW  C0
3530:  IORWF  FF2,F
....................          restart_wdt(); 
3532:  CLRWDT
....................          setup_wdt(WDT_ON); 
3534:  BSF    FD1.0
....................             break; } 
3536:  BRA    39B6
....................         case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3538:  CLRF   FEA
353A:  MOVLW  54
353C:  MOVWF  FE9
353E:  CLRF   FE2
3540:  MOVLW  55
3542:  MOVWF  FE1
3544:  MOVLW  12
3546:  MOVWF  01
3548:  MOVFF  FE6,FEE
354C:  DECFSZ 01,F
354E:  BRA    3548
....................             if (atol(cmd_msg)!=22) break; 
3550:  MOVLB  1
3552:  CLRF   x07
3554:  MOVLW  54
3556:  MOVWF  x06
3558:  MOVLB  0
355A:  CALL   0B4E
355E:  MOVFF  02,107
3562:  MOVFF  01,106
3566:  MOVLB  1
3568:  MOVF   01,W
356A:  SUBLW  16
356C:  BNZ   3572
356E:  MOVF   x07,F
3570:  BZ    3578
3572:  MOVLB  0
3574:  BRA    39B6
3576:  MOVLB  1
....................          PORTE.tx_en=1; 
3578:  BSF    F84.2
....................          printf("\r\ndeleting entire flash data "); 
357A:  CLRF   x06
357C:  MOVF   x06,W
357E:  MOVLB  0
3580:  CALL   01C6
3584:  MOVLB  1
3586:  INCF   x06,F
3588:  MOVWF  00
358A:  MOVF   00,W
358C:  BTFSS  F9E.4
358E:  BRA    358C
3590:  MOVWF  FAD
3592:  MOVLW  1D
3594:  SUBWF  x06,W
3596:  BNZ   357C
....................          tx_delay=TX_DLY_TIME; 
3598:  MOVLW  01
359A:  MOVLB  0
359C:  MOVWF  xC2
....................          ext_flash_block_erase(); 
359E:  GOTO   2BA2
....................             break; } 
....................       case 't': { // timer set 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
35A2:  CLRF   FEA
35A4:  MOVLW  54
35A6:  MOVWF  FE9
35A8:  CLRF   FE2
35AA:  MOVLW  55
35AC:  MOVWF  FE1
35AE:  MOVLW  12
35B0:  MOVWF  01
35B2:  MOVFF  FE6,FEE
35B6:  DECFSZ 01,F
35B8:  BRA    35B2
....................          timer_sec=atoi32(cmd_msg); 
35BA:  MOVLB  1
35BC:  CLRF   x07
35BE:  MOVLW  54
35C0:  MOVWF  x06
35C2:  MOVLB  0
35C4:  GOTO   2BFA
35C8:  MOVFF  03,23
35CC:  MOVFF  02,22
35D0:  MOVFF  01,21
35D4:  MOVFF  00,20
....................          lcd_send_cmd(0,0x02); 
35D8:  MOVLB  1
35DA:  CLRF   x23
35DC:  MOVLW  02
35DE:  MOVWF  x24
35E0:  MOVLB  0
35E2:  CALL   0A16
35E6:  CLRF   18
35E8:  BTFSC  FF2.7
35EA:  BSF    18.7
35EC:  BCF    FF2.7
....................          next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
35EE:  MOVFF  23,124
35F2:  MOVFF  22,123
35F6:  MOVFF  21,122
35FA:  MOVFF  20,121
35FE:  MOVLW  07
3600:  MOVLB  1
3602:  MOVWF  x28
3604:  MOVLW  86
3606:  MOVWF  x27
3608:  MOVLW  1F
360A:  MOVWF  x26
360C:  MOVLW  80
360E:  MOVWF  x25
3610:  MOVLB  0
3612:  CALL   0340
3616:  BTFSC  18.7
3618:  BSF    FF2.7
361A:  MOVFF  FEF,106
361E:  MOVFF  FEC,107
3622:  MOVFF  FEC,108
3626:  MOVFF  FEC,109
362A:  MOVFF  109,119
362E:  MOVFF  108,118
3632:  MOVFF  107,117
3636:  MOVFF  106,116
363A:  RCALL  2E9C
363C:  MOVFF  02,108
3640:  MOVFF  01,107
3644:  MOVFF  02,117
3648:  MOVFF  01,116
364C:  RCALL  2F3E
364E:  MOVFF  03,10B
3652:  MOVFF  02,10A
3656:  MOVFF  01,109
365A:  MOVFF  00,108
365E:  MOVFF  FEA,10D
3662:  MOVFF  FE9,10C
3666:  MOVFF  03,12D
366A:  MOVFF  02,12C
366E:  MOVFF  01,12B
3672:  MOVFF  00,12A
3676:  MOVLB  1
3678:  CLRF   x31
367A:  CLRF   x30
367C:  MOVLW  01
367E:  MOVWF  x2F
3680:  MOVLW  C2
3682:  MOVWF  x2E
3684:  MOVLB  0
3686:  CALL   13DE
368A:  MOVFF  10D,FEA
368E:  MOVFF  10C,FE9
3692:  MOVFF  03,6D
3696:  MOVFF  02,6C
369A:  MOVFF  01,6B
369E:  MOVFF  00,6A
....................          enable_interrupts(INT_TIMER1);    
36A2:  BSF    F9D.0
....................          enable_interrupts(GLOBAL);  
36A4:  MOVLW  C0
36A6:  IORWF  FF2,F
....................          flag.task1_armed=true; 
36A8:  BSF    1F.0
....................          write_eeprom_data(0); // save full_stroke_tick and current_position 
36AA:  MOVLB  1
36AC:  CLRF   x06
36AE:  MOVLB  0
36B0:  CALL   0858
....................          flag.setup_required =false; 
36B4:  BCF    1F.4
....................          break; 
36B6:  BRA    39B6
....................       } 
....................       case 'h' : { //return home 
....................          move_act(2000,9000,move_act_time_out,1,0); // move actuator to west 
36B8:  MOVLW  07
36BA:  MOVLB  1
36BC:  MOVWF  x09
36BE:  MOVLW  D0
36C0:  MOVWF  x08
36C2:  MOVLW  23
36C4:  MOVWF  x0B
36C6:  MOVLW  28
36C8:  MOVWF  x0A
36CA:  MOVFF  C1,10D
36CE:  MOVFF  C0,10C
36D2:  MOVLW  01
36D4:  MOVWF  x0E
36D6:  CLRF   x0F
36D8:  MOVLB  0
36DA:  CALL   23CE
....................          move_act(2000,9000,move_act_time_out,0,0); // move actuator to home position 
36DE:  MOVLW  07
36E0:  MOVLB  1
36E2:  MOVWF  x09
36E4:  MOVLW  D0
36E6:  MOVWF  x08
36E8:  MOVLW  23
36EA:  MOVWF  x0B
36EC:  MOVLW  28
36EE:  MOVWF  x0A
36F0:  MOVFF  C1,10D
36F4:  MOVFF  C0,10C
36F8:  CLRF   x0E
36FA:  CLRF   x0F
36FC:  MOVLB  0
36FE:  CALL   23CE
....................          FULL_STROKE_TICK= actuator_pulse; 
3702:  MOVFF  C9,BB
3706:  MOVFF  C8,BA
....................          current_act_position =0; 
370A:  CLRF   x6F
370C:  CLRF   x6E
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
370E:  MOVLW  01
3710:  MOVLB  1
3712:  MOVWF  x06
3714:  MOVLB  0
3716:  CALL   0858
....................          break; 
371A:  BRA    39B6
....................       } 
.................... /* 
....................       case 'g': { 
....................          print_date_time(); 
....................           break; 
....................       } 
....................       case 'a': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          PORTE.tx_en=1; 
....................          printf("\r\n   Sun angle %u, stroke length =%f",atoi(cmd_msg),actuator_length(atoi(cmd_msg))); 
....................          tx_delay=TX_DLY_TIME; 
....................          break; 
....................       } 
.................... */ 
....................       case 's': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
371C:  CLRF   FEA
371E:  MOVLW  54
3720:  MOVWF  FE9
3722:  CLRF   FE2
3724:  MOVLW  55
3726:  MOVWF  FE1
3728:  MOVLW  12
372A:  MOVWF  01
372C:  MOVFF  FE6,FEE
3730:  DECFSZ 01,F
3732:  BRA    372C
....................             if (atol(cmd_msg)!=22) break; 
3734:  MOVLB  1
3736:  CLRF   x07
3738:  MOVLW  54
373A:  MOVWF  x06
373C:  MOVLB  0
373E:  CALL   0B4E
3742:  MOVFF  02,107
3746:  MOVFF  01,106
374A:  MOVLB  1
374C:  MOVF   01,W
374E:  SUBLW  16
3750:  BNZ   3756
3752:  MOVF   x07,F
3754:  BZ    375C
3756:  MOVLB  0
3758:  BRA    39B6
375A:  MOVLB  1
....................          write_eeprom_data(1); 
375C:  MOVLW  01
375E:  MOVWF  x06
3760:  MOVLB  0
3762:  CALL   0858
....................          break; 
3766:  BRA    39B6
....................       } 
....................       case 'y': { //adc conversion 
....................          set_adc_channel( 0 ); 
3768:  MOVLW  00
376A:  MOVWF  01
376C:  MOVF   FC2,W
376E:  ANDLW  C7
3770:  IORWF  01,W
3772:  MOVWF  FC2
....................          delay_us(20); 
3774:  MOVLW  10
3776:  MOVWF  00
3778:  DECFSZ 00,F
377A:  BRA    3778
377C:  NOP   
....................          current_measured = (read_adc()); 
377E:  BSF    FC2.2
3780:  BTFSC  FC2.2
3782:  BRA    3780
3784:  MOVFF  FC3,C3
3788:  MOVFF  FC4,C4
....................          printf("\r\nADC= %lu",current_measured); 
378C:  MOVLB  1
378E:  CLRF   x06
3790:  MOVF   x06,W
3792:  MOVLB  0
3794:  CALL   01FE
3798:  MOVLB  1
379A:  INCF   x06,F
379C:  MOVWF  00
379E:  MOVF   00,W
37A0:  BTFSS  F9E.4
37A2:  BRA    37A0
37A4:  MOVWF  FAD
37A6:  MOVLW  07
37A8:  SUBWF  x06,W
37AA:  BNZ   3790
37AC:  MOVLW  10
37AE:  MOVWF  FE9
37B0:  MOVFF  C4,10B
37B4:  MOVFF  C3,10A
37B8:  MOVLB  0
37BA:  RCALL  2FD0
....................          break; 
37BC:  BRA    39B6
....................       } 
....................       case 'w': { //buffer1 read 
....................          //ext_flash_buffer1_write(0x00,0x00, 1); 
....................          //ext_flash_buffer1_read(); 
....................          //ext_flash_buffer1_write(0x12,0xAA, 0); 
....................          disable_interrupts(GLOBAL); 
37BE:  BCF    FF2.6
37C0:  BCF    FF2.7
37C2:  BTFSC  FF2.7
37C4:  BRA    37C0
....................          restart_wdt(); 
37C6:  CLRWDT
....................          setup_wdt(WDT_OFF); 
37C8:  BCF    FD1.0
....................          ext_flash_buffer1_read(); 
37CA:  BRA    307A
....................          enable_interrupts(GLOBAL); 
37CC:  MOVLW  C0
37CE:  IORWF  FF2,F
....................          restart_wdt(); 
37D0:  CLRWDT
....................          setup_wdt(WDT_ON); 
37D2:  BSF    FD1.0
....................  
....................          //ext_flash_write_buffer1_to_main_memory(1024); 
....................          break; 
37D4:  BRA    39B6
....................       } 
....................       case 'i': { //adc conversion 
....................          printf("\r\nAct:%lu/%lu",current_act_position,FULL_STROKE_TICK); 
37D6:  MOVLB  1
37D8:  CLRF   x06
37DA:  MOVF   x06,W
37DC:  MOVLB  0
37DE:  CALL   0224
37E2:  MOVLB  1
37E4:  INCF   x06,F
37E6:  MOVWF  00
37E8:  MOVF   00,W
37EA:  BTFSS  F9E.4
37EC:  BRA    37EA
37EE:  MOVWF  FAD
37F0:  MOVLW  06
37F2:  SUBWF  x06,W
37F4:  BNZ   37DA
37F6:  MOVLW  10
37F8:  MOVWF  FE9
37FA:  MOVFF  6F,10B
37FE:  MOVFF  6E,10A
3802:  MOVLB  0
3804:  CALL   2FD0
3808:  MOVLW  2F
380A:  BTFSS  F9E.4
380C:  BRA    380A
380E:  MOVWF  FAD
3810:  MOVLW  10
3812:  MOVWF  FE9
3814:  MOVFF  BB,10B
3818:  MOVFF  BA,10A
381C:  CALL   2FD0
....................          printf("\r\nRestart:%lu",startup_counter); 
3820:  MOVLB  1
3822:  CLRF   x06
3824:  MOVF   x06,W
3826:  MOVLB  0
3828:  CALL   024C
382C:  MOVLB  1
382E:  INCF   x06,F
3830:  MOVWF  00
3832:  MOVF   00,W
3834:  BTFSS  F9E.4
3836:  BRA    3834
3838:  MOVWF  FAD
383A:  MOVLW  0A
383C:  SUBWF  x06,W
383E:  BNZ   3824
3840:  MOVLW  10
3842:  MOVWF  FE9
3844:  MOVFF  C7,10B
3848:  MOVFF  C6,10A
384C:  MOVLB  0
384E:  CALL   2FD0
....................          printf("\r\nCurrent:%lu (%d)",current_measured/n_avg_current_measured, n_avg_current_measured); 
3852:  MOVFF  C4,109
3856:  MOVFF  C3,108
385A:  MOVLB  1
385C:  CLRF   x0B
385E:  MOVFF  C5,10A
3862:  MOVLB  0
3864:  RCALL  3124
3866:  MOVFF  02,107
386A:  MOVFF  01,106
386E:  MOVLB  1
3870:  CLRF   x08
3872:  MOVF   x08,W
3874:  MOVLB  0
3876:  CALL   0274
387A:  MOVLB  1
387C:  INCF   x08,F
387E:  MOVWF  00
3880:  MOVF   00,W
3882:  BTFSS  F9E.4
3884:  BRA    3882
3886:  MOVWF  FAD
3888:  MOVLW  0A
388A:  SUBWF  x08,W
388C:  BNZ   3872
388E:  MOVLW  10
3890:  MOVWF  FE9
3892:  MOVFF  107,10B
3896:  MOVFF  106,10A
389A:  MOVLB  0
389C:  CALL   2FD0
38A0:  MOVLW  20
38A2:  BTFSS  F9E.4
38A4:  BRA    38A2
38A6:  MOVWF  FAD
38A8:  MOVLW  28
38AA:  BTFSS  F9E.4
38AC:  BRA    38AA
38AE:  MOVWF  FAD
38B0:  MOVFF  C5,109
38B4:  MOVLW  1F
38B6:  MOVLB  1
38B8:  MOVWF  x0A
38BA:  MOVLB  0
38BC:  CALL   077C
38C0:  MOVLW  29
38C2:  BTFSS  F9E.4
38C4:  BRA    38C2
38C6:  MOVWF  FAD
....................          printf("\r\nTimer:%lu",timer_sec); 
38C8:  MOVLB  1
38CA:  CLRF   x06
38CC:  MOVF   x06,W
38CE:  MOVLB  0
38D0:  CALL   02A2
38D4:  MOVLB  1
38D6:  INCF   x06,F
38D8:  MOVWF  00
38DA:  MOVF   00,W
38DC:  BTFSS  F9E.4
38DE:  BRA    38DC
38E0:  MOVWF  FAD
38E2:  MOVLW  08
38E4:  SUBWF  x06,W
38E6:  BNZ   38CC
38E8:  MOVLW  41
38EA:  MOVWF  FE9
38EC:  MOVFF  23,10A
38F0:  MOVFF  22,109
38F4:  MOVFF  21,108
38F8:  MOVFF  20,107
38FC:  MOVLB  0
38FE:  BRA    316A
3900:  CLRF   18
3902:  BTFSC  FF2.7
3904:  BSF    18.7
3906:  BCF    FF2.7
....................          printf("\r\n#Day:%lu",find_day_number((timer_sec)%SEC_IN_4_YEARS)); 
3908:  MOVFF  23,124
390C:  MOVFF  22,123
3910:  MOVFF  21,122
3914:  MOVFF  20,121
3918:  MOVLW  07
391A:  MOVLB  1
391C:  MOVWF  x28
391E:  MOVLW  86
3920:  MOVWF  x27
3922:  MOVLW  1F
3924:  MOVWF  x26
3926:  MOVLW  80
3928:  MOVWF  x25
392A:  MOVLB  0
392C:  CALL   0340
3930:  BTFSC  18.7
3932:  BSF    FF2.7
3934:  MOVFF  FEF,106
3938:  MOVFF  FEC,107
393C:  MOVFF  FEC,108
3940:  MOVFF  FEC,109
3944:  MOVFF  109,119
3948:  MOVFF  108,118
394C:  MOVFF  107,117
3950:  MOVFF  106,116
3954:  CALL   2E9C
3958:  MOVFF  02,108
395C:  MOVFF  01,107
3960:  MOVLB  1
3962:  CLRF   x09
3964:  MOVF   x09,W
3966:  MOVLB  0
3968:  CALL   02C8
396C:  MOVLB  1
396E:  INCF   x09,F
3970:  MOVWF  00
3972:  MOVF   00,W
3974:  BTFSS  F9E.4
3976:  BRA    3974
3978:  MOVWF  FAD
397A:  MOVLW  07
397C:  SUBWF  x09,W
397E:  BNZ   3964
3980:  MOVLW  10
3982:  MOVWF  FE9
3984:  MOVFF  108,10B
3988:  MOVFF  107,10A
398C:  MOVLB  0
398E:  CALL   2FD0
....................  
....................          break; 
3992:  BRA    39B6
....................       } 
....................       case 'c': { //clear write buffer 
....................           ext_flash_buffer1_write(0xAA,0,255); 
3994:  MOVLW  AA
3996:  MOVLB  1
3998:  MOVWF  x11
399A:  CLRF   x12
399C:  MOVLW  FF
399E:  MOVWF  x13
39A0:  MOVLB  0
39A2:  RCALL  3248
....................          break; 
39A4:  BRA    39B6
....................       } 
....................  
....................       case 'x': { //stop timer 
....................          flag.setup_required=true;          
39A6:  BSF    1F.4
....................          restart_wdt(); 
39A8:  CLRWDT
....................          setup_wdt(WDT_OFF); 
39AA:  BCF    FD1.0
....................          break; 
39AC:  BRA    39B6
....................       } 
....................  
....................       case 'o': { //start timer 
....................          flag.setup_required=false;          
39AE:  BCF    1F.4
....................          setup_wdt(WDT_ON); 
39B0:  BSF    FD1.0
....................          restart_wdt(); 
39B2:  CLRWDT
....................          break; 
39B4:  BRA    39B6
....................       } 
....................  
....................  
....................       } 
....................        
....................    } 
39B6:  RETLW  00
....................  
.................... void print_len_and_tick() 
.................... { 
....................    lcd_gotoxy(0,3); 
*
61BE:  MOVLB  1
61C0:  CLRF   x1F
61C2:  MOVLW  03
61C4:  MOVWF  x20
61C6:  MOVLB  0
61C8:  CALL   0D3E
....................    itoa((int16)(al),10,tmp_str); 
61CC:  MOVFF  BF,161
61D0:  MOVFF  BE,160
61D4:  MOVFF  BD,15F
61D8:  MOVFF  BC,15E
61DC:  CALL   48CC
61E0:  MOVFF  02,107
61E4:  MOVFF  01,106
61E8:  MOVLB  1
61EA:  CLRF   x1E
61EC:  CLRF   x1D
61EE:  MOVFF  02,11C
61F2:  MOVFF  01,11B
61F6:  MOVLW  0A
61F8:  MOVWF  x1F
61FA:  CLRF   x21
61FC:  MOVLW  2C
61FE:  MOVWF  x20
6200:  MOVLB  0
6202:  CALL   150E
....................     printf(lcd_putc,"L=%s.",tmp_str); 
6206:  MOVLW  4C
6208:  MOVLB  1
620A:  MOVWF  x1E
620C:  MOVLB  0
620E:  CALL   0D6E
6212:  MOVLW  3D
6214:  MOVLB  1
6216:  MOVWF  x1E
6218:  MOVLB  0
621A:  CALL   0D6E
621E:  CLRF   FEA
6220:  MOVLW  2C
6222:  MOVWF  FE9
6224:  MOVLW  00
6226:  IORWF  FEF,W
6228:  BZ    624A
622A:  MOVFF  FEA,107
622E:  MOVFF  FE9,106
6232:  MOVFF  FEF,11E
6236:  CALL   0D6E
623A:  MOVFF  107,FEA
623E:  MOVFF  106,FE9
6242:  INCF   FE9,F
6244:  BTFSC  FD8.2
6246:  INCF   FEA,F
6248:  BRA    6224
624A:  MOVLW  2E
624C:  MOVLB  1
624E:  MOVWF  x1E
6250:  MOVLB  0
6252:  CALL   0D6E
....................    itoa((int16)(al*100.0)%100,10,tmp_str); 
6256:  MOVFF  BF,165
625A:  MOVFF  BE,164
625E:  MOVFF  BD,163
6262:  MOVFF  BC,162
6266:  MOVLB  1
6268:  CLRF   x69
626A:  CLRF   x68
626C:  MOVLW  48
626E:  MOVWF  x67
6270:  MOVLW  85
6272:  MOVWF  x66
6274:  MOVLB  0
6276:  CALL   0ECE
627A:  MOVFF  03,161
627E:  MOVFF  02,160
6282:  MOVFF  01,15F
6286:  MOVFF  00,15E
628A:  CALL   48CC
628E:  MOVFF  02,107
6292:  MOVFF  01,106
6296:  MOVFF  02,109
629A:  MOVFF  01,108
629E:  MOVLB  1
62A0:  CLRF   x0B
62A2:  MOVLW  64
62A4:  MOVWF  x0A
62A6:  MOVLB  0
62A8:  CALL   3124
62AC:  MOVFF  00,107
62B0:  MOVLB  1
62B2:  MOVFF  03,108
62B6:  CLRF   x1E
62B8:  CLRF   x1D
62BA:  MOVFF  03,11C
62BE:  MOVFF  00,11B
62C2:  MOVLW  0A
62C4:  MOVWF  x1F
62C6:  CLRF   x21
62C8:  MOVLW  2C
62CA:  MOVWF  x20
62CC:  MOVLB  0
62CE:  CALL   150E
....................     printf(lcd_putc,"%scm",tmp_str); 
62D2:  CLRF   FEA
62D4:  MOVLW  2C
62D6:  MOVWF  FE9
62D8:  MOVLW  00
62DA:  IORWF  FEF,W
62DC:  BZ    62FE
62DE:  MOVFF  FEA,107
62E2:  MOVFF  FE9,106
62E6:  MOVFF  FEF,11E
62EA:  CALL   0D6E
62EE:  MOVFF  107,FEA
62F2:  MOVFF  106,FE9
62F6:  INCF   FE9,F
62F8:  BTFSC  FD8.2
62FA:  INCF   FEA,F
62FC:  BRA    62D8
62FE:  MOVLW  63
6300:  MOVLB  1
6302:  MOVWF  x1E
6304:  MOVLB  0
6306:  CALL   0D6E
630A:  MOVLW  6D
630C:  MOVLB  1
630E:  MOVWF  x1E
6310:  MOVLB  0
6312:  CALL   0D6E
....................    lcd_gotoxy(11,3); 
6316:  MOVLW  0B
6318:  MOVLB  1
631A:  MOVWF  x1F
631C:  MOVLW  03
631E:  MOVWF  x20
6320:  MOVLB  0
6322:  CALL   0D3E
....................     printf(lcd_putc,"*%4lu",target_act_position); 
6326:  MOVLW  2A
6328:  MOVLB  1
632A:  MOVWF  x1E
632C:  MOVLB  0
632E:  CALL   0D6E
6332:  MOVLW  01
6334:  MOVWF  FE9
6336:  MOVFF  71,116
633A:  MOVFF  70,115
633E:  CALL   0DD8
....................  
.................... } 
6342:  RETLW  00
....................  
....................  
.................... void main() { 
6344:  CLRF   FF8
6346:  BCF    FD0.7
6348:  BSF    0D.7
634A:  CLRF   FEA
634C:  CLRF   FE9
634E:  MOVLW  0A
6350:  MOVWF  FAF
6352:  MOVLW  A6
6354:  MOVWF  FAC
6356:  MOVLW  90
6358:  MOVWF  FAB
635A:  BSF    FC1.0
635C:  BSF    FC1.1
635E:  BSF    FC1.2
6360:  BCF    FC1.3
6362:  MOVLW  07
6364:  MOVWF  FB4
6366:  CLRF   19
6368:  CLRF   1A
636A:  CLRF   20
636C:  CLRF   21
636E:  CLRF   22
6370:  CLRF   23
6372:  CLRF   24
6374:  CLRF   25
6376:  CLRF   26
6378:  CLRF   27
637A:  CLRF   28
637C:  CLRF   29
637E:  CLRF   2A
6380:  CLRF   2B
6382:  CLRF   x68
6384:  CLRF   x69
6386:  CLRF   x6E
6388:  CLRF   x6F
638A:  CLRF   x70
638C:  CLRF   x71
638E:  CLRF   xBA
6390:  CLRF   xBB
6392:  MOVLW  03
6394:  MOVWF  xC0
6396:  CLRF   xC1
6398:  CLRF   xC2
639A:  CLRF   xC3
639C:  CLRF   xC4
639E:  CLRF   xC5
63A0:  CLRF   xC6
63A2:  CLRF   xC7
63A4:  CLRF   xC8
63A6:  CLRF   xC9
....................     unsigned int8 solar_angle; 
....................    int16 tick=0; 
63A8:  MOVLB  1
63AA:  CLRF   x00
63AC:  CLRF   x01
....................    int16 temp_mem; 
....................    int8 i; 
....................     set_tris_d(0x00); // all D are output 
63AE:  MOVLW  00
63B0:  MOVWF  F95
....................    set_tris_e(0b00000010); // RE1 = emergnecy input 
63B2:  BCF    F96.0
63B4:  BSF    F96.1
63B6:  BCF    F96.2
....................    set_tris_a(0b11111111); // A0 -1 is output 
63B8:  MOVLW  FF
63BA:  MOVWF  F92
....................    set_tris_b(0xA0); 
63BC:  MOVLW  A0
63BE:  MOVWF  F93
....................    set_tris_c(0b10010000); 
63C0:  MOVLW  90
63C2:  MOVWF  F94
....................    timer_sec=0; 
63C4:  CLRF   23
63C6:  CLRF   22
63C8:  CLRF   21
63CA:  CLRF   20
63CC:  CLRF   18
63CE:  BTFSC  FF2.7
63D0:  BSF    18.7
63D2:  BCF    FF2.7
....................    delay_ms(200); 
63D4:  MOVLW  C8
63D6:  MOVWF  x20
63D8:  MOVLB  0
63DA:  CALL   04C2
63DE:  BTFSC  18.7
63E0:  BSF    FF2.7
....................    read_eeprom_data(); 
63E2:  GOTO   05C8
....................    restart_wdt(); 
63E6:  CLRWDT
....................    setup_wdt(WDT_OFF); 
63E8:  BCF    FD1.0
....................    setup_adc_ports(AN0); 
63EA:  BCF    FC1.0
63EC:  BSF    FC1.1
63EE:  BSF    FC1.2
63F0:  BSF    FC1.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
63F2:  BCF    FC1.6
63F4:  BSF    FC2.6
63F6:  BSF    FC2.7
63F8:  BSF    FC1.7
63FA:  BSF    FC2.0
....................    set_adc_channel( 0 ); 
63FC:  MOVLW  00
63FE:  MOVWF  01
6400:  MOVF   FC2,W
6402:  ANDLW  C7
6404:  IORWF  01,W
6406:  MOVWF  FC2
....................    current_measured =0; 
6408:  CLRF   xC4
640A:  CLRF   xC3
....................    startup_counter++; 
640C:  INCF   xC6,F
640E:  BTFSC  FD8.2
6410:  INCF   xC7,F
....................    printf("\r\nVer2.1 Restart Cause:%3d",restart_cause()); 
6412:  MOVF   FD0,W
6414:  ANDLW  0F
6416:  BTFSS  FD0.4
6418:  MOVLW  00
641A:  BSF    FD0.0
641C:  BSF    FD0.1
641E:  BSF    FD0.4
6420:  BSF    FD8.3
6422:  BSF    FD8.4
6424:  MOVLB  1
6426:  MOVWF  x05
6428:  CLRF   x06
642A:  MOVF   x06,W
642C:  MOVLB  0
642E:  CALL   02EE
6432:  MOVLB  1
6434:  INCF   x06,F
6436:  MOVWF  00
6438:  MOVF   00,W
643A:  BTFSS  F9E.4
643C:  BRA    643A
643E:  MOVWF  FAD
6440:  MOVLW  17
6442:  SUBWF  x06,W
6444:  BNZ   642A
6446:  MOVFF  105,109
644A:  MOVLW  13
644C:  MOVWF  x0A
644E:  MOVLB  0
6450:  CALL   077C
....................    write_eeprom_data(0); 
6454:  MOVLB  1
6456:  CLRF   x06
6458:  MOVLB  0
645A:  CALL   0858
....................    output_low(CCW); 
645E:  BCF    F93.4
6460:  BCF    F8A.4
....................    output_low(EN0); 
6462:  BCF    F93.0
6464:  BCF    F8A.0
....................    output_low(EN1); 
6466:  BCF    F93.1
6468:  BCF    F8A.1
....................    output_low(EN2); 
646A:  BCF    F93.2
646C:  BCF    F8A.2
....................    output_low(EN3); 
646E:  BCF    F93.3
6470:  BCF    F8A.3
....................    PORTD.ps_en=1; 
6472:  BSF    F83.4
....................    PORTD.disp_en=0;  
6474:  BCF    F83.7
....................    PORTE.tx_en=1; 
6476:  BSF    F84.2
....................    lcd_init(); 
6478:  CALL   0A46
....................    init_ext_flash(); 
647C:  GOTO   0B1E
....................    restart_wdt(); 
6480:  CLRWDT
....................    portd.pwr_ctrl=0; 
6482:  BCF    F83.6
....................     output_high(FLASH_SELECT); 
6484:  BCF    F94.2
6486:  BSF    F8B.2
....................     setup_timer_0(RTCC_DIV_32); 
6488:  MOVLW  84
648A:  MOVWF  FD5
....................    T1CON = 0x8F; 
648C:  MOVLW  8F
648E:  MOVWF  FCD
....................    //setup_timer_0(RTCC_DIV_1); 
....................     disable_interrupts(INT_TIMER0);   // Setup interrupt on falling edge 
6490:  BCF    FF2.5
....................     disable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
6492:  BCF    F9D.0
....................     disable_interrupts(GLOBAL); 
6494:  BCF    FF2.6
6496:  BCF    FF2.7
6498:  BTFSC  FF2.7
649A:  BRA    6496
....................    flag=0; 
649C:  CLRF   1F
....................     strcpy(cmd_msg,""); 
649E:  CLRF   FEA
64A0:  MOVLW  54
64A2:  MOVWF  FE9
64A4:  MOVFF  FF2,105
64A8:  BCF    FF2.7
64AA:  MOVLW  00
64AC:  CALL   0324
64B0:  TBLRD*-
64B2:  TBLRD*+
64B4:  MOVF   FF5,W
64B6:  MOVWF  FEE
64B8:  IORLW  00
64BA:  BNZ   64B2
64BC:  MOVLB  1
64BE:  BTFSC  x05.7
64C0:  BSF    FF2.7
....................    if (timer_sec ==0x00000000) 
64C2:  MOVF   20,F
64C4:  BNZ   64D6
64C6:  MOVF   21,F
64C8:  BNZ   64D6
64CA:  MOVF   22,F
64CC:  BNZ   64D6
64CE:  MOVF   23,F
64D0:  BNZ   64D6
....................       flag.setup_required = true; 
64D2:  BSF    1F.4
....................    else 
64D4:  BRA    64D8
....................       flag.setup_required = false; 
64D6:  BCF    1F.4
....................  
.................... ///////////////// 
....................    enable_interrupts(INT_RDA); 
64D8:  BSF    F9D.5
....................    enable_interrupts(INT_TIMER1);   
64DA:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);  
64DC:  MOVLW  C0
64DE:  IORWF  FF2,F
....................    while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
64E0:  BTFSS  1F.4
64E2:  BRA    64F2
64E4:  BTFSS  1F.3
64E6:  BRA    64F0
64E8:  MOVLB  0
64EA:  CALL   32BE
64EE:  MOVLB  1
64F0:  BRA    64E0
....................    setup_wdt(WDT_ON); 
64F2:  BSF    FD1.0
64F4:  CLRF   18
64F6:  BTFSC  FF2.7
64F8:  BSF    18.7
64FA:  BCF    FF2.7
....................    next_sun_rise=get_timer_index(find_day_number((timer_sec)%SEC_IN_4_YEARS))*450; 
64FC:  MOVFF  23,124
6500:  MOVFF  22,123
6504:  MOVFF  21,122
6508:  MOVFF  20,121
650C:  MOVLW  07
650E:  MOVWF  x28
6510:  MOVLW  86
6512:  MOVWF  x27
6514:  MOVLW  1F
6516:  MOVWF  x26
6518:  MOVLW  80
651A:  MOVWF  x25
651C:  MOVLB  0
651E:  CALL   0340
6522:  BTFSC  18.7
6524:  BSF    FF2.7
6526:  MOVFF  FEF,105
652A:  MOVFF  FEC,106
652E:  MOVFF  FEC,107
6532:  MOVFF  FEC,108
6536:  MOVFF  108,119
653A:  MOVFF  107,118
653E:  MOVFF  106,117
6542:  MOVFF  105,116
6546:  CALL   2E9C
654A:  MOVFF  02,107
654E:  MOVFF  01,106
6552:  MOVFF  02,117
6556:  MOVFF  01,116
655A:  CALL   2F3E
655E:  MOVFF  03,10A
6562:  MOVFF  02,109
6566:  MOVFF  01,108
656A:  MOVFF  00,107
656E:  MOVFF  FEA,10C
6572:  MOVFF  FE9,10B
6576:  MOVFF  03,12D
657A:  MOVFF  02,12C
657E:  MOVFF  01,12B
6582:  MOVFF  00,12A
6586:  MOVLB  1
6588:  CLRF   x31
658A:  CLRF   x30
658C:  MOVLW  01
658E:  MOVWF  x2F
6590:  MOVLW  C2
6592:  MOVWF  x2E
6594:  MOVLB  0
6596:  CALL   13DE
659A:  MOVFF  10C,FEA
659E:  MOVFF  10B,FE9
65A2:  MOVFF  03,6D
65A6:  MOVFF  02,6C
65AA:  MOVFF  01,6B
65AE:  MOVFF  00,6A
....................  
.................... ////////////////// 
....................    // take sun angle and calculate the length of actuator needed to push 
....................    // also need counter of reed switch 
....................    flag.task1_armed =true; 
65B2:  BSF    1F.0
65B4:  CLRF   18
65B6:  BTFSC  FF2.7
65B8:  BSF    18.7
65BA:  BCF    FF2.7
....................    ext_flash_main_memory_to_buffer1(1010+(find_day_number(timer_sec%SEC_IN_4_YEARS)/2)); 
65BC:  MOVFF  23,124
65C0:  MOVFF  22,123
65C4:  MOVFF  21,122
65C8:  MOVFF  20,121
65CC:  MOVLW  07
65CE:  MOVLB  1
65D0:  MOVWF  x28
65D2:  MOVLW  86
65D4:  MOVWF  x27
65D6:  MOVLW  1F
65D8:  MOVWF  x26
65DA:  MOVLW  80
65DC:  MOVWF  x25
65DE:  MOVLB  0
65E0:  CALL   0340
65E4:  BTFSC  18.7
65E6:  BSF    FF2.7
65E8:  MOVFF  FEF,105
65EC:  MOVFF  FEC,106
65F0:  MOVFF  FEC,107
65F4:  MOVFF  FEC,108
65F8:  MOVFF  108,119
65FC:  MOVFF  107,118
6600:  MOVFF  106,117
6604:  MOVFF  105,116
6608:  CALL   2E9C
660C:  MOVFF  02,107
6610:  MOVFF  01,106
6614:  BCF    FD8.0
6616:  MOVLB  1
6618:  RRCF   02,W
661A:  MOVWF  03
661C:  RRCF   01,W
661E:  MOVWF  02
6620:  ADDLW  F2
6622:  MOVWF  x08
6624:  MOVLW  03
6626:  ADDWFC 03,W
6628:  MOVWF  x09
662A:  MOVWF  x0C
662C:  MOVFF  108,10B
6630:  MOVLB  0
6632:  GOTO   3A0A
....................  
....................    while(1) { 
....................  
....................       while(flag.setup_required)   if (flag.cmd_posted) process_cmd_msg(); 
6636:  BTFSS  1F.4
6638:  BRA    6644
663A:  BTFSS  1F.3
663C:  BRA    6642
663E:  CALL   32BE
6642:  BRA    6636
....................  
....................       if (flag.update_time) { 
6644:  BTFSS  1F.1
6646:  BRA    664E
....................          flag.update_time = false; 
6648:  BCF    1F.1
....................          print_date_time(); 
664A:  CALL   175C
....................       } 
....................  
....................       if (flag.measured_current) {    
664E:  BTFSS  1F.7
6650:  BRA    6664
....................          flag.measured_current = false; 
6652:  BCF    1F.7
....................          current_measured += (read_adc()); 
6654:  BSF    FC2.2
6656:  BTFSC  FC2.2
6658:  BRA    6656
665A:  MOVF   FC3,W
665C:  ADDWF  xC3,F
665E:  MOVF   FC4,W
6660:  ADDWFC xC4,F
....................          n_avg_current_measured++; 
6662:  INCF   xC5,F
....................       } 
....................  
....................       if (flag.cmd_posted) { 
6664:  BTFSS  1F.3
6666:  BRA    666E
....................          flag.cmd_posted = false; 
6668:  BCF    1F.3
....................          process_cmd_msg(); 
666A:  CALL   32BE
....................       } 
....................       if (flag.reset_rs232) { 
666E:  BTFSS  1F.5
6670:  BRA    6678
....................          flag.reset_rs232 =false; 
6672:  BCF    1F.5
....................           init_rs232(); 
6674:  GOTO   3A4E
....................       } 
....................       if (input(WALL_PWR)==false) { 
6678:  BSF    F92.5
667A:  BTFSC  F80.5
667C:  BRA    6682
....................          flag.pwr_state = false; 
667E:  BCF    1F.6
....................       } else { 
6680:  BRA    668C
....................          if (flag.pwr_state==false) 
6682:  BTFSC  1F.6
6684:  BRA    668A
....................             lcd_init(); 
6686:  CALL   0A46
....................          flag.pwr_state=true; 
668A:  BSF    1F.6
....................       } 
....................       if (tx_delay==0) PORTE.tx_en=0; 
668C:  MOVF   xC2,F
668E:  BTFSC  FD8.2
6690:  BCF    F84.2
....................       if (flag.task1_armed) { 
6692:  BTFSS  1F.0
6694:  BRA    6A1C
....................          flag.task1_armed = false; 
6696:  BCF    1F.0
....................          solar_angle= task1(); 
6698:  GOTO   3CEC
669C:  MOVFF  01,FF
....................  
....................          if ((solar_angle>30) && (solar_angle<150)) { 
66A0:  MOVF   xFF,W
66A2:  SUBLW  1E
66A4:  BC    66D4
66A6:  MOVF   xFF,W
66A8:  SUBLW  95
66AA:  BNC   66D4
....................             lcd_gotoxy(0,3); 
66AC:  MOVLB  1
66AE:  CLRF   x1F
66B0:  MOVLW  03
66B2:  MOVWF  x20
66B4:  MOVLB  0
66B6:  CALL   0D3E
....................             actuator_length(solar_angle); 
66BA:  MOVFF  FF,108
66BE:  CALL   4EA6
....................             al=act_len; 
66C2:  MOVFF  FE,BF
66C6:  MOVFF  FD,BE
66CA:  MOVFF  FC,BD
66CE:  MOVFF  FB,BC
....................          } else { 
66D2:  BRA    675E
....................             if ((solar_angle>0) && (solar_angle<=30)) { 
66D4:  MOVF   xFF,F
66D6:  BZ    6714
66D8:  MOVF   xFF,W
66DA:  SUBLW  1E
66DC:  BNC   6714
....................                actuator_length(90-get_backtrack_angle(90-solar_angle)); 
66DE:  MOVLW  5A
66E0:  BSF    FD8.0
66E2:  SUBFWB xFF,W
66E4:  MOVLB  1
66E6:  MOVWF  x05
66E8:  MOVWF  x07
66EA:  MOVLB  0
66EC:  CALL   5EA6
66F0:  MOVLW  5A
66F2:  BSF    FD8.0
66F4:  SUBFWB 01,W
66F6:  MOVLB  1
66F8:  MOVWF  x06
66FA:  MOVWF  x08
66FC:  MOVLB  0
66FE:  CALL   4EA6
....................                al=act_len; 
6702:  MOVFF  FE,BF
6706:  MOVFF  FD,BE
670A:  MOVFF  FC,BD
670E:  MOVFF  FB,BC
....................             } else if ((solar_angle>=150) && (solar_angle<=180)) { 
6712:  BRA    675E
6714:  MOVF   xFF,W
6716:  SUBLW  95
6718:  BC    675E
671A:  MOVF   xFF,W
671C:  SUBLW  B4
671E:  BNC   675E
....................                lcd_gotoxy(0,3); 
6720:  MOVLB  1
6722:  CLRF   x1F
6724:  MOVLW  03
6726:  MOVWF  x20
6728:  MOVLB  0
672A:  CALL   0D3E
....................                actuator_length(90+get_backtrack_angle(solar_angle-90)); 
672E:  MOVLW  5A
6730:  SUBWF  xFF,W
6732:  MOVLB  1
6734:  MOVWF  x05
6736:  MOVWF  x07
6738:  MOVLB  0
673A:  CALL   5EA6
673E:  MOVLW  5A
6740:  ADDWF  01,W
6742:  MOVLB  1
6744:  MOVWF  x06
6746:  MOVWF  x08
6748:  MOVLB  0
674A:  CALL   4EA6
....................                al=act_len; 
674E:  MOVFF  FE,BF
6752:  MOVFF  FD,BE
6756:  MOVFF  FC,BD
675A:  MOVFF  FB,BC
....................             } 
....................          } 
....................          if((al >= MIN_STROKE) && (al <=MAX_STROKE)) { 
675E:  MOVLW  9A
6760:  MOVLB  1
6762:  MOVWF  x61
6764:  MOVLW  99
6766:  MOVWF  x60
6768:  MOVLW  0C
676A:  MOVWF  x5F
676C:  MOVLW  85
676E:  MOVWF  x5E
6770:  MOVFF  BF,165
6774:  MOVFF  BE,164
6778:  MOVFF  BD,163
677C:  MOVFF  BC,162
6780:  MOVLB  0
6782:  CALL   42F2
6786:  BC    678A
6788:  BNZ   686E
678A:  MOVFF  BF,161
678E:  MOVFF  BE,160
6792:  MOVFF  BD,15F
6796:  MOVFF  BC,15E
679A:  MOVLB  1
679C:  CLRF   x65
679E:  CLRF   x64
67A0:  CLRF   x63
67A2:  MOVLW  86
67A4:  MOVWF  x62
67A6:  MOVLB  0
67A8:  CALL   42F2
67AC:  BC    67B0
67AE:  BNZ   686E
....................             tick = ((al-MIN_STROKE)/(MAX_STROKE-MIN_STROKE))*FULL_STROKE_TICK; 
67B0:  BSF    FD8.1
67B2:  MOVFF  BF,167
67B6:  MOVFF  BE,166
67BA:  MOVFF  BD,165
67BE:  MOVFF  BC,164
67C2:  MOVLW  9A
67C4:  MOVLB  1
67C6:  MOVWF  x6B
67C8:  MOVLW  99
67CA:  MOVWF  x6A
67CC:  MOVLW  0C
67CE:  MOVWF  x69
67D0:  MOVLW  85
67D2:  MOVWF  x68
67D4:  MOVLB  0
67D6:  CALL   1122
67DA:  MOVFF  00,105
67DE:  MOVFF  01,106
67E2:  MOVFF  02,107
67E6:  MOVFF  03,108
67EA:  MOVFF  03,161
67EE:  MOVFF  02,160
67F2:  MOVFF  01,15F
67F6:  MOVFF  00,15E
67FA:  MOVLW  CC
67FC:  MOVLB  1
67FE:  MOVWF  x65
6800:  MOVWF  x64
6802:  MOVLW  66
6804:  MOVWF  x63
6806:  MOVLW  84
6808:  MOVWF  x62
680A:  MOVLB  0
680C:  CALL   0FC4
6810:  MOVFF  00,109
6814:  MOVFF  01,10A
6818:  MOVFF  02,10B
681C:  MOVFF  03,10C
6820:  MOVFF  BB,163
6824:  MOVFF  BA,162
6828:  CALL   4896
682C:  MOVFF  10C,165
6830:  MOVFF  10B,164
6834:  MOVFF  10A,163
6838:  MOVFF  109,162
683C:  MOVFF  03,169
6840:  MOVFF  02,168
6844:  MOVFF  01,167
6848:  MOVFF  00,166
684C:  CALL   0ECE
6850:  MOVFF  03,161
6854:  MOVFF  02,160
6858:  MOVFF  01,15F
685C:  MOVFF  00,15E
6860:  CALL   48CC
6864:  MOVFF  02,101
6868:  MOVFF  01,100
....................          } else if (al<MIN_STROKE) { 
686C:  BRA    68CC
686E:  MOVFF  BF,161
6872:  MOVFF  BE,160
6876:  MOVFF  BD,15F
687A:  MOVFF  BC,15E
687E:  MOVLW  9A
6880:  MOVLB  1
6882:  MOVWF  x65
6884:  MOVLW  99
6886:  MOVWF  x64
6888:  MOVLW  0C
688A:  MOVWF  x63
688C:  MOVLW  85
688E:  MOVWF  x62
6890:  MOVLB  0
6892:  CALL   42F2
6896:  BNC   68A0
....................             tick = 0; 
6898:  MOVLB  1
689A:  CLRF   x01
689C:  CLRF   x00
....................          } else if (al>MAX_STROKE) { 
689E:  BRA    68CC
68A0:  MOVLB  1
68A2:  CLRF   x61
68A4:  CLRF   x60
68A6:  CLRF   x5F
68A8:  MOVLW  86
68AA:  MOVWF  x5E
68AC:  MOVFF  BF,165
68B0:  MOVFF  BE,164
68B4:  MOVFF  BD,163
68B8:  MOVFF  BC,162
68BC:  MOVLB  0
68BE:  CALL   42F2
68C2:  BNC   68CC
....................             tick = FULL_STROKE_TICK; 
68C4:  MOVFF  BB,101
68C8:  MOVFF  BA,100
....................          } 
....................          lcd_init(); 
68CC:  MOVLB  0
68CE:  CALL   0A46
....................          target_act_position = tick; 
68D2:  MOVFF  101,71
68D6:  MOVFF  100,70
....................          write_eeprom_data(0); 
68DA:  MOVLB  1
68DC:  CLRF   x06
68DE:  MOVLB  0
68E0:  CALL   0858
....................          print_len_and_tick(); 
68E4:  RCALL  61BE
....................  
....................          if(current_act_position > (target_act_position+5))// move east 
68E6:  MOVLW  05
68E8:  ADDWF  x70,W
68EA:  MOVWF  01
68EC:  MOVLW  00
68EE:  ADDWFC x71,W
68F0:  MOVWF  03
68F2:  MOVF   03,W
68F4:  SUBWF  x6F,W
68F6:  BNC   6936
68F8:  BNZ   6900
68FA:  MOVF   x6E,W
68FC:  SUBWF  01,W
68FE:  BC    6936
....................          { 
....................             move_act(current_act_position-target_act_position,4500,move_act_time_out,0,1); 
6900:  MOVF   x70,W
6902:  SUBWF  x6E,W
6904:  MOVLB  1
6906:  MOVWF  x05
6908:  MOVLB  0
690A:  MOVF   x71,W
690C:  SUBWFB x6F,W
690E:  MOVLB  1
6910:  MOVWF  x06
6912:  MOVWF  x09
6914:  MOVFF  105,108
6918:  MOVLW  11
691A:  MOVWF  x0B
691C:  MOVLW  94
691E:  MOVWF  x0A
6920:  MOVFF  C1,10D
6924:  MOVFF  C0,10C
6928:  CLRF   x0E
692A:  MOVLW  01
692C:  MOVWF  x0F
692E:  MOVLB  0
6930:  CALL   23CE
....................          } else if((current_act_position+5) < target_act_position)// move west 
6934:  BRA    69F8
6936:  MOVLW  05
6938:  ADDWF  x6E,W
693A:  MOVLB  1
693C:  MOVWF  x05
693E:  MOVLW  00
6940:  MOVLB  0
6942:  ADDWFC x6F,W
6944:  MOVLB  1
6946:  MOVWF  x06
6948:  MOVLB  0
694A:  SUBWF  x71,W
694C:  BNC   6996
694E:  BNZ   6960
6950:  MOVF   x70,W
6952:  MOVLB  1
6954:  SUBWF  x05,W
6956:  BTFSS  FD8.0
6958:  BRA    695E
695A:  MOVLB  0
695C:  BRA    6996
695E:  MOVLB  0
....................          { 
....................             move_act(target_act_position-current_act_position,4500,move_act_time_out,1,1); 
6960:  MOVF   x6E,W
6962:  SUBWF  x70,W
6964:  MOVLB  1
6966:  MOVWF  x05
6968:  MOVLB  0
696A:  MOVF   x6F,W
696C:  SUBWFB x71,W
696E:  MOVLB  1
6970:  MOVWF  x06
6972:  MOVWF  x09
6974:  MOVFF  105,108
6978:  MOVLW  11
697A:  MOVWF  x0B
697C:  MOVLW  94
697E:  MOVWF  x0A
6980:  MOVFF  C1,10D
6984:  MOVFF  C0,10C
6988:  MOVLW  01
698A:  MOVWF  x0E
698C:  MOVWF  x0F
698E:  MOVLB  0
6990:  CALL   23CE
....................          } else if (target_act_position == 0x00)  // move east all the way 
6994:  BRA    69F8
6996:  MOVF   x70,F
6998:  BNZ   69C6
699A:  MOVF   x71,F
699C:  BNZ   69C6
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,0,1); 
699E:  MOVFF  BB,109
69A2:  MOVFF  BA,108
69A6:  MOVLW  11
69A8:  MOVLB  1
69AA:  MOVWF  x0B
69AC:  MOVLW  94
69AE:  MOVWF  x0A
69B0:  MOVFF  C1,10D
69B4:  MOVFF  C0,10C
69B8:  CLRF   x0E
69BA:  MOVLW  01
69BC:  MOVWF  x0F
69BE:  MOVLB  0
69C0:  CALL   23CE
....................          else if (target_act_position == FULL_STROKE_TICK) // move west all the way 
69C4:  BRA    69F8
69C6:  MOVF   xBA,W
69C8:  SUBWF  x70,W
69CA:  BNZ   69F8
69CC:  MOVF   xBB,W
69CE:  SUBWF  x71,W
69D0:  BNZ   69F8
....................             move_act(FULL_STROKE_TICK,4500,move_act_time_out,1,1); 
69D2:  MOVFF  BB,109
69D6:  MOVFF  BA,108
69DA:  MOVLW  11
69DC:  MOVLB  1
69DE:  MOVWF  x0B
69E0:  MOVLW  94
69E2:  MOVWF  x0A
69E4:  MOVFF  C1,10D
69E8:  MOVFF  C0,10C
69EC:  MOVLW  01
69EE:  MOVWF  x0E
69F0:  MOVWF  x0F
69F2:  MOVLB  0
69F4:  CALL   23CE
....................          //delay_ms(20); 
....................          //task1(); 
....................          print_len_and_tick(); 
69F8:  CALL   61BE
....................          write_eeprom_data(0); 
69FC:  MOVLB  1
69FE:  CLRF   x06
6A00:  MOVLB  0
6A02:  CALL   0858
....................          PORTE.tx_en=1; 
6A06:  BSF    F84.2
....................          current_measured=0; 
6A08:  CLRF   xC4
6A0A:  CLRF   xC3
....................          n_avg_current_measured=0; 
6A0C:  CLRF   xC5
....................          printf("."); 
6A0E:  MOVLW  2E
6A10:  BTFSS  F9E.4
6A12:  BRA    6A10
6A14:  MOVWF  FAD
....................          tx_delay=TX_DLY_TIME; 
6A16:  MOVLW  01
6A18:  MOVWF  xC2
....................          sleep(); 
6A1A:  SLEEP 
....................       } 
....................    } 
6A1C:  BRA    6636
....................  
.................... } 
6A1E:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: B1 05 00 00 00 00 00 00 00 00 
