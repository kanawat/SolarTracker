CCS PCH C Compiler, Version 4.078, 38112               10-Jul-10 11:37

               Filename: main_direct_comm.lst

               ROM used: 16936 bytes (52%)
                         Largest free fragment is 15828
               RAM used: 439 (29%) at main() level
                         479 (31%) worst case
               Stack:    8 worst case (6 in main + 2 for interrupts)

*
0000:  GOTO   3E6E
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   05E8
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   0828
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #include <solar_lib.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1C04:  MOVFF  1B7,1B9
1C08:  MOVFF  1B6,1B8
1C0C:  MOVFF  1B9,03
1C10:  MOVLB  1
1C12:  MOVFF  1B8,FE9
1C16:  MOVFF  1B9,FEA
1C1A:  MOVF   FEF,F
1C1C:  BZ    1C2A
1C1E:  INCF   xB8,F
1C20:  BTFSC  FD8.2
1C22:  INCF   xB9,F
1C24:  MOVLB  0
1C26:  BRA    1C0C
1C28:  MOVLB  1
....................    return(sc - s); 
1C2A:  MOVF   xB6,W
1C2C:  SUBWF  xB8,W
1C2E:  MOVWF  00
1C30:  MOVF   xB7,W
1C32:  SUBWFB xB9,W
1C34:  MOVWF  03
1C36:  MOVFF  00,01
.................... } 
1C3A:  MOVLB  0
1C3C:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
26F4:  MOVLB  1
26F6:  CLRF   xBA
....................    sign = 0; 
26F8:  CLRF   xB8
....................    base = 10; 
26FA:  MOVLW  0A
26FC:  MOVWF  xB9
....................    result = 0; 
26FE:  CLRF   xB7
....................  
....................    if (!s) 
2700:  MOVF   xB5,W
2702:  IORWF  xB6,W
2704:  BNZ   270C
....................       return 0; 
2706:  MOVLW  00
2708:  MOVWF  01
270A:  BRA    2892
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
270C:  MOVF   xBA,W
270E:  INCF   xBA,F
2710:  CLRF   03
2712:  ADDWF  xB5,W
2714:  MOVWF  FE9
2716:  MOVF   xB6,W
2718:  ADDWFC 03,W
271A:  MOVWF  FEA
271C:  MOVFF  FEF,1BB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
2720:  MOVF   xBB,W
2722:  SUBLW  2D
2724:  BNZ   2740
....................    { 
....................       sign = 1;         // Set the sign to negative 
2726:  MOVLW  01
2728:  MOVWF  xB8
....................       c = s[index++]; 
272A:  MOVF   xBA,W
272C:  INCF   xBA,F
272E:  CLRF   03
2730:  ADDWF  xB5,W
2732:  MOVWF  FE9
2734:  MOVF   xB6,W
2736:  ADDWFC 03,W
2738:  MOVWF  FEA
273A:  MOVFF  FEF,1BB
....................    } 
....................    else if (c == '+') 
273E:  BRA    275A
2740:  MOVF   xBB,W
2742:  SUBLW  2B
2744:  BNZ   275A
....................    { 
....................       c = s[index++]; 
2746:  MOVF   xBA,W
2748:  INCF   xBA,F
274A:  CLRF   03
274C:  ADDWF  xB5,W
274E:  MOVWF  FE9
2750:  MOVF   xB6,W
2752:  ADDWFC 03,W
2754:  MOVWF  FEA
2756:  MOVFF  FEF,1BB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
275A:  MOVF   xBB,W
275C:  SUBLW  2F
275E:  BTFSC  FD8.0
2760:  BRA    2882
2762:  MOVF   xBB,W
2764:  SUBLW  39
2766:  BTFSS  FD8.0
2768:  BRA    2882
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
276A:  MOVF   xBB,W
276C:  SUBLW  30
276E:  BNZ   27B2
2770:  CLRF   03
2772:  MOVF   xBA,W
2774:  ADDWF  xB5,W
2776:  MOVWF  FE9
2778:  MOVF   xB6,W
277A:  ADDWFC 03,W
277C:  MOVWF  FEA
277E:  MOVF   FEF,W
2780:  SUBLW  78
2782:  BZ    2798
2784:  CLRF   03
2786:  MOVF   xBA,W
2788:  ADDWF  xB5,W
278A:  MOVWF  FE9
278C:  MOVF   xB6,W
278E:  ADDWFC 03,W
2790:  MOVWF  FEA
2792:  MOVF   FEF,W
2794:  SUBLW  58
2796:  BNZ   27B2
....................       { 
....................          base = 16; 
2798:  MOVLW  10
279A:  MOVWF  xB9
....................          index++; 
279C:  INCF   xBA,F
....................          c = s[index++]; 
279E:  MOVF   xBA,W
27A0:  INCF   xBA,F
27A2:  CLRF   03
27A4:  ADDWF  xB5,W
27A6:  MOVWF  FE9
27A8:  MOVF   xB6,W
27AA:  ADDWFC 03,W
27AC:  MOVWF  FEA
27AE:  MOVFF  FEF,1BB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
27B2:  MOVF   xB9,W
27B4:  SUBLW  0A
27B6:  BNZ   27F2
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
27B8:  MOVF   xBB,W
27BA:  SUBLW  2F
27BC:  BC    27F0
27BE:  MOVF   xBB,W
27C0:  SUBLW  39
27C2:  BNC   27F0
....................             result = 10*result + (c - '0'); 
27C4:  MOVLW  0A
27C6:  MOVWF  xBC
27C8:  MOVFF  1B7,1BD
27CC:  MOVLB  0
27CE:  RCALL  26A6
27D0:  MOVLW  30
27D2:  MOVLB  1
27D4:  SUBWF  xBB,W
27D6:  ADDWF  01,W
27D8:  MOVWF  xB7
....................             c = s[index++]; 
27DA:  MOVF   xBA,W
27DC:  INCF   xBA,F
27DE:  CLRF   03
27E0:  ADDWF  xB5,W
27E2:  MOVWF  FE9
27E4:  MOVF   xB6,W
27E6:  ADDWFC 03,W
27E8:  MOVWF  FEA
27EA:  MOVFF  FEF,1BB
....................          } 
27EE:  BRA    27B8
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
27F0:  BRA    2882
27F2:  MOVF   xB9,W
27F4:  SUBLW  10
27F6:  BNZ   2882
....................       { 
....................          c = toupper(c); 
27F8:  MOVF   xBB,W
27FA:  SUBLW  60
27FC:  BC    280A
27FE:  MOVF   xBB,W
2800:  SUBLW  7A
2802:  BNC   280A
2804:  MOVF   xBB,W
2806:  ANDLW  DF
2808:  BRA    280C
280A:  MOVF   xBB,W
280C:  MOVWF  xBB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
280E:  MOVF   xBB,W
2810:  SUBLW  2F
2812:  BC    281A
2814:  MOVF   xBB,W
2816:  SUBLW  39
2818:  BC    2826
281A:  MOVF   xBB,W
281C:  SUBLW  40
281E:  BC    2882
2820:  MOVF   xBB,W
2822:  SUBLW  46
2824:  BNC   2882
....................             if (c >= '0' && c <= '9') 
2826:  MOVF   xBB,W
2828:  SUBLW  2F
282A:  BC    2844
282C:  MOVF   xBB,W
282E:  SUBLW  39
2830:  BNC   2844
....................                result = (result << 4) + (c - '0'); 
2832:  SWAPF  xB7,W
2834:  MOVWF  xBC
2836:  MOVLW  F0
2838:  ANDWF  xBC,F
283A:  MOVLW  30
283C:  SUBWF  xBB,W
283E:  ADDWF  xBC,W
2840:  MOVWF  xB7
....................             else 
2842:  BRA    2856
....................                result = (result << 4) + (c - 'A' + 10); 
2844:  SWAPF  xB7,W
2846:  MOVWF  xBC
2848:  MOVLW  F0
284A:  ANDWF  xBC,F
284C:  MOVLW  41
284E:  SUBWF  xBB,W
2850:  ADDLW  0A
2852:  ADDWF  xBC,W
2854:  MOVWF  xB7
....................  
....................             c = s[index++]; 
2856:  MOVF   xBA,W
2858:  INCF   xBA,F
285A:  CLRF   03
285C:  ADDWF  xB5,W
285E:  MOVWF  FE9
2860:  MOVF   xB6,W
2862:  ADDWFC 03,W
2864:  MOVWF  FEA
2866:  MOVFF  FEF,1BB
....................             c = toupper(c); 
286A:  MOVF   xBB,W
286C:  SUBLW  60
286E:  BC    287C
2870:  MOVF   xBB,W
2872:  SUBLW  7A
2874:  BNC   287C
2876:  MOVF   xBB,W
2878:  ANDLW  DF
287A:  BRA    287E
287C:  MOVF   xBB,W
287E:  MOVWF  xBB
....................          } 
2880:  BRA    280E
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
2882:  DECFSZ xB8,W
2884:  BRA    288E
2886:  MOVF   xB9,W
2888:  SUBLW  0A
288A:  BNZ   288E
....................        result = -result; 
288C:  NEGF   xB7
....................  
....................    return(result); 
288E:  MOVFF  1B7,01
.................... } 
2892:  MOVLB  0
2894:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
12DC:  MOVLB  1
12DE:  CLRF   xBA
....................    sign = 0; 
12E0:  CLRF   xB8
....................    base = 10; 
12E2:  MOVLW  0A
12E4:  MOVWF  xB9
....................    result = 0; 
12E6:  CLRF   xB7
12E8:  CLRF   xB6
....................  
....................    if (!s) 
12EA:  MOVF   xB4,W
12EC:  IORWF  xB5,W
12EE:  BNZ   12F8
....................       return 0; 
12F0:  MOVLW  00
12F2:  MOVWF  01
12F4:  MOVWF  02
12F6:  BRA    14C8
....................    c = s[index++]; 
12F8:  MOVF   xBA,W
12FA:  INCF   xBA,F
12FC:  CLRF   03
12FE:  ADDWF  xB4,W
1300:  MOVWF  FE9
1302:  MOVF   xB5,W
1304:  ADDWFC 03,W
1306:  MOVWF  FEA
1308:  MOVFF  FEF,1BB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
130C:  MOVF   xBB,W
130E:  SUBLW  2D
1310:  BNZ   132C
....................    { 
....................       sign = 1;         // Set the sign to negative 
1312:  MOVLW  01
1314:  MOVWF  xB8
....................       c = s[index++]; 
1316:  MOVF   xBA,W
1318:  INCF   xBA,F
131A:  CLRF   03
131C:  ADDWF  xB4,W
131E:  MOVWF  FE9
1320:  MOVF   xB5,W
1322:  ADDWFC 03,W
1324:  MOVWF  FEA
1326:  MOVFF  FEF,1BB
....................    } 
....................    else if (c == '+') 
132A:  BRA    1346
132C:  MOVF   xBB,W
132E:  SUBLW  2B
1330:  BNZ   1346
....................    { 
....................       c = s[index++]; 
1332:  MOVF   xBA,W
1334:  INCF   xBA,F
1336:  CLRF   03
1338:  ADDWF  xB4,W
133A:  MOVWF  FE9
133C:  MOVF   xB5,W
133E:  ADDWFC 03,W
1340:  MOVWF  FEA
1342:  MOVFF  FEF,1BB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1346:  MOVF   xBB,W
1348:  SUBLW  2F
134A:  BTFSC  FD8.0
134C:  BRA    14AC
134E:  MOVF   xBB,W
1350:  SUBLW  39
1352:  BTFSS  FD8.0
1354:  BRA    14AC
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1356:  MOVF   xBB,W
1358:  SUBLW  30
135A:  BNZ   139E
135C:  CLRF   03
135E:  MOVF   xBA,W
1360:  ADDWF  xB4,W
1362:  MOVWF  FE9
1364:  MOVF   xB5,W
1366:  ADDWFC 03,W
1368:  MOVWF  FEA
136A:  MOVF   FEF,W
136C:  SUBLW  78
136E:  BZ    1384
1370:  CLRF   03
1372:  MOVF   xBA,W
1374:  ADDWF  xB4,W
1376:  MOVWF  FE9
1378:  MOVF   xB5,W
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVF   FEF,W
1380:  SUBLW  58
1382:  BNZ   139E
....................       { 
....................          base = 16; 
1384:  MOVLW  10
1386:  MOVWF  xB9
....................          index++; 
1388:  INCF   xBA,F
....................          c = s[index++]; 
138A:  MOVF   xBA,W
138C:  INCF   xBA,F
138E:  CLRF   03
1390:  ADDWF  xB4,W
1392:  MOVWF  FE9
1394:  MOVF   xB5,W
1396:  ADDWFC 03,W
1398:  MOVWF  FEA
139A:  MOVFF  FEF,1BB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
139E:  MOVF   xB9,W
13A0:  SUBLW  0A
13A2:  BNZ   13EA
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
13A4:  MOVF   xBB,W
13A6:  SUBLW  2F
13A8:  BC    13E8
13AA:  MOVF   xBB,W
13AC:  SUBLW  39
13AE:  BNC   13E8
....................             result = 10*result + (c - '0'); 
13B0:  CLRF   xBD
13B2:  MOVLW  0A
13B4:  MOVWF  xBC
13B6:  MOVFF  1B7,1BF
13BA:  MOVFF  1B6,1BE
13BE:  MOVLB  0
13C0:  BRA    12B8
13C2:  MOVLW  30
13C4:  MOVLB  1
13C6:  SUBWF  xBB,W
13C8:  ADDWF  01,W
13CA:  MOVWF  xB6
13CC:  MOVLW  00
13CE:  ADDWFC 02,W
13D0:  MOVWF  xB7
....................             c = s[index++]; 
13D2:  MOVF   xBA,W
13D4:  INCF   xBA,F
13D6:  CLRF   03
13D8:  ADDWF  xB4,W
13DA:  MOVWF  FE9
13DC:  MOVF   xB5,W
13DE:  ADDWFC 03,W
13E0:  MOVWF  FEA
13E2:  MOVFF  FEF,1BB
....................          } 
13E6:  BRA    13A4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
13E8:  BRA    14AC
13EA:  MOVF   xB9,W
13EC:  SUBLW  10
13EE:  BNZ   14AC
....................       { 
....................          c = toupper(c); 
13F0:  MOVF   xBB,W
13F2:  SUBLW  60
13F4:  BC    1402
13F6:  MOVF   xBB,W
13F8:  SUBLW  7A
13FA:  BNC   1402
13FC:  MOVF   xBB,W
13FE:  ANDLW  DF
1400:  BRA    1404
1402:  MOVF   xBB,W
1404:  MOVWF  xBB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
1406:  MOVF   xBB,W
1408:  SUBLW  2F
140A:  BC    1412
140C:  MOVF   xBB,W
140E:  SUBLW  39
1410:  BC    141E
1412:  MOVF   xBB,W
1414:  SUBLW  40
1416:  BC    14AC
1418:  MOVF   xBB,W
141A:  SUBLW  46
141C:  BNC   14AC
....................             if (c >= '0' && c <= '9') 
141E:  MOVF   xBB,W
1420:  SUBLW  2F
1422:  BC    1456
1424:  MOVF   xBB,W
1426:  SUBLW  39
1428:  BNC   1456
....................                result = (result << 4) + (c - '0'); 
142A:  RLCF   xB6,W
142C:  MOVWF  xBC
142E:  RLCF   xB7,W
1430:  MOVWF  xBD
1432:  RLCF   xBC,F
1434:  RLCF   xBD,F
1436:  RLCF   xBC,F
1438:  RLCF   xBD,F
143A:  RLCF   xBC,F
143C:  RLCF   xBD,F
143E:  MOVLW  F0
1440:  ANDWF  xBC,F
1442:  MOVLW  30
1444:  SUBWF  xBB,W
1446:  ADDWF  xBC,W
1448:  MOVWF  01
144A:  MOVLW  00
144C:  ADDWFC xBD,W
144E:  MOVFF  01,1B6
1452:  MOVWF  xB7
....................             else 
1454:  BRA    1482
....................                result = (result << 4) + (c - 'A' + 10); 
1456:  RLCF   xB6,W
1458:  MOVWF  xBC
145A:  RLCF   xB7,W
145C:  MOVWF  xBD
145E:  RLCF   xBC,F
1460:  RLCF   xBD,F
1462:  RLCF   xBC,F
1464:  RLCF   xBD,F
1466:  RLCF   xBC,F
1468:  RLCF   xBD,F
146A:  MOVLW  F0
146C:  ANDWF  xBC,F
146E:  MOVLW  41
1470:  SUBWF  xBB,W
1472:  ADDLW  0A
1474:  ADDWF  xBC,W
1476:  MOVWF  01
1478:  MOVLW  00
147A:  ADDWFC xBD,W
147C:  MOVFF  01,1B6
1480:  MOVWF  xB7
....................  
....................             c = s[index++];c = toupper(c); 
1482:  MOVF   xBA,W
1484:  INCF   xBA,F
1486:  CLRF   03
1488:  ADDWF  xB4,W
148A:  MOVWF  FE9
148C:  MOVF   xB5,W
148E:  ADDWFC 03,W
1490:  MOVWF  FEA
1492:  MOVF   FEF,W
1494:  MOVWF  xBB
1496:  SUBLW  60
1498:  BC    14A6
149A:  MOVF   xBB,W
149C:  SUBLW  7A
149E:  BNC   14A6
14A0:  MOVF   xBB,W
14A2:  ANDLW  DF
14A4:  BRA    14A8
14A6:  MOVF   xBB,W
14A8:  MOVWF  xBB
....................          } 
14AA:  BRA    1406
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
14AC:  MOVF   xB9,W
14AE:  SUBLW  0A
14B0:  BNZ   14C0
14B2:  DECFSZ xB8,W
14B4:  BRA    14C0
....................       result = -result; 
14B6:  COMF   xB6,F
14B8:  COMF   xB7,F
14BA:  INCF   xB6,F
14BC:  BTFSC  FD8.2
14BE:  INCF   xB7,F
....................  
....................    return(result); 
14C0:  MOVFF  1B6,01
14C4:  MOVFF  1B7,02
.................... } 
14C8:  MOVLB  0
14CA:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
2404:  MOVLB  1
2406:  CLRF   xBC
....................    sign = 0; 
2408:  CLRF   xBA
....................    base = 10; 
240A:  MOVLW  0A
240C:  MOVWF  xBB
....................    result = 0; 
240E:  CLRF   xB9
2410:  CLRF   xB8
2412:  CLRF   xB7
2414:  CLRF   xB6
....................  
....................    if (!s) 
2416:  MOVF   xB4,W
2418:  IORWF  xB5,W
241A:  BNZ   2426
....................       return 0; 
241C:  CLRF   00
241E:  CLRF   01
2420:  CLRF   02
2422:  CLRF   03
2424:  BRA    26A0
....................    c = s[index++]; 
2426:  MOVF   xBC,W
2428:  INCF   xBC,F
242A:  CLRF   03
242C:  ADDWF  xB4,W
242E:  MOVWF  FE9
2430:  MOVF   xB5,W
2432:  ADDWFC 03,W
2434:  MOVWF  FEA
2436:  MOVFF  FEF,1BD
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
243A:  MOVF   xBD,W
243C:  SUBLW  2D
243E:  BNZ   245A
....................    { 
....................       sign = 1;         // Set the sign to negative 
2440:  MOVLW  01
2442:  MOVWF  xBA
....................       c = s[index++]; 
2444:  MOVF   xBC,W
2446:  INCF   xBC,F
2448:  CLRF   03
244A:  ADDWF  xB4,W
244C:  MOVWF  FE9
244E:  MOVF   xB5,W
2450:  ADDWFC 03,W
2452:  MOVWF  FEA
2454:  MOVFF  FEF,1BD
....................    } 
....................    else if (c == '+') 
2458:  BRA    2474
245A:  MOVF   xBD,W
245C:  SUBLW  2B
245E:  BNZ   2474
....................    { 
....................       c = s[index++]; 
2460:  MOVF   xBC,W
2462:  INCF   xBC,F
2464:  CLRF   03
2466:  ADDWF  xB4,W
2468:  MOVWF  FE9
246A:  MOVF   xB5,W
246C:  ADDWFC 03,W
246E:  MOVWF  FEA
2470:  MOVFF  FEF,1BD
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2474:  MOVF   xBD,W
2476:  SUBLW  2F
2478:  BTFSC  FD8.0
247A:  BRA    2670
247C:  MOVF   xBD,W
247E:  SUBLW  39
2480:  BTFSS  FD8.0
2482:  BRA    2670
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2484:  MOVF   xBD,W
2486:  SUBLW  30
2488:  BNZ   24CC
248A:  CLRF   03
248C:  MOVF   xBC,W
248E:  ADDWF  xB4,W
2490:  MOVWF  FE9
2492:  MOVF   xB5,W
2494:  ADDWFC 03,W
2496:  MOVWF  FEA
2498:  MOVF   FEF,W
249A:  SUBLW  78
249C:  BZ    24B2
249E:  CLRF   03
24A0:  MOVF   xBC,W
24A2:  ADDWF  xB4,W
24A4:  MOVWF  FE9
24A6:  MOVF   xB5,W
24A8:  ADDWFC 03,W
24AA:  MOVWF  FEA
24AC:  MOVF   FEF,W
24AE:  SUBLW  58
24B0:  BNZ   24CC
....................       { 
....................          base = 16; 
24B2:  MOVLW  10
24B4:  MOVWF  xBB
....................          index++; 
24B6:  INCF   xBC,F
....................          c = s[index++]; 
24B8:  MOVF   xBC,W
24BA:  INCF   xBC,F
24BC:  CLRF   03
24BE:  ADDWF  xB4,W
24C0:  MOVWF  FE9
24C2:  MOVF   xB5,W
24C4:  ADDWFC 03,W
24C6:  MOVWF  FEA
24C8:  MOVFF  FEF,1BD
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
24CC:  MOVF   xBB,W
24CE:  SUBLW  0A
24D0:  BNZ   255A
....................       { 
....................          while (c >= '0' && c <= '9') { 
24D2:  MOVF   xBD,W
24D4:  SUBLW  2F
24D6:  BC    2558
24D8:  MOVF   xBD,W
24DA:  SUBLW  39
24DC:  BNC   2558
....................             result = (result << 1) + (result << 3);  // result *= 10; 
24DE:  BCF    FD8.0
24E0:  RLCF   xB6,W
24E2:  MOVWF  xBF
24E4:  RLCF   xB7,W
24E6:  MOVWF  xC0
24E8:  RLCF   xB8,W
24EA:  MOVWF  xC1
24EC:  RLCF   xB9,W
24EE:  MOVWF  xC2
24F0:  RLCF   xB6,W
24F2:  MOVWF  00
24F4:  RLCF   xB7,W
24F6:  MOVWF  01
24F8:  RLCF   xB8,W
24FA:  MOVWF  02
24FC:  RLCF   xB9,W
24FE:  MOVWF  03
2500:  RLCF   00,F
2502:  RLCF   01,F
2504:  RLCF   02,F
2506:  RLCF   03,F
2508:  RLCF   00,F
250A:  RLCF   01,F
250C:  RLCF   02,F
250E:  RLCF   03,F
2510:  MOVLW  F8
2512:  ANDWF  00,F
2514:  MOVF   xBF,W
2516:  ADDWF  00,F
2518:  MOVF   xC0,W
251A:  ADDWFC 01,F
251C:  MOVF   xC1,W
251E:  ADDWFC 02,F
2520:  MOVF   xC2,W
2522:  ADDWFC 03,F
2524:  MOVFF  03,1B9
2528:  MOVFF  02,1B8
252C:  MOVFF  01,1B7
2530:  MOVFF  00,1B6
....................             result += (c - '0'); 
2534:  MOVLW  30
2536:  SUBWF  xBD,W
2538:  ADDWF  xB6,F
253A:  MOVLW  00
253C:  ADDWFC xB7,F
253E:  ADDWFC xB8,F
2540:  ADDWFC xB9,F
....................             c = s[index++]; 
2542:  MOVF   xBC,W
2544:  INCF   xBC,F
2546:  CLRF   03
2548:  ADDWF  xB4,W
254A:  MOVWF  FE9
254C:  MOVF   xB5,W
254E:  ADDWFC 03,W
2550:  MOVWF  FEA
2552:  MOVFF  FEF,1BD
....................          } 
2556:  BRA    24D2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2558:  BRA    2670
255A:  MOVF   xBB,W
255C:  SUBLW  10
255E:  BTFSS  FD8.2
2560:  BRA    2670
....................       { 
....................          c = toupper(c); 
2562:  MOVF   xBD,W
2564:  SUBLW  60
2566:  BC    2574
2568:  MOVF   xBD,W
256A:  SUBLW  7A
256C:  BNC   2574
256E:  MOVF   xBD,W
2570:  ANDLW  DF
2572:  BRA    2576
2574:  MOVF   xBD,W
2576:  MOVWF  xBD
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2578:  MOVF   xBD,W
257A:  SUBLW  2F
257C:  BC    2584
257E:  MOVF   xBD,W
2580:  SUBLW  39
2582:  BC    2592
2584:  MOVF   xBD,W
2586:  SUBLW  40
2588:  BTFSC  FD8.0
258A:  BRA    2670
258C:  MOVF   xBD,W
258E:  SUBLW  46
2590:  BNC   2670
....................             if (c >= '0' && c <= '9') 
2592:  MOVF   xBD,W
2594:  SUBLW  2F
2596:  BC    25F2
2598:  MOVF   xBD,W
259A:  SUBLW  39
259C:  BNC   25F2
....................                result = (result << 4) + (c - '0'); 
259E:  RLCF   xB6,W
25A0:  MOVWF  xBF
25A2:  RLCF   xB7,W
25A4:  MOVWF  xC0
25A6:  RLCF   xB8,W
25A8:  MOVWF  xC1
25AA:  RLCF   xB9,W
25AC:  MOVWF  xC2
25AE:  RLCF   xBF,F
25B0:  RLCF   xC0,F
25B2:  RLCF   xC1,F
25B4:  RLCF   xC2,F
25B6:  RLCF   xBF,F
25B8:  RLCF   xC0,F
25BA:  RLCF   xC1,F
25BC:  RLCF   xC2,F
25BE:  RLCF   xBF,F
25C0:  RLCF   xC0,F
25C2:  RLCF   xC1,F
25C4:  RLCF   xC2,F
25C6:  MOVLW  F0
25C8:  ANDWF  xBF,F
25CA:  MOVLW  30
25CC:  SUBWF  xBD,W
25CE:  ADDWF  xBF,W
25D0:  MOVWF  00
25D2:  MOVLW  00
25D4:  ADDWFC xC0,W
25D6:  MOVWF  01
25D8:  MOVLW  00
25DA:  ADDWFC xC1,W
25DC:  MOVWF  02
25DE:  MOVLW  00
25E0:  ADDWFC xC2,W
25E2:  MOVWF  xB9
25E4:  MOVFF  02,1B8
25E8:  MOVFF  01,1B7
25EC:  MOVFF  00,1B6
....................             else 
25F0:  BRA    2646
....................                result = (result << 4) + (c - 'A' + 10); 
25F2:  RLCF   xB6,W
25F4:  MOVWF  xBF
25F6:  RLCF   xB7,W
25F8:  MOVWF  xC0
25FA:  RLCF   xB8,W
25FC:  MOVWF  xC1
25FE:  RLCF   xB9,W
2600:  MOVWF  xC2
2602:  RLCF   xBF,F
2604:  RLCF   xC0,F
2606:  RLCF   xC1,F
2608:  RLCF   xC2,F
260A:  RLCF   xBF,F
260C:  RLCF   xC0,F
260E:  RLCF   xC1,F
2610:  RLCF   xC2,F
2612:  RLCF   xBF,F
2614:  RLCF   xC0,F
2616:  RLCF   xC1,F
2618:  RLCF   xC2,F
261A:  MOVLW  F0
261C:  ANDWF  xBF,F
261E:  MOVLW  41
2620:  SUBWF  xBD,W
2622:  ADDLW  0A
2624:  ADDWF  xBF,W
2626:  MOVWF  00
2628:  MOVLW  00
262A:  ADDWFC xC0,W
262C:  MOVWF  01
262E:  MOVLW  00
2630:  ADDWFC xC1,W
2632:  MOVWF  02
2634:  MOVLW  00
2636:  ADDWFC xC2,W
2638:  MOVWF  xB9
263A:  MOVFF  02,1B8
263E:  MOVFF  01,1B7
2642:  MOVFF  00,1B6
....................  
....................             c = s[index++];c = toupper(c); 
2646:  MOVF   xBC,W
2648:  INCF   xBC,F
264A:  CLRF   03
264C:  ADDWF  xB4,W
264E:  MOVWF  FE9
2650:  MOVF   xB5,W
2652:  ADDWFC 03,W
2654:  MOVWF  FEA
2656:  MOVF   FEF,W
2658:  MOVWF  xBD
265A:  SUBLW  60
265C:  BC    266A
265E:  MOVF   xBD,W
2660:  SUBLW  7A
2662:  BNC   266A
2664:  MOVF   xBD,W
2666:  ANDLW  DF
2668:  BRA    266C
266A:  MOVF   xBD,W
266C:  MOVWF  xBD
....................          } 
266E:  BRA    2578
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2670:  MOVF   xBB,W
2672:  SUBLW  0A
2674:  BNZ   2690
2676:  DECFSZ xBA,W
2678:  BRA    2690
....................       result = -result; 
267A:  COMF   xB6,F
267C:  COMF   xB7,F
267E:  COMF   xB8,F
2680:  COMF   xB9,F
2682:  INCF   xB6,F
2684:  BTFSC  FD8.2
2686:  INCF   xB7,F
2688:  BTFSC  FD8.2
268A:  INCF   xB8,F
268C:  BTFSC  FD8.2
268E:  INCF   xB9,F
....................  
....................    return(result); 
2690:  MOVFF  1B6,00
2694:  MOVFF  1B7,01
2698:  MOVFF  1B8,02
269C:  MOVFF  1B9,03
.................... } 
26A0:  MOVLB  0
26A2:  GOTO   36DE (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
1A20:  MOVLW  01
1A22:  MOVLB  1
1A24:  MOVWF  xC1
1A26:  CLRF   xC2
1A28:  CLRF   xC3
1A2A:  CLRF   xC4
....................      unsigned int8 i,sign=0,cnt=0; 
1A2C:  CLRF   xC6
1A2E:  CLRF   xC7
....................      char c; 
....................  
....................      if(num<0) { 
1A30:  BTFSC  xBD.7
1A32:  BRA    1A36
1A34:  BRA    1A6A
....................          sign=1;        // Check for negative number 
1A36:  MOVLW  01
1A38:  MOVWF  xC6
....................          num*=-1; 
1A3A:  MOVFF  1BD,1CD
1A3E:  MOVFF  1BC,1CC
1A42:  MOVFF  1BB,1CB
1A46:  MOVFF  1BA,1CA
1A4A:  MOVLW  FF
1A4C:  MOVWF  xD1
1A4E:  MOVWF  xD0
1A50:  MOVWF  xCF
1A52:  MOVWF  xCE
1A54:  MOVLB  0
1A56:  RCALL  18F0
1A58:  MOVFF  03,1BD
1A5C:  MOVFF  02,1BC
1A60:  MOVFF  01,1BB
1A64:  MOVFF  00,1BA
1A68:  MOVLB  1
....................      } 
....................  
....................      while(temp>0) { 
1A6A:  MOVF   xC1,F
1A6C:  BNZ   1A7A
1A6E:  MOVF   xC2,F
1A70:  BNZ   1A7A
1A72:  MOVF   xC3,F
1A74:  BNZ   1A7A
1A76:  MOVF   xC4,F
1A78:  BZ    1B68
....................          temp=(num/base); 
1A7A:  MOVFF  1BD,1D0
1A7E:  MOVFF  1BC,1CF
1A82:  MOVFF  1BB,1CE
1A86:  MOVFF  1BA,1CD
1A8A:  CLRF   xD4
1A8C:  CLRF   xD3
1A8E:  CLRF   xD2
1A90:  MOVFF  1BE,1D1
1A94:  MOVLB  0
1A96:  RCALL  194A
1A98:  MOVFF  03,1C4
1A9C:  MOVFF  02,1C3
1AA0:  MOVFF  01,1C2
1AA4:  MOVFF  00,1C1
....................          s[cnt]=(num%base)+'0';    // Conversion 
1AA8:  CLRF   03
1AAA:  MOVLB  1
1AAC:  MOVF   xC7,W
1AAE:  ADDWF  xBF,W
1AB0:  MOVWF  01
1AB2:  MOVF   xC0,W
1AB4:  ADDWFC 03,F
1AB6:  MOVFF  01,1C9
1ABA:  MOVFF  03,1CA
1ABE:  MOVFF  FEA,1CC
1AC2:  MOVFF  FE9,1CB
1AC6:  MOVFF  1BD,1D0
1ACA:  MOVFF  1BC,1CF
1ACE:  MOVFF  1BB,1CE
1AD2:  MOVFF  1BA,1CD
1AD6:  CLRF   xD4
1AD8:  CLRF   xD3
1ADA:  CLRF   xD2
1ADC:  MOVFF  1BE,1D1
1AE0:  MOVLB  0
1AE2:  RCALL  194A
1AE4:  MOVFF  FEF,00
1AE8:  MOVFF  FEC,01
1AEC:  MOVFF  FEC,02
1AF0:  MOVFF  FEC,03
1AF4:  MOVFF  1CC,FEA
1AF8:  MOVFF  1CB,FE9
1AFC:  MOVFF  03,1D0
1B00:  MOVFF  02,1CF
1B04:  MOVFF  01,1CE
1B08:  MOVFF  00,1CD
1B0C:  MOVLW  30
1B0E:  MOVLB  1
1B10:  ADDWF  00,W
1B12:  MOVWF  00
1B14:  MOVLW  00
1B16:  ADDWFC 01,W
1B18:  MOVLW  00
1B1A:  ADDWFC 02,W
1B1C:  MOVLW  00
1B1E:  ADDWFC 03,W
1B20:  MOVFF  1CA,FEA
1B24:  MOVFF  1C9,FE9
1B28:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
1B2C:  CLRF   03
1B2E:  MOVF   xC7,W
1B30:  ADDWF  xBF,W
1B32:  MOVWF  FE9
1B34:  MOVF   xC0,W
1B36:  ADDWFC 03,W
1B38:  MOVWF  FEA
1B3A:  MOVF   FEF,W
1B3C:  SUBLW  39
1B3E:  BC    1B54
....................             s[cnt]+=0x7; 
1B40:  CLRF   03
1B42:  MOVF   xC7,W
1B44:  ADDWF  xBF,W
1B46:  MOVWF  FE9
1B48:  MOVF   xC0,W
1B4A:  ADDWFC 03,W
1B4C:  MOVWF  FEA
1B4E:  MOVLW  07
1B50:  ADDWF  FEF,W
1B52:  MOVWF  FEF
....................  
....................          cnt++; 
1B54:  INCF   xC7,F
....................          num=temp; 
1B56:  MOVFF  1C4,1BD
1B5A:  MOVFF  1C3,1BC
1B5E:  MOVFF  1C2,1BB
1B62:  MOVFF  1C1,1BA
....................      } 
1B66:  BRA    1A6A
....................  
....................      if(sign==1) { 
1B68:  DECFSZ xC6,W
1B6A:  BRA    1B80
....................          s[cnt]=0x2D;      // Negative sign 
1B6C:  CLRF   03
1B6E:  MOVF   xC7,W
1B70:  ADDWF  xBF,W
1B72:  MOVWF  FE9
1B74:  MOVF   xC0,W
1B76:  ADDWFC 03,W
1B78:  MOVWF  FEA
1B7A:  MOVLW  2D
1B7C:  MOVWF  FEF
....................          cnt++; 
1B7E:  INCF   xC7,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1B80:  CLRF   xC5
1B82:  BCF    FD8.0
1B84:  RRCF   xC7,W
1B86:  SUBWF  xC5,W
1B88:  BC    1BE8
....................  
....................          c=s[i]; 
1B8A:  CLRF   03
1B8C:  MOVF   xC5,W
1B8E:  ADDWF  xBF,W
1B90:  MOVWF  FE9
1B92:  MOVF   xC0,W
1B94:  ADDWFC 03,W
1B96:  MOVWF  FEA
1B98:  MOVFF  FEF,1C8
....................          s[i]=s[cnt-i-1];        // Reverse the number 
1B9C:  CLRF   03
1B9E:  MOVF   xC5,W
1BA0:  ADDWF  xBF,W
1BA2:  MOVWF  01
1BA4:  MOVF   xC0,W
1BA6:  ADDWFC 03,F
1BA8:  MOVFF  03,1CA
1BAC:  MOVF   xC5,W
1BAE:  SUBWF  xC7,W
1BB0:  ADDLW  FF
1BB2:  CLRF   03
1BB4:  ADDWF  xBF,W
1BB6:  MOVWF  FE9
1BB8:  MOVF   xC0,W
1BBA:  ADDWFC 03,W
1BBC:  MOVWF  FEA
1BBE:  MOVFF  FEF,1CD
1BC2:  MOVFF  1CA,FEA
1BC6:  MOVFF  01,FE9
1BCA:  MOVFF  1CD,FEF
....................          s[cnt-i-1]=c; 
1BCE:  MOVF   xC5,W
1BD0:  SUBWF  xC7,W
1BD2:  ADDLW  FF
1BD4:  CLRF   03
1BD6:  ADDWF  xBF,W
1BD8:  MOVWF  FE9
1BDA:  MOVF   xC0,W
1BDC:  ADDWFC 03,W
1BDE:  MOVWF  FEA
1BE0:  MOVFF  1C8,FEF
....................      } 
1BE4:  INCF   xC5,F
1BE6:  BRA    1B82
....................      s[cnt]='\0';     // End the string 
1BE8:  CLRF   03
1BEA:  MOVF   xC7,W
1BEC:  ADDWF  xBF,W
1BEE:  MOVWF  FE9
1BF0:  MOVF   xC0,W
1BF2:  ADDWFC 03,W
1BF4:  MOVWF  FEA
1BF6:  CLRF   FEF
....................      return s; 
1BF8:  MOVFF  1BF,01
1BFC:  MOVFF  1C0,02
.................... } 
1C00:  MOVLB  0
1C02:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <math.h> 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20,NOLVP,WRT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
0576:  MOVLW  01
0578:  MOVWF  FEA
057A:  MOVLW  C7
057C:  MOVWF  FE9
057E:  MOVF   FEF,W
0580:  BZ    059E
0582:  MOVLW  03
0584:  MOVWF  01
0586:  CLRF   00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  DECFSZ 01,F
058E:  BRA    0586
0590:  MOVLW  3C
0592:  MOVWF  00
0594:  DECFSZ 00,F
0596:  BRA    0594
0598:  BRA    059A
059A:  DECFSZ FEF,F
059C:  BRA    0582
059E:  RETLW  00
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N,BITS=8) 
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, BITS=8, MSB_FIRST, IDLE=0) 
....................  
....................  
....................  
.................... #define FLASH_CS PIN_C2 
.................... #define TX_EN PIN_E1 
....................  
.................... struct port_d_map{ 
....................    int8 data_bus:4; //0:3 
....................    boolean rs;     //4 
....................    boolean LED_latch;  //5 
....................    boolean MUX_en;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte SSPCON2 = 0xFC5 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1  = 0xFCE 
.................... #byte T1CON = 0xFCD 
....................  
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1 PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3 PIN_B3 
.................... #define CCW PIN_B4 
.................... #define SENSE_0     PIN_A2 
.................... #define SENSE_1     PIN_A3 
.................... #define SENSE_2     PIN_A4 
.................... #define SENSE_3     PIN_A5 
.................... #define WALL_PWR    PIN_A0 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00010 
.................... #define ADDR_TIME           0xf00020 
.................... #define ADDR_START_COUNTER  0xf00030 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x047E,0x037F,0x0280,0x0181} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000,0x0001,0x0002,0x0003} 
.................... #rom ADDR_TIME={0x0000,0x0000,0x0001,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... #rom 0xf00040 ={0x1234} // to check if eeprom can be read properly 
.................... ////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////// flag 
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct flag2 { 
....................    boolean en_operate; 
....................    boolean button_pressed; 
....................    boolean abort_current_activity; 
....................    boolean allow_manual_move_act; 
....................    boolean current_pulse_state; 
....................    boolean power; 
....................    boolean is_moving; 
....................    boolean unused3; 
.................... } flag2; 
....................  
.................... struct LED_status { 
....................   boolean power; 
....................   boolean operation; 
....................   int8 aux:2; 
....................   int8 unused:4; 
.................... } LED_status; 
....................  
.................... /////////////////////////// timer_related 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... unsigned int32 nDay=1; 
.................... unsigned int16 startup_counter=0; 
.................... /////////////////////////// command processing 
.................... int16 device_id = 0x0075; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... int8 nButton=-1; 
.................... unsigned int32 last_command =0; 
.................... int8 de_stuffing_mask = 0x00; 
.................... int8 posted_cmd_len =0; 
.................... int8 command_byte=0x00; 
.................... int16 aux_command; 
.................... int8 output_buffer[256]; 
.................... int8 output_checksum; 
.................... /////////////////////////// string format 
.................... char tmp_str[20]; 
.................... char tmp_str2[20]; 
.................... //////////////////////////// ADC 
.................... int16 wall_pwr_read; 
.................... /////////////////////////// flash_related_variable 
.................... int8 flash_mfg_id[4]; 
.................... int8 flash_stat=0; 
.................... int8 flash_page_data=0; 
.................... int8 flash_page_data2=0; 
.................... /////////////////////////// actuator related 
.................... int16 move_act_time_out=3; 
.................... int16 actuator_pulse=0; 
.................... float act_len; 
.................... unsigned int16 current_act_position[4]={0,0,0,0}; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int16 act_full_stroke_tick[4]={0,0,0,0}; 
.................... unsigned int16 act_max_stroke=0; 
.................... unsigned int16 act_min_stroke=0; 
.................... unsigned int16 act_safety_stroke=0; 
.................... unsigned int16 latitude=0; 
.................... unsigned int16 longitude=0; 
.................... unsigned int16 altitude=0; 
.................... int8 actuator_move_mask=0x00; 
.................... ///////////////////PROTOTYE/////////////////////////////////// 
.................... void button_scan(); 
.................... void stuff_data(int8 data_to_stuff); 
.................... void send_data(int8 packet_type,int8 size); 
....................  
.................... ///////////////////////////////////////////////////// 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
0522:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
0524:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
0526:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
0528:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
052A:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
052C:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
052E:  BCF    FAC.5
....................    delay_cycles(10); 
0530:  MOVLW  03
0532:  MOVWF  00
0534:  DECFSZ 00,F
0536:  BRA    0534
....................    bit_set(RCSTA,4); //CREN=1 
0538:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
053A:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
053C:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
053E:  BSF    F9D.5
....................  
.................... } 
0540:  RETLW  00
....................  
....................  
.................... void flash_read_mfg_id() { 
.................... 		output_low(FLASH_CS); 
*
0918:  BCF    F94.2
091A:  BCF    F8B.2
.................... 		delay_cycles(20); 
091C:  MOVLW  06
091E:  MOVWF  00
0920:  DECFSZ 00,F
0922:  BRA    0920
0924:  NOP   
.................... 		spi_write(0x9F); 
0926:  MOVF   FC9,W
0928:  MOVLW  9F
092A:  MOVWF  FC9
092C:  RRCF   FC7,W
092E:  BNC   092C
.................... 		flash_mfg_id[0] = spi_read(0); 
0930:  MOVF   FC9,W
0932:  CLRF   FC9
0934:  RRCF   FC7,W
0936:  BNC   0934
0938:  MOVFF  FC9,180
.................... 		flash_mfg_id[1] = spi_read(0); 
093C:  MOVF   FC9,W
093E:  CLRF   FC9
0940:  RRCF   FC7,W
0942:  BNC   0940
0944:  MOVFF  FC9,181
.................... 		flash_mfg_id[2] = spi_read(0); 
0948:  MOVF   FC9,W
094A:  CLRF   FC9
094C:  RRCF   FC7,W
094E:  BNC   094C
0950:  MOVFF  FC9,182
.................... 		flash_mfg_id[3] = spi_read(0); 
0954:  MOVF   FC9,W
0956:  CLRF   FC9
0958:  RRCF   FC7,W
095A:  BNC   0958
095C:  MOVFF  FC9,183
.................... 		delay_cycles(20); 
0960:  MOVLW  06
0962:  MOVWF  00
0964:  DECFSZ 00,F
0966:  BRA    0964
0968:  NOP   
.................... 		output_high(FLASH_CS); 
096A:  BCF    F94.2
096C:  BSF    F8B.2
.................... } 
096E:  GOTO   400C (RETURN)
....................  
.................... void flash_read_stat() { 
.................... 		output_low(FLASH_CS); 
*
08B8:  BCF    F94.2
08BA:  BCF    F8B.2
.................... 		delay_cycles(20); 
08BC:  MOVLW  06
08BE:  MOVWF  00
08C0:  DECFSZ 00,F
08C2:  BRA    08C0
08C4:  NOP   
.................... 		spi_write(0xD7); 
08C6:  MOVF   FC9,W
08C8:  MOVLW  D7
08CA:  MOVWF  FC9
08CC:  RRCF   FC7,W
08CE:  BNC   08CC
.................... 		flash_stat = spi_read(0); 
08D0:  MOVF   FC9,W
08D2:  CLRF   FC9
08D4:  RRCF   FC7,W
08D6:  BNC   08D4
08D8:  MOVFF  FC9,184
.................... 		delay_cycles(20); 
08DC:  MOVLW  06
08DE:  MOVWF  00
08E0:  DECFSZ 00,F
08E2:  BRA    08E0
08E4:  NOP   
.................... 		output_high(FLASH_CS); 
08E6:  BCF    F94.2
08E8:  BSF    F8B.2
.................... } 
08EA:  RETLW  00
....................  
.................... void flash_wait_until_ready() { 
....................    int8 wait_loop=0; 
08EC:  MOVLB  1
08EE:  CLRF   xC8
....................    for ( wait_loop=0; wait_loop<0xFF; wait_loop++) { 
08F0:  CLRF   xC8
08F2:  INCFSZ xC8,W
08F4:  BRA    08F8
08F6:  BRA    0914
.................... 	 flash_read_stat(); 
08F8:  MOVLB  0
08FA:  RCALL  08B8
....................      if ((flash_stat & 0xBF)==0x9C) break; 
08FC:  MOVLB  1
08FE:  MOVF   x84,W
0900:  ANDLW  BF
0902:  SUBLW  9C
0904:  BNZ   0908
0906:  BRA    0914
.................... 	 delay_cycles(100); 
0908:  MOVLW  21
090A:  MOVWF  00
090C:  DECFSZ 00,F
090E:  BRA    090C
....................    } 
0910:  INCF   xC8,F
0912:  BRA    08F2
.................... } 
0914:  MOVLB  0
0916:  RETLW  00
....................  
.................... void flash_read_page(int16 pageAddress, int8 pageIndex) { 
....................  
.................... 	//pageAddress <<= 1; 
.................... 	//pageAddress &= 0xFE; 
.................... 	flash_wait_until_ready(); 
*
0C3A:  RCALL  08EC
....................    	output_low(FLASH_CS); 
0C3C:  BCF    F94.2
0C3E:  BCF    F8B.2
.................... 	delay_cycles(20); 
0C40:  MOVLW  06
0C42:  MOVWF  00
0C44:  DECFSZ 00,F
0C46:  BRA    0C44
0C48:  NOP   
....................    	spi_write(0xD2); 
0C4A:  MOVF   FC9,W
0C4C:  MOVLW  D2
0C4E:  MOVWF  FC9
0C50:  RRCF   FC7,W
0C52:  BNC   0C50
....................     spi_write(make8(pageAddress,1)); 
0C54:  MOVFF  1C6,1C8
0C58:  MOVF   FC9,W
0C5A:  MOVFF  1C6,FC9
0C5E:  RRCF   FC7,W
0C60:  BNC   0C5E
....................     spi_write(make8(pageAddress,0)); 
0C62:  MOVFF  1C5,1C8
0C66:  MOVF   FC9,W
0C68:  MOVFF  1C5,FC9
0C6C:  RRCF   FC7,W
0C6E:  BNC   0C6C
....................     spi_write(pageIndex); 
0C70:  MOVF   FC9,W
0C72:  MOVFF  1C7,FC9
0C76:  RRCF   FC7,W
0C78:  BNC   0C76
....................     spi_write(0); 
0C7A:  MOVF   FC9,W
0C7C:  CLRF   FC9
0C7E:  RRCF   FC7,W
0C80:  BNC   0C7E
....................     spi_write(0); 
0C82:  MOVF   FC9,W
0C84:  CLRF   FC9
0C86:  RRCF   FC7,W
0C88:  BNC   0C86
....................     spi_write(0); 
0C8A:  MOVF   FC9,W
0C8C:  CLRF   FC9
0C8E:  RRCF   FC7,W
0C90:  BNC   0C8E
....................     spi_write(0); 
0C92:  MOVF   FC9,W
0C94:  CLRF   FC9
0C96:  RRCF   FC7,W
0C98:  BNC   0C96
.................... 	flash_page_data = spi_read(0); 
0C9A:  MOVF   FC9,W
0C9C:  CLRF   FC9
0C9E:  RRCF   FC7,W
0CA0:  BNC   0C9E
0CA2:  MOVFF  FC9,185
.................... 	flash_page_data2 = spi_read(0); 
0CA6:  MOVF   FC9,W
0CA8:  CLRF   FC9
0CAA:  RRCF   FC7,W
0CAC:  BNC   0CAA
0CAE:  MOVFF  FC9,186
....................    	output_high(FLASH_CS); 
0CB2:  BCF    F94.2
0CB4:  BSF    F8B.2
.................... } 
0CB6:  RETLW  00
....................  
.................... void flash_block_erase() { 
....................    int8 i,j; 
....................    i=0xFF; 
*
14CC:  MOVLW  FF
14CE:  MOVLB  1
14D0:  MOVWF  xB4
....................    do 
....................    { 
....................    i++; 
14D2:  INCF   xB4,F
....................    flash_wait_until_ready(); 
14D4:  MOVLB  0
14D6:  CALL   08EC
....................    output_low(FLASH_CS); 
14DA:  BCF    F94.2
14DC:  BCF    F8B.2
....................    spi_write(0x50); 
14DE:  MOVF   FC9,W
14E0:  MOVLW  50
14E2:  MOVWF  FC9
14E4:  RRCF   FC7,W
14E6:  BNC   14E4
....................    j = i>>5; 
14E8:  MOVLB  1
14EA:  SWAPF  xB4,W
14EC:  MOVWF  xB5
14EE:  RRCF   xB5,F
14F0:  MOVLW  07
14F2:  ANDWF  xB5,F
....................    spi_write(j); 
14F4:  MOVF   FC9,W
14F6:  MOVFF  1B5,FC9
14FA:  RRCF   FC7,W
14FC:  BNC   14FA
....................    j = i<<3; 
14FE:  RLCF   xB4,W
1500:  MOVWF  xB5
1502:  RLCF   xB5,F
1504:  RLCF   xB5,F
1506:  MOVLW  F8
1508:  ANDWF  xB5,F
....................    spi_write(j); 
150A:  MOVF   FC9,W
150C:  MOVFF  1B5,FC9
1510:  RRCF   FC7,W
1512:  BNC   1510
....................    spi_write(0); 
1514:  MOVF   FC9,W
1516:  CLRF   FC9
1518:  RRCF   FC7,W
151A:  BNC   1518
....................    output_high(FLASH_CS); 
151C:  BCF    F94.2
151E:  BSF    F8B.2
....................    } while(i!=0xFF); 
1520:  INCFSZ xB4,W
1522:  BRA    14D2
....................    flash_wait_until_ready(); 
1524:  MOVLB  0
1526:  CALL   08EC
.................... } 
152A:  GOTO   3A0C (RETURN)
....................  
.................... void flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    flash_wait_until_ready(); 
....................    output_low(FLASH_CS); 
....................    delay_cycles(20); 
....................    spi_write(0x84); 
....................    spi_write(0); 
....................    spi_write(0); 
....................    spi_write(PageIndex); 
....................    if (nData>1) { 
....................    i=255; 
....................    do { 
....................       spi_write(data); 
....................       i++; 
....................    } while(i<nData); 
....................    } else 
....................          spi_write(data); 
....................    output_high(FLASH_CS); 
.................... } 
....................  
.................... void flash_buffer1_read(int8 PageIndex) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
1F48:  CALL   08EC
....................    output_low(FLASH_CS); 
1F4C:  BCF    F94.2
1F4E:  BCF    F8B.2
....................    delay_cycles(20); 
1F50:  MOVLW  06
1F52:  MOVWF  00
1F54:  DECFSZ 00,F
1F56:  BRA    1F54
1F58:  NOP   
....................    spi_write(0xD1); 
1F5A:  MOVF   FC9,W
1F5C:  MOVLW  D1
1F5E:  MOVWF  FC9
1F60:  RRCF   FC7,W
1F62:  BNC   1F60
....................    spi_write(0); 
1F64:  MOVF   FC9,W
1F66:  CLRF   FC9
1F68:  RRCF   FC7,W
1F6A:  BNC   1F68
....................    spi_write(0); 
1F6C:  MOVF   FC9,W
1F6E:  CLRF   FC9
1F70:  RRCF   FC7,W
1F72:  BNC   1F70
....................    spi_write(PageIndex); 
1F74:  MOVF   FC9,W
1F76:  MOVFF  1B6,FC9
1F7A:  RRCF   FC7,W
1F7C:  BNC   1F7A
....................    flash_page_data = spi_read(0); 
1F7E:  MOVF   FC9,W
1F80:  CLRF   FC9
1F82:  RRCF   FC7,W
1F84:  BNC   1F82
1F86:  MOVFF  FC9,185
....................    flash_page_data2 = spi_read(0); 
1F8A:  MOVF   FC9,W
1F8C:  CLRF   FC9
1F8E:  RRCF   FC7,W
1F90:  BNC   1F8E
1F92:  MOVFF  FC9,186
....................    output_high(FLASH_CS);    
1F96:  BCF    F94.2
1F98:  BSF    F8B.2
.................... } 
1F9A:  GOTO   347E (RETURN)
....................  
.................... void flash_set_256_page_size() { 
....................    flash_wait_until_ready(); 
*
23C2:  CALL   08EC
....................    output_low(FLASH_CS); 
23C6:  BCF    F94.2
23C8:  BCF    F8B.2
....................    delay_cycles(20); 
23CA:  MOVLW  06
23CC:  MOVWF  00
23CE:  DECFSZ 00,F
23D0:  BRA    23CE
23D2:  NOP   
....................    spi_write(0x3D); 
23D4:  MOVF   FC9,W
23D6:  MOVLW  3D
23D8:  MOVWF  FC9
23DA:  RRCF   FC7,W
23DC:  BNC   23DA
....................    spi_write(0x2A); 
23DE:  MOVF   FC9,W
23E0:  MOVLW  2A
23E2:  MOVWF  FC9
23E4:  RRCF   FC7,W
23E6:  BNC   23E4
....................    spi_write(0x80); 
23E8:  MOVF   FC9,W
23EA:  MOVLW  80
23EC:  MOVWF  FC9
23EE:  RRCF   FC7,W
23F0:  BNC   23EE
....................    spi_write(0xA6); 
23F2:  MOVF   FC9,W
23F4:  MOVLW  A6
23F6:  MOVWF  FC9
23F8:  RRCF   FC7,W
23FA:  BNC   23F8
....................    output_high(FLASH_CS);  
23FC:  BCF    F94.2
23FE:  BSF    F8B.2
.................... } 
2400:  GOTO   3A0C (RETURN)
....................  
.................... void flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    flash_wait_until_ready(); 
*
16FA:  CALL   08EC
....................    output_low(FLASH_CS); 
16FE:  BCF    F94.2
1700:  BCF    F8B.2
....................    delay_cycles(20);	 
1702:  MOVLW  06
1704:  MOVWF  00
1706:  DECFSZ 00,F
1708:  BRA    1706
170A:  NOP   
....................    spi_write(0x83); 
170C:  MOVF   FC9,W
170E:  MOVLW  83
1710:  MOVWF  FC9
1712:  RRCF   FC7,W
1714:  BNC   1712
....................    spi_write(make8(pageAddress,1)); 
1716:  MOVFF  1B7,1B8
171A:  MOVF   FC9,W
171C:  MOVFF  1B7,FC9
1720:  RRCF   FC7,W
1722:  BNC   1720
....................    spi_write(make8(pageAddress,0)); 
1724:  MOVFF  1B6,1B8
1728:  MOVF   FC9,W
172A:  MOVFF  1B6,FC9
172E:  RRCF   FC7,W
1730:  BNC   172E
....................    spi_write(0); 
1732:  MOVF   FC9,W
1734:  CLRF   FC9
1736:  RRCF   FC7,W
1738:  BNC   1736
....................    output_high(FLASH_CS); 
173A:  BCF    F94.2
173C:  BSF    F8B.2
.................... } 
173E:  GOTO   327C (RETURN)
....................  
.................... void flash_write_page(int16 pageAddress) { 
....................    int8 i,check_sum; 
....................    char input_data; 
....................    disable_interrupts(GLOBAL); 
*
1780:  BCF    FF2.6
1782:  BCF    FF2.7
1784:  BTFSC  FF2.7
1786:  BRA    1782
....................    output_high(FLASH_CS); 
1788:  BCF    F94.2
178A:  BSF    F8B.2
....................    flash_wait_until_ready(); 
178C:  CALL   08EC
....................    output_low(FLASH_CS); 
1790:  BCF    F94.2
1792:  BCF    F8B.2
....................    if (pageAddress%2) spi_write(0x82); else spi_write(0x85); 
1794:  MOVLB  1
1796:  MOVF   xB6,W
1798:  ANDLW  01
179A:  MOVWF  00
179C:  CLRF   03
179E:  MOVF   00,W
17A0:  IORWF  03,W
17A2:  BZ    17B0
17A4:  MOVF   FC9,W
17A6:  MOVLW  82
17A8:  MOVWF  FC9
17AA:  RRCF   FC7,W
17AC:  BNC   17AA
17AE:  BRA    17BA
17B0:  MOVF   FC9,W
17B2:  MOVLW  85
17B4:  MOVWF  FC9
17B6:  RRCF   FC7,W
17B8:  BNC   17B6
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    spi_write(make8(pageAddress,1)); 
17BA:  MOVFF  1B7,1BB
17BE:  MOVF   FC9,W
17C0:  MOVFF  1B7,FC9
17C4:  RRCF   FC7,W
17C6:  BNC   17C4
....................    spi_write(make8(pageAddress,0)); 
17C8:  MOVFF  1B6,1BB
17CC:  MOVF   FC9,W
17CE:  MOVFF  1B6,FC9
17D2:  RRCF   FC7,W
17D4:  BNC   17D2
....................    spi_write(0); 
17D6:  MOVF   FC9,W
17D8:  CLRF   FC9
17DA:  RRCF   FC7,W
17DC:  BNC   17DA
....................    check_sum=0; 
17DE:  CLRF   xB9
....................    i=0xFF; 
17E0:  MOVLW  FF
17E2:  MOVWF  xB8
....................    check_sum=0xCC; 
17E4:  MOVLW  CC
17E6:  MOVWF  xB9
....................    do { 
....................       input_data = getc(); 
17E8:  BTFSS  F9E.5
17EA:  BRA    17E8
17EC:  MOVFF  FAE,1BA
....................       check_sum ^= input_data; 
17F0:  MOVF   xBA,W
17F2:  XORWF  xB9,F
....................       spi_write(input_data); 
17F4:  MOVF   FC9,W
17F6:  MOVFF  1BA,FC9
17FA:  RRCF   FC7,W
17FC:  BNC   17FA
....................       i++; 
17FE:  INCF   xB8,F
....................    } while(i!=0xFF); 
1800:  INCFSZ xB8,W
1802:  BRA    17E8
....................    output_high(FLASH_CS); 
1804:  BCF    F94.2
1806:  BSF    F8B.2
....................    enable_interrupts(GLOBAL); 
1808:  MOVLW  C0
180A:  IORWF  FF2,F
.................... } 
180C:  MOVLB  0
180E:  GOTO   33C8 (RETURN)
....................  
.................... void flash_read_main_memory_to_buffer1(int16 pageAddress) { 
....................    flash_wait_until_ready(); 
*
1742:  CALL   08EC
....................    output_low(FLASH_CS); 
1746:  BCF    F94.2
1748:  BCF    F8B.2
....................    spi_write(0x53); 
174A:  MOVF   FC9,W
174C:  MOVLW  53
174E:  MOVWF  FC9
1750:  RRCF   FC7,W
1752:  BNC   1750
....................    spi_write(make8(pageAddress,1)); 
1754:  MOVFF  1B7,1B8
1758:  MOVF   FC9,W
175A:  MOVFF  1B7,FC9
175E:  RRCF   FC7,W
1760:  BNC   175E
....................    spi_write(make8(pageAddress,0)); 
1762:  MOVFF  1B6,1B8
1766:  MOVF   FC9,W
1768:  MOVFF  1B6,FC9
176C:  RRCF   FC7,W
176E:  BNC   176C
....................    spi_write(0); 
1770:  MOVF   FC9,W
1772:  CLRF   FC9
1774:  RRCF   FC7,W
1776:  BNC   1774
....................    output_high(FLASH_CS); 
1778:  BCF    F94.2
177A:  BSF    F8B.2
.................... } 
177C:  GOTO   332E (RETURN)
....................  
....................  
.................... void print_date_time() { 
....................  
.................... 	  printf("\r\n Day#%lu, ",nDay); 
*
1C3E:  MOVLB  1
1C40:  CLRF   xB4
1C42:  MOVF   xB4,W
1C44:  MOVLB  0
1C46:  CALL   00AA
1C4A:  MOVLB  1
1C4C:  INCF   xB4,F
1C4E:  MOVWF  00
1C50:  MOVF   00,W
1C52:  BTFSS  F9E.4
1C54:  BRA    1C52
1C56:  MOVWF  FAD
1C58:  MOVLW  07
1C5A:  SUBWF  xB4,W
1C5C:  BNZ   1C42
1C5E:  MOVLW  41
1C60:  MOVWF  FE9
1C62:  MOVFF  31,1B8
1C66:  MOVFF  30,1B7
1C6A:  MOVFF  2F,1B6
1C6E:  MOVFF  2E,1B5
1C72:  MOVLB  0
1C74:  BRA    1812
1C76:  MOVLW  2C
1C78:  BTFSS  F9E.4
1C7A:  BRA    1C78
1C7C:  MOVWF  FAD
1C7E:  MOVLW  20
1C80:  BTFSS  F9E.4
1C82:  BRA    1C80
1C84:  MOVWF  FAD
....................       strcpy(tmp_str,"00:00:00"); 
1C86:  MOVLW  01
1C88:  MOVWF  FEA
1C8A:  MOVLW  56
1C8C:  MOVWF  FE9
1C8E:  MOVFF  FF2,1B4
1C92:  BCF    FF2.7
1C94:  MOVLW  00
1C96:  CALL   00D2
1C9A:  TBLRD*-
1C9C:  TBLRD*+
1C9E:  MOVF   FF5,W
1CA0:  MOVWF  FEE
1CA2:  IORLW  00
1CA4:  BNZ   1C9C
1CA6:  MOVLB  1
1CA8:  BTFSC  xB4.7
1CAA:  BSF    FF2.7
1CAC:  CLRF   18
1CAE:  BTFSC  FF2.7
1CB0:  BSF    18.7
1CB2:  BCF    FF2.7
....................       itoa((int8) (timer_sec/3600),10,tmp_str2); 
1CB4:  MOVFF  25,1C7
1CB8:  MOVFF  24,1C6
1CBC:  MOVFF  23,1C5
1CC0:  MOVFF  22,1C4
1CC4:  CLRF   xCB
1CC6:  CLRF   xCA
1CC8:  MOVLW  0E
1CCA:  MOVWF  xC9
1CCC:  MOVLW  10
1CCE:  MOVWF  xC8
1CD0:  MOVLB  0
1CD2:  CALL   04A2
1CD6:  BTFSC  18.7
1CD8:  BSF    FF2.7
1CDA:  MOVFF  00,1B4
1CDE:  MOVLB  1
1CE0:  CLRF   xBD
1CE2:  CLRF   xBC
1CE4:  CLRF   xBB
1CE6:  MOVFF  00,1BA
1CEA:  MOVLW  0A
1CEC:  MOVWF  xBE
1CEE:  MOVLW  01
1CF0:  MOVWF  xC0
1CF2:  MOVLW  6A
1CF4:  MOVWF  xBF
1CF6:  MOVLB  0
1CF8:  RCALL  1A20
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1CFA:  MOVLW  01
1CFC:  MOVLB  1
1CFE:  MOVWF  xB7
1D00:  MOVLW  6A
1D02:  MOVWF  xB6
1D04:  MOVLB  0
1D06:  RCALL  1C04
1D08:  MOVF   01,W
1D0A:  SUBLW  02
1D0C:  BNC   1D60
1D0E:  MOVLW  01
1D10:  MOVLB  1
1D12:  MOVWF  xB7
1D14:  MOVLW  6A
1D16:  MOVWF  xB6
1D18:  MOVLB  0
1D1A:  RCALL  1C04
1D1C:  MOVLW  58
1D1E:  BSF    FD8.0
1D20:  SUBFWB 01,W
1D22:  MOVLB  1
1D24:  MOVWF  xB4
1D26:  MOVLW  01
1D28:  BTFSS  FD8.0
1D2A:  DECF   FE8,F
1D2C:  MOVWF  xB5
1D2E:  MOVLW  01
1D30:  MOVWF  xB7
1D32:  MOVLW  6A
1D34:  MOVWF  xB6
1D36:  MOVLB  0
1D38:  RCALL  1C04
1D3A:  MOVFF  01,1B6
1D3E:  MOVFF  1B5,FEA
1D42:  MOVFF  1B4,FE9
1D46:  MOVLW  01
1D48:  MOVWF  FE2
1D4A:  MOVLW  6A
1D4C:  MOVWF  FE1
1D4E:  MOVLB  1
1D50:  MOVF   01,W
1D52:  MOVWF  01
1D54:  BZ    1D5E
1D56:  MOVFF  FE6,FEE
1D5A:  DECFSZ 01,F
1D5C:  BRA    1D56
1D5E:  MOVLB  0
1D60:  CLRF   18
1D62:  BTFSC  FF2.7
1D64:  BSF    18.7
1D66:  BCF    FF2.7
....................       itoa((int8) ((timer_sec%3600)/60),10,tmp_str2); 
1D68:  MOVFF  25,1C7
1D6C:  MOVFF  24,1C6
1D70:  MOVFF  23,1C5
1D74:  MOVFF  22,1C4
1D78:  MOVLB  1
1D7A:  CLRF   xCB
1D7C:  CLRF   xCA
1D7E:  MOVLW  0E
1D80:  MOVWF  xC9
1D82:  MOVLW  10
1D84:  MOVWF  xC8
1D86:  MOVLB  0
1D88:  CALL   04A2
1D8C:  BTFSC  18.7
1D8E:  BSF    FF2.7
1D90:  MOVFF  FEF,1B4
1D94:  MOVFF  FEC,1B5
1D98:  MOVFF  FEC,1B6
1D9C:  MOVFF  FEC,1B7
1DA0:  MOVFF  FEA,1B9
1DA4:  MOVFF  FE9,1B8
1DA8:  CLRF   18
1DAA:  BTFSC  FF2.7
1DAC:  BSF    18.7
1DAE:  BCF    FF2.7
1DB0:  MOVFF  1B7,1C7
1DB4:  MOVFF  1B6,1C6
1DB8:  MOVFF  1B5,1C5
1DBC:  MOVFF  1B4,1C4
1DC0:  MOVLB  1
1DC2:  CLRF   xCB
1DC4:  CLRF   xCA
1DC6:  CLRF   xC9
1DC8:  MOVLW  3C
1DCA:  MOVWF  xC8
1DCC:  MOVLB  0
1DCE:  CALL   04A2
1DD2:  BTFSC  18.7
1DD4:  BSF    FF2.7
1DD6:  MOVFF  1B9,FEA
1DDA:  MOVFF  1B8,FE9
1DDE:  MOVFF  00,1B5
1DE2:  MOVLB  1
1DE4:  CLRF   xBD
1DE6:  CLRF   xBC
1DE8:  CLRF   xBB
1DEA:  MOVFF  00,1BA
1DEE:  MOVLW  0A
1DF0:  MOVWF  xBE
1DF2:  MOVLW  01
1DF4:  MOVWF  xC0
1DF6:  MOVLW  6A
1DF8:  MOVWF  xBF
1DFA:  MOVLB  0
1DFC:  RCALL  1A20
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1DFE:  MOVLW  01
1E00:  MOVLB  1
1E02:  MOVWF  xB7
1E04:  MOVLW  6A
1E06:  MOVWF  xB6
1E08:  MOVLB  0
1E0A:  RCALL  1C04
1E0C:  MOVF   01,W
1E0E:  SUBLW  02
1E10:  BNC   1E64
1E12:  MOVLW  01
1E14:  MOVLB  1
1E16:  MOVWF  xB7
1E18:  MOVLW  6A
1E1A:  MOVWF  xB6
1E1C:  MOVLB  0
1E1E:  RCALL  1C04
1E20:  MOVLW  5B
1E22:  BSF    FD8.0
1E24:  SUBFWB 01,W
1E26:  MOVLB  1
1E28:  MOVWF  xB4
1E2A:  MOVLW  01
1E2C:  BTFSS  FD8.0
1E2E:  DECF   FE8,F
1E30:  MOVWF  xB5
1E32:  MOVLW  01
1E34:  MOVWF  xB7
1E36:  MOVLW  6A
1E38:  MOVWF  xB6
1E3A:  MOVLB  0
1E3C:  RCALL  1C04
1E3E:  MOVFF  01,1B6
1E42:  MOVFF  1B5,FEA
1E46:  MOVFF  1B4,FE9
1E4A:  MOVLW  01
1E4C:  MOVWF  FE2
1E4E:  MOVLW  6A
1E50:  MOVWF  FE1
1E52:  MOVLB  1
1E54:  MOVF   01,W
1E56:  MOVWF  01
1E58:  BZ    1E62
1E5A:  MOVFF  FE6,FEE
1E5E:  DECFSZ 01,F
1E60:  BRA    1E5A
1E62:  MOVLB  0
1E64:  CLRF   18
1E66:  BTFSC  FF2.7
1E68:  BSF    18.7
1E6A:  BCF    FF2.7
....................       itoa((int8) (timer_sec%60),10,tmp_str2); 
1E6C:  MOVFF  25,1C7
1E70:  MOVFF  24,1C6
1E74:  MOVFF  23,1C5
1E78:  MOVFF  22,1C4
1E7C:  MOVLB  1
1E7E:  CLRF   xCB
1E80:  CLRF   xCA
1E82:  CLRF   xC9
1E84:  MOVLW  3C
1E86:  MOVWF  xC8
1E88:  MOVLB  0
1E8A:  CALL   04A2
1E8E:  BTFSC  18.7
1E90:  BSF    FF2.7
1E92:  MOVFF  FEF,00
1E96:  MOVFF  FEC,01
1E9A:  MOVFF  FEC,02
1E9E:  MOVFF  FEC,03
1EA2:  MOVFF  00,1B4
1EA6:  MOVLB  1
1EA8:  CLRF   xBD
1EAA:  CLRF   xBC
1EAC:  CLRF   xBB
1EAE:  MOVFF  00,1BA
1EB2:  MOVLW  0A
1EB4:  MOVWF  xBE
1EB6:  MOVLW  01
1EB8:  MOVWF  xC0
1EBA:  MOVLW  6A
1EBC:  MOVWF  xBF
1EBE:  MOVLB  0
1EC0:  RCALL  1A20
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1EC2:  MOVLW  01
1EC4:  MOVLB  1
1EC6:  MOVWF  xB7
1EC8:  MOVLW  6A
1ECA:  MOVWF  xB6
1ECC:  MOVLB  0
1ECE:  RCALL  1C04
1ED0:  MOVF   01,W
1ED2:  SUBLW  02
1ED4:  BNC   1F28
1ED6:  MOVLW  01
1ED8:  MOVLB  1
1EDA:  MOVWF  xB7
1EDC:  MOVLW  6A
1EDE:  MOVWF  xB6
1EE0:  MOVLB  0
1EE2:  RCALL  1C04
1EE4:  MOVLW  5E
1EE6:  BSF    FD8.0
1EE8:  SUBFWB 01,W
1EEA:  MOVLB  1
1EEC:  MOVWF  xB4
1EEE:  MOVLW  01
1EF0:  BTFSS  FD8.0
1EF2:  DECF   FE8,F
1EF4:  MOVWF  xB5
1EF6:  MOVLW  01
1EF8:  MOVWF  xB7
1EFA:  MOVLW  6A
1EFC:  MOVWF  xB6
1EFE:  MOVLB  0
1F00:  RCALL  1C04
1F02:  MOVFF  01,1B6
1F06:  MOVFF  1B5,FEA
1F0A:  MOVFF  1B4,FE9
1F0E:  MOVLW  01
1F10:  MOVWF  FE2
1F12:  MOVLW  6A
1F14:  MOVWF  FE1
1F16:  MOVLB  1
1F18:  MOVF   01,W
1F1A:  MOVWF  01
1F1C:  BZ    1F26
1F1E:  MOVFF  FE6,FEE
1F22:  DECFSZ 01,F
1F24:  BRA    1F1E
1F26:  MOVLB  0
....................    	  printf("%s",tmp_str); 
1F28:  MOVLW  01
1F2A:  MOVWF  FEA
1F2C:  MOVLW  56
1F2E:  MOVWF  FE9
1F30:  MOVLW  00
1F32:  IORWF  FEF,W
1F34:  BZ    1F46
1F36:  MOVF   FEF,W
1F38:  BTFSS  F9E.4
1F3A:  BRA    1F38
1F3C:  MOVWF  FAD
1F3E:  INCF   FE9,F
1F40:  BTFSC  FD8.2
1F42:  INCF   FEA,F
1F44:  BRA    1F30
.................... } 
1F46:  RETLW  00
....................  
.................... void print_page_data(int16 nPage) { 
....................     int8 i; 
....................     int8 j; 
....................     for(i=0;i<16;i++) { 
*
1656:  MOVLB  1
1658:  CLRF   xB8
165A:  MOVF   xB8,W
165C:  SUBLW  0F
165E:  BNC   16F4
....................       printf("\r\n%02X : ",i); 
1660:  MOVLW  0D
1662:  BTFSS  F9E.4
1664:  BRA    1662
1666:  MOVWF  FAD
1668:  MOVLW  0A
166A:  BTFSS  F9E.4
166C:  BRA    166A
166E:  MOVWF  FAD
1670:  MOVFF  1B8,1BA
1674:  MOVLW  37
1676:  MOVWF  xBB
1678:  MOVLB  0
167A:  RCALL  1610
167C:  MOVLW  20
167E:  BTFSS  F9E.4
1680:  BRA    167E
1682:  MOVWF  FAD
1684:  MOVLW  3A
1686:  BTFSS  F9E.4
1688:  BRA    1686
168A:  MOVWF  FAD
168C:  MOVLW  20
168E:  BTFSS  F9E.4
1690:  BRA    168E
1692:  MOVWF  FAD
....................       for (j=0;j<8;j++) { 
1694:  MOVLB  1
1696:  CLRF   xB9
1698:  MOVF   xB9,W
169A:  SUBLW  07
169C:  BNC   16F0
....................         flash_read_page(nPage,i*16+j*2); 
169E:  MOVF   xB8,W
16A0:  MULLW  10
16A2:  MOVFF  FF3,1BA
16A6:  BCF    FD8.0
16A8:  RLCF   xB9,W
16AA:  ADDWF  xBA,W
16AC:  MOVWF  xBB
16AE:  MOVFF  1B7,1C6
16B2:  MOVFF  1B6,1C5
16B6:  MOVWF  xC7
16B8:  MOVLB  0
16BA:  CALL   0C3A
.................... 		printf("%02X %02X ",flash_page_data,flash_page_data2); 
16BE:  MOVFF  185,1BA
16C2:  MOVLW  37
16C4:  MOVLB  1
16C6:  MOVWF  xBB
16C8:  MOVLB  0
16CA:  RCALL  1610
16CC:  MOVLW  20
16CE:  BTFSS  F9E.4
16D0:  BRA    16CE
16D2:  MOVWF  FAD
16D4:  MOVFF  186,1BA
16D8:  MOVLW  37
16DA:  MOVLB  1
16DC:  MOVWF  xBB
16DE:  MOVLB  0
16E0:  RCALL  1610
16E2:  MOVLW  20
16E4:  BTFSS  F9E.4
16E6:  BRA    16E4
16E8:  MOVWF  FAD
.................... 	  } 
16EA:  MOVLB  1
16EC:  INCF   xB9,F
16EE:  BRA    1698
....................    } 
16F0:  INCF   xB8,F
16F2:  BRA    165A
.................... } 
16F4:  MOVLB  0
16F6:  GOTO   31E0 (RETURN)
....................  
.................... void solar_load_parameter_from_flash() { 
....................     flash_read_page(0,0x4E);  
*
0CB8:  MOVLB  1
0CBA:  CLRF   xC6
0CBC:  CLRF   xC5
0CBE:  MOVLW  4E
0CC0:  MOVWF  xC7
0CC2:  MOVLB  0
0CC4:  RCALL  0C3A
.................... 	act_min_stroke = make16(flash_page_data2,flash_page_data); 
0CC6:  MOVFF  186,1A4
0CCA:  MOVFF  185,1A3
....................     flash_read_page(0,0x50);  
0CCE:  MOVLB  1
0CD0:  CLRF   xC6
0CD2:  CLRF   xC5
0CD4:  MOVLW  50
0CD6:  MOVWF  xC7
0CD8:  MOVLB  0
0CDA:  RCALL  0C3A
.................... 	act_max_stroke = make16(flash_page_data2,flash_page_data); 
0CDC:  MOVFF  186,1A2
0CE0:  MOVFF  185,1A1
....................     flash_read_page(0,0x56);  
0CE4:  MOVLB  1
0CE6:  CLRF   xC6
0CE8:  CLRF   xC5
0CEA:  MOVLW  56
0CEC:  MOVWF  xC7
0CEE:  MOVLB  0
0CF0:  RCALL  0C3A
.................... 	latitude = make16(flash_page_data2,flash_page_data); 
0CF2:  MOVFF  186,1A8
0CF6:  MOVFF  185,1A7
....................     flash_read_page(0,0x58);  
0CFA:  MOVLB  1
0CFC:  CLRF   xC6
0CFE:  CLRF   xC5
0D00:  MOVLW  58
0D02:  MOVWF  xC7
0D04:  MOVLB  0
0D06:  RCALL  0C3A
.................... 	longitude = make16(flash_page_data2,flash_page_data); 
0D08:  MOVFF  186,1AA
0D0C:  MOVFF  185,1A9
....................     flash_read_page(0,0x5A);  
0D10:  MOVLB  1
0D12:  CLRF   xC6
0D14:  CLRF   xC5
0D16:  MOVLW  5A
0D18:  MOVWF  xC7
0D1A:  MOVLB  0
0D1C:  RCALL  0C3A
.................... 	altitude = make16(flash_page_data2,flash_page_data);	 
0D1E:  MOVFF  186,1AC
0D22:  MOVFF  185,1AB
....................     flash_read_page(0,0x5C);  
0D26:  MOVLB  1
0D28:  CLRF   xC6
0D2A:  CLRF   xC5
0D2C:  MOVLW  5C
0D2E:  MOVWF  xC7
0D30:  MOVLB  0
0D32:  RCALL  0C3A
.................... 	act_safety_stroke = make16(flash_page_data2,flash_page_data); 
0D34:  MOVFF  186,1A6
0D38:  MOVFF  185,1A5
.................... } 
0D3C:  GOTO   0E88 (RETURN)
....................  
.................... void print_fw_info() { 
....................     int8 i,j; 
.................... 	disable_interrupts(GLOBAL); 
*
0DEA:  BCF    FF2.6
0DEC:  BCF    FF2.7
0DEE:  BTFSC  FF2.7
0DF0:  BRA    0DEC
....................     for (i=0;i<4;i++) { 
0DF2:  MOVLB  1
0DF4:  CLRF   xB4
0DF6:  MOVF   xB4,W
0DF8:  SUBLW  03
0DFA:  BNC   0E48
....................         printf("\r\n"); 
0DFC:  MOVLW  0D
0DFE:  BTFSS  F9E.4
0E00:  BRA    0DFE
0E02:  MOVWF  FAD
0E04:  MOVLW  0A
0E06:  BTFSS  F9E.4
0E08:  BRA    0E06
0E0A:  MOVWF  FAD
.................... 		for (j=0;j<8;j++) { 
0E0C:  CLRF   xB5
0E0E:  MOVF   xB5,W
0E10:  SUBLW  07
0E12:  BNC   0E44
....................     		flash_read_page(0,i*16+j*2); 
0E14:  MOVF   xB4,W
0E16:  MULLW  10
0E18:  MOVFF  FF3,1B6
0E1C:  BCF    FD8.0
0E1E:  RLCF   xB5,W
0E20:  ADDWF  xB6,W
0E22:  MOVWF  xB7
0E24:  CLRF   xC6
0E26:  CLRF   xC5
0E28:  MOVWF  xC7
0E2A:  MOVLB  0
0E2C:  RCALL  0C3A
.................... 			printf("%c%c",flash_page_data,flash_page_data2); 
0E2E:  MOVLB  1
0E30:  MOVF   x85,W
0E32:  BTFSS  F9E.4
0E34:  BRA    0E32
0E36:  MOVWF  FAD
0E38:  MOVF   x86,W
0E3A:  BTFSS  F9E.4
0E3C:  BRA    0E3A
0E3E:  MOVWF  FAD
.................... 		} 
0E40:  INCF   xB5,F
0E42:  BRA    0E0E
.................... 	} 
0E44:  INCF   xB4,F
0E46:  BRA    0DF6
.................... 	flash_read_page(0,0x40); 
0E48:  CLRF   xC6
0E4A:  CLRF   xC5
0E4C:  MOVLW  40
0E4E:  MOVWF  xC7
0E50:  MOVLB  0
0E52:  RCALL  0C3A
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
0E54:  MOVLB  1
0E56:  MOVF   x85,W
0E58:  BTFSS  F9E.4
0E5A:  BRA    0E58
0E5C:  MOVWF  FAD
0E5E:  MOVF   x86,W
0E60:  BTFSS  F9E.4
0E62:  BRA    0E60
0E64:  MOVWF  FAD
....................   	flash_read_page(0,0x42); 
0E66:  CLRF   xC6
0E68:  CLRF   xC5
0E6A:  MOVLW  42
0E6C:  MOVWF  xC7
0E6E:  MOVLB  0
0E70:  RCALL  0C3A
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
0E72:  MOVLB  1
0E74:  MOVF   x85,W
0E76:  BTFSS  F9E.4
0E78:  BRA    0E76
0E7A:  MOVWF  FAD
0E7C:  MOVF   x86,W
0E7E:  BTFSS  F9E.4
0E80:  BRA    0E7E
0E82:  MOVWF  FAD
....................     solar_load_parameter_from_flash(); 
0E84:  MOVLB  0
0E86:  BRA    0CB8
.................... 	printf("\r\n Min Stroke=%lu/256 cm",act_min_stroke); 
0E88:  MOVLB  1
0E8A:  CLRF   xB6
0E8C:  MOVF   xB6,W
0E8E:  MOVLB  0
0E90:  CALL   00F6
0E94:  MOVLB  1
0E96:  INCF   xB6,F
0E98:  MOVWF  00
0E9A:  MOVF   00,W
0E9C:  BTFSS  F9E.4
0E9E:  BRA    0E9C
0EA0:  MOVWF  FAD
0EA2:  MOVLW  0E
0EA4:  SUBWF  xB6,W
0EA6:  BNZ   0E8C
0EA8:  MOVLW  10
0EAA:  MOVWF  FE9
0EAC:  MOVFF  1A4,1BC
0EB0:  MOVFF  1A3,1BB
0EB4:  MOVLB  0
0EB6:  RCALL  0D40
0EB8:  MOVLW  11
0EBA:  MOVLB  1
0EBC:  MOVWF  xB7
0EBE:  MOVF   xB7,W
0EC0:  MOVLB  0
0EC2:  CALL   00F6
0EC6:  MOVLB  1
0EC8:  INCF   xB7,F
0ECA:  MOVWF  00
0ECC:  MOVF   00,W
0ECE:  BTFSS  F9E.4
0ED0:  BRA    0ECE
0ED2:  MOVWF  FAD
0ED4:  MOVLW  18
0ED6:  SUBWF  xB7,W
0ED8:  BNZ   0EBE
.................... 	printf("\r\n Max Stroke=%lu/256 cm",act_max_stroke); 
0EDA:  CLRF   xB6
0EDC:  MOVF   xB6,W
0EDE:  MOVLB  0
0EE0:  CALL   012A
0EE4:  MOVLB  1
0EE6:  INCF   xB6,F
0EE8:  MOVWF  00
0EEA:  MOVF   00,W
0EEC:  BTFSS  F9E.4
0EEE:  BRA    0EEC
0EF0:  MOVWF  FAD
0EF2:  MOVLW  0E
0EF4:  SUBWF  xB6,W
0EF6:  BNZ   0EDC
0EF8:  MOVLW  10
0EFA:  MOVWF  FE9
0EFC:  MOVFF  1A2,1BC
0F00:  MOVFF  1A1,1BB
0F04:  MOVLB  0
0F06:  RCALL  0D40
0F08:  MOVLW  11
0F0A:  MOVLB  1
0F0C:  MOVWF  xB7
0F0E:  MOVF   xB7,W
0F10:  MOVLB  0
0F12:  CALL   012A
0F16:  MOVLB  1
0F18:  INCF   xB7,F
0F1A:  MOVWF  00
0F1C:  MOVF   00,W
0F1E:  BTFSS  F9E.4
0F20:  BRA    0F1E
0F22:  MOVWF  FAD
0F24:  MOVLW  18
0F26:  SUBWF  xB7,W
0F28:  BNZ   0F0E
.................... 	printf("\r\n Safty Stroke=%lu/256 cm",act_safety_stroke); 
0F2A:  CLRF   xB6
0F2C:  MOVF   xB6,W
0F2E:  MOVLB  0
0F30:  CALL   015E
0F34:  MOVLB  1
0F36:  INCF   xB6,F
0F38:  MOVWF  00
0F3A:  MOVF   00,W
0F3C:  BTFSS  F9E.4
0F3E:  BRA    0F3C
0F40:  MOVWF  FAD
0F42:  MOVLW  10
0F44:  SUBWF  xB6,W
0F46:  BNZ   0F2C
0F48:  MOVLW  10
0F4A:  MOVWF  FE9
0F4C:  MOVFF  1A6,1BC
0F50:  MOVFF  1A5,1BB
0F54:  MOVLB  0
0F56:  RCALL  0D40
0F58:  MOVLW  13
0F5A:  MOVLB  1
0F5C:  MOVWF  xB7
0F5E:  MOVF   xB7,W
0F60:  MOVLB  0
0F62:  CALL   015E
0F66:  MOVLB  1
0F68:  INCF   xB7,F
0F6A:  MOVWF  00
0F6C:  MOVF   00,W
0F6E:  BTFSS  F9E.4
0F70:  BRA    0F6E
0F72:  MOVWF  FAD
0F74:  MOVLW  1A
0F76:  SUBWF  xB7,W
0F78:  BNZ   0F5E
.................... 	printf("\r\n Latitude=%lu/100",latitude); 
0F7A:  CLRF   xB6
0F7C:  MOVF   xB6,W
0F7E:  MOVLB  0
0F80:  CALL   0194
0F84:  MOVLB  1
0F86:  INCF   xB6,F
0F88:  MOVWF  00
0F8A:  MOVF   00,W
0F8C:  BTFSS  F9E.4
0F8E:  BRA    0F8C
0F90:  MOVWF  FAD
0F92:  MOVLW  0C
0F94:  SUBWF  xB6,W
0F96:  BNZ   0F7C
0F98:  MOVLW  10
0F9A:  MOVWF  FE9
0F9C:  MOVFF  1A8,1BC
0FA0:  MOVFF  1A7,1BB
0FA4:  MOVLB  0
0FA6:  RCALL  0D40
0FA8:  MOVLW  0F
0FAA:  MOVLB  1
0FAC:  MOVWF  xB7
0FAE:  MOVF   xB7,W
0FB0:  MOVLB  0
0FB2:  CALL   0194
0FB6:  MOVLB  1
0FB8:  INCF   xB7,F
0FBA:  MOVWF  00
0FBC:  MOVF   00,W
0FBE:  BTFSS  F9E.4
0FC0:  BRA    0FBE
0FC2:  MOVWF  FAD
0FC4:  MOVLW  13
0FC6:  SUBWF  xB7,W
0FC8:  BNZ   0FAE
.................... 	printf("\r\n Longitude=%lu/100",longitude); 
0FCA:  CLRF   xB6
0FCC:  MOVF   xB6,W
0FCE:  MOVLB  0
0FD0:  CALL   01C2
0FD4:  MOVLB  1
0FD6:  INCF   xB6,F
0FD8:  MOVWF  00
0FDA:  MOVF   00,W
0FDC:  BTFSS  F9E.4
0FDE:  BRA    0FDC
0FE0:  MOVWF  FAD
0FE2:  MOVLW  0D
0FE4:  SUBWF  xB6,W
0FE6:  BNZ   0FCC
0FE8:  MOVLW  10
0FEA:  MOVWF  FE9
0FEC:  MOVFF  1AA,1BC
0FF0:  MOVFF  1A9,1BB
0FF4:  MOVLB  0
0FF6:  RCALL  0D40
0FF8:  MOVLW  10
0FFA:  MOVLB  1
0FFC:  MOVWF  xB7
0FFE:  MOVF   xB7,W
1000:  MOVLB  0
1002:  CALL   01C2
1006:  MOVLB  1
1008:  INCF   xB7,F
100A:  MOVWF  00
100C:  MOVF   00,W
100E:  BTFSS  F9E.4
1010:  BRA    100E
1012:  MOVWF  FAD
1014:  MOVLW  14
1016:  SUBWF  xB7,W
1018:  BNZ   0FFE
.................... 	printf("\r\n Altitude =%lu/100",altitude); 
101A:  CLRF   xB6
101C:  MOVF   xB6,W
101E:  MOVLB  0
1020:  CALL   01F2
1024:  MOVLB  1
1026:  INCF   xB6,F
1028:  MOVWF  00
102A:  MOVF   00,W
102C:  BTFSS  F9E.4
102E:  BRA    102C
1030:  MOVWF  FAD
1032:  MOVLW  0D
1034:  SUBWF  xB6,W
1036:  BNZ   101C
1038:  MOVLW  10
103A:  MOVWF  FE9
103C:  MOVFF  1AC,1BC
1040:  MOVFF  1AB,1BB
1044:  MOVLB  0
1046:  RCALL  0D40
1048:  MOVLW  10
104A:  MOVLB  1
104C:  MOVWF  xB7
104E:  MOVF   xB7,W
1050:  MOVLB  0
1052:  CALL   01F2
1056:  MOVLB  1
1058:  INCF   xB7,F
105A:  MOVWF  00
105C:  MOVF   00,W
105E:  BTFSS  F9E.4
1060:  BRA    105E
1062:  MOVWF  FAD
1064:  MOVLW  14
1066:  SUBWF  xB7,W
1068:  BNZ   104E
.................... 	enable_interrupts(GLOBAL); 
106A:  MOVLW  C0
106C:  IORWF  FF2,F
....................  
.................... } 
106E:  MOVLB  0
1070:  RETLW  00
....................  
.................... void display_LED() { 
.................... 	portd.data_bus=LED_status; 
*
0542:  MOVF   21,W
0544:  ANDLW  0F
0546:  MOVWF  00
0548:  MOVLW  F0
054A:  ANDWF  F83,W
054C:  IORWF  00,W
054E:  MOVWF  F83
.................... 	delay_cycles(20); 
0550:  MOVLW  06
0552:  MOVWF  00
0554:  DECFSZ 00,F
0556:  BRA    0554
0558:  NOP   
.................... 	portd.LED_latch=1; 
055A:  BSF    F83.5
.................... 	delay_cycles(20); 
055C:  MOVLW  06
055E:  MOVWF  00
0560:  DECFSZ 00,F
0562:  BRA    0560
0564:  NOP   
.................... 	portd.LED_latch=0; 
0566:  BCF    F83.5
.................... 	delay_cycles(20); 
0568:  MOVLW  06
056A:  MOVWF  00
056C:  DECFSZ 00,F
056E:  BRA    056C
0570:  NOP   
.................... 	portd.LED_latch=1; 
0572:  BSF    F83.5
.................... } 
0574:  RETLW  00
....................  
.................... ///////////////////////////// 
.................... void stuff_data(int8 data_to_stuff) { 
.................... 	int8 stuffing_mask =0xFF; 
.................... 	if ((data_to_stuff==0xA8) || (data_to_stuff==0xA9)) { 
.................... 		printf("%c",0xA9); 
.................... 		stuffing_mask = 0xDF; 
.................... 	} 
.................... 	printf("%c",stuffing_mask&data_to_stuff); 
.................... } 
.................... // send whatever in sent buffer 
.................... // packet_type: 0= ACK, 1=NACK, 2=DATA 
.................... void send_data(int8 packet_type,int8 size) { 
.................... 	int8 i,stuffing_mask; 
.................... 	output_checksum=0; 
.................... 	printf("%c",0xA8); 
.................... 	stuff_data(make8(device_id,1)); 
.................... 	output_checksum ^= make8(device_id,1); 
.................... 	stuff_data(make8(device_id,0)); 
.................... 	output_checksum ^= make8(device_id,0); 
.................... 	stuff_data(packet_type); 
.................... 	output_checksum ^= packet_type; 
.................... 	for (i=0;i<size;i++) { 
.................... 		output_checksum ^=output_buffer[i]; 
.................... 		stuff_data(output_buffer[i]); 
.................... 	} 
.................... 	stuff_data(output_checksum); 
.................... 	printf("%c",0xA8); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void solar_get_act_length(unsigned int8 nActuator) { 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 current_period_fraction; 
....................  
.................... 	unsigned int16 current_act_len; 
.................... 	unsigned int16 next_act_len; 
.................... 	 
....................     target_act_position =0; 
*
2896:  MOVLB  1
2898:  CLRF   x98
289A:  CLRF   x97
....................  
.................... 	flash_read_page(nDay,0x00);  // verify page number 
289C:  MOVFF  2F,1C1
28A0:  MOVFF  2E,1C0
28A4:  MOVFF  2F,1C6
28A8:  MOVFF  2E,1C5
28AC:  CLRF   xC7
28AE:  MOVLB  0
28B0:  CALL   0C3A
....................     if (nDay != make16(flash_page_data2,flash_page_data))  { 
28B4:  MOVFF  186,03
28B8:  MOVLB  1
28BA:  MOVF   x85,W
28BC:  SUBWF  2E,W
28BE:  BNZ   28CE
28C0:  MOVF   03,W
28C2:  SUBWF  2F,W
28C4:  BNZ   28CE
28C6:  MOVF   30,F
28C8:  BNZ   28CE
28CA:  MOVF   31,F
28CC:  BZ    28EE
.................... 		printf("Error:Flash data corrupt"); 
28CE:  CLRF   xC0
28D0:  MOVF   xC0,W
28D2:  MOVLB  0
28D4:  CALL   0222
28D8:  MOVLB  1
28DA:  INCF   xC0,F
28DC:  MOVWF  00
28DE:  MOVF   00,W
28E0:  BTFSS  F9E.4
28E2:  BRA    28E0
28E4:  MOVWF  FAD
28E6:  MOVLW  18
28E8:  SUBWF  xC0,W
28EA:  BNZ   28D0
.................... 		return; 
28EC:  BRA    2DCA
.................... 	} 
....................     current_period = (timer_sec+225)/450; 
28EE:  MOVLW  E1
28F0:  ADDWF  22,W
28F2:  MOVWF  xC0
28F4:  MOVLW  00
28F6:  ADDWFC 23,W
28F8:  MOVWF  xC1
28FA:  MOVLW  00
28FC:  ADDWFC 24,W
28FE:  MOVWF  xC2
2900:  MOVLW  00
2902:  ADDWFC 25,W
2904:  MOVWF  xC3
2906:  CLRF   18
2908:  BTFSC  FF2.7
290A:  BSF    18.7
290C:  BCF    FF2.7
290E:  MOVWF  xC7
2910:  MOVFF  1C2,1C6
2914:  MOVFF  1C1,1C5
2918:  MOVFF  1C0,1C4
291C:  CLRF   xCB
291E:  CLRF   xCA
2920:  MOVLW  01
2922:  MOVWF  xC9
2924:  MOVLW  C2
2926:  MOVWF  xC8
2928:  MOVLB  0
292A:  CALL   04A2
292E:  BTFSC  18.7
2930:  BSF    FF2.7
2932:  MOVFF  01,1B9
2936:  MOVFF  00,1B8
....................     current_period_fraction = (timer_sec+225)%450; 
293A:  MOVLW  E1
293C:  ADDWF  22,W
293E:  MOVLB  1
2940:  MOVWF  xC0
2942:  MOVLW  00
2944:  ADDWFC 23,W
2946:  MOVWF  xC1
2948:  MOVLW  00
294A:  ADDWFC 24,W
294C:  MOVWF  xC2
294E:  MOVLW  00
2950:  ADDWFC 25,W
2952:  MOVWF  xC3
2954:  CLRF   18
2956:  BTFSC  FF2.7
2958:  BSF    18.7
295A:  BCF    FF2.7
295C:  MOVWF  xC7
295E:  MOVFF  1C2,1C6
2962:  MOVFF  1C1,1C5
2966:  MOVFF  1C0,1C4
296A:  CLRF   xCB
296C:  CLRF   xCA
296E:  MOVLW  01
2970:  MOVWF  xC9
2972:  MOVLW  C2
2974:  MOVWF  xC8
2976:  MOVLB  0
2978:  CALL   04A2
297C:  BTFSC  18.7
297E:  BSF    FF2.7
2980:  MOVFF  FEF,1BA
2984:  MOVFF  FEC,1BB
....................     flash_read_page(nDay,0x02); // get sun rise time 
2988:  MOVFF  2F,1C1
298C:  MOVFF  2E,1C0
2990:  MOVFF  2F,1C6
2994:  MOVFF  2E,1C5
2998:  MOVLW  02
299A:  MOVLB  1
299C:  MOVWF  xC7
299E:  MOVLB  0
29A0:  CALL   0C3A
....................     sun_rise_period=make16(flash_page_data2,flash_page_data); 
29A4:  MOVFF  186,1B7
29A8:  MOVFF  185,1B6
.................... 	if ((current_period < sun_rise_period) || (current_period > sun_rise_period+124)) // still dark 
29AC:  MOVLB  1
29AE:  MOVF   xB9,W
29B0:  SUBWF  xB7,W
29B2:  BNC   29BC
29B4:  BNZ   29D8
29B6:  MOVF   xB6,W
29B8:  SUBWF  xB8,W
29BA:  BNC   29D8
29BC:  MOVLW  7C
29BE:  ADDWF  xB6,W
29C0:  MOVWF  01
29C2:  MOVLW  00
29C4:  ADDWFC xB7,W
29C6:  MOVWF  03
29C8:  MOVF   03,W
29CA:  SUBWF  xB9,W
29CC:  BTFSS  FD8.0
29CE:  BRA    2AC2
29D0:  BNZ   29D8
29D2:  MOVF   xB8,W
29D4:  SUBWF  01,W
29D6:  BC    2AC2
.................... 	{ 
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]*(int32)(act_safety_stroke-act_min_stroke); 
29D8:  BCF    FD8.0
29DA:  RLCF   xB5,W
29DC:  CLRF   03
29DE:  ADDLW  99
29E0:  MOVWF  FE9
29E2:  MOVLW  01
29E4:  ADDWFC 03,W
29E6:  MOVWF  FEA
29E8:  MOVFF  FEC,03
29EC:  MOVF   FED,F
29EE:  MOVFF  FEF,1C0
29F2:  MOVFF  03,1C1
29F6:  CLRF   xC2
29F8:  CLRF   xC3
29FA:  MOVF   xA3,W
29FC:  SUBWF  xA5,W
29FE:  MOVWF  00
2A00:  MOVF   xA4,W
2A02:  SUBWFB xA6,W
2A04:  MOVWF  03
2A06:  MOVF   00,W
2A08:  MOVFF  03,01
2A0C:  CLRF   02
2A0E:  CLRF   03
2A10:  MOVFF  03,1C7
2A14:  MOVFF  02,1C6
2A18:  MOVFF  01,1C5
2A1C:  MOVFF  00,1C4
2A20:  MOVFF  FEA,1C9
2A24:  MOVFF  FE9,1C8
2A28:  MOVFF  1C3,1CD
2A2C:  MOVFF  1C2,1CC
2A30:  MOVFF  1C1,1CB
2A34:  MOVFF  1C0,1CA
2A38:  MOVFF  03,1D1
2A3C:  MOVFF  02,1D0
2A40:  MOVFF  01,1CF
2A44:  MOVFF  00,1CE
2A48:  MOVLB  0
2A4A:  CALL   18F0
2A4E:  MOVFF  1C9,FEA
2A52:  MOVFF  1C8,FE9
2A56:  MOVFF  03,29
2A5A:  MOVFF  02,28
2A5E:  MOVFF  01,27
2A62:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
2A66:  MOVLB  1
2A68:  MOVF   xA3,W
2A6A:  SUBWF  xA1,W
2A6C:  MOVWF  00
2A6E:  MOVF   xA4,W
2A70:  SUBWFB xA2,W
2A72:  MOVWF  03
2A74:  MOVFF  00,1C0
2A78:  MOVWF  xC1
2A7A:  CLRF   18
2A7C:  BTFSC  FF2.7
2A7E:  BSF    18.7
2A80:  BCF    FF2.7
2A82:  MOVFF  29,1C7
2A86:  MOVFF  28,1C6
2A8A:  MOVFF  27,1C5
2A8E:  MOVFF  26,1C4
2A92:  CLRF   xCB
2A94:  CLRF   xCA
2A96:  MOVWF  xC9
2A98:  MOVFF  00,1C8
2A9C:  MOVLB  0
2A9E:  CALL   04A2
2AA2:  BTFSC  18.7
2AA4:  BSF    FF2.7
2AA6:  MOVFF  03,29
2AAA:  MOVFF  02,28
2AAE:  MOVFF  01,27
2AB2:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
2AB6:  MOVFF  27,198
2ABA:  MOVFF  26,197
.................... 	} else { 
2ABE:  BRA    2DC8
2AC0:  MOVLB  1
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+4); 
2AC2:  MOVFF  2F,1C1
2AC6:  MOVFF  2E,1C0
2ACA:  MOVF   xB6,W
2ACC:  SUBWF  xB8,W
2ACE:  MOVWF  00
2AD0:  MOVF   xB7,W
2AD2:  SUBWFB xB9,W
2AD4:  MOVWF  03
2AD6:  MOVF   00,W
2AD8:  BCF    FD8.0
2ADA:  RLCF   00,F
2ADC:  MOVF   00,W
2ADE:  ADDLW  04
2AE0:  MOVWF  xC4
2AE2:  MOVFF  2F,1C6
2AE6:  MOVFF  2E,1C5
2AEA:  MOVWF  xC7
2AEC:  MOVLB  0
2AEE:  CALL   0C3A
.................... 		current_act_len = make16(flash_page_data2,flash_page_data); 
2AF2:  MOVFF  186,1BD
2AF6:  MOVFF  185,1BC
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+6); 
2AFA:  MOVFF  2F,1C1
2AFE:  MOVFF  2E,1C0
2B02:  MOVLB  1
2B04:  MOVF   xB6,W
2B06:  SUBWF  xB8,W
2B08:  MOVWF  00
2B0A:  MOVF   xB7,W
2B0C:  SUBWFB xB9,W
2B0E:  MOVWF  03
2B10:  MOVF   00,W
2B12:  BCF    FD8.0
2B14:  RLCF   00,F
2B16:  MOVF   00,W
2B18:  ADDLW  06
2B1A:  MOVWF  xC4
2B1C:  MOVFF  2F,1C6
2B20:  MOVFF  2E,1C5
2B24:  MOVWF  xC7
2B26:  MOVLB  0
2B28:  CALL   0C3A
.................... 		next_act_len = make16(flash_page_data2,flash_page_data); 
2B2C:  MOVFF  186,1BF
2B30:  MOVFF  185,1BE
.................... 		// do linear interpolation of the act len 
.................... 		if (next_act_len>current_act_len) { 
2B34:  MOVLB  1
2B36:  MOVF   xBD,W
2B38:  SUBWF  xBF,W
2B3A:  BNC   2BFE
2B3C:  BNZ   2B44
2B3E:  MOVF   xBE,W
2B40:  SUBWF  xBC,W
2B42:  BC    2BFE
.................... 			tick = (int32)(next_act_len-current_act_len)*(int32)(current_period_fraction); 
2B44:  MOVF   xBC,W
2B46:  SUBWF  xBE,W
2B48:  MOVWF  00
2B4A:  MOVF   xBD,W
2B4C:  SUBWFB xBF,W
2B4E:  MOVWF  03
2B50:  MOVFF  00,1C0
2B54:  MOVWF  xC1
2B56:  CLRF   xC2
2B58:  CLRF   xC3
2B5A:  MOVFF  1BA,00
2B5E:  MOVFF  1BB,01
2B62:  CLRF   02
2B64:  CLRF   03
2B66:  MOVFF  03,1C7
2B6A:  MOVFF  02,1C6
2B6E:  MOVFF  1BB,1C5
2B72:  MOVFF  1BA,1C4
2B76:  MOVFF  1C3,1CD
2B7A:  MOVFF  1C2,1CC
2B7E:  MOVWF  xCB
2B80:  MOVFF  1C0,1CA
2B84:  MOVFF  03,1D1
2B88:  MOVFF  02,1D0
2B8C:  MOVFF  1BB,1CF
2B90:  MOVFF  1BA,1CE
2B94:  MOVLB  0
2B96:  CALL   18F0
2B9A:  MOVFF  03,29
2B9E:  MOVFF  02,28
2BA2:  MOVFF  01,27
2BA6:  MOVFF  00,26
2BAA:  CLRF   18
2BAC:  BTFSC  FF2.7
2BAE:  BSF    18.7
2BB0:  BCF    FF2.7
.................... 			tick = tick/450; 
2BB2:  MOVFF  29,1C7
2BB6:  MOVFF  28,1C6
2BBA:  MOVFF  27,1C5
2BBE:  MOVFF  26,1C4
2BC2:  MOVLB  1
2BC4:  CLRF   xCB
2BC6:  CLRF   xCA
2BC8:  MOVLW  01
2BCA:  MOVWF  xC9
2BCC:  MOVLW  C2
2BCE:  MOVWF  xC8
2BD0:  MOVLB  0
2BD2:  CALL   04A2
2BD6:  BTFSC  18.7
2BD8:  BSF    FF2.7
2BDA:  MOVFF  03,29
2BDE:  MOVFF  02,28
2BE2:  MOVFF  01,27
2BE6:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
2BEA:  MOVFF  27,1BF
2BEE:  MOVFF  26,1BE
.................... 			current_act_len = current_act_len + next_act_len; 
2BF2:  MOVLB  1
2BF4:  MOVF   xBE,W
2BF6:  ADDWF  xBC,F
2BF8:  MOVF   xBF,W
2BFA:  ADDWFC xBD,F
.................... 		} else  { 
2BFC:  BRA    2CB6
.................... 			tick = (int32)(current_act_len-next_act_len)*(int32)(current_period_fraction); 
2BFE:  MOVF   xBE,W
2C00:  SUBWF  xBC,W
2C02:  MOVWF  00
2C04:  MOVF   xBF,W
2C06:  SUBWFB xBD,W
2C08:  MOVWF  03
2C0A:  MOVFF  00,1C0
2C0E:  MOVWF  xC1
2C10:  CLRF   xC2
2C12:  CLRF   xC3
2C14:  MOVFF  1BA,00
2C18:  MOVFF  1BB,01
2C1C:  CLRF   02
2C1E:  CLRF   03
2C20:  MOVFF  03,1C7
2C24:  MOVFF  02,1C6
2C28:  MOVFF  1BB,1C5
2C2C:  MOVFF  1BA,1C4
2C30:  MOVFF  1C3,1CD
2C34:  MOVFF  1C2,1CC
2C38:  MOVWF  xCB
2C3A:  MOVFF  1C0,1CA
2C3E:  MOVFF  03,1D1
2C42:  MOVFF  02,1D0
2C46:  MOVFF  1BB,1CF
2C4A:  MOVFF  1BA,1CE
2C4E:  MOVLB  0
2C50:  CALL   18F0
2C54:  MOVFF  03,29
2C58:  MOVFF  02,28
2C5C:  MOVFF  01,27
2C60:  MOVFF  00,26
2C64:  CLRF   18
2C66:  BTFSC  FF2.7
2C68:  BSF    18.7
2C6A:  BCF    FF2.7
.................... 			tick = tick/450; 
2C6C:  MOVFF  29,1C7
2C70:  MOVFF  28,1C6
2C74:  MOVFF  27,1C5
2C78:  MOVFF  26,1C4
2C7C:  MOVLB  1
2C7E:  CLRF   xCB
2C80:  CLRF   xCA
2C82:  MOVLW  01
2C84:  MOVWF  xC9
2C86:  MOVLW  C2
2C88:  MOVWF  xC8
2C8A:  MOVLB  0
2C8C:  CALL   04A2
2C90:  BTFSC  18.7
2C92:  BSF    FF2.7
2C94:  MOVFF  03,29
2C98:  MOVFF  02,28
2C9C:  MOVFF  01,27
2CA0:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
2CA4:  MOVFF  27,1BF
2CA8:  MOVFF  26,1BE
.................... 			current_act_len = current_act_len - next_act_len; 
2CAC:  MOVLB  1
2CAE:  MOVF   xBE,W
2CB0:  SUBWF  xBC,F
2CB2:  MOVF   xBF,W
2CB4:  SUBWFB xBD,F
.................... 		} 
.................... 		if (current_act_len >= act_max_stroke) current_act_len = act_max_stroke; 
2CB6:  MOVF   xA2,W
2CB8:  SUBWF  xBD,W
2CBA:  BNC   2CCC
2CBC:  BNZ   2CC4
2CBE:  MOVF   xA1,W
2CC0:  SUBWF  xBC,W
2CC2:  BNC   2CCC
2CC4:  MOVFF  1A2,1BD
2CC8:  MOVFF  1A1,1BC
.................... 		if (current_act_len <= act_min_stroke) current_act_len = act_min_stroke; 
2CCC:  MOVF   xBD,W
2CCE:  SUBWF  xA4,W
2CD0:  BNC   2CE2
2CD2:  BNZ   2CDA
2CD4:  MOVF   xBC,W
2CD6:  SUBWF  xA3,W
2CD8:  BNC   2CE2
2CDA:  MOVFF  1A4,1BD
2CDE:  MOVFF  1A3,1BC
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]* (int32)(current_act_len-act_min_stroke); 
2CE2:  BCF    FD8.0
2CE4:  RLCF   xB5,W
2CE6:  CLRF   03
2CE8:  ADDLW  99
2CEA:  MOVWF  FE9
2CEC:  MOVLW  01
2CEE:  ADDWFC 03,W
2CF0:  MOVWF  FEA
2CF2:  MOVFF  FEC,03
2CF6:  MOVF   FED,F
2CF8:  MOVFF  FEF,1C0
2CFC:  MOVFF  03,1C1
2D00:  CLRF   xC2
2D02:  CLRF   xC3
2D04:  MOVF   xA3,W
2D06:  SUBWF  xBC,W
2D08:  MOVWF  00
2D0A:  MOVF   xA4,W
2D0C:  SUBWFB xBD,W
2D0E:  MOVWF  03
2D10:  MOVF   00,W
2D12:  MOVFF  03,01
2D16:  CLRF   02
2D18:  CLRF   03
2D1A:  MOVFF  03,1C7
2D1E:  MOVFF  02,1C6
2D22:  MOVFF  01,1C5
2D26:  MOVFF  00,1C4
2D2A:  MOVFF  FEA,1C9
2D2E:  MOVFF  FE9,1C8
2D32:  MOVFF  1C3,1CD
2D36:  MOVFF  1C2,1CC
2D3A:  MOVFF  1C1,1CB
2D3E:  MOVFF  1C0,1CA
2D42:  MOVFF  03,1D1
2D46:  MOVFF  02,1D0
2D4A:  MOVFF  01,1CF
2D4E:  MOVFF  00,1CE
2D52:  MOVLB  0
2D54:  CALL   18F0
2D58:  MOVFF  1C9,FEA
2D5C:  MOVFF  1C8,FE9
2D60:  MOVFF  03,29
2D64:  MOVFF  02,28
2D68:  MOVFF  01,27
2D6C:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
2D70:  MOVLB  1
2D72:  MOVF   xA3,W
2D74:  SUBWF  xA1,W
2D76:  MOVWF  00
2D78:  MOVF   xA4,W
2D7A:  SUBWFB xA2,W
2D7C:  MOVWF  03
2D7E:  MOVFF  00,1C0
2D82:  MOVWF  xC1
2D84:  CLRF   18
2D86:  BTFSC  FF2.7
2D88:  BSF    18.7
2D8A:  BCF    FF2.7
2D8C:  MOVFF  29,1C7
2D90:  MOVFF  28,1C6
2D94:  MOVFF  27,1C5
2D98:  MOVFF  26,1C4
2D9C:  CLRF   xCB
2D9E:  CLRF   xCA
2DA0:  MOVWF  xC9
2DA2:  MOVFF  00,1C8
2DA6:  MOVLB  0
2DA8:  CALL   04A2
2DAC:  BTFSC  18.7
2DAE:  BSF    FF2.7
2DB0:  MOVFF  03,29
2DB4:  MOVFF  02,28
2DB8:  MOVFF  01,27
2DBC:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
2DC0:  MOVFF  27,198
2DC4:  MOVFF  26,197
2DC8:  MOVLB  1
.................... 	} 
....................  
.................... } 
2DCA:  MOVLB  0
2DCC:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,int8 direction,unsigned int8 nActuator) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
1F9E:  MOVLB  1
1FA0:  CLRF   xC2
1FA2:  CLRF   xC3
....................    unsigned int16 yyy=0;    
1FA4:  CLRF   xC4
1FA6:  CLRF   xC5
....................    output_low(CCW); 
1FA8:  BCF    F93.4
1FAA:  BCF    F8A.4
....................    output_low(EN0); 
1FAC:  BCF    F93.0
1FAE:  BCF    F8A.0
....................    output_low(EN1); 
1FB0:  BCF    F93.1
1FB2:  BCF    F8A.1
....................    output_low(EN2); 
1FB4:  BCF    F93.2
1FB6:  BCF    F8A.2
....................    output_low(EN3); 
1FB8:  BCF    F93.3
1FBA:  BCF    F8A.3
1FBC:  CLRF   18
1FBE:  BTFSC  FF2.7
1FC0:  BSF    18.7
1FC2:  BCF    FF2.7
....................    delay_ms(20); 
1FC4:  MOVLW  14
1FC6:  MOVWF  xC7
1FC8:  MOVLB  0
1FCA:  CALL   0576
1FCE:  BTFSC  18.7
1FD0:  BSF    FF2.7
....................    if (nActuator > 3) return; // actuator exceed max number allowable 
1FD2:  MOVLB  1
1FD4:  MOVF   xC1,W
1FD6:  SUBLW  03
1FD8:  BC    1FDC
1FDA:  BRA    230E
....................    flag2.is_moving =1; 
1FDC:  BSF    20.6
....................    switch (nActuator) { 
1FDE:  MOVF   xC1,W
1FE0:  ADDLW  FC
1FE2:  BC    2024
1FE4:  ADDLW  04
1FE6:  MOVLB  0
1FE8:  GOTO   2312
.................... 		case 0: { flag.prev_pulse_state = input(SENSE_0); break;} 
1FEC:  BSF    F92.2
1FEE:  BCF    1F.2
1FF0:  BTFSC  F80.2
1FF2:  BSF    1F.2
1FF4:  MOVLB  1
1FF6:  BRA    2024
1FF8:  MOVLB  0
.................... 		case 1: { flag.prev_pulse_state = input(SENSE_1); break;} 
1FFA:  BSF    F92.3
1FFC:  BCF    1F.2
1FFE:  BTFSC  F80.3
2000:  BSF    1F.2
2002:  MOVLB  1
2004:  BRA    2024
2006:  MOVLB  0
.................... 		case 2: { flag.prev_pulse_state = input(SENSE_2); break;} 
2008:  BSF    F92.4
200A:  BCF    1F.2
200C:  BTFSC  F80.4
200E:  BSF    1F.2
2010:  MOVLB  1
2012:  BRA    2024
2014:  MOVLB  0
.................... 		case 3: { flag.prev_pulse_state = input(SENSE_3); break;} 
2016:  BSF    F92.5
2018:  BCF    1F.2
201A:  BTFSC  F80.5
201C:  BSF    1F.2
201E:  MOVLB  1
2020:  BRA    2024
2022:  MOVLB  1
....................    } 
....................  
....................    if (!direction)   { 
2024:  MOVF   xC0,F
2026:  BNZ   202C
....................       output_high(CCW); 
2028:  BCF    F93.4
202A:  BSF    F8A.4
202C:  CLRF   18
202E:  BTFSC  FF2.7
2030:  BSF    18.7
2032:  BCF    FF2.7
....................    } 
....................  
....................    delay_ms(200); 
2034:  MOVLW  C8
2036:  MOVWF  xC7
2038:  MOVLB  0
203A:  CALL   0576
203E:  BTFSC  18.7
2040:  BSF    FF2.7
....................    switch (nActuator) { 
2042:  MOVLB  1
2044:  MOVF   xC1,W
2046:  ADDLW  FC
2048:  BC    207A
204A:  ADDLW  04
204C:  MOVLB  0
204E:  GOTO   233E
.................... 		case 0: {output_high(EN0); break;} 
2052:  BCF    F93.0
2054:  BSF    F8A.0
2056:  MOVLB  1
2058:  BRA    207A
205A:  MOVLB  0
.................... 		case 1: {output_high(EN1); break;} 
205C:  BCF    F93.1
205E:  BSF    F8A.1
2060:  MOVLB  1
2062:  BRA    207A
2064:  MOVLB  0
.................... 		case 2: {output_high(EN2); break;} 
2066:  BCF    F93.2
2068:  BSF    F8A.2
206A:  MOVLB  1
206C:  BRA    207A
206E:  MOVLB  0
.................... 		case 3: {output_high(EN3); break;} 
2070:  BCF    F93.3
2072:  BSF    F8A.3
2074:  MOVLB  1
2076:  BRA    207A
2078:  MOVLB  1
....................    } 
....................    delay_ms(10); 
207A:  CLRF   18
207C:  BTFSC  FF2.7
207E:  BSF    18.7
2080:  BCF    FF2.7
2082:  MOVLW  0A
2084:  MOVWF  xC7
2086:  MOVLB  0
2088:  CALL   0576
208C:  BTFSC  18.7
208E:  BSF    FF2.7
....................  
....................    tick = timer_sec; 
2090:  MOVFF  25,29
2094:  MOVFF  24,28
2098:  MOVFF  23,27
209C:  MOVFF  22,26
....................    tick2 = timer_sec; 
20A0:  MOVFF  25,2D
20A4:  MOVFF  24,2C
20A8:  MOVFF  23,2B
20AC:  MOVFF  22,2A
....................    actuator_pulse =0; 
20B0:  MOVLB  1
20B2:  CLRF   x8A
20B4:  CLRF   x89
....................    while(1) { 
....................       restart_wdt(); 
20B6:  CLRWDT
....................       xxx = (int16) (timer_sec-tick); 
20B8:  MOVF   26,W
20BA:  SUBWF  22,W
20BC:  MOVWF  00
20BE:  MOVF   27,W
20C0:  SUBWFB 23,W
20C2:  MOVWF  01
20C4:  MOVF   28,W
20C6:  SUBWFB 24,W
20C8:  MOVF   29,W
20CA:  SUBWFB 25,W
20CC:  MOVFF  01,1C3
20D0:  MOVFF  00,1C2
....................       yyy = (int16) (timer_sec-tick2); 
20D4:  MOVF   2A,W
20D6:  SUBWF  22,W
20D8:  MOVWF  00
20DA:  MOVF   2B,W
20DC:  SUBWFB 23,W
20DE:  MOVWF  01
20E0:  MOVF   2C,W
20E2:  SUBWFB 24,W
20E4:  MOVF   2D,W
20E6:  SUBWFB 25,W
20E8:  MOVFF  01,1C5
20EC:  MOVFF  00,1C4
....................    	  switch (nActuator) { 
20F0:  MOVF   xC1,W
20F2:  ADDLW  FC
20F4:  BC    2136
20F6:  ADDLW  04
20F8:  MOVLB  0
20FA:  GOTO   236A
.................... 		case 0: { flag2.current_pulse_state = input(SENSE_0); break;} 
20FE:  BSF    F92.2
2100:  BCF    20.4
2102:  BTFSC  F80.2
2104:  BSF    20.4
2106:  MOVLB  1
2108:  BRA    2136
210A:  MOVLB  0
.................... 		case 1: { flag2.current_pulse_state = input(SENSE_1); break;} 
210C:  BSF    F92.3
210E:  BCF    20.4
2110:  BTFSC  F80.3
2112:  BSF    20.4
2114:  MOVLB  1
2116:  BRA    2136
2118:  MOVLB  0
.................... 		case 2: { flag2.current_pulse_state = input(SENSE_2); break;} 
211A:  BSF    F92.4
211C:  BCF    20.4
211E:  BTFSC  F80.4
2120:  BSF    20.4
2122:  MOVLB  1
2124:  BRA    2136
2126:  MOVLB  0
.................... 		case 3: { flag2.current_pulse_state = input(SENSE_3); break;} 
2128:  BSF    F92.5
212A:  BCF    20.4
212C:  BTFSC  F80.5
212E:  BSF    20.4
2130:  MOVLB  1
2132:  BRA    2136
2134:  MOVLB  1
....................       } 
....................  
.................... 	  if (flag2.allow_manual_move_act) { 
2136:  BTFSS  20.3
2138:  BRA    2158
.................... 		  if (((!direction && (nButton==3)) || (direction && (nButton==5))) && flag2.button_pressed)  
213A:  MOVF   xC0,F
213C:  BNZ   2144
213E:  MOVF   4B,W
2140:  SUBLW  03
2142:  BZ    214E
2144:  MOVF   xC0,F
2146:  BZ    2156
2148:  MOVF   4B,W
214A:  SUBLW  05
214C:  BNZ   2156
214E:  BTFSS  20.1
2150:  BRA    2156
.................... 			flag2.allow_manual_move_act=1; 
2152:  BSF    20.3
.................... 		  else 
2154:  BRA    2158
.................... 			flag2.allow_manual_move_act=0;	 
2156:  BCF    20.3
.................... 	  } 
.................... 	  if (!flag2.allow_manual_move_act) {  
2158:  BTFSC  20.3
215A:  BRA    21C8
....................       if (flag2.abort_current_activity ==1) { 
215C:  BTFSS  20.2
215E:  BRA    2164
.................... 		 flag2.abort_current_activity=0; 
2160:  BCF    20.2
.................... 		 break; 
2162:  BRA    22B8
....................       } 
....................       if ( xxx>= time_out_sec)  
2164:  MOVF   xBD,W
2166:  SUBWF  xC3,W
2168:  BNC   2174
216A:  BNZ   2172
216C:  MOVF   xBC,W
216E:  SUBWF  xC2,W
2170:  BNC   2174
....................          break; 
2172:  BRA    22B8
....................        if (actuator_pulse >= nPulse) 
2174:  MOVF   xBB,W
2176:  SUBWF  x8A,W
2178:  BNC   21B8
217A:  BNZ   2182
217C:  MOVF   xBA,W
217E:  SUBWF  x89,W
2180:  BNC   21B8
.................... 	    switch (nActuator) { 
2182:  MOVF   xC1,W
2184:  ADDLW  FC
2186:  BC    21B8
2188:  ADDLW  04
218A:  MOVLB  0
218C:  GOTO   2396
.................... 			case 0: {output_low(EN0); break;} 
2190:  BCF    F93.0
2192:  BCF    F8A.0
2194:  MOVLB  1
2196:  BRA    21B8
2198:  MOVLB  0
.................... 			case 1: {output_low(EN1); break;} 
219A:  BCF    F93.1
219C:  BCF    F8A.1
219E:  MOVLB  1
21A0:  BRA    21B8
21A2:  MOVLB  0
.................... 			case 2: {output_low(EN2); break;} 
21A4:  BCF    F93.2
21A6:  BCF    F8A.2
21A8:  MOVLB  1
21AA:  BRA    21B8
21AC:  MOVLB  0
.................... 			case 3: {output_low(EN3); break;} 
21AE:  BCF    F93.3
21B0:  BCF    F8A.3
21B2:  MOVLB  1
21B4:  BRA    21B8
21B6:  MOVLB  1
....................    		} 
....................       if ( yyy >=stuck_sec) 
21B8:  MOVF   xBF,W
21BA:  SUBWF  xC5,W
21BC:  BNC   21C8
21BE:  BNZ   21C6
21C0:  MOVF   xBE,W
21C2:  SUBWF  xC4,W
21C4:  BNC   21C8
....................          break; 
21C6:  BRA    22B8
....................       }    
....................       if (flag.prev_pulse_state != flag2.current_pulse_state) { 
21C8:  CLRF   00
21CA:  BTFSC  20.4
21CC:  BSF    00.2
21CE:  MOVF   1F,W
21D0:  XORWF  00,W
21D2:  ANDLW  04
21D4:  BTFSC  FD8.2
21D6:  BRA    22B6
....................          tick2 = timer_sec; 
21D8:  MOVFF  25,2D
21DC:  MOVFF  24,2C
21E0:  MOVFF  23,2B
21E4:  MOVFF  22,2A
....................          flag.prev_pulse_state = flag2.current_pulse_state; 
21E8:  BCF    1F.2
21EA:  BTFSC  20.4
21EC:  BSF    1F.2
....................          if (!direction && (current_act_position[nActuator] >0)) current_act_position[nActuator]--; 
21EE:  MOVF   xC0,F
21F0:  BNZ   222E
21F2:  BCF    FD8.0
21F4:  RLCF   xC1,W
21F6:  CLRF   03
21F8:  ADDLW  8F
21FA:  MOVWF  FE9
21FC:  MOVLW  01
21FE:  ADDWFC 03,W
2200:  MOVWF  FEA
2202:  MOVFF  FEC,1C7
2206:  MOVF   FED,F
2208:  MOVFF  FEF,1C6
220C:  MOVF   xC6,F
220E:  BNZ   2214
2210:  MOVF   xC7,F
2212:  BZ    222E
2214:  BCF    FD8.0
2216:  RLCF   xC1,W
2218:  CLRF   03
221A:  ADDLW  8F
221C:  MOVWF  FE9
221E:  MOVLW  01
2220:  ADDWFC 03,W
2222:  MOVWF  FEA
2224:  MOVLW  FF
2226:  ADDWF  FEF,F
2228:  BC    222E
222A:  MOVF   FEE,F
222C:  DECF   FED,F
....................          if (direction && (current_act_position[nActuator] < act_full_stroke_tick[nActuator])) current_act_position[nActuator]++; 
222E:  MOVF   xC0,F
2230:  BZ    228C
2232:  BCF    FD8.0
2234:  RLCF   xC1,W
2236:  CLRF   03
2238:  ADDLW  8F
223A:  MOVWF  FE9
223C:  MOVLW  01
223E:  ADDWFC 03,W
2240:  MOVWF  FEA
2242:  MOVFF  FEC,1C7
2246:  MOVF   FED,F
2248:  MOVFF  FEF,1C6
224C:  BCF    FD8.0
224E:  RLCF   xC1,W
2250:  CLRF   03
2252:  ADDLW  99
2254:  MOVWF  FE9
2256:  MOVLW  01
2258:  ADDWFC 03,W
225A:  MOVWF  FEA
225C:  MOVFF  FEC,03
2260:  MOVF   FED,F
2262:  MOVFF  FEF,01
2266:  MOVF   xC7,W
2268:  SUBWF  03,W
226A:  BNC   228C
226C:  BNZ   2274
226E:  MOVF   01,W
2270:  SUBWF  xC6,W
2272:  BC    228C
2274:  BCF    FD8.0
2276:  RLCF   xC1,W
2278:  CLRF   03
227A:  ADDLW  8F
227C:  MOVWF  FE9
227E:  MOVLW  01
2280:  ADDWFC 03,W
2282:  MOVWF  FEA
2284:  MOVLW  01
2286:  ADDWF  FEE,F
2288:  BNC   228C
228A:  INCF   FEF,F
....................          actuator_pulse=actuator_pulse+1; 
228C:  MOVLW  01
228E:  ADDWF  x89,F
2290:  MOVLW  00
2292:  ADDWFC x8A,F
.................... 	     printf("\r%ld",actuator_pulse); 
2294:  MOVLW  0D
2296:  BTFSS  F9E.4
2298:  BRA    2296
229A:  MOVWF  FAD
229C:  MOVLW  10
229E:  MOVWF  FE9
22A0:  MOVFF  18A,1C7
22A4:  MOVFF  189,1C6
22A8:  MOVLB  0
22AA:  CALL   152E
.................... 		 led_status.operation = !led_status.operation; 
22AE:  BTG    21.1
.................... 		 display_LED(); 
22B0:  CALL   0542
22B4:  MOVLB  1
....................       } 
....................    } 
22B6:  BRA    20B6
....................    flag2.abort_current_activity=0; 
22B8:  BCF    20.2
....................    output_low(EN0); 
22BA:  BCF    F93.0
22BC:  BCF    F8A.0
....................    output_low(EN1); 
22BE:  BCF    F93.1
22C0:  BCF    F8A.1
....................    output_low(EN2); 
22C2:  BCF    F93.2
22C4:  BCF    F8A.2
....................    output_low(EN3); 
22C6:  BCF    F93.3
22C8:  BCF    F8A.3
....................    delay_ms(500); 
22CA:  MOVLW  02
22CC:  MOVWF  xC6
22CE:  CLRF   18
22D0:  BTFSC  FF2.7
22D2:  BSF    18.7
22D4:  BCF    FF2.7
22D6:  MOVLW  FA
22D8:  MOVWF  xC7
22DA:  MOVLB  0
22DC:  CALL   0576
22E0:  BTFSC  18.7
22E2:  BSF    FF2.7
22E4:  MOVLB  1
22E6:  DECFSZ xC6,F
22E8:  BRA    22CE
....................    output_low(CCW); 
22EA:  BCF    F93.4
22EC:  BCF    F8A.4
22EE:  CLRF   18
22F0:  BTFSC  FF2.7
22F2:  BSF    18.7
22F4:  BCF    FF2.7
....................    delay_ms(20); 
22F6:  MOVLW  14
22F8:  MOVWF  xC7
22FA:  MOVLB  0
22FC:  CALL   0576
2300:  BTFSC  18.7
2302:  BSF    FF2.7
....................    led_status.operation = 1; 
2304:  BSF    21.1
....................    display_LED(); 
2306:  CALL   0542
....................    flag2.is_moving =0; 
230A:  BCF    20.6
230C:  MOVLB  1
....................  
....................  
.................... } 
230E:  MOVLB  0
2310:  RETLW  00
....................  
.................... void actuator_move_execute(nActuator) { 
....................     if(current_act_position[nActuator] > (target_act_position+5))// move east 
*
2ED6:  BCF    FD8.0
2ED8:  MOVLB  1
2EDA:  RLCF   xB5,W
2EDC:  CLRF   03
2EDE:  ADDLW  8F
2EE0:  MOVWF  FE9
2EE2:  MOVLW  01
2EE4:  ADDWFC 03,W
2EE6:  MOVWF  FEA
2EE8:  MOVFF  FEC,1B7
2EEC:  MOVF   FED,F
2EEE:  MOVFF  FEF,1B6
2EF2:  MOVLW  05
2EF4:  ADDWF  x97,W
2EF6:  MOVWF  01
2EF8:  MOVLW  00
2EFA:  ADDWFC x98,W
2EFC:  MOVWF  03
2EFE:  MOVF   03,W
2F00:  SUBWF  xB7,W
2F02:  BNC   2F58
2F04:  BNZ   2F0C
2F06:  MOVF   xB6,W
2F08:  SUBWF  01,W
2F0A:  BC    2F58
....................             move_act(current_act_position[nActuator]-target_act_position,4500,move_act_time_out,0,nActuator); 
2F0C:  BCF    FD8.0
2F0E:  RLCF   xB5,W
2F10:  CLRF   03
2F12:  ADDLW  8F
2F14:  MOVWF  FE9
2F16:  MOVLW  01
2F18:  ADDWFC 03,W
2F1A:  MOVWF  FEA
2F1C:  MOVFF  FEC,1B7
2F20:  MOVF   FED,F
2F22:  MOVFF  FEF,1B6
2F26:  MOVF   x97,W
2F28:  SUBWF  xB6,W
2F2A:  MOVWF  xB8
2F2C:  MOVF   x98,W
2F2E:  SUBWFB xB7,W
2F30:  MOVWF  xB9
2F32:  MOVWF  xBB
2F34:  MOVFF  1B8,1BA
2F38:  MOVLW  11
2F3A:  MOVWF  xBD
2F3C:  MOVLW  94
2F3E:  MOVWF  xBC
2F40:  MOVFF  188,1BF
2F44:  MOVFF  187,1BE
2F48:  CLRF   xC0
2F4A:  MOVFF  1B5,1C1
2F4E:  MOVLB  0
2F50:  CALL   1F9E
....................     else if((current_act_position[nActuator]+5) < target_act_position)// move west 
2F54:  BRA    3080
2F56:  MOVLB  1
2F58:  BCF    FD8.0
2F5A:  RLCF   xB5,W
2F5C:  CLRF   03
2F5E:  ADDLW  8F
2F60:  MOVWF  FE9
2F62:  MOVLW  01
2F64:  ADDWFC 03,W
2F66:  MOVWF  FEA
2F68:  MOVFF  FEC,1B7
2F6C:  MOVF   FED,F
2F6E:  MOVFF  FEF,1B6
2F72:  MOVLW  05
2F74:  ADDWF  xB6,W
2F76:  MOVWF  xB8
2F78:  MOVLW  00
2F7A:  ADDWFC xB7,W
2F7C:  MOVWF  xB9
2F7E:  SUBWF  x98,W
2F80:  BNC   2FD4
2F82:  BNZ   2F8A
2F84:  MOVF   x97,W
2F86:  SUBWF  xB8,W
2F88:  BC    2FD4
....................             move_act(target_act_position-current_act_position[nActuator],4500,move_act_time_out,1,nActuator); 
2F8A:  BCF    FD8.0
2F8C:  RLCF   xB5,W
2F8E:  CLRF   03
2F90:  ADDLW  8F
2F92:  MOVWF  FE9
2F94:  MOVLW  01
2F96:  ADDWFC 03,W
2F98:  MOVWF  FEA
2F9A:  MOVFF  FEC,03
2F9E:  MOVF   FED,F
2FA0:  MOVF   FEF,W
2FA2:  SUBWF  x97,W
2FA4:  MOVWF  xB6
2FA6:  MOVF   03,W
2FA8:  SUBWFB x98,W
2FAA:  MOVWF  xB7
2FAC:  MOVWF  xBB
2FAE:  MOVFF  1B6,1BA
2FB2:  MOVLW  11
2FB4:  MOVWF  xBD
2FB6:  MOVLW  94
2FB8:  MOVWF  xBC
2FBA:  MOVFF  188,1BF
2FBE:  MOVFF  187,1BE
2FC2:  MOVLW  01
2FC4:  MOVWF  xC0
2FC6:  MOVFF  1B5,1C1
2FCA:  MOVLB  0
2FCC:  CALL   1F9E
....................     else if (target_act_position == 0x00)  // move east all the way 
2FD0:  BRA    3080
2FD2:  MOVLB  1
2FD4:  MOVF   x97,F
2FD6:  BNZ   301E
2FD8:  MOVF   x98,F
2FDA:  BNZ   301E
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,0,nActuator); 
2FDC:  BCF    FD8.0
2FDE:  RLCF   xB5,W
2FE0:  CLRF   03
2FE2:  ADDLW  99
2FE4:  MOVWF  FE9
2FE6:  MOVLW  01
2FE8:  ADDWFC 03,W
2FEA:  MOVWF  FEA
2FEC:  MOVFF  FEC,1B7
2FF0:  MOVF   FED,F
2FF2:  MOVFF  FEF,1B6
2FF6:  MOVFF  1B7,1BB
2FFA:  MOVFF  1B6,1BA
2FFE:  MOVLW  11
3000:  MOVWF  xBD
3002:  MOVLW  94
3004:  MOVWF  xBC
3006:  MOVFF  188,1BF
300A:  MOVFF  187,1BE
300E:  CLRF   xC0
3010:  MOVFF  1B5,1C1
3014:  MOVLB  0
3016:  CALL   1F9E
....................     else if (target_act_position == act_full_stroke_tick[nActuator]) // move west all the way 
301A:  BRA    3080
301C:  MOVLB  1
301E:  BCF    FD8.0
3020:  RLCF   xB5,W
3022:  CLRF   03
3024:  ADDLW  99
3026:  MOVWF  FE9
3028:  MOVLW  01
302A:  ADDWFC 03,W
302C:  MOVWF  FEA
302E:  MOVFF  FEC,03
3032:  MOVF   FED,F
3034:  MOVF   FEF,W
3036:  SUBWF  x97,W
3038:  BNZ   3082
303A:  MOVF   03,W
303C:  SUBWF  x98,W
303E:  BNZ   3082
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,1,nActuator); 
3040:  BCF    FD8.0
3042:  RLCF   xB5,W
3044:  CLRF   03
3046:  ADDLW  99
3048:  MOVWF  FE9
304A:  MOVLW  01
304C:  ADDWFC 03,W
304E:  MOVWF  FEA
3050:  MOVFF  FEC,1B7
3054:  MOVF   FED,F
3056:  MOVFF  FEF,1B6
305A:  MOVFF  1B7,1BB
305E:  MOVFF  1B6,1BA
3062:  MOVLW  11
3064:  MOVWF  xBD
3066:  MOVLW  94
3068:  MOVWF  xBC
306A:  MOVFF  188,1BF
306E:  MOVFF  187,1BE
3072:  MOVLW  01
3074:  MOVWF  xC0
3076:  MOVFF  1B5,1C1
307A:  MOVLB  0
307C:  CALL   1F9E
3080:  MOVLB  1
.................... } 
3082:  MOVLB  0
3084:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... void read_eeprom_data() 
.................... { 
....................    int8 i,j; 
....................    int16 temp_mem;    
....................  
....................    temp_mem= &timer_sec; 
*
0990:  MOVLB  1
0992:  CLRF   xB5
0994:  MOVLW  22
0996:  MOVWF  xB4
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
0998:  CLRF   xB2
099A:  MOVF   xB2,W
099C:  SUBLW  03
099E:  BNC   09E6
09A0:  MOVF   xB2,W
09A2:  ADDWF  xB4,W
09A4:  MOVWF  xB6
09A6:  MOVLW  00
09A8:  ADDWFC xB5,W
09AA:  MOVWF  xB7
09AC:  MOVLW  20
09AE:  ADDWF  xB2,W
09B0:  MOVWF  xB8
09B2:  MOVFF  FF2,1B9
09B6:  BCF    FF2.7
09B8:  MOVFF  1B8,FA9
09BC:  BCF    FA6.6
09BE:  BCF    FA6.7
09C0:  BSF    FA6.0
09C2:  MOVF   FA8,W
09C4:  BTFSC  xB9.7
09C6:  BSF    FF2.7
09C8:  MOVWF  xB9
09CA:  MOVFF  1B7,FEA
09CE:  MOVFF  1B6,FE9
09D2:  MOVFF  1B9,1BB
09D6:  CLRF   xBD
09D8:  MOVLW  01
09DA:  MOVWF  xBC
09DC:  MOVLB  0
09DE:  RCALL  0972
09E0:  MOVLB  1
09E2:  INCF   xB2,F
09E4:  BRA    099A
....................  
....................    temp_mem= &nDay; 
09E6:  CLRF   xB5
09E8:  MOVLW  2E
09EA:  MOVWF  xB4
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i+4),1); 
09EC:  CLRF   xB2
09EE:  MOVF   xB2,W
09F0:  SUBLW  03
09F2:  BNC   0A3C
09F4:  MOVF   xB2,W
09F6:  ADDWF  xB4,W
09F8:  MOVWF  xB6
09FA:  MOVLW  00
09FC:  ADDWFC xB5,W
09FE:  MOVWF  xB7
0A00:  MOVLW  20
0A02:  ADDWF  xB2,W
0A04:  ADDLW  04
0A06:  MOVWF  xB9
0A08:  MOVFF  FF2,1BA
0A0C:  BCF    FF2.7
0A0E:  MOVFF  1B9,FA9
0A12:  BCF    FA6.6
0A14:  BCF    FA6.7
0A16:  BSF    FA6.0
0A18:  MOVF   FA8,W
0A1A:  BTFSC  xBA.7
0A1C:  BSF    FF2.7
0A1E:  MOVWF  xBA
0A20:  MOVFF  1B7,FEA
0A24:  MOVFF  1B6,FE9
0A28:  MOVFF  1BA,1BB
0A2C:  CLRF   xBD
0A2E:  MOVLW  01
0A30:  MOVWF  xBC
0A32:  MOVLB  0
0A34:  RCALL  0972
0A36:  MOVLB  1
0A38:  INCF   xB2,F
0A3A:  BRA    09EE
....................  
....................  
....................    temp_mem= &startup_counter; 
0A3C:  CLRF   xB5
0A3E:  MOVLW  32
0A40:  MOVWF  xB4
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
0A42:  CLRF   xB2
0A44:  MOVF   xB2,W
0A46:  SUBLW  01
0A48:  BNC   0A90
0A4A:  MOVF   xB2,W
0A4C:  ADDWF  xB4,W
0A4E:  MOVWF  xB6
0A50:  MOVLW  00
0A52:  ADDWFC xB5,W
0A54:  MOVWF  xB7
0A56:  MOVLW  30
0A58:  ADDWF  xB2,W
0A5A:  MOVWF  xB8
0A5C:  MOVFF  FF2,1B9
0A60:  BCF    FF2.7
0A62:  MOVFF  1B8,FA9
0A66:  BCF    FA6.6
0A68:  BCF    FA6.7
0A6A:  BSF    FA6.0
0A6C:  MOVF   FA8,W
0A6E:  BTFSC  xB9.7
0A70:  BSF    FF2.7
0A72:  MOVWF  xB9
0A74:  MOVFF  1B7,FEA
0A78:  MOVFF  1B6,FE9
0A7C:  MOVFF  1B9,1BB
0A80:  CLRF   xBD
0A82:  MOVLW  01
0A84:  MOVWF  xBC
0A86:  MOVLB  0
0A88:  RCALL  0972
0A8A:  MOVLB  1
0A8C:  INCF   xB2,F
0A8E:  BRA    0A44
....................  
....................    for (j=0;j<4;j++) { 
0A90:  CLRF   xB3
0A92:  MOVF   xB3,W
0A94:  SUBLW  03
0A96:  BTFSS  FD8.0
0A98:  BRA    0C34
....................    		temp_mem= &act_full_stroke_tick[j]; 
0A9A:  BCF    FD8.0
0A9C:  RLCF   xB3,W
0A9E:  CLRF   03
0AA0:  ADDLW  99
0AA2:  MOVWF  01
0AA4:  MOVLW  01
0AA6:  ADDWFC 03,F
0AA8:  MOVFF  01,1B4
0AAC:  MOVFF  03,1B5
.................... 	   	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i+j*2),1); 
0AB0:  CLRF   xB2
0AB2:  MOVF   xB2,W
0AB4:  SUBLW  01
0AB6:  BNC   0B00
0AB8:  MOVF   xB2,W
0ABA:  ADDWF  xB4,W
0ABC:  MOVWF  xB6
0ABE:  MOVLW  00
0AC0:  ADDWFC xB5,W
0AC2:  MOVWF  xB7
0AC4:  BCF    FD8.0
0AC6:  RLCF   xB3,W
0AC8:  ADDWF  xB2,W
0ACA:  MOVWF  xB8
0ACC:  MOVFF  FF2,1B9
0AD0:  BCF    FF2.7
0AD2:  MOVFF  1B8,FA9
0AD6:  BCF    FA6.6
0AD8:  BCF    FA6.7
0ADA:  BSF    FA6.0
0ADC:  MOVF   FA8,W
0ADE:  BTFSC  xB9.7
0AE0:  BSF    FF2.7
0AE2:  MOVWF  xB9
0AE4:  MOVFF  1B7,FEA
0AE8:  MOVFF  1B6,FE9
0AEC:  MOVFF  1B9,1BB
0AF0:  CLRF   xBD
0AF2:  MOVLW  01
0AF4:  MOVWF  xBC
0AF6:  MOVLB  0
0AF8:  RCALL  0972
0AFA:  MOVLB  1
0AFC:  INCF   xB2,F
0AFE:  BRA    0AB2
....................    		if (act_full_stroke_tick[j] > MAX_FULL_STROKE) act_full_stroke_tick[j] = MAX_FULL_STROKE; 
0B00:  BCF    FD8.0
0B02:  RLCF   xB3,W
0B04:  CLRF   03
0B06:  ADDLW  99
0B08:  MOVWF  FE9
0B0A:  MOVLW  01
0B0C:  ADDWFC 03,W
0B0E:  MOVWF  FEA
0B10:  MOVFF  FEC,1B7
0B14:  MOVF   FED,F
0B16:  MOVFF  FEF,1B6
0B1A:  MOVF   xB7,W
0B1C:  SUBLW  06
0B1E:  BC    0B44
0B20:  XORLW  FF
0B22:  BNZ   0B2A
0B24:  MOVF   xB6,W
0B26:  SUBLW  D0
0B28:  BC    0B44
0B2A:  BCF    FD8.0
0B2C:  RLCF   xB3,W
0B2E:  CLRF   03
0B30:  ADDLW  99
0B32:  MOVWF  FE9
0B34:  MOVLW  01
0B36:  ADDWFC 03,W
0B38:  MOVWF  FEA
0B3A:  MOVLW  07
0B3C:  MOVWF  FEC
0B3E:  MOVF   FED,F
0B40:  MOVLW  D0
0B42:  MOVWF  FEF
....................    		temp_mem= &current_act_position[j]; 
0B44:  BCF    FD8.0
0B46:  RLCF   xB3,W
0B48:  CLRF   03
0B4A:  ADDLW  8F
0B4C:  MOVWF  01
0B4E:  MOVLW  01
0B50:  ADDWFC 03,F
0B52:  MOVFF  01,1B4
0B56:  MOVFF  03,1B5
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2),1); 
0B5A:  CLRF   xB2
0B5C:  MOVF   xB2,W
0B5E:  SUBLW  01
0B60:  BNC   0BB0
0B62:  MOVF   xB2,W
0B64:  ADDWF  xB4,W
0B66:  MOVWF  xB6
0B68:  MOVLW  00
0B6A:  ADDWFC xB5,W
0B6C:  MOVWF  xB7
0B6E:  MOVLW  10
0B70:  ADDWF  xB2,W
0B72:  MOVWF  xB8
0B74:  BCF    FD8.0
0B76:  RLCF   xB3,W
0B78:  ADDWF  xB8,W
0B7A:  MOVWF  xB9
0B7C:  MOVFF  FF2,1BA
0B80:  BCF    FF2.7
0B82:  MOVFF  1B9,FA9
0B86:  BCF    FA6.6
0B88:  BCF    FA6.7
0B8A:  BSF    FA6.0
0B8C:  MOVF   FA8,W
0B8E:  BTFSC  xBA.7
0B90:  BSF    FF2.7
0B92:  MOVWF  xBA
0B94:  MOVFF  1B7,FEA
0B98:  MOVFF  1B6,FE9
0B9C:  MOVFF  1BA,1BB
0BA0:  CLRF   xBD
0BA2:  MOVLW  01
0BA4:  MOVWF  xBC
0BA6:  MOVLB  0
0BA8:  RCALL  0972
0BAA:  MOVLB  1
0BAC:  INCF   xB2,F
0BAE:  BRA    0B5C
....................    		if (current_act_position[j] > act_full_stroke_tick[j]) current_act_position[j] = act_full_stroke_tick[j]; 
0BB0:  BCF    FD8.0
0BB2:  RLCF   xB3,W
0BB4:  CLRF   03
0BB6:  ADDLW  8F
0BB8:  MOVWF  FE9
0BBA:  MOVLW  01
0BBC:  ADDWFC 03,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEC,1B7
0BC4:  MOVF   FED,F
0BC6:  MOVFF  FEF,1B6
0BCA:  BCF    FD8.0
0BCC:  RLCF   xB3,W
0BCE:  CLRF   03
0BD0:  ADDLW  99
0BD2:  MOVWF  FE9
0BD4:  MOVLW  01
0BD6:  ADDWFC 03,W
0BD8:  MOVWF  FEA
0BDA:  MOVFF  FEC,03
0BDE:  MOVF   FED,F
0BE0:  MOVFF  FEF,01
0BE4:  MOVF   03,W
0BE6:  SUBWF  xB7,W
0BE8:  BNC   0C30
0BEA:  BNZ   0BF2
0BEC:  MOVF   xB6,W
0BEE:  SUBWF  01,W
0BF0:  BC    0C30
0BF2:  BCF    FD8.0
0BF4:  RLCF   xB3,W
0BF6:  CLRF   03
0BF8:  ADDLW  8F
0BFA:  MOVWF  01
0BFC:  MOVLW  01
0BFE:  ADDWFC 03,F
0C00:  MOVFF  03,1B7
0C04:  BCF    FD8.0
0C06:  RLCF   xB3,W
0C08:  CLRF   03
0C0A:  ADDLW  99
0C0C:  MOVWF  FE9
0C0E:  MOVLW  01
0C10:  ADDWFC 03,W
0C12:  MOVWF  FEA
0C14:  MOVFF  FEC,03
0C18:  MOVF   FED,F
0C1A:  MOVFF  FEF,1B8
0C1E:  MOVFF  1B7,FEA
0C22:  MOVFF  01,FE9
0C26:  MOVFF  03,FEC
0C2A:  MOVF   FED,F
0C2C:  MOVFF  1B8,FEF
....................    } 
0C30:  INCF   xB3,F
0C32:  BRA    0A92
....................  
....................  
.................... } 
0C34:  MOVLB  0
0C36:  GOTO   4014 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i,j; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
1072:  MOVLB  1
1074:  CLRF   xB5
1076:  MOVF   xB5,W
1078:  SUBLW  03
107A:  BNC   10DC
107C:  MOVLW  20
107E:  ADDWF  xB5,W
1080:  MOVWF  xB7
1082:  MOVF   xB5,W
1084:  MULLW  08
1086:  MOVFF  FF3,1B8
108A:  MOVFF  25,1BC
108E:  MOVFF  24,1BB
1092:  MOVFF  23,1BA
1096:  MOVFF  22,1B9
109A:  MOVF   xB8,F
109C:  BZ    10AC
109E:  BCF    FD8.0
10A0:  RRCF   xBC,F
10A2:  RRCF   xBB,F
10A4:  RRCF   xBA,F
10A6:  RRCF   xB9,F
10A8:  DECFSZ xB8,F
10AA:  BRA    109E
10AC:  MOVFF  1B7,FA9
10B0:  MOVFF  1B9,FA8
10B4:  BCF    FA6.6
10B6:  BCF    FA6.7
10B8:  BSF    FA6.2
10BA:  MOVFF  FF2,00
10BE:  BCF    FF2.7
10C0:  MOVLB  F
10C2:  MOVLW  55
10C4:  MOVWF  FA7
10C6:  MOVLW  AA
10C8:  MOVWF  FA7
10CA:  BSF    FA6.1
10CC:  BTFSC  FA6.1
10CE:  BRA    10CC
10D0:  BCF    FA6.2
10D2:  MOVF   00,W
10D4:  IORWF  FF2,F
10D6:  MOVLB  1
10D8:  INCF   xB5,F
10DA:  BRA    1076
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i+4,nDay>>(i*8)); 
10DC:  CLRF   xB5
10DE:  MOVF   xB5,W
10E0:  SUBLW  03
10E2:  BNC   1146
10E4:  MOVLW  20
10E6:  ADDWF  xB5,W
10E8:  ADDLW  04
10EA:  MOVWF  xB8
10EC:  MOVF   xB5,W
10EE:  MULLW  08
10F0:  MOVFF  FF3,1B9
10F4:  MOVFF  31,1BD
10F8:  MOVFF  30,1BC
10FC:  MOVFF  2F,1BB
1100:  MOVFF  2E,1BA
1104:  MOVF   xB9,F
1106:  BZ    1116
1108:  BCF    FD8.0
110A:  RRCF   xBD,F
110C:  RRCF   xBC,F
110E:  RRCF   xBB,F
1110:  RRCF   xBA,F
1112:  DECFSZ xB9,F
1114:  BRA    1108
1116:  MOVFF  1B8,FA9
111A:  MOVFF  1BA,FA8
111E:  BCF    FA6.6
1120:  BCF    FA6.7
1122:  BSF    FA6.2
1124:  MOVFF  FF2,00
1128:  BCF    FF2.7
112A:  MOVLB  F
112C:  MOVLW  55
112E:  MOVWF  FA7
1130:  MOVLW  AA
1132:  MOVWF  FA7
1134:  BSF    FA6.1
1136:  BTFSC  FA6.1
1138:  BRA    1136
113A:  BCF    FA6.2
113C:  MOVF   00,W
113E:  IORWF  FF2,F
1140:  MOVLB  1
1142:  INCF   xB5,F
1144:  BRA    10DE
....................  
....................    for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2,current_act_position[j]>>(i*8)); 
1146:  CLRF   xB6
1148:  MOVF   xB6,W
114A:  SUBLW  03
114C:  BNC   11D0
114E:  CLRF   xB5
1150:  MOVF   xB5,W
1152:  SUBLW  01
1154:  BNC   11CC
1156:  MOVLW  10
1158:  ADDWF  xB5,W
115A:  MOVWF  xB7
115C:  BCF    FD8.0
115E:  RLCF   xB6,W
1160:  ADDWF  xB7,W
1162:  MOVWF  xB8
1164:  BCF    FD8.0
1166:  RLCF   xB6,W
1168:  CLRF   03
116A:  ADDLW  8F
116C:  MOVWF  FE9
116E:  MOVLW  01
1170:  ADDWFC 03,W
1172:  MOVWF  FEA
1174:  MOVFF  FEC,1BA
1178:  MOVF   FED,F
117A:  MOVFF  FEF,1B9
117E:  MOVF   xB5,W
1180:  MULLW  08
1182:  MOVFF  FF3,00
1186:  MOVFF  1BA,1BC
118A:  MOVFF  1B9,1BB
118E:  MOVF   00,F
1190:  BZ    119C
1192:  BCF    FD8.0
1194:  RRCF   xBC,F
1196:  RRCF   xBB,F
1198:  DECFSZ 00,F
119A:  BRA    1192
119C:  MOVFF  1B8,FA9
11A0:  MOVFF  1BB,FA8
11A4:  BCF    FA6.6
11A6:  BCF    FA6.7
11A8:  BSF    FA6.2
11AA:  MOVFF  FF2,00
11AE:  BCF    FF2.7
11B0:  MOVLB  F
11B2:  MOVLW  55
11B4:  MOVWF  FA7
11B6:  MOVLW  AA
11B8:  MOVWF  FA7
11BA:  BSF    FA6.1
11BC:  BTFSC  FA6.1
11BE:  BRA    11BC
11C0:  BCF    FA6.2
11C2:  MOVF   00,W
11C4:  IORWF  FF2,F
11C6:  MOVLB  1
11C8:  INCF   xB5,F
11CA:  BRA    1150
11CC:  INCF   xB6,F
11CE:  BRA    1148
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
11D0:  CLRF   xB5
11D2:  MOVF   xB5,W
11D4:  SUBLW  01
11D6:  BNC   122C
11D8:  MOVLW  30
11DA:  ADDWF  xB5,W
11DC:  MOVWF  xB7
11DE:  MOVF   xB5,W
11E0:  MULLW  08
11E2:  MOVFF  FF3,00
11E6:  MOVFF  33,1B9
11EA:  MOVFF  32,1B8
11EE:  MOVF   00,F
11F0:  BZ    11FC
11F2:  BCF    FD8.0
11F4:  RRCF   xB9,F
11F6:  RRCF   xB8,F
11F8:  DECFSZ 00,F
11FA:  BRA    11F2
11FC:  MOVFF  1B7,FA9
1200:  MOVFF  1B8,FA8
1204:  BCF    FA6.6
1206:  BCF    FA6.7
1208:  BSF    FA6.2
120A:  MOVFF  FF2,00
120E:  BCF    FF2.7
1210:  MOVLB  F
1212:  MOVLW  55
1214:  MOVWF  FA7
1216:  MOVLW  AA
1218:  MOVWF  FA7
121A:  BSF    FA6.1
121C:  BTFSC  FA6.1
121E:  BRA    121C
1220:  BCF    FA6.2
1222:  MOVF   00,W
1224:  IORWF  FF2,F
1226:  MOVLB  1
1228:  INCF   xB5,F
122A:  BRA    11D2
....................    if (write_cal ==1) 
122C:  DECFSZ xB4,W
122E:  BRA    12B4
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i+j*2,act_full_stroke_tick[j]>>(i*8)); 
1230:  CLRF   xB6
1232:  MOVF   xB6,W
1234:  SUBLW  03
1236:  BNC   12B4
1238:  CLRF   xB5
123A:  MOVF   xB5,W
123C:  SUBLW  01
123E:  BNC   12B0
1240:  BCF    FD8.0
1242:  RLCF   xB6,W
1244:  ADDWF  xB5,W
1246:  MOVWF  xB7
1248:  BCF    FD8.0
124A:  RLCF   xB6,W
124C:  CLRF   03
124E:  ADDLW  99
1250:  MOVWF  FE9
1252:  MOVLW  01
1254:  ADDWFC 03,W
1256:  MOVWF  FEA
1258:  MOVFF  FEC,1B9
125C:  MOVF   FED,F
125E:  MOVFF  FEF,1B8
1262:  MOVF   xB5,W
1264:  MULLW  08
1266:  MOVFF  FF3,00
126A:  MOVFF  1B9,1BB
126E:  MOVFF  1B8,1BA
1272:  MOVF   00,F
1274:  BZ    1280
1276:  BCF    FD8.0
1278:  RRCF   xBB,F
127A:  RRCF   xBA,F
127C:  DECFSZ 00,F
127E:  BRA    1276
1280:  MOVFF  1B7,FA9
1284:  MOVFF  1BA,FA8
1288:  BCF    FA6.6
128A:  BCF    FA6.7
128C:  BSF    FA6.2
128E:  MOVFF  FF2,00
1292:  BCF    FF2.7
1294:  MOVLB  F
1296:  MOVLW  55
1298:  MOVWF  FA7
129A:  MOVLW  AA
129C:  MOVWF  FA7
129E:  BSF    FA6.1
12A0:  BTFSC  FA6.1
12A2:  BRA    12A0
12A4:  BCF    FA6.2
12A6:  MOVF   00,W
12A8:  IORWF  FF2,F
12AA:  MOVLB  1
12AC:  INCF   xB5,F
12AE:  BRA    123A
12B0:  INCF   xB6,F
12B2:  BRA    1232
.................... } 
12B4:  MOVLB  0
12B6:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////// 
.................... void button_scan() { 
.................... 	int8 i; 
....................     flag2.button_pressed=0; 
*
05A0:  BCF    20.1
.................... 	for(i=0;i<6;i++) { 
05A2:  MOVLB  1
05A4:  CLRF   xB4
05A6:  MOVF   xB4,W
05A8:  SUBLW  05
05AA:  BNC   05E2
.................... 		portd.data_bus=i; 
05AC:  MOVF   xB4,W
05AE:  ANDLW  0F
05B0:  MOVWF  00
05B2:  MOVLW  F0
05B4:  ANDWF  F83,W
05B6:  IORWF  00,W
05B8:  MOVWF  F83
.................... 		portd.MUX_en =0; 
05BA:  BCF    F83.6
.................... 		delay_cycles(20); 
05BC:  MOVLW  06
05BE:  MOVWF  00
05C0:  DECFSZ 00,F
05C2:  BRA    05C0
05C4:  NOP   
.................... 		if (!input(PIN_E0)) { 
05C6:  BSF    F96.0
05C8:  BTFSC  F84.0
05CA:  BRA    05D2
.................... 			flag2.button_pressed=1; 
05CC:  BSF    20.1
.................... 			nButton=i; 
05CE:  MOVFF  1B4,4B
.................... 		}  
.................... 		delay_cycles(20); 
05D2:  MOVLW  06
05D4:  MOVWF  00
05D6:  DECFSZ 00,F
05D8:  BRA    05D6
05DA:  NOP   
.................... 		portd.MUX_en =1; 
05DC:  BSF    F83.6
.................... 	} 
05DE:  INCF   xB4,F
05E0:  BRA    05A6
.................... 	restart_wdt(); 
05E2:  CLRWDT
.................... } 
05E4:  MOVLB  0
05E6:  RETLW  00
....................  
....................  
.................... ////////////////////////////////// 
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       //set_timer1(get_timer1()+0x7FB8); 
.................... 	  #asm 
.................... 		MOVLW 0x80; 
05E8:  MOVLW  80
.................... 		MOVWF TMR1H; 
05EA:  MOVWF  FCF
.................... 	  #endasm 
....................       timer_sec+=1;  
05EC:  MOVLW  01
05EE:  ADDWF  22,F
05F0:  MOVLW  00
05F2:  ADDWFC 23,F
05F4:  ADDWFC 24,F
05F6:  ADDWFC 25,F
.................... 	  last_command +=1; 
05F8:  MOVLW  01
05FA:  ADDWF  4C,F
05FC:  MOVLW  00
05FE:  ADDWFC 4D,F
0600:  ADDWFC 4E,F
0602:  ADDWFC 4F,F
....................       if (timer_sec>=86400) { 
0604:  MOVF   25,F
0606:  BNZ   0622
0608:  MOVF   24,W
060A:  SUBLW  00
060C:  BC    066E
060E:  XORLW  FF
0610:  BNZ   0622
0612:  MOVF   23,W
0614:  SUBLW  50
0616:  BC    066E
0618:  XORLW  FF
061A:  BNZ   0622
061C:  MOVF   22,W
061E:  SUBLW  7F
0620:  BC    066E
.................... 		nDay = (nDay%1461)+1; 
0622:  MOVFF  31,1C7
0626:  MOVFF  30,1C6
062A:  MOVFF  2F,1C5
062E:  MOVFF  2E,1C4
0632:  MOVLB  1
0634:  CLRF   xCB
0636:  CLRF   xCA
0638:  MOVLW  05
063A:  MOVWF  xC9
063C:  MOVLW  B5
063E:  MOVWF  xC8
0640:  MOVLB  0
0642:  RCALL  04A2
0644:  MOVFF  FEF,1DB
0648:  MOVFF  FEC,1DC
064C:  MOVFF  FEC,1DD
0650:  MOVFF  FEC,1DE
0654:  MOVLW  01
0656:  MOVLB  1
0658:  ADDWF  xDB,W
065A:  MOVWF  2E
065C:  MOVLW  00
065E:  ADDWFC xDC,W
0660:  MOVWF  2F
0662:  MOVLW  00
0664:  ADDWFC xDD,W
0666:  MOVWF  30
0668:  MOVLW  00
066A:  ADDWFC xDE,W
066C:  MOVWF  31
.................... 	  } 
.................... 	  timer_sec = timer_sec % 86400; 
066E:  MOVFF  25,1C7
0672:  MOVFF  24,1C6
0676:  MOVFF  23,1C5
067A:  MOVFF  22,1C4
067E:  MOVLB  1
0680:  CLRF   xCB
0682:  MOVLW  01
0684:  MOVWF  xCA
0686:  MOVLW  51
0688:  MOVWF  xC9
068A:  MOVLW  80
068C:  MOVWF  xC8
068E:  MOVLB  0
0690:  RCALL  04A2
0692:  MOVFF  FEF,22
0696:  MOVFF  FEC,23
069A:  MOVFF  FEC,24
069E:  MOVFF  FEC,25
.................... 	  if (last_command > 180)// if no command recv in 3 minutes, reset the RS232 
06A2:  MOVF   4F,F
06A4:  BNZ   06B4
06A6:  MOVF   4E,F
06A8:  BNZ   06B4
06AA:  MOVF   4D,F
06AC:  BNZ   06B4
06AE:  MOVF   4C,W
06B0:  SUBLW  B4
06B2:  BC    06C0
.................... 	  {	 init_rs232(); 
06B4:  RCALL  0522
.................... 		 last_command =0; 
06B6:  CLRF   4F
06B8:  CLRF   4E
06BA:  CLRF   4D
06BC:  CLRF   4C
.................... 		 cmd_len =0; 
06BE:  CLRF   4A
....................       }    
.................... 	  if (read_adc()<650) { 
06C0:  BSF    FC2.2
06C2:  BTFSC  FC2.2
06C4:  BRA    06C2
06C6:  MOVFF  FC4,1DC
06CA:  MOVLB  1
06CC:  MOVFF  FC3,1DB
06D0:  MOVF   FC4,W
06D2:  SUBLW  02
06D4:  BNC   0704
06D6:  BNZ   06DE
06D8:  MOVF   xDB,W
06DA:  SUBLW  89
06DC:  BNC   0704
.................... 		 if (flag2.is_moving) flag2.abort_current_activity=1; 
06DE:  BTFSC  20.6
06E0:  BSF    20.2
.................... 		 flag2.power = 0; 
06E2:  BCF    20.5
.................... 		 disable_interrupts(INT_RDA); 
06E4:  BCF    F9D.5
.................... 		 led_status =0xFE; 
06E6:  MOVLW  FE
06E8:  MOVWF  21
.................... 		 display_LED(); 
06EA:  MOVLB  0
06EC:  RCALL  0542
.................... 		 delay_ms(10); 
06EE:  MOVLW  0A
06F0:  MOVLB  1
06F2:  MOVWF  xC7
06F4:  MOVLB  0
06F6:  RCALL  0576
.................... 		 led_status =0xFF; 
06F8:  MOVLW  FF
06FA:  MOVWF  21
.................... 		 display_LED(); 
06FC:  RCALL  0542
....................          return; 
06FE:  BRA    0822
.................... 	  } else { 
0700:  BRA    0714
0702:  MOVLB  1
.................... 		 if (flag2.power==0) { 
0704:  BTFSC  20.5
0706:  BRA    0710
.................... 			enable_interrupts(INT_RDA); 
0708:  BSF    F9D.5
.................... 			init_rs232(); 
070A:  MOVLB  0
070C:  RCALL  0522
070E:  MOVLB  1
.................... 		 } 
.................... 		 flag2.power=1; 
0710:  BSF    20.5
0712:  MOVLB  0
.................... 	  } 
....................  
....................       flag.update_time = true; 
0714:  BSF    1F.1
....................       if (flag2.en_operate == 1) { 
0716:  BTFSS  20.0
0718:  BRA    081A
.................... 	  	led_status.power = !led_status.power; // blink power led 
071A:  BTG    21.0
.................... 		// display morning, noon, evening 
.................... 	    if(timer_sec >64800 || timer_sec <21600) { 
071C:  MOVF   25,F
071E:  BNZ   074A
0720:  MOVF   24,F
0722:  BNZ   074A
0724:  MOVF   23,W
0726:  SUBLW  FC
0728:  BC    0734
072A:  XORLW  FF
072C:  BNZ   074A
072E:  MOVF   22,W
0730:  SUBLW  20
0732:  BNC   074A
0734:  MOVF   25,F
0736:  BNZ   0754
0738:  MOVF   24,F
073A:  BNZ   0754
073C:  MOVF   23,W
073E:  SUBLW  54
0740:  BNC   0754
0742:  BNZ   074A
0744:  MOVF   22,W
0746:  SUBLW  5F
0748:  BNC   0754
.................... 			led_status.aux=3; 
074A:  MOVLW  F3
074C:  ANDWF  21,W
074E:  IORLW  0C
0750:  MOVWF  21
.................... 		} else if ( timer_sec < 36000 ) { 
0752:  BRA    079A
0754:  MOVF   25,F
0756:  BNZ   0774
0758:  MOVF   24,F
075A:  BNZ   0774
075C:  MOVF   23,W
075E:  SUBLW  8C
0760:  BNC   0774
0762:  BNZ   076A
0764:  MOVF   22,W
0766:  SUBLW  9F
0768:  BNC   0774
.................... 			led_status.aux=2; 
076A:  MOVLW  F3
076C:  ANDWF  21,W
076E:  IORLW  08
0770:  MOVWF  21
.................... 		} else if ( timer_sec < 50400) { 
0772:  BRA    079A
0774:  MOVF   25,F
0776:  BNZ   0792
0778:  MOVF   24,F
077A:  BNZ   0792
077C:  MOVF   23,W
077E:  SUBLW  C4
0780:  BNC   0792
0782:  BNZ   078A
0784:  MOVF   22,W
0786:  SUBLW  DF
0788:  BNC   0792
.................... 			led_status.aux=0; 
078A:  MOVLW  F3
078C:  ANDWF  21,W
078E:  MOVWF  21
.................... 		} else { 
0790:  BRA    079A
.................... 			led_status.aux=1; 
0792:  MOVLW  F3
0794:  ANDWF  21,W
0796:  IORLW  04
0798:  MOVWF  21
.................... 		} 
....................  
.................... 	  	display_LED(); 
079A:  RCALL  0542
.................... 	  	switch ((unsigned int16) (timer_sec % 450)) { 
079C:  MOVFF  25,1C7
07A0:  MOVFF  24,1C6
07A4:  MOVFF  23,1C5
07A8:  MOVFF  22,1C4
07AC:  MOVLB  1
07AE:  CLRF   xCB
07B0:  CLRF   xCA
07B2:  MOVLW  01
07B4:  MOVWF  xC9
07B6:  MOVLW  C2
07B8:  MOVWF  xC8
07BA:  MOVLB  0
07BC:  RCALL  04A2
07BE:  MOVFF  FEF,00
07C2:  MOVFF  FEC,01
07C6:  MOVFF  FEC,02
07CA:  MOVFF  FEC,03
07CE:  MOVF   01,W
07D0:  MOVWF  03
07D2:  BNZ   07D8
07D4:  MOVF   00,F
07D6:  BZ    07FA
07D8:  MOVF   03,W
07DA:  BNZ   07E2
07DC:  MOVLW  6E
07DE:  SUBWF  00,W
07E0:  BZ    0802
07E2:  MOVF   03,W
07E4:  BNZ   07EC
07E6:  MOVLW  DC
07E8:  SUBWF  00,W
07EA:  BZ    080A
07EC:  MOVLW  01
07EE:  SUBWF  03,W
07F0:  BNZ   07F8
07F2:  MOVLW  4A
07F4:  SUBWF  00,W
07F6:  BZ    0812
07F8:  BRA    081A
.................... 			case 0: {	bit_set(actuator_move_mask,0); break;} 
07FA:  MOVLB  1
07FC:  BSF    xAD.0
07FE:  MOVLB  0
0800:  BRA    081A
.................... 			case 110: {	bit_set(actuator_move_mask,1); break;} 
0802:  MOVLB  1
0804:  BSF    xAD.1
0806:  MOVLB  0
0808:  BRA    081A
.................... 			case 220: {	bit_set(actuator_move_mask,2); break;} 
080A:  MOVLB  1
080C:  BSF    xAD.2
080E:  MOVLB  0
0810:  BRA    081A
.................... 			case 330: {	bit_set(actuator_move_mask,3); break;} 
0812:  MOVLB  1
0814:  BSF    xAD.3
0816:  MOVLB  0
0818:  BRA    081A
.................... 	  	} 
.................... 	  } 
.................... 	  button_scan(); 
081A:  RCALL  05A0
.................... 	  if (nButton == 0) flag2.abort_current_activity=1; 
081C:  MOVF   4B,F
081E:  BTFSC  FD8.2
0820:  BSF    20.2
....................  
.................... } 
....................  
0822:  BCF    F9E.0
0824:  GOTO   0064
.................... void init_spi() { 
.................... 	setup_spi(spi_master |spi_h_to_l | spi_clk_div_16 ); 
*
08A0:  BCF    FC6.5
08A2:  BCF    F94.5
08A4:  BSF    F94.4
08A6:  BCF    F94.3
08A8:  MOVLW  31
08AA:  MOVWF  FC6
08AC:  MOVLW  40
08AE:  MOVWF  FC7
....................     SSPSTAT = 0xC0; 
08B0:  MOVLW  C0
08B2:  MOVWF  FC7
.................... } 
08B4:  GOTO   3F32 (RETURN)
....................  
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................    c=getc(); 
*
0828:  BTFSS  F9E.5
082A:  BRA    0828
082C:  MOVFF  FAE,1DB
0830:  MOVLB  1
....................    switch (c) {	 
0832:  MOVF   xDB,W
0834:  XORLW  08
0836:  MOVLB  0
0838:  BZ    0844
083A:  XORLW  05
083C:  BZ    0848
083E:  XORLW  07
0840:  BZ    0864
0842:  BRA    0866
.................... 	 case(8): 	cmd_len--; break; 
0844:  DECF   4A,F
0846:  BRA    089A
....................      case(13): 	cmd_msg[cmd_len]=0; 
0848:  CLRF   03
084A:  MOVF   4A,W
084C:  ADDLW  36
084E:  MOVWF  FE9
0850:  MOVLW  00
0852:  ADDWFC 03,W
0854:  MOVWF  FEA
0856:  CLRF   FEF
....................    				if(cmd_len>=1)flag.cmd_posted=true; 
0858:  MOVF   4A,W
085A:  SUBLW  00
085C:  BTFSS  FD8.0
085E:  BSF    1F.3
....................    				cmd_len =0; 
0860:  CLRF   4A
.................... 				break; 
0862:  BRA    089A
....................      case(10):  break; 
0864:  BRA    089A
....................      default: 	if ((c>=' ')&&(c<='~'))  
0866:  MOVLB  1
0868:  MOVF   xDB,W
086A:  SUBLW  1F
086C:  BC    0896
086E:  MOVF   xDB,W
0870:  SUBLW  7E
0872:  BNC   0896
.................... 					if(cmd_len<=MAX_CMD_LEN) { 
0874:  MOVF   4A,W
0876:  SUBLW  12
0878:  BNC   0896
.................... 						cmd_msg[cmd_len++]=c; 
087A:  MOVF   4A,W
087C:  INCF   4A,F
087E:  CLRF   03
0880:  ADDLW  36
0882:  MOVWF  FE9
0884:  MOVLW  00
0886:  ADDWFC 03,W
0888:  MOVWF  FEA
088A:  MOVFF  1DB,FEF
.................... 						last_command =0;  
088E:  CLRF   4F
0890:  CLRF   4E
0892:  CLRF   4D
0894:  CLRF   4C
.................... 					} 
.................... 				break;  
0896:  MOVLB  0
0898:  BRA    089A
....................    } 
.................... } 
....................  
089A:  BCF    F9E.5
089C:  GOTO   0064
.................... void process_cmd_msg(){ 
....................    int8 i,j; 
....................    flag.cmd_posted =false; 
*
3086:  BCF    1F.3
....................    last_command =0; 
3088:  CLRF   4F
308A:  CLRF   4E
308C:  CLRF   4D
308E:  CLRF   4C
....................    printf("\r\n>%s\r\n",cmd_msg); 
3090:  MOVLW  0D
3092:  BTFSS  F9E.4
3094:  BRA    3092
3096:  MOVWF  FAD
3098:  MOVLW  0A
309A:  BTFSS  F9E.4
309C:  BRA    309A
309E:  MOVWF  FAD
30A0:  MOVLW  3E
30A2:  BTFSS  F9E.4
30A4:  BRA    30A2
30A6:  MOVWF  FAD
30A8:  CLRF   FEA
30AA:  MOVLW  36
30AC:  MOVWF  FE9
30AE:  MOVLW  00
30B0:  IORWF  FEF,W
30B2:  BZ    30C4
30B4:  MOVF   FEF,W
30B6:  BTFSS  F9E.4
30B8:  BRA    30B6
30BA:  MOVWF  FAD
30BC:  INCF   FE9,F
30BE:  BTFSC  FD8.2
30C0:  INCF   FEA,F
30C2:  BRA    30AE
30C4:  MOVLW  0D
30C6:  BTFSS  F9E.4
30C8:  BRA    30C6
30CA:  MOVWF  FAD
30CC:  MOVLW  0A
30CE:  BTFSS  F9E.4
30D0:  BRA    30CE
30D2:  MOVWF  FAD
....................    switch (cmd_msg[0]) { 
30D4:  MOVLW  62
30D6:  SUBWF  36,W
30D8:  ADDLW  E7
30DA:  BTFSC  FD8.0
30DC:  GOTO   3A0C
30E0:  ADDLW  19
30E2:  GOTO   3A10
....................       case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
30E6:  CLRF   FEA
30E8:  MOVLW  36
30EA:  MOVWF  FE9
30EC:  CLRF   FE2
30EE:  MOVLW  37
30F0:  MOVWF  FE1
30F2:  MOVLW  12
30F4:  MOVWF  01
30F6:  MOVFF  FE6,FEE
30FA:  DECFSZ 01,F
30FC:  BRA    30F6
....................          if (atol(cmd_msg)!=22) break; 
30FE:  MOVLB  1
3100:  CLRF   xB5
3102:  MOVLW  36
3104:  MOVWF  xB4
3106:  MOVLB  0
3108:  CALL   12DC
310C:  MOVFF  02,1B5
3110:  MOVFF  01,1B4
3114:  MOVLB  1
3116:  MOVF   01,W
3118:  SUBLW  16
311A:  BNZ   3120
311C:  MOVF   xB5,F
311E:  BZ    3128
3120:  MOVLB  0
3122:  GOTO   3A0C
3126:  MOVLB  1
.................... 		 printf("\r\n Block erase\r\n"); 
3128:  CLRF   xB4
312A:  MOVF   xB4,W
312C:  MOVLB  0
312E:  CALL   0256
3132:  MOVLB  1
3134:  INCF   xB4,F
3136:  MOVWF  00
3138:  MOVF   00,W
313A:  BTFSS  F9E.4
313C:  BRA    313A
313E:  MOVWF  FAD
3140:  MOVLW  10
3142:  SUBWF  xB4,W
3144:  BNZ   312A
....................          flash_block_erase(); 
3146:  MOVLB  0
3148:  GOTO   14CC
....................          break; } 
....................  
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
314C:  BCF    FF2.6
314E:  BCF    FF2.7
3150:  BTFSC  FF2.7
3152:  BRA    314E
.................... 	     setup_WDT(WDT_OFF); 
3154:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3156:  CLRF   FEA
3158:  MOVLW  36
315A:  MOVWF  FE9
315C:  CLRF   FE2
315E:  MOVLW  37
3160:  MOVWF  FE1
3162:  MOVLW  12
3164:  MOVWF  01
3166:  MOVFF  FE6,FEE
316A:  DECFSZ 01,F
316C:  BRA    3166
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
316E:  MOVLB  1
3170:  CLRF   xB5
3172:  MOVLW  36
3174:  MOVWF  xB4
3176:  MOVLB  0
3178:  CALL   12DC
317C:  MOVFF  02,1B5
3180:  MOVFF  01,1B4
3184:  MOVLB  1
3186:  CLRF   xB6
3188:  MOVF   xB6,W
318A:  MOVLB  0
318C:  CALL   0282
3190:  MOVLB  1
3192:  INCF   xB6,F
3194:  MOVWF  00
3196:  MOVF   00,W
3198:  BTFSS  F9E.4
319A:  BRA    3198
319C:  MOVWF  FAD
319E:  MOVLW  08
31A0:  SUBWF  xB6,W
31A2:  BNZ   3188
31A4:  MOVLW  10
31A6:  MOVWF  FE9
31A8:  MOVFF  1B5,1C7
31AC:  MOVFF  1B4,1C6
31B0:  MOVLB  0
31B2:  CALL   152E
31B6:  MOVLW  3A
31B8:  BTFSS  F9E.4
31BA:  BRA    31B8
31BC:  MOVWF  FAD
....................          print_page_data(atol(cmd_msg)); 
31BE:  MOVLB  1
31C0:  CLRF   xB5
31C2:  MOVLW  36
31C4:  MOVWF  xB4
31C6:  MOVLB  0
31C8:  CALL   12DC
31CC:  MOVFF  02,1B5
31D0:  MOVFF  01,1B4
31D4:  MOVFF  02,1B7
31D8:  MOVFF  01,1B6
31DC:  GOTO   1656
.................... 		 setup_WDT(WDT_ON); 
31E0:  BSF    FD1.0
....................          enable_interrupts(GLOBAL); 
31E2:  MOVLW  C0
31E4:  IORWF  FF2,F
....................          break; 
31E6:  GOTO   3A0C
....................       } 
....................       case 'b': { 
....................          disable_interrupts(GLOBAL); 
31EA:  BCF    FF2.6
31EC:  BCF    FF2.7
31EE:  BTFSC  FF2.7
31F0:  BRA    31EC
....................          memcpy(cmd_msg,cmd_msg+1,18); 
31F2:  CLRF   FEA
31F4:  MOVLW  36
31F6:  MOVWF  FE9
31F8:  CLRF   FE2
31FA:  MOVLW  37
31FC:  MOVWF  FE1
31FE:  MOVLW  12
3200:  MOVWF  01
3202:  MOVFF  FE6,FEE
3206:  DECFSZ 01,F
3208:  BRA    3202
....................          printf("\r\n Write buffer1 -> PAGE %ld:",atol(cmd_msg)); 
320A:  MOVLB  1
320C:  CLRF   xB5
320E:  MOVLW  36
3210:  MOVWF  xB4
3212:  MOVLB  0
3214:  CALL   12DC
3218:  MOVFF  02,1B5
321C:  MOVFF  01,1B4
3220:  MOVLB  1
3222:  CLRF   xB6
3224:  MOVF   xB6,W
3226:  MOVLB  0
3228:  CALL   02AA
322C:  MOVLB  1
322E:  INCF   xB6,F
3230:  MOVWF  00
3232:  MOVF   00,W
3234:  BTFSS  F9E.4
3236:  BRA    3234
3238:  MOVWF  FAD
323A:  MOVLW  19
323C:  SUBWF  xB6,W
323E:  BNZ   3224
3240:  MOVLW  10
3242:  MOVWF  FE9
3244:  MOVFF  1B5,1C7
3248:  MOVFF  1B4,1C6
324C:  MOVLB  0
324E:  CALL   152E
3252:  MOVLW  3A
3254:  BTFSS  F9E.4
3256:  BRA    3254
3258:  MOVWF  FAD
....................          flash_write_buffer1_to_main_memory(atol(cmd_msg)); 
325A:  MOVLB  1
325C:  CLRF   xB5
325E:  MOVLW  36
3260:  MOVWF  xB4
3262:  MOVLB  0
3264:  CALL   12DC
3268:  MOVFF  02,1B5
326C:  MOVFF  01,1B4
3270:  MOVFF  02,1B7
3274:  MOVFF  01,1B6
3278:  GOTO   16FA
....................          enable_interrupts(GLOBAL); 
327C:  MOVLW  C0
327E:  IORWF  FF2,F
....................          break; 
3280:  GOTO   3A0C
....................       } 
....................  
....................       case 'c': { 
....................          disable_interrupts(GLOBAL); 
3284:  BCF    FF2.6
3286:  BCF    FF2.7
3288:  BTFSC  FF2.7
328A:  BRA    3286
....................          memcpy(cmd_msg,cmd_msg+1,18); 
328C:  CLRF   FEA
328E:  MOVLW  36
3290:  MOVWF  FE9
3292:  CLRF   FE2
3294:  MOVLW  37
3296:  MOVWF  FE1
3298:  MOVLW  12
329A:  MOVWF  01
329C:  MOVFF  FE6,FEE
32A0:  DECFSZ 01,F
32A2:  BRA    329C
....................          printf("\r\n Read PAGE %ld -> buffer1",atol(cmd_msg)); 
32A4:  MOVLB  1
32A6:  CLRF   xB5
32A8:  MOVLW  36
32AA:  MOVWF  xB4
32AC:  MOVLB  0
32AE:  CALL   12DC
32B2:  MOVFF  02,1B5
32B6:  MOVFF  01,1B4
32BA:  MOVLB  1
32BC:  CLRF   xB6
32BE:  MOVF   xB6,W
32C0:  MOVLB  0
32C2:  CALL   02E2
32C6:  MOVLB  1
32C8:  INCF   xB6,F
32CA:  MOVWF  00
32CC:  MOVF   00,W
32CE:  BTFSS  F9E.4
32D0:  BRA    32CE
32D2:  MOVWF  FAD
32D4:  MOVLW  0D
32D6:  SUBWF  xB6,W
32D8:  BNZ   32BE
32DA:  MOVLW  10
32DC:  MOVWF  FE9
32DE:  MOVFF  1B5,1C7
32E2:  MOVFF  1B4,1C6
32E6:  MOVLB  0
32E8:  CALL   152E
32EC:  MOVLW  10
32EE:  MOVLB  1
32F0:  MOVWF  xB7
32F2:  MOVF   xB7,W
32F4:  MOVLB  0
32F6:  CALL   02E2
32FA:  MOVLB  1
32FC:  INCF   xB7,F
32FE:  MOVWF  00
3300:  MOVF   00,W
3302:  BTFSS  F9E.4
3304:  BRA    3302
3306:  MOVWF  FAD
3308:  MOVLW  1B
330A:  SUBWF  xB7,W
330C:  BNZ   32F2
....................          flash_read_main_memory_to_buffer1(atol(cmd_msg)); 
330E:  CLRF   xB5
3310:  MOVLW  36
3312:  MOVWF  xB4
3314:  MOVLB  0
3316:  CALL   12DC
331A:  MOVFF  02,1B5
331E:  MOVFF  01,1B4
3322:  MOVFF  02,1B7
3326:  MOVFF  01,1B6
332A:  GOTO   1742
....................          enable_interrupts(GLOBAL); 
332E:  MOVLW  C0
3330:  IORWF  FF2,F
....................          break; 
3332:  BRA    3A0C
....................       } 
....................  
....................       case 'f': { 
....................          disable_interrupts(GLOBAL); 
3334:  BCF    FF2.6
3336:  BCF    FF2.7
3338:  BTFSC  FF2.7
333A:  BRA    3336
.................... 		 setup_WDT(WDT_OFF); 
333C:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
333E:  CLRF   FEA
3340:  MOVLW  36
3342:  MOVWF  FE9
3344:  CLRF   FE2
3346:  MOVLW  37
3348:  MOVWF  FE1
334A:  MOVLW  12
334C:  MOVWF  01
334E:  MOVFF  FE6,FEE
3352:  DECFSZ 01,F
3354:  BRA    334E
....................          printf("\r\n WRITE PAGE %ld:",atol(cmd_msg)); 
3356:  MOVLB  1
3358:  CLRF   xB5
335A:  MOVLW  36
335C:  MOVWF  xB4
335E:  MOVLB  0
3360:  CALL   12DC
3364:  MOVFF  02,1B5
3368:  MOVFF  01,1B4
336C:  MOVLB  1
336E:  CLRF   xB6
3370:  MOVF   xB6,W
3372:  MOVLB  0
3374:  CALL   0318
3378:  MOVLB  1
337A:  INCF   xB6,F
337C:  MOVWF  00
337E:  MOVF   00,W
3380:  BTFSS  F9E.4
3382:  BRA    3380
3384:  MOVWF  FAD
3386:  MOVLW  0E
3388:  SUBWF  xB6,W
338A:  BNZ   3370
338C:  MOVLW  10
338E:  MOVWF  FE9
3390:  MOVFF  1B5,1C7
3394:  MOVFF  1B4,1C6
3398:  MOVLB  0
339A:  CALL   152E
339E:  MOVLW  3A
33A0:  BTFSS  F9E.4
33A2:  BRA    33A0
33A4:  MOVWF  FAD
....................          flash_write_page(atol(cmd_msg)); 
33A6:  MOVLB  1
33A8:  CLRF   xB5
33AA:  MOVLW  36
33AC:  MOVWF  xB4
33AE:  MOVLB  0
33B0:  CALL   12DC
33B4:  MOVFF  02,1B5
33B8:  MOVFF  01,1B4
33BC:  MOVFF  02,1B7
33C0:  MOVFF  01,1B6
33C4:  GOTO   1780
.................... 		 printf("\r\n."); 
33C8:  MOVLW  0D
33CA:  BTFSS  F9E.4
33CC:  BRA    33CA
33CE:  MOVWF  FAD
33D0:  MOVLW  0A
33D2:  BTFSS  F9E.4
33D4:  BRA    33D2
33D6:  MOVWF  FAD
33D8:  MOVLW  2E
33DA:  BTFSS  F9E.4
33DC:  BRA    33DA
33DE:  MOVWF  FAD
.................... 		 setup_WDT(WDT_ON); 
33E0:  BSF    FD1.0
....................          enable_interrupts(GLOBAL); 
33E2:  MOVLW  C0
33E4:  IORWF  FF2,F
....................          break; 
33E6:  BRA    3A0C
....................       } 
....................       case 'g': { 
....................          print_date_time(); 
33E8:  CALL   1C3E
....................          break; 
33EC:  BRA    3A0C
....................       } 
....................  
....................       case 'w': { //buffer1 read 
....................          disable_interrupts(GLOBAL); 
33EE:  BCF    FF2.6
33F0:  BCF    FF2.7
33F2:  BTFSC  FF2.7
33F4:  BRA    33F0
.................... 		 printf("\r\n Buffer1:"); 
33F6:  MOVLB  1
33F8:  CLRF   xB4
33FA:  MOVF   xB4,W
33FC:  MOVLB  0
33FE:  CALL   0346
3402:  MOVLB  1
3404:  INCF   xB4,F
3406:  MOVWF  00
3408:  MOVF   00,W
340A:  BTFSS  F9E.4
340C:  BRA    340A
340E:  MOVWF  FAD
3410:  MOVLW  0B
3412:  SUBWF  xB4,W
3414:  BNZ   33FA
....................     	for(i=0;i<16;i++) { 
3416:  CLRF   xB2
3418:  MOVF   xB2,W
341A:  SUBLW  0F
341C:  BNC   34BA
....................       		printf("\r\n%02X : ",i*16); 
341E:  MOVF   xB2,W
3420:  MULLW  10
3422:  MOVFF  FF3,1B4
3426:  MOVLW  0D
3428:  BTFSS  F9E.4
342A:  BRA    3428
342C:  MOVWF  FAD
342E:  MOVLW  0A
3430:  BTFSS  F9E.4
3432:  BRA    3430
3434:  MOVWF  FAD
3436:  MOVFF  1B4,1BA
343A:  MOVLW  37
343C:  MOVWF  xBB
343E:  MOVLB  0
3440:  CALL   1610
3444:  MOVLW  20
3446:  BTFSS  F9E.4
3448:  BRA    3446
344A:  MOVWF  FAD
344C:  MOVLW  3A
344E:  BTFSS  F9E.4
3450:  BRA    344E
3452:  MOVWF  FAD
3454:  MOVLW  20
3456:  BTFSS  F9E.4
3458:  BRA    3456
345A:  MOVWF  FAD
....................       		for (j=0;j<8;j++) { 
345C:  MOVLB  1
345E:  CLRF   xB3
3460:  MOVF   xB3,W
3462:  SUBLW  07
3464:  BNC   34B6
....................         		flash_buffer1_read(i*16+j*2); 
3466:  MOVF   xB2,W
3468:  MULLW  10
346A:  MOVFF  FF3,1B4
346E:  BCF    FD8.0
3470:  RLCF   xB3,W
3472:  ADDWF  xB4,W
3474:  MOVWF  xB5
3476:  MOVWF  xB6
3478:  MOVLB  0
347A:  GOTO   1F48
.................... 				printf("%02X %02X ",flash_page_data,flash_page_data2); 
347E:  MOVFF  185,1BA
3482:  MOVLW  37
3484:  MOVLB  1
3486:  MOVWF  xBB
3488:  MOVLB  0
348A:  CALL   1610
348E:  MOVLW  20
3490:  BTFSS  F9E.4
3492:  BRA    3490
3494:  MOVWF  FAD
3496:  MOVFF  186,1BA
349A:  MOVLW  37
349C:  MOVLB  1
349E:  MOVWF  xBB
34A0:  MOVLB  0
34A2:  CALL   1610
34A6:  MOVLW  20
34A8:  BTFSS  F9E.4
34AA:  BRA    34A8
34AC:  MOVWF  FAD
.................... 				restart_wdt(); 
34AE:  CLRWDT
.................... 	  	 	} 
34B0:  MOVLB  1
34B2:  INCF   xB3,F
34B4:  BRA    3460
.................... 		 } 
34B6:  INCF   xB2,F
34B8:  BRA    3418
....................          enable_interrupts(GLOBAL);          
34BA:  MOVLW  C0
34BC:  IORWF  FF2,F
....................          break;	 
34BE:  MOVLB  0
34C0:  BRA    3A0C
.................... 	  } 
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
34C2:  CLRF   FEA
34C4:  MOVLW  36
34C6:  MOVWF  FE9
34C8:  CLRF   FE2
34CA:  MOVLW  37
34CC:  MOVWF  FE1
34CE:  MOVLW  12
34D0:  MOVWF  01
34D2:  MOVFF  FE6,FEE
34D6:  DECFSZ 01,F
34D8:  BRA    34D2
....................          if (atol(cmd_msg)==0) break; 
34DA:  MOVLB  1
34DC:  CLRF   xB5
34DE:  MOVLW  36
34E0:  MOVWF  xB4
34E2:  MOVLB  0
34E4:  CALL   12DC
34E8:  MOVFF  02,1B5
34EC:  MOVFF  01,1B4
34F0:  MOVLB  1
34F2:  MOVF   xB4,F
34F4:  BNZ   3500
34F6:  MOVF   xB5,F
34F8:  BNZ   3500
34FA:  MOVLB  0
34FC:  BRA    3A0C
34FE:  MOVLB  1
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
3500:  CLRF   xB5
3502:  MOVLW  36
3504:  MOVWF  xB4
3506:  MOVLB  0
3508:  CALL   12DC
350C:  MOVFF  02,1B5
3510:  MOVFF  01,1B4
3514:  MOVFF  02,1BB
3518:  MOVFF  01,1BA
351C:  MOVLW  23
351E:  MOVLB  1
3520:  MOVWF  xBD
3522:  MOVLW  28
3524:  MOVWF  xBC
3526:  MOVFF  188,1BF
352A:  MOVFF  187,1BE
352E:  MOVLW  01
3530:  MOVWF  xC0
3532:  CLRF   xC1
3534:  MOVLB  0
3536:  CALL   1F9E
....................          break;    } 
353A:  BRA    3A0C
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
353C:  CLRF   FEA
353E:  MOVLW  36
3540:  MOVWF  FE9
3542:  CLRF   FE2
3544:  MOVLW  37
3546:  MOVWF  FE1
3548:  MOVLW  12
354A:  MOVWF  01
354C:  MOVFF  FE6,FEE
3550:  DECFSZ 01,F
3552:  BRA    354C
....................          if (atol(cmd_msg)==0) break; 
3554:  MOVLB  1
3556:  CLRF   xB5
3558:  MOVLW  36
355A:  MOVWF  xB4
355C:  MOVLB  0
355E:  CALL   12DC
3562:  MOVFF  02,1B5
3566:  MOVFF  01,1B4
356A:  MOVLB  1
356C:  MOVF   xB4,F
356E:  BNZ   357A
3570:  MOVF   xB5,F
3572:  BNZ   357A
3574:  MOVLB  0
3576:  BRA    3A0C
3578:  MOVLB  1
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
357A:  CLRF   xB5
357C:  MOVLW  36
357E:  MOVWF  xB4
3580:  MOVLB  0
3582:  CALL   12DC
3586:  MOVFF  02,1B5
358A:  MOVFF  01,1B4
358E:  MOVFF  02,1BB
3592:  MOVFF  01,1BA
3596:  MOVLW  23
3598:  MOVLB  1
359A:  MOVWF  xBD
359C:  MOVLW  28
359E:  MOVWF  xBC
35A0:  MOVFF  188,1BF
35A4:  MOVFF  187,1BE
35A8:  CLRF   xC0
35AA:  CLRF   xC1
35AC:  MOVLB  0
35AE:  CALL   1F9E
....................          break;    } 
35B2:  BRA    3A0C
....................       case 'p': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
35B4:  CLRF   FEA
35B6:  MOVLW  36
35B8:  MOVWF  FE9
35BA:  CLRF   FE2
35BC:  MOVLW  37
35BE:  MOVWF  FE1
35C0:  MOVLW  12
35C2:  MOVWF  01
35C4:  MOVFF  FE6,FEE
35C8:  DECFSZ 01,F
35CA:  BRA    35C4
....................          if (atol(cmd_msg)!=22) break; 
35CC:  MOVLB  1
35CE:  CLRF   xB5
35D0:  MOVLW  36
35D2:  MOVWF  xB4
35D4:  MOVLB  0
35D6:  CALL   12DC
35DA:  MOVFF  02,1B5
35DE:  MOVFF  01,1B4
35E2:  MOVLB  1
35E4:  MOVF   01,W
35E6:  SUBLW  16
35E8:  BNZ   35EE
35EA:  MOVF   xB5,F
35EC:  BZ    35F4
35EE:  MOVLB  0
35F0:  BRA    3A0C
35F2:  MOVLB  1
.................... 		 printf("\r\n Set 256 page size\r\n"); 
35F4:  CLRF   xB4
35F6:  MOVF   xB4,W
35F8:  MOVLB  0
35FA:  CALL   036C
35FE:  MOVLB  1
3600:  INCF   xB4,F
3602:  MOVWF  00
3604:  MOVF   00,W
3606:  BTFSS  F9E.4
3608:  BRA    3606
360A:  MOVWF  FAD
360C:  MOVLW  16
360E:  SUBWF  xB4,W
3610:  BNZ   35F6
....................          flash_set_256_page_size(); 
3612:  MOVLB  0
3614:  GOTO   23C2
....................          break; } 
....................  
.................... 	  case 'z': { 
.................... 		 print_fw_info(); 
3618:  CALL   0DEA
.................... 		 printf("\r\n startup = %ld",startup_counter); 
361C:  MOVLB  1
361E:  CLRF   xB4
3620:  MOVF   xB4,W
3622:  MOVLB  0
3624:  CALL   039E
3628:  MOVLB  1
362A:  INCF   xB4,F
362C:  MOVWF  00
362E:  MOVF   00,W
3630:  BTFSS  F9E.4
3632:  BRA    3630
3634:  MOVWF  FAD
3636:  MOVLW  0D
3638:  SUBWF  xB4,W
363A:  BNZ   3620
363C:  MOVLW  10
363E:  MOVWF  FE9
3640:  MOVFF  33,1C7
3644:  MOVFF  32,1C6
3648:  MOVLB  0
364A:  CALL   152E
.................... 		 break; 
364E:  BRA    3A0C
.................... 	  } 
.................... 	  case 'd': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3650:  CLRF   FEA
3652:  MOVLW  36
3654:  MOVWF  FE9
3656:  CLRF   FE2
3658:  MOVLW  37
365A:  MOVWF  FE1
365C:  MOVLW  12
365E:  MOVWF  01
3660:  MOVFF  FE6,FEE
3664:  DECFSZ 01,F
3666:  BRA    3660
....................          if (atol(cmd_msg)==0) break; 
3668:  MOVLB  1
366A:  CLRF   xB5
366C:  MOVLW  36
366E:  MOVWF  xB4
3670:  MOVLB  0
3672:  CALL   12DC
3676:  MOVFF  02,1B5
367A:  MOVFF  01,1B4
367E:  MOVLB  1
3680:  MOVF   xB4,F
3682:  BNZ   368E
3684:  MOVF   xB5,F
3686:  BNZ   368E
3688:  MOVLB  0
368A:  BRA    3A0C
368C:  MOVLB  1
....................          nDay= atol(cmd_msg); 
368E:  CLRF   xB5
3690:  MOVLW  36
3692:  MOVWF  xB4
3694:  MOVLB  0
3696:  CALL   12DC
369A:  MOVFF  01,00
369E:  MOVFF  02,01
36A2:  CLRF   02
36A4:  CLRF   03
36A6:  MOVFF  03,31
36AA:  MOVFF  02,30
36AE:  MOVFF  01,2F
36B2:  MOVFF  00,2E
....................          break;    } 
36B6:  BRA    3A0C
.................... 	  case 't': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
36B8:  CLRF   FEA
36BA:  MOVLW  36
36BC:  MOVWF  FE9
36BE:  CLRF   FE2
36C0:  MOVLW  37
36C2:  MOVWF  FE1
36C4:  MOVLW  12
36C6:  MOVWF  01
36C8:  MOVFF  FE6,FEE
36CC:  DECFSZ 01,F
36CE:  BRA    36C8
....................          timer_sec = atoi32(cmd_msg); 
36D0:  MOVLB  1
36D2:  CLRF   xB5
36D4:  MOVLW  36
36D6:  MOVWF  xB4
36D8:  MOVLB  0
36DA:  GOTO   2404
36DE:  MOVFF  03,25
36E2:  MOVFF  02,24
36E6:  MOVFF  01,23
36EA:  MOVFF  00,22
.................... 		 timer_sec = timer_sec; // rouding to 60 sec 
....................          break;    } 
36EE:  BRA    3A0C
.................... 	  case 'l': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
36F0:  CLRF   FEA
36F2:  MOVLW  36
36F4:  MOVWF  FE9
36F6:  CLRF   FE2
36F8:  MOVLW  37
36FA:  MOVWF  FE1
36FC:  MOVLW  12
36FE:  MOVWF  01
3700:  MOVFF  FE6,FEE
3704:  DECFSZ 01,F
3706:  BRA    3700
....................          solar_get_act_length(atoi(cmd_msg)); 
3708:  MOVLB  1
370A:  CLRF   xB6
370C:  MOVLW  36
370E:  MOVWF  xB5
3710:  MOVLB  0
3712:  CALL   26F4
3716:  MOVFF  01,1B4
371A:  MOVFF  01,1B5
371E:  CALL   2896
.................... 		 disable_interrupts(GLOBAL); 
3722:  BCF    FF2.6
3724:  BCF    FF2.7
3726:  BTFSC  FF2.7
3728:  BRA    3724
.................... 		 printf("\r\n Act#%d Len=%lu Now=%lu\r\n",atoi(cmd_msg), target_act_position, current_act_position[atoi(cmd_msg)]); 
372A:  MOVLB  1
372C:  CLRF   xB6
372E:  MOVLW  36
3730:  MOVWF  xB5
3732:  MOVLB  0
3734:  CALL   26F4
3738:  MOVFF  01,1B4
373C:  MOVLB  1
373E:  CLRF   xB6
3740:  MOVLW  36
3742:  MOVWF  xB5
3744:  MOVLB  0
3746:  CALL   26F4
374A:  MOVFF  01,1BC
374E:  MOVLW  02
3750:  MOVLB  1
3752:  MOVWF  xBD
3754:  MOVLB  0
3756:  CALL   26A6
375A:  MOVF   01,W
375C:  CLRF   03
375E:  ADDLW  8F
3760:  MOVWF  FE9
3762:  MOVLW  01
3764:  ADDWFC 03,W
3766:  MOVWF  FEA
3768:  MOVFF  FEC,1B7
376C:  MOVF   FED,F
376E:  MOVFF  FEF,1B6
3772:  MOVLB  1
3774:  CLRF   xB8
3776:  MOVF   xB8,W
3778:  MOVLB  0
377A:  CALL   03CA
377E:  MOVLB  1
3780:  INCF   xB8,F
3782:  MOVWF  00
3784:  MOVF   00,W
3786:  BTFSS  F9E.4
3788:  BRA    3786
378A:  MOVWF  FAD
378C:  MOVLW  07
378E:  SUBWF  xB8,W
3790:  BNZ   3776
3792:  MOVFF  1B4,1B9
3796:  MOVLW  1F
3798:  MOVWF  xBA
379A:  MOVLB  0
379C:  CALL   2DFA
37A0:  MOVLW  09
37A2:  MOVLB  1
37A4:  MOVWF  xB9
37A6:  MOVF   xB9,W
37A8:  MOVLB  0
37AA:  CALL   03CA
37AE:  MOVLB  1
37B0:  INCF   xB9,F
37B2:  MOVWF  00
37B4:  MOVF   00,W
37B6:  BTFSS  F9E.4
37B8:  BRA    37B6
37BA:  MOVWF  FAD
37BC:  MOVLW  0E
37BE:  SUBWF  xB9,W
37C0:  BNZ   37A6
37C2:  MOVLW  10
37C4:  MOVWF  FE9
37C6:  MOVFF  198,1BC
37CA:  MOVFF  197,1BB
37CE:  MOVLB  0
37D0:  CALL   0D40
37D4:  MOVLW  11
37D6:  MOVLB  1
37D8:  MOVWF  xBA
37DA:  MOVF   xBA,W
37DC:  MOVLB  0
37DE:  CALL   03CA
37E2:  MOVLB  1
37E4:  INCF   xBA,F
37E6:  MOVWF  00
37E8:  MOVF   00,W
37EA:  BTFSS  F9E.4
37EC:  BRA    37EA
37EE:  MOVWF  FAD
37F0:  MOVLW  16
37F2:  SUBWF  xBA,W
37F4:  BNZ   37DA
37F6:  MOVLW  10
37F8:  MOVWF  FE9
37FA:  MOVFF  1B7,1BC
37FE:  MOVFF  1B6,1BB
3802:  MOVLB  0
3804:  CALL   0D40
3808:  MOVLW  0D
380A:  BTFSS  F9E.4
380C:  BRA    380A
380E:  MOVWF  FAD
3810:  MOVLW  0A
3812:  BTFSS  F9E.4
3814:  BRA    3812
3816:  MOVWF  FAD
.................... 		 enable_interrupts(GLOBAL); 
3818:  MOVLW  C0
381A:  IORWF  FF2,F
.................... 		 actuator_move_execute(atoi(cmd_msg)); 
381C:  MOVLB  1
381E:  CLRF   xB6
3820:  MOVLW  36
3822:  MOVWF  xB5
3824:  MOVLB  0
3826:  CALL   26F4
382A:  MOVFF  01,1B4
382E:  MOVFF  01,1B5
3832:  CALL   2ED6
....................          break;    } 
3836:  BRA    3A0C
....................       case 'h' : { //return home 
.................... 	     memcpy(cmd_msg,cmd_msg+1,18); 
3838:  CLRF   FEA
383A:  MOVLW  36
383C:  MOVWF  FE9
383E:  CLRF   FE2
3840:  MOVLW  37
3842:  MOVWF  FE1
3844:  MOVLW  12
3846:  MOVWF  01
3848:  MOVFF  FE6,FEE
384C:  DECFSZ 01,F
384E:  BRA    3848
....................          if(strlen(cmd_msg)>0) { 
3850:  MOVLB  1
3852:  CLRF   xB7
3854:  MOVLW  36
3856:  MOVWF  xB6
3858:  MOVLB  0
385A:  CALL   1C04
385E:  MOVF   01,F
3860:  BZ    394C
.................... 	     flag2.en_operate =0; 
3862:  BCF    20.0
....................          move_act(2000,9000,move_act_time_out,1,atoi(cmd_msg)); // move actuator to west 
3864:  MOVLB  1
3866:  CLRF   xB6
3868:  MOVLW  36
386A:  MOVWF  xB5
386C:  MOVLB  0
386E:  CALL   26F4
3872:  MOVFF  01,1B4
3876:  MOVLW  07
3878:  MOVLB  1
387A:  MOVWF  xBB
387C:  MOVLW  D0
387E:  MOVWF  xBA
3880:  MOVLW  23
3882:  MOVWF  xBD
3884:  MOVLW  28
3886:  MOVWF  xBC
3888:  MOVFF  188,1BF
388C:  MOVFF  187,1BE
3890:  MOVLW  01
3892:  MOVWF  xC0
3894:  MOVFF  01,1C1
3898:  MOVLB  0
389A:  CALL   1F9E
....................          move_act(2000,9000,move_act_time_out,0,atoi(cmd_msg)); // move actuator to home position 
389E:  MOVLB  1
38A0:  CLRF   xB6
38A2:  MOVLW  36
38A4:  MOVWF  xB5
38A6:  MOVLB  0
38A8:  CALL   26F4
38AC:  MOVFF  01,1B4
38B0:  MOVLW  07
38B2:  MOVLB  1
38B4:  MOVWF  xBB
38B6:  MOVLW  D0
38B8:  MOVWF  xBA
38BA:  MOVLW  23
38BC:  MOVWF  xBD
38BE:  MOVLW  28
38C0:  MOVWF  xBC
38C2:  MOVFF  188,1BF
38C6:  MOVFF  187,1BE
38CA:  CLRF   xC0
38CC:  MOVFF  01,1C1
38D0:  MOVLB  0
38D2:  CALL   1F9E
....................          act_full_stroke_tick[atoi(cmd_msg)]= actuator_pulse; 
38D6:  MOVLB  1
38D8:  CLRF   xB6
38DA:  MOVLW  36
38DC:  MOVWF  xB5
38DE:  MOVLB  0
38E0:  CALL   26F4
38E4:  MOVFF  01,1BC
38E8:  MOVLW  02
38EA:  MOVLB  1
38EC:  MOVWF  xBD
38EE:  MOVLB  0
38F0:  CALL   26A6
38F4:  MOVF   01,W
38F6:  CLRF   03
38F8:  ADDLW  99
38FA:  MOVWF  FE9
38FC:  MOVLW  01
38FE:  ADDWFC 03,W
3900:  MOVWF  FEA
3902:  MOVFF  18A,FEC
3906:  MOVF   FED,F
3908:  MOVFF  189,FEF
....................          current_act_position[atoi(cmd_msg)] =0; 
390C:  MOVLB  1
390E:  CLRF   xB6
3910:  MOVLW  36
3912:  MOVWF  xB5
3914:  MOVLB  0
3916:  CALL   26F4
391A:  MOVFF  01,1BC
391E:  MOVLW  02
3920:  MOVLB  1
3922:  MOVWF  xBD
3924:  MOVLB  0
3926:  CALL   26A6
392A:  MOVF   01,W
392C:  CLRF   03
392E:  ADDLW  8F
3930:  MOVWF  FE9
3932:  MOVLW  01
3934:  ADDWFC 03,W
3936:  MOVWF  FEA
3938:  CLRF   FEC
393A:  MOVF   FED,F
393C:  CLRF   FEF
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
393E:  MOVLW  01
3940:  MOVLB  1
3942:  MOVWF  xB4
3944:  MOVLB  0
3946:  CALL   1072
.................... 	     flag2.en_operate =1;  
394A:  BSF    20.0
.................... 		 } 
....................  
....................          break; 
394C:  BRA    3A0C
....................       } 
.................... 		  
....................       case 'j': { 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
394E:  MOVLW  01
3950:  MOVLB  1
3952:  MOVWF  xB4
3954:  MOVLB  0
3956:  CALL   1072
....................          break; 
395A:  BRA    3A0C
....................       } 
....................  
.................... 	  case 'o': { 
.................... 		 flag2.en_operate = !flag2.en_operate; 
395C:  BTG    20.0
.................... 		 if (flag2.en_operate) printf("\r\n Normal operation"); else printf("\r\n Halt operation"); 
395E:  BTFSS  20.0
3960:  BRA    3984
3962:  MOVLB  1
3964:  CLRF   xB4
3966:  MOVF   xB4,W
3968:  MOVLB  0
396A:  CALL   0400
396E:  MOVLB  1
3970:  INCF   xB4,F
3972:  MOVWF  00
3974:  MOVF   00,W
3976:  BTFSS  F9E.4
3978:  BRA    3976
397A:  MOVWF  FAD
397C:  MOVLW  13
397E:  SUBWF  xB4,W
3980:  BNZ   3966
3982:  BRA    39A4
3984:  MOVLB  1
3986:  CLRF   xB4
3988:  MOVF   xB4,W
398A:  MOVLB  0
398C:  CALL   042E
3990:  MOVLB  1
3992:  INCF   xB4,F
3994:  MOVWF  00
3996:  MOVF   00,W
3998:  BTFSS  F9E.4
399A:  BRA    3998
399C:  MOVWF  FAD
399E:  MOVLW  11
39A0:  SUBWF  xB4,W
39A2:  BNZ   3988
.................... 		 break; 
39A4:  MOVLB  0
39A6:  BRA    3A0C
.................... 	  } 
....................  
....................       case 'y': { //adc conversion 
....................          set_adc_channel(0); 
39A8:  MOVLW  00
39AA:  MOVWF  01
39AC:  MOVF   FC2,W
39AE:  ANDLW  C7
39B0:  IORWF  01,W
39B2:  MOVWF  FC2
....................          delay_us(20); 
39B4:  MOVLW  10
39B6:  MOVWF  00
39B8:  DECFSZ 00,F
39BA:  BRA    39B8
39BC:  NOP   
.................... 		 wall_pwr_read =read_adc(); 
39BE:  BSF    FC2.2
39C0:  BTFSC  FC2.2
39C2:  BRA    39C0
39C4:  MOVFF  FC4,17F
39C8:  MOVLB  1
39CA:  MOVFF  FC3,17E
....................          printf("\r\nADC= %lu",wall_pwr_read); 
39CE:  CLRF   xB4
39D0:  MOVF   xB4,W
39D2:  MOVLB  0
39D4:  CALL   045A
39D8:  MOVLB  1
39DA:  INCF   xB4,F
39DC:  MOVWF  00
39DE:  MOVF   00,W
39E0:  BTFSS  F9E.4
39E2:  BRA    39E0
39E4:  MOVWF  FAD
39E6:  MOVLW  07
39E8:  SUBWF  xB4,W
39EA:  BNZ   39D0
39EC:  MOVLW  10
39EE:  MOVWF  FE9
39F0:  MOVFF  17F,1BC
39F4:  MOVFF  17E,1BB
39F8:  MOVLB  0
39FA:  CALL   0D40
....................          break; 
39FE:  BRA    3A0C
....................       } 
....................       case 'k': { 
.................... 		 disable_interrupts(GLOBAL); 
3A00:  BCF    FF2.6
3A02:  BCF    FF2.7
3A04:  BTFSC  FF2.7
3A06:  BRA    3A02
....................          while(1); 
3A08:  BRA    3A08
....................          break; 
3A0A:  BRA    3A0C
....................       } 
....................  
....................  
....................  
....................       }// end case       
.................... } 
3A0C:  GOTO   40A8 (RETURN)
.................... ////////////////////////////////////// 
.................... void button_menu() { 
.................... 	int8 k; 
.................... 	int8 target_act=0; 
*
3A66:  MOVLB  1
3A68:  CLRF   xB3
....................     flag2.en_operate = 0; // enter halt operation 
3A6A:  BCF    20.0
.................... 	LED_status.power = 0; // always red 
3A6C:  BCF    21.0
.................... 	LED_status.operation =0; 
3A6E:  BCF    21.1
.................... 	LED_status.aux =3; // both turned off 
3A70:  MOVLW  F3
3A72:  ANDWF  21,W
3A74:  IORLW  0C
3A76:  MOVWF  21
.................... 	display_LED(); 
3A78:  MOVLB  0
3A7A:  CALL   0542
....................     flag2.abort_current_activity =0; 
3A7E:  BCF    20.2
.................... 	while(flag2.button_pressed ==1)	button_scan(); 
3A80:  BTFSS  20.1
3A82:  BRA    3A96
3A84:  CLRF   18
3A86:  BTFSC  FF2.7
3A88:  BSF    18.7
3A8A:  BCF    FF2.7
3A8C:  CALL   05A0
3A90:  BTFSC  18.7
3A92:  BSF    FF2.7
3A94:  BRA    3A80
3A96:  CLRF   18
3A98:  BTFSC  FF2.7
3A9A:  BSF    18.7
3A9C:  BCF    FF2.7
.................... 	delay_ms(10); 
3A9E:  MOVLW  0A
3AA0:  MOVLB  1
3AA2:  MOVWF  xC7
3AA4:  MOVLB  0
3AA6:  CALL   0576
3AAA:  BTFSC  18.7
3AAC:  BSF    FF2.7
.................... 	// button release 
....................  
....................     while(1) { 
.................... 		nButton =-1; 
3AAE:  MOVLW  FF
3AB0:  MOVWF  4B
3AB2:  CLRF   18
3AB4:  BTFSC  FF2.7
3AB6:  BSF    18.7
3AB8:  BCF    FF2.7
.................... 		button_scan(); 
3ABA:  CALL   05A0
3ABE:  BTFSC  18.7
3AC0:  BSF    FF2.7
.................... 		restart_wdt(); 
3AC2:  CLRWDT
.................... 		if (nButton != -1){ 
3AC4:  MOVF   4B,W
3AC6:  SUBLW  FF
3AC8:  BTFSC  FD8.2
3ACA:  BRA    3E38
.................... 		switch (nButton) { 
3ACC:  MOVF   4B,W
3ACE:  ADDLW  FA
3AD0:  BTFSC  FD8.0
3AD2:  BRA    3E38
3AD4:  ADDLW  06
3AD6:  GOTO   3E3E
.................... 			case 0: { // operate/halt button  
.................... 					while (flag2.button_pressed ==1) button_scan(); 
3ADA:  BTFSS  20.1
3ADC:  BRA    3AF0
3ADE:  CLRF   18
3AE0:  BTFSC  FF2.7
3AE2:  BSF    18.7
3AE4:  BCF    FF2.7
3AE6:  CALL   05A0
3AEA:  BTFSC  18.7
3AEC:  BSF    FF2.7
3AEE:  BRA    3ADA
3AF0:  CLRF   18
3AF2:  BTFSC  FF2.7
3AF4:  BSF    18.7
3AF6:  BCF    FF2.7
.................... 					delay_ms(10); 
3AF8:  MOVLW  0A
3AFA:  MOVLB  1
3AFC:  MOVWF  xC7
3AFE:  MOVLB  0
3B00:  CALL   0576
3B04:  BTFSC  18.7
3B06:  BSF    FF2.7
.................... 					nButton=-1; 
3B08:  MOVLW  FF
3B0A:  MOVWF  4B
.................... 					flag2.en_operate =1; 
3B0C:  BSF    20.0
.................... 					flag2.abort_current_activity =0; 
3B0E:  BCF    20.2
.................... 					init_rs232(); 
3B10:  CALL   0522
.................... 					return;} 
3B14:  BRA    3E3A
.................... 			case 1: { // actuator select button 
.................... 					while (flag2.button_pressed ==1) button_scan(); 
3B16:  BTFSS  20.1
3B18:  BRA    3B2C
3B1A:  CLRF   18
3B1C:  BTFSC  FF2.7
3B1E:  BSF    18.7
3B20:  BCF    FF2.7
3B22:  CALL   05A0
3B26:  BTFSC  18.7
3B28:  BSF    FF2.7
3B2A:  BRA    3B16
3B2C:  CLRF   18
3B2E:  BTFSC  FF2.7
3B30:  BSF    18.7
3B32:  BCF    FF2.7
.................... 					delay_ms(10); 
3B34:  MOVLW  0A
3B36:  MOVLB  1
3B38:  MOVWF  xC7
3B3A:  MOVLB  0
3B3C:  CALL   0576
3B40:  BTFSC  18.7
3B42:  BSF    FF2.7
.................... 					target_act++; 
3B44:  MOVLB  1
3B46:  INCF   xB3,F
.................... 					target_act = target_act%4; 
3B48:  MOVLW  03
3B4A:  ANDWF  xB3,F
.................... 					LED_status.aux=target_act ^ 0xFF ; 
3B4C:  MOVF   xB3,W
3B4E:  XORLW  FF
3B50:  ANDLW  03
3B52:  MOVWF  00
3B54:  BCF    FD8.0
3B56:  RLCF   00,F
3B58:  RLCF   00,F
3B5A:  MOVLW  F3
3B5C:  ANDWF  21,W
3B5E:  IORWF  00,W
3B60:  MOVWF  21
.................... 					display_LED(); 
3B62:  MOVLB  0
3B64:  CALL   0542
.................... 					break;} 
3B68:  BRA    3E38
....................       		case 2: { //return home 
....................          			move_act(2000,9000,move_act_time_out,1,target_act); // move actuator to west 
3B6A:  MOVLW  07
3B6C:  MOVLB  1
3B6E:  MOVWF  xBB
3B70:  MOVLW  D0
3B72:  MOVWF  xBA
3B74:  MOVLW  23
3B76:  MOVWF  xBD
3B78:  MOVLW  28
3B7A:  MOVWF  xBC
3B7C:  MOVFF  188,1BF
3B80:  MOVFF  187,1BE
3B84:  MOVLW  01
3B86:  MOVWF  xC0
3B88:  MOVFF  1B3,1C1
3B8C:  MOVLB  0
3B8E:  CALL   1F9E
....................          			move_act(2000,9000,move_act_time_out,0,target_act); // move actuator to home position 
3B92:  MOVLW  07
3B94:  MOVLB  1
3B96:  MOVWF  xBB
3B98:  MOVLW  D0
3B9A:  MOVWF  xBA
3B9C:  MOVLW  23
3B9E:  MOVWF  xBD
3BA0:  MOVLW  28
3BA2:  MOVWF  xBC
3BA4:  MOVFF  188,1BF
3BA8:  MOVFF  187,1BE
3BAC:  CLRF   xC0
3BAE:  MOVFF  1B3,1C1
3BB2:  MOVLB  0
3BB4:  CALL   1F9E
....................          			act_full_stroke_tick[target_act]= actuator_pulse; 
3BB8:  BCF    FD8.0
3BBA:  MOVLB  1
3BBC:  RLCF   xB3,W
3BBE:  CLRF   03
3BC0:  ADDLW  99
3BC2:  MOVWF  FE9
3BC4:  MOVLW  01
3BC6:  ADDWFC 03,W
3BC8:  MOVWF  FEA
3BCA:  MOVFF  18A,FEC
3BCE:  MOVF   FED,F
3BD0:  MOVFF  189,FEF
....................          			current_act_position[target_act] =0; 
3BD4:  BCF    FD8.0
3BD6:  RLCF   xB3,W
3BD8:  CLRF   03
3BDA:  ADDLW  8F
3BDC:  MOVWF  FE9
3BDE:  MOVLW  01
3BE0:  ADDWFC 03,W
3BE2:  MOVWF  FEA
3BE4:  CLRF   FEC
3BE6:  MOVF   FED,F
3BE8:  CLRF   FEF
....................          			write_eeprom_data(1); // save full_stroke_tick and current_position 
3BEA:  MOVLW  01
3BEC:  MOVWF  xB4
3BEE:  MOVLB  0
3BF0:  CALL   1072
....................          			break; 
3BF4:  BRA    3E38
....................       				} 
.................... 			case 3: { // move east 
.................... 					flag2.allow_manual_move_act=1; 
3BF6:  BSF    20.3
.................... 					move_act(10,4500,move_act_time_out,0,target_act); 
3BF8:  MOVLB  1
3BFA:  CLRF   xBB
3BFC:  MOVLW  0A
3BFE:  MOVWF  xBA
3C00:  MOVLW  11
3C02:  MOVWF  xBD
3C04:  MOVLW  94
3C06:  MOVWF  xBC
3C08:  MOVFF  188,1BF
3C0C:  MOVFF  187,1BE
3C10:  CLRF   xC0
3C12:  MOVFF  1B3,1C1
3C16:  MOVLB  0
3C18:  CALL   1F9E
.................... 					flag2.allow_manual_move_act=0; 
3C1C:  BCF    20.3
.................... 					break; } 
3C1E:  BRA    3E38
.................... 			case 4: { // move safty 
.................... 				    while (flag2.button_pressed ==1) button_scan(); 
3C20:  BTFSS  20.1
3C22:  BRA    3C36
3C24:  CLRF   18
3C26:  BTFSC  FF2.7
3C28:  BSF    18.7
3C2A:  BCF    FF2.7
3C2C:  CALL   05A0
3C30:  BTFSC  18.7
3C32:  BSF    FF2.7
3C34:  BRA    3C20
3C36:  CLRF   18
3C38:  BTFSC  FF2.7
3C3A:  BSF    18.7
3C3C:  BCF    FF2.7
.................... 					delay_ms(10); 
3C3E:  MOVLW  0A
3C40:  MOVLB  1
3C42:  MOVWF  xC7
3C44:  MOVLB  0
3C46:  CALL   0576
3C4A:  BTFSC  18.7
3C4C:  BSF    FF2.7
.................... 					tick = (int32)act_full_stroke_tick[target_act]*(int32)(act_safety_stroke-act_min_stroke); 
3C4E:  BCF    FD8.0
3C50:  MOVLB  1
3C52:  RLCF   xB3,W
3C54:  CLRF   03
3C56:  ADDLW  99
3C58:  MOVWF  FE9
3C5A:  MOVLW  01
3C5C:  ADDWFC 03,W
3C5E:  MOVWF  FEA
3C60:  MOVFF  FEC,03
3C64:  MOVF   FED,F
3C66:  MOVFF  FEF,1B4
3C6A:  MOVFF  03,1B5
3C6E:  CLRF   xB6
3C70:  CLRF   xB7
3C72:  MOVF   xA3,W
3C74:  SUBWF  xA5,W
3C76:  MOVWF  00
3C78:  MOVF   xA4,W
3C7A:  SUBWFB xA6,W
3C7C:  MOVWF  03
3C7E:  MOVF   00,W
3C80:  MOVFF  03,01
3C84:  CLRF   02
3C86:  CLRF   03
3C88:  MOVFF  03,1BB
3C8C:  MOVFF  02,1BA
3C90:  MOVFF  01,1B9
3C94:  MOVFF  00,1B8
3C98:  MOVFF  FEA,1BD
3C9C:  MOVFF  FE9,1BC
3CA0:  MOVFF  1B7,1CD
3CA4:  MOVFF  1B6,1CC
3CA8:  MOVFF  1B5,1CB
3CAC:  MOVFF  1B4,1CA
3CB0:  MOVFF  03,1D1
3CB4:  MOVFF  02,1D0
3CB8:  MOVFF  01,1CF
3CBC:  MOVFF  00,1CE
3CC0:  MOVLB  0
3CC2:  CALL   18F0
3CC6:  MOVFF  1BD,FEA
3CCA:  MOVFF  1BC,FE9
3CCE:  MOVFF  03,29
3CD2:  MOVFF  02,28
3CD6:  MOVFF  01,27
3CDA:  MOVFF  00,26
.................... 					tick = tick/(act_max_stroke-act_min_stroke); 
3CDE:  MOVLB  1
3CE0:  MOVF   xA3,W
3CE2:  SUBWF  xA1,W
3CE4:  MOVWF  00
3CE6:  MOVF   xA4,W
3CE8:  SUBWFB xA2,W
3CEA:  MOVWF  03
3CEC:  MOVFF  00,1B4
3CF0:  MOVWF  xB5
3CF2:  CLRF   18
3CF4:  BTFSC  FF2.7
3CF6:  BSF    18.7
3CF8:  BCF    FF2.7
3CFA:  MOVFF  29,1C7
3CFE:  MOVFF  28,1C6
3D02:  MOVFF  27,1C5
3D06:  MOVFF  26,1C4
3D0A:  CLRF   xCB
3D0C:  CLRF   xCA
3D0E:  MOVWF  xC9
3D10:  MOVFF  00,1C8
3D14:  MOVLB  0
3D16:  CALL   04A2
3D1A:  BTFSC  18.7
3D1C:  BSF    FF2.7
3D1E:  MOVFF  03,29
3D22:  MOVFF  02,28
3D26:  MOVFF  01,27
3D2A:  MOVFF  00,26
.................... 					target_act_position = (unsigned int16) tick; 
3D2E:  MOVFF  27,198
3D32:  MOVFF  26,197
.................... 					disable_interrupts(GLOBAL); 
3D36:  BCF    FF2.6
3D38:  BCF    FF2.7
3D3A:  BTFSC  FF2.7
3D3C:  BRA    3D38
.................... 			 		printf("\r\n Act#%d Len=%lu Now=%lu\r\n",target_act, target_act_position, current_act_position[target_act]); 
3D3E:  BCF    FD8.0
3D40:  MOVLB  1
3D42:  RLCF   xB3,W
3D44:  CLRF   03
3D46:  ADDLW  8F
3D48:  MOVWF  FE9
3D4A:  MOVLW  01
3D4C:  ADDWFC 03,W
3D4E:  MOVWF  FEA
3D50:  MOVFF  FEC,1B5
3D54:  MOVF   FED,F
3D56:  MOVFF  FEF,1B4
3D5A:  CLRF   xB6
3D5C:  MOVF   xB6,W
3D5E:  MOVLB  0
3D60:  CALL   03CA
3D64:  MOVLB  1
3D66:  INCF   xB6,F
3D68:  MOVWF  00
3D6A:  MOVF   00,W
3D6C:  BTFSS  F9E.4
3D6E:  BRA    3D6C
3D70:  MOVWF  FAD
3D72:  MOVLW  07
3D74:  SUBWF  xB6,W
3D76:  BNZ   3D5C
3D78:  MOVFF  1B3,1B9
3D7C:  MOVLW  1F
3D7E:  MOVWF  xBA
3D80:  MOVLB  0
3D82:  CALL   2DFA
3D86:  MOVLW  09
3D88:  MOVLB  1
3D8A:  MOVWF  xB7
3D8C:  MOVF   xB7,W
3D8E:  MOVLB  0
3D90:  CALL   03CA
3D94:  MOVLB  1
3D96:  INCF   xB7,F
3D98:  MOVWF  00
3D9A:  MOVF   00,W
3D9C:  BTFSS  F9E.4
3D9E:  BRA    3D9C
3DA0:  MOVWF  FAD
3DA2:  MOVLW  0E
3DA4:  SUBWF  xB7,W
3DA6:  BNZ   3D8C
3DA8:  MOVLW  10
3DAA:  MOVWF  FE9
3DAC:  MOVFF  198,1BC
3DB0:  MOVFF  197,1BB
3DB4:  MOVLB  0
3DB6:  CALL   0D40
3DBA:  MOVLW  11
3DBC:  MOVLB  1
3DBE:  MOVWF  xB8
3DC0:  MOVF   xB8,W
3DC2:  MOVLB  0
3DC4:  CALL   03CA
3DC8:  MOVLB  1
3DCA:  INCF   xB8,F
3DCC:  MOVWF  00
3DCE:  MOVF   00,W
3DD0:  BTFSS  F9E.4
3DD2:  BRA    3DD0
3DD4:  MOVWF  FAD
3DD6:  MOVLW  16
3DD8:  SUBWF  xB8,W
3DDA:  BNZ   3DC0
3DDC:  MOVLW  10
3DDE:  MOVWF  FE9
3DE0:  MOVFF  1B5,1BC
3DE4:  MOVFF  1B4,1BB
3DE8:  MOVLB  0
3DEA:  CALL   0D40
3DEE:  MOVLW  0D
3DF0:  BTFSS  F9E.4
3DF2:  BRA    3DF0
3DF4:  MOVWF  FAD
3DF6:  MOVLW  0A
3DF8:  BTFSS  F9E.4
3DFA:  BRA    3DF8
3DFC:  MOVWF  FAD
.................... 					enable_interrupts(GLOBAL); 
3DFE:  MOVLW  C0
3E00:  IORWF  FF2,F
.................... 					actuator_move_execute(target_act); 
3E02:  MOVFF  1B3,1B5
3E06:  CALL   2ED6
.................... 					break; } 
3E0A:  BRA    3E38
.................... 			case 5: { // move west 
.................... 					flag2.allow_manual_move_act=1; 
3E0C:  BSF    20.3
.................... 					move_act(10,4500,move_act_time_out,1,target_act); 
3E0E:  MOVLB  1
3E10:  CLRF   xBB
3E12:  MOVLW  0A
3E14:  MOVWF  xBA
3E16:  MOVLW  11
3E18:  MOVWF  xBD
3E1A:  MOVLW  94
3E1C:  MOVWF  xBC
3E1E:  MOVFF  188,1BF
3E22:  MOVFF  187,1BE
3E26:  MOVLW  01
3E28:  MOVWF  xC0
3E2A:  MOVFF  1B3,1C1
3E2E:  MOVLB  0
3E30:  CALL   1F9E
.................... 					flag2.allow_manual_move_act=0; 
3E34:  BCF    20.3
.................... 					break; } 
3E36:  BRA    3E38
....................  
.................... 			} 
.................... 			 
.................... 		} 
.................... 		} 
3E38:  BRA    3AAE
.................... 		 
.................... } 
3E3A:  GOTO   4220 (RETURN)
....................  
.................... ////////////////////////////////////// 
.................... void main() { 
*
3E6E:  CLRF   FF8
3E70:  BCF    FD0.7
3E72:  BSF    0D.7
3E74:  CLRF   FEA
3E76:  CLRF   FE9
3E78:  MOVLW  03
3E7A:  MOVWF  FAF
3E7C:  MOVLW  A2
3E7E:  MOVWF  FAC
3E80:  MOVLW  90
3E82:  MOVWF  FAB
3E84:  BSF    F94.4
3E86:  BCF    F94.5
3E88:  BCF    F94.3
3E8A:  BCF    F8B.3
3E8C:  BSF    FC1.0
3E8E:  BSF    FC1.1
3E90:  BSF    FC1.2
3E92:  BCF    FC1.3
3E94:  MOVLW  07
3E96:  MOVWF  FB4
3E98:  CLRF   19
3E9A:  CLRF   1A
3E9C:  CLRF   22
3E9E:  CLRF   23
3EA0:  CLRF   24
3EA2:  CLRF   25
3EA4:  CLRF   26
3EA6:  CLRF   27
3EA8:  CLRF   28
3EAA:  CLRF   29
3EAC:  CLRF   2A
3EAE:  CLRF   2B
3EB0:  CLRF   2C
3EB2:  CLRF   2D
3EB4:  MOVLW  01
3EB6:  MOVWF  2E
3EB8:  CLRF   2F
3EBA:  CLRF   30
3EBC:  CLRF   31
3EBE:  CLRF   32
3EC0:  CLRF   33
3EC2:  MOVLW  75
3EC4:  MOVWF  34
3EC6:  CLRF   35
3EC8:  CLRF   4A
3ECA:  MOVLW  FF
3ECC:  MOVWF  4B
3ECE:  CLRF   4C
3ED0:  CLRF   4D
3ED2:  CLRF   4E
3ED4:  CLRF   4F
3ED6:  CLRF   50
3ED8:  CLRF   51
3EDA:  CLRF   52
3EDC:  MOVLB  1
3EDE:  CLRF   x84
3EE0:  CLRF   x85
3EE2:  CLRF   x86
3EE4:  MOVLW  03
3EE6:  MOVWF  x87
3EE8:  CLRF   x88
3EEA:  CLRF   x89
3EEC:  CLRF   x8A
3EEE:  CLRF   x8F
3EF0:  CLRF   x90
3EF2:  CLRF   x91
3EF4:  CLRF   x92
3EF6:  CLRF   x93
3EF8:  CLRF   x94
3EFA:  CLRF   x95
3EFC:  CLRF   x96
3EFE:  CLRF   x97
3F00:  CLRF   x98
3F02:  CLRF   x99
3F04:  CLRF   x9A
3F06:  CLRF   x9B
3F08:  CLRF   x9C
3F0A:  CLRF   x9D
3F0C:  CLRF   x9E
3F0E:  CLRF   x9F
3F10:  CLRF   xA0
3F12:  CLRF   xA1
3F14:  CLRF   xA2
3F16:  CLRF   xA3
3F18:  CLRF   xA4
3F1A:  CLRF   xA5
3F1C:  CLRF   xA6
3F1E:  CLRF   xA7
3F20:  CLRF   xA8
3F22:  CLRF   xA9
3F24:  CLRF   xAA
3F26:  CLRF   xAB
3F28:  CLRF   xAC
3F2A:  CLRF   xAD
.................... 	int16 relay_time; 
.................... 	int8 act_loop,i; 
.................... 	init_spi(); 
3F2C:  MOVLB  0
3F2E:  GOTO   08A0
....................     setup_adc_ports(AN0); 
3F32:  BCF    FC1.0
3F34:  BSF    FC1.1
3F36:  BSF    FC1.2
3F38:  BSF    FC1.3
....................     setup_adc(ADC_CLOCK_INTERNAL); 
3F3A:  BCF    FC1.6
3F3C:  BSF    FC2.6
3F3E:  BSF    FC2.7
3F40:  BSF    FC1.7
3F42:  BSF    FC2.0
....................     set_adc_channel(0); 
3F44:  MOVLW  00
3F46:  MOVWF  01
3F48:  MOVF   FC2,W
3F4A:  ANDLW  C7
3F4C:  IORWF  01,W
3F4E:  MOVWF  FC2
.................... 	set_tris_a(0xFF); 
3F50:  MOVLW  FF
3F52:  MOVWF  F92
.................... 	set_tris_b(0xFF); 
3F54:  MOVWF  F93
.................... 	set_tris_d(0x00); 
3F56:  MOVLW  00
3F58:  MOVWF  F95
....................     led_status =0xF0; 
3F5A:  MOVLW  F0
3F5C:  MOVWF  21
.................... 	display_LED(); 
3F5E:  CALL   0542
.................... 	delay_ms(5000); 
3F62:  MOVLW  14
3F64:  MOVLB  1
3F66:  MOVWF  xB2
3F68:  CLRF   18
3F6A:  BTFSC  FF2.7
3F6C:  BSF    18.7
3F6E:  BCF    FF2.7
3F70:  MOVLW  FA
3F72:  MOVWF  xC7
3F74:  MOVLB  0
3F76:  CALL   0576
3F7A:  BTFSC  18.7
3F7C:  BSF    FF2.7
3F7E:  MOVLB  1
3F80:  DECFSZ xB2,F
3F82:  BRA    3F68
.................... 	while(read_adc() < 700) { 
3F84:  BSF    FC2.2
3F86:  BTFSC  FC2.2
3F88:  BRA    3F86
3F8A:  MOVFF  FC4,03
3F8E:  MOVFF  FC3,1B2
3F92:  MOVF   FC4,W
3F94:  MOVWF  xB3
3F96:  SUBLW  02
3F98:  BNC   3FE8
3F9A:  BNZ   3FA2
3F9C:  MOVF   xB2,W
3F9E:  SUBLW  BB
3FA0:  BNC   3FE8
.................... 		 led_status =0xFE; 
3FA2:  MOVLW  FE
3FA4:  MOVWF  21
.................... 		 display_LED(); 
3FA6:  MOVLB  0
3FA8:  CALL   0542
3FAC:  CLRF   18
3FAE:  BTFSC  FF2.7
3FB0:  BSF    18.7
3FB2:  BCF    FF2.7
.................... 		 delay_ms(2); 
3FB4:  MOVLW  02
3FB6:  MOVLB  1
3FB8:  MOVWF  xC7
3FBA:  MOVLB  0
3FBC:  CALL   0576
3FC0:  BTFSC  18.7
3FC2:  BSF    FF2.7
.................... 		 led_status =0xFF; 
3FC4:  MOVLW  FF
3FC6:  MOVWF  21
.................... 		 display_LED();			 
3FC8:  CALL   0542
3FCC:  CLRF   18
3FCE:  BTFSC  FF2.7
3FD0:  BSF    18.7
3FD2:  BCF    FF2.7
.................... 		 delay_ms(50); 
3FD4:  MOVLW  32
3FD6:  MOVLB  1
3FD8:  MOVWF  xC7
3FDA:  MOVLB  0
3FDC:  CALL   0576
3FE0:  BTFSC  18.7
3FE2:  BSF    FF2.7
.................... 	} // trap here  until voltage level is good 
3FE4:  MOVLB  1
3FE6:  BRA    3F84
3FE8:  CLRF   18
3FEA:  BTFSC  FF2.7
3FEC:  BSF    18.7
3FEE:  BCF    FF2.7
.................... 	delay_ms(200); 
3FF0:  MOVLW  C8
3FF2:  MOVWF  xC7
3FF4:  MOVLB  0
3FF6:  CALL   0576
3FFA:  BTFSC  18.7
3FFC:  BSF    FF2.7
.................... 	flag2.power=1; 
3FFE:  BSF    20.5
....................  
....................  
.................... 	output_high(TX_EN); 
4000:  BCF    F96.1
4002:  BSF    F8D.1
....................  
....................  
.................... 	flash_wait_until_ready(); 
4004:  CALL   08EC
.................... 	flash_read_mfg_id(); 
4008:  GOTO   0918
.................... 	flash_read_stat(); // stat & 0xBF == 0x9C means device ready 
400C:  CALL   08B8
....................     // check flash readiness here // 
.................... 	read_eeprom_data(); 
4010:  GOTO   0990
.................... 	print_fw_info(); 
4014:  CALL   0DEA
....................     T1CON = 0b00001111;  // 0b10011011 
4018:  MOVLW  0F
401A:  MOVWF  FCD
....................     enable_interrupts(INT_RDA); 
401C:  BSF    F9D.5
....................     enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
401E:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
4020:  MOVLW  C0
4022:  IORWF  FF2,F
.................... 	init_rs232(); 
4024:  CALL   0522
.................... 	relay_time =0; 
4028:  MOVLB  1
402A:  CLRF   xAF
402C:  CLRF   xAE
.................... 	flag2.en_operate =1; 
402E:  BSF    20.0
.................... 	flag2.button_pressed=0; 
4030:  BCF    20.1
.................... 	flag2.allow_manual_move_act=0; 
4032:  BCF    20.3
.................... 	LED_status =0x00; 
4034:  CLRF   21
4036:  CLRF   18
4038:  BTFSC  FF2.7
403A:  BSF    18.7
403C:  BCF    FF2.7
....................  
.................... 	delay_ms(200); 
403E:  MOVLW  C8
4040:  MOVWF  xC7
4042:  MOVLB  0
4044:  CALL   0576
4048:  BTFSC  18.7
404A:  BSF    FF2.7
.................... 	while(read_eeprom((int8)0xf00040)!=0x34); 
404C:  MOVFF  FF2,1B2
4050:  BCF    FF2.7
4052:  MOVLW  40
4054:  MOVWF  FA9
4056:  BCF    FA6.6
4058:  BCF    FA6.7
405A:  BSF    FA6.0
405C:  MOVF   FA8,W
405E:  MOVLB  1
4060:  BTFSC  xB2.7
4062:  BSF    FF2.7
4064:  SUBLW  34
4066:  BTFSC  FD8.2
4068:  BRA    406E
406A:  MOVLB  0
406C:  BRA    404C
.................... 	while(read_eeprom((int8)0xf00041)!=0x12); 
406E:  MOVFF  FF2,1B2
4072:  BCF    FF2.7
4074:  MOVLW  41
4076:  MOVWF  FA9
4078:  BCF    FA6.6
407A:  BCF    FA6.7
407C:  BSF    FA6.0
407E:  MOVF   FA8,W
4080:  BTFSC  xB2.7
4082:  BSF    FF2.7
4084:  SUBLW  12
4086:  BNZ   406E
.................... 	display_LED(); 
4088:  MOVLB  0
408A:  CALL   0542
.................... 	startup_counter++; 
408E:  INCF   32,F
4090:  BTFSC  FD8.2
4092:  INCF   33,F
.................... 	write_eeprom_data(0); 
4094:  MOVLB  1
4096:  CLRF   xB4
4098:  MOVLB  0
409A:  CALL   1072
.................... 	setup_wdt(WDT_ON); 
409E:  BSF    FD1.0
.................... 	while(1) { 
.................... 		if (flag.cmd_posted==1) process_cmd_msg(); 
40A0:  BTFSS  1F.3
40A2:  BRA    40A8
40A4:  GOTO   3086
.................... 		for(act_loop=0;act_loop<4;act_loop++) 
40A8:  MOVLB  1
40AA:  CLRF   xB0
40AC:  MOVF   xB0,W
40AE:  SUBLW  03
40B0:  BTFSS  FD8.0
40B2:  BRA    4218
.................... 		{ 
.................... 			if (bit_test(actuator_move_mask,act_loop)==1){ 
40B4:  MOVFF  1AD,00
40B8:  MOVF   xB0,W
40BA:  MOVWF  01
40BC:  BZ    40C6
40BE:  BCF    FD8.0
40C0:  RRCF   00,F
40C2:  DECFSZ 01,F
40C4:  BRA    40BE
40C6:  BTFSS  00.0
40C8:  BRA    4214
.................... 				if (act_full_stroke_tick[act_loop]>0x0010) { 
40CA:  BCF    FD8.0
40CC:  RLCF   xB0,W
40CE:  CLRF   03
40D0:  ADDLW  99
40D2:  MOVWF  FE9
40D4:  MOVLW  01
40D6:  ADDWFC 03,W
40D8:  MOVWF  FEA
40DA:  MOVFF  FEC,1B3
40DE:  MOVF   FED,F
40E0:  MOVFF  FEF,1B2
40E4:  MOVF   xB3,F
40E6:  BNZ   40F0
40E8:  MOVF   xB2,W
40EA:  SUBLW  10
40EC:  BTFSC  FD8.0
40EE:  BRA    4214
....................          		solar_get_act_length(act_loop); 
40F0:  MOVFF  1B0,1B5
40F4:  MOVLB  0
40F6:  CALL   2896
.................... 				disable_interrupts(GLOBAL); 
40FA:  BCF    FF2.6
40FC:  BCF    FF2.7
40FE:  BTFSC  FF2.7
4100:  BRA    40FC
.................... 		 		printf("\r\n Act#%d Len=%lu Now=%lu\r\n",act_loop, target_act_position, current_act_position[act_loop]); 
4102:  BCF    FD8.0
4104:  MOVLB  1
4106:  RLCF   xB0,W
4108:  CLRF   03
410A:  ADDLW  8F
410C:  MOVWF  FE9
410E:  MOVLW  01
4110:  ADDWFC 03,W
4112:  MOVWF  FEA
4114:  MOVFF  FEC,1B3
4118:  MOVF   FED,F
411A:  MOVFF  FEF,1B2
411E:  CLRF   xB4
4120:  MOVF   xB4,W
4122:  MOVLB  0
4124:  CALL   03CA
4128:  MOVLB  1
412A:  INCF   xB4,F
412C:  MOVWF  00
412E:  MOVF   00,W
4130:  BTFSS  F9E.4
4132:  BRA    4130
4134:  MOVWF  FAD
4136:  MOVLW  07
4138:  SUBWF  xB4,W
413A:  BNZ   4120
413C:  MOVFF  1B0,1B9
4140:  MOVLW  1F
4142:  MOVWF  xBA
4144:  MOVLB  0
4146:  CALL   2DFA
414A:  MOVLW  09
414C:  MOVLB  1
414E:  MOVWF  xB5
4150:  MOVF   xB5,W
4152:  MOVLB  0
4154:  CALL   03CA
4158:  MOVLB  1
415A:  INCF   xB5,F
415C:  MOVWF  00
415E:  MOVF   00,W
4160:  BTFSS  F9E.4
4162:  BRA    4160
4164:  MOVWF  FAD
4166:  MOVLW  0E
4168:  SUBWF  xB5,W
416A:  BNZ   4150
416C:  MOVLW  10
416E:  MOVWF  FE9
4170:  MOVFF  198,1BC
4174:  MOVFF  197,1BB
4178:  MOVLB  0
417A:  CALL   0D40
417E:  MOVLW  11
4180:  MOVLB  1
4182:  MOVWF  xB6
4184:  MOVF   xB6,W
4186:  MOVLB  0
4188:  CALL   03CA
418C:  MOVLB  1
418E:  INCF   xB6,F
4190:  MOVWF  00
4192:  MOVF   00,W
4194:  BTFSS  F9E.4
4196:  BRA    4194
4198:  MOVWF  FAD
419A:  MOVLW  16
419C:  SUBWF  xB6,W
419E:  BNZ   4184
41A0:  MOVLW  10
41A2:  MOVWF  FE9
41A4:  MOVFF  1B3,1BC
41A8:  MOVFF  1B2,1BB
41AC:  MOVLB  0
41AE:  CALL   0D40
41B2:  MOVLW  0D
41B4:  BTFSS  F9E.4
41B6:  BRA    41B4
41B8:  MOVWF  FAD
41BA:  MOVLW  0A
41BC:  BTFSS  F9E.4
41BE:  BRA    41BC
41C0:  MOVWF  FAD
.................... 				enable_interrupts(GLOBAL); 
41C2:  MOVLW  C0
41C4:  IORWF  FF2,F
.................... 		 		actuator_move_execute(act_loop); 
41C6:  MOVFF  1B0,1B5
41CA:  CALL   2ED6
.................... 		 		printf("done \r\n"); 
41CE:  MOVLB  1
41D0:  CLRF   xB2
41D2:  MOVF   xB2,W
41D4:  MOVLB  0
41D6:  CALL   0480
41DA:  MOVLB  1
41DC:  INCF   xB2,F
41DE:  MOVWF  00
41E0:  MOVF   00,W
41E2:  BTFSS  F9E.4
41E4:  BRA    41E2
41E6:  MOVWF  FAD
41E8:  MOVLW  07
41EA:  SUBWF  xB2,W
41EC:  BNZ   41D2
.................... 		   		bit_clear(actuator_move_mask,act_loop); 
41EE:  MOVLW  01
41F0:  MOVWF  00
41F2:  MOVF   xB0,W
41F4:  MOVWF  01
41F6:  BZ    4200
41F8:  BCF    FD8.0
41FA:  RLCF   00,F
41FC:  DECFSZ 01,F
41FE:  BRA    41F8
4200:  MOVF   00,W
4202:  XORLW  FF
4204:  ANDWF  xAD,F
.................... 				write_eeprom_data(0); 
4206:  CLRF   xB4
4208:  MOVLB  0
420A:  CALL   1072
.................... 				print_date_time(); 
420E:  CALL   1C3E
4212:  MOVLB  1
.................... 			}  
.................... 			} 
.................... 		} 
4214:  INCF   xB0,F
4216:  BRA    40AC
....................  
.................... 		if (nButton==0) { 
4218:  MOVF   4B,F
421A:  BNZ   4222
.................... 		    button_menu(); 
421C:  MOVLB  0
421E:  BRA    3A66
4220:  MOVLB  1
.................... 		} 
.................... 		restart_wdt(); 
4222:  CLRWDT
.................... 		//sleep(); 
.................... 	} 
4224:  MOVLB  0
4226:  BRA    40A0
....................  
.................... DEAD_TRAP: while(1); 
4228:  BRA    4228
.................... } 
422A:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E000   WRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 7E 04 7F 03 80 02 81 01 

F00010: 00 00 01 00 02 00 03 00 

F00020: 00 00 00 00 01 00 00 00 

F00030: 00 00 

F00040: 34 12 
