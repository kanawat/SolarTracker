CCS PCH C Compiler, Version 4.093, 5967               28-Aug-12 22:53

               Filename: main.lst

               ROM used: 11440 bytes (35%)
                         Largest free fragment is 21324
               RAM used: 189 (12%) at main() level
                         239 (16%) worst case
               Stack:    9 worst case (5 in main + 4 for interrupts)

*
0000:  GOTO   2948
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   01E4
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04DC
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  MOVFF  0D,FE9
007C:  MOVFF  08,FEA
0080:  BSF    08.7
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #define NETWORK_COMM 1 
.................... #include <solar_lib.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <math.h> 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20,NOLVP,WRT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
0178:  CLRF   FEA
017A:  MOVLW  E2
017C:  MOVWF  FE9
017E:  MOVF   FEF,W
0180:  BZ    019E
0182:  MOVLW  03
0184:  MOVWF  01
0186:  CLRF   00
0188:  DECFSZ 00,F
018A:  BRA    0188
018C:  DECFSZ 01,F
018E:  BRA    0186
0190:  MOVLW  3C
0192:  MOVWF  00
0194:  DECFSZ 00,F
0196:  BRA    0194
0198:  BRA    019A
019A:  DECFSZ FEF,F
019C:  BRA    0182
019E:  RETLW  00
*
1D3E:  MOVLW  07
1D40:  SUBWF  xC0,F
1D42:  BNC   1D5A
1D44:  CLRF   FEA
1D46:  MOVLW  C0
1D48:  MOVWF  FE9
1D4A:  BCF    FD8.0
1D4C:  RRCF   FEF,F
1D4E:  MOVF   FEF,W
1D50:  BZ    1D5A
1D52:  BRA    1D56
1D54:  BRA    1D56
1D56:  DECFSZ FEF,F
1D58:  BRA    1D54
1D5A:  GOTO   255C (RETURN)
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N,BITS=8) 
*
0440:  BTFSS  F9E.4
0442:  BRA    0440
0444:  MOVWF  FAD
0446:  RETLW  00
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, BITS=8, MSB_FIRST, IDLE=0) 
....................  
....................  
....................  
....................  
....................  
.................... struct port_d_map{ 
....................    int8 data_bus:4; //0:3 
....................    boolean rs;     //4 
....................    boolean LED_latch;  //5 
....................    boolean MUX_en;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte SSPCON2 = 0xFC5 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1  = 0xFCE 
.................... #byte T1CON = 0xFCD 
....................  
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1 PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3 PIN_B3 
.................... #define CCW PIN_B4 
.................... #define SENSE_0     PIN_A2 
.................... #define SENSE_1     PIN_A3 
.................... #define SENSE_2     PIN_A4 
.................... #define SENSE_3     PIN_A5 
.................... #define WALL_PWR    PIN_A0 //input 
.................... #define FLASH_CS PIN_C2 
.................... #define TX_EN PIN_E1 
....................  
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00010 
.................... #define ADDR_TIME           0xf00020 
.................... #define ADDR_START_COUNTER  0xf00030 
.................... #define ADDR_ACT_MIN_LEN    0xf00060 
.................... #define ADDR_ACT_MAX_LEN    0xf00070 
....................  
.................... #define MAX_FULL_STROKE 6000 
.................... #rom ADDR_FULL_STROKE={0x047E,0x037F,0x0280,0x0181} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000,0x0001,0x0002,0x0003} 
.................... #rom ADDR_TIME={0x0000,0x0000,0x0001,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... #rom 0xf00040 ={0x1234} // to check if eeprom can be read properly 
.................... #rom 0xf00050 ={0xFFFE} // device ID 
.................... #rom ADDR_ACT_MIN_LEN={0x4C80,0x4C81,0x4C82,0x4C83} 
.................... #rom ADDR_ACT_MAX_LEN={0x7B80,0x7B81,0x7B82,0x7B83} 
....................  
.................... ////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////// flag 
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct flag2 { 
....................    boolean en_operate; 
....................    boolean button_pressed; 
....................    boolean abort_current_activity; 
....................    boolean allow_manual_move_act; 
....................    boolean current_pulse_state; 
....................    boolean power; 
....................    boolean is_moving; 
....................    boolean unused3; 
.................... } flag2; 
....................  
.................... struct LED_status { 
....................   boolean power; 
....................   boolean operation; 
....................   int8 aux:2; 
....................   int8 unused:4; 
.................... } LED_status; 
....................  
.................... /////////////////////////// timer_related 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... unsigned int32 nDay=1; 
.................... unsigned int16 startup_counter=0; 
.................... /////////////////////////// command processing 
.................... int16 dev_id = 0x0075; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... int8 nButton=-1; 
.................... unsigned int32 last_command =0; 
.................... int8 de_stuffing_mask = 0x00; 
.................... int8 command_byte=0x00; 
.................... int16 aux_command; 
.................... int8 output_buffer[36]; 
.................... int8 output_checksum; 
.................... /////////////////////////// flash_related_variable 
.................... int8 flash_mfg_id[4]; 
.................... int8 flash_stat=0; 
.................... int8 flash_page_data=0; 
.................... int8 flash_page_data2=0; 
.................... /////////////////////////// actuator related 
.................... int16 move_act_time_out=2; 
.................... int16 actuator_pulse=0; 
.................... int16 last_actuator_pulse; 
.................... float act_len; 
.................... unsigned int16 current_act_position[4]={0,0,0,0}; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int16 act_full_stroke_tick[4]={0,0,0,0}; 
.................... unsigned int16 act_max_stroke[4]={0,0,0,0}; 
.................... unsigned int16 act_min_stroke[4]={0,0,0,0}; 
.................... unsigned int16 act_safety_stroke=0; 
.................... unsigned int16 latitude=0; 
.................... unsigned int16 longitude=0; 
.................... unsigned int16 altitude=0; 
.................... int8 actuator_move_mask=0x00; 
.................... ///////////////////PROTOTYPE/////////////////////////////////// 
.................... void button_scan(); 
.................... void stuff_data(int8 data_to_stuff); 
.................... void send_data(int8 packet_type,int8 size); 
.................... void process_cmd_msg(); 
.................... ///////////////////////////////////////////////////// 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
0124:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
0126:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
0128:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
012A:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
012C:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
012E:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
0130:  BCF    FAC.5
....................    delay_cycles(10); 
0132:  MOVLW  03
0134:  MOVWF  00
0136:  DECFSZ 00,F
0138:  BRA    0136
....................    bit_set(RCSTA,4); //CREN=1 
013A:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
013C:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
013E:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
0140:  BSF    F9D.5
....................  
.................... } 
0142:  RETLW  00
....................  
....................  
.................... void flash_read_mfg_id() { 
.................... 		output_low(FLASH_CS); 
*
0606:  BCF    F94.2
0608:  BCF    F8B.2
.................... 		delay_cycles(20); 
060A:  MOVLW  06
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  NOP   
.................... 		spi_write(0x9F); 
0614:  MOVF   FC9,W
0616:  MOVLW  9F
0618:  MOVWF  FC9
061A:  RRCF   FC7,W
061C:  BNC   061A
.................... 		flash_mfg_id[0] = spi_read(0); 
061E:  MOVF   FC9,W
0620:  CLRF   FC9
0622:  RRCF   FC7,W
0624:  BNC   0622
0626:  MOVFF  FC9,79
.................... 		flash_mfg_id[1] = spi_read(0); 
062A:  MOVF   FC9,W
062C:  CLRF   FC9
062E:  RRCF   FC7,W
0630:  BNC   062E
0632:  MOVFF  FC9,7A
.................... 		flash_mfg_id[2] = spi_read(0); 
0636:  MOVF   FC9,W
0638:  CLRF   FC9
063A:  RRCF   FC7,W
063C:  BNC   063A
063E:  MOVFF  FC9,7B
.................... 		flash_mfg_id[3] = spi_read(0); 
0642:  MOVF   FC9,W
0644:  CLRF   FC9
0646:  RRCF   FC7,W
0648:  BNC   0646
064A:  MOVFF  FC9,7C
.................... 		delay_cycles(20); 
064E:  MOVLW  06
0650:  MOVWF  00
0652:  DECFSZ 00,F
0654:  BRA    0652
0656:  NOP   
.................... 		output_high(FLASH_CS); 
0658:  BCF    F94.2
065A:  BSF    F8B.2
.................... } 
065C:  GOTO   2B2A (RETURN)
....................  
.................... void flash_read_stat() { 
.................... 		output_low(FLASH_CS); 
*
05AE:  BCF    F94.2
05B0:  BCF    F8B.2
.................... 		delay_cycles(20); 
05B2:  MOVLW  06
05B4:  MOVWF  00
05B6:  DECFSZ 00,F
05B8:  BRA    05B6
05BA:  NOP   
.................... 		spi_write(0xD7); 
05BC:  MOVF   FC9,W
05BE:  MOVLW  D7
05C0:  MOVWF  FC9
05C2:  RRCF   FC7,W
05C4:  BNC   05C2
.................... 		flash_stat = spi_read(0); 
05C6:  MOVF   FC9,W
05C8:  CLRF   FC9
05CA:  RRCF   FC7,W
05CC:  BNC   05CA
05CE:  MOVFF  FC9,7D
.................... 		delay_cycles(20); 
05D2:  MOVLW  06
05D4:  MOVWF  00
05D6:  DECFSZ 00,F
05D8:  BRA    05D6
05DA:  NOP   
.................... 		output_high(FLASH_CS); 
05DC:  BCF    F94.2
05DE:  BSF    F8B.2
.................... } 
05E0:  RETLW  00
....................  
.................... void flash_wait_until_ready() { 
....................    int8 wait_loop=0; 
05E2:  CLRF   xD0
....................    for ( wait_loop=0; wait_loop<0xFF; wait_loop++) { 
05E4:  CLRF   xD0
05E6:  INCFSZ xD0,W
05E8:  BRA    05EC
05EA:  BRA    0604
.................... 	 flash_read_stat(); 
05EC:  RCALL  05AE
....................      if ((flash_stat & 0xBF)==0x9C) break; 
05EE:  MOVF   x7D,W
05F0:  ANDLW  BF
05F2:  SUBLW  9C
05F4:  BNZ   05F8
05F6:  BRA    0604
.................... 	 delay_cycles(100); 
05F8:  MOVLW  21
05FA:  MOVWF  00
05FC:  DECFSZ 00,F
05FE:  BRA    05FC
....................    } 
0600:  INCF   xD0,F
0602:  BRA    05E6
.................... } 
0604:  RETLW  00
....................  
.................... void flash_read_page(int16 pageAddress, int8 pageIndex) { 
....................  
.................... 	//pageAddress <<= 1; 
.................... 	//pageAddress &= 0xFE; 
....................     if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0D6C:  MOVF   x7A,W
0D6E:  SUBLW  26
0D70:  BNZ   0D78
0D72:  BCF    FD8.0
0D74:  RLCF   xCD,F
0D76:  RLCF   xCE,F
.................... 	flash_wait_until_ready(); 
0D78:  RCALL  05E2
....................    	output_low(FLASH_CS); 
0D7A:  BCF    F94.2
0D7C:  BCF    F8B.2
.................... 	delay_cycles(20); 
0D7E:  MOVLW  06
0D80:  MOVWF  00
0D82:  DECFSZ 00,F
0D84:  BRA    0D82
0D86:  NOP   
....................    	spi_write(0xD2); 
0D88:  MOVF   FC9,W
0D8A:  MOVLW  D2
0D8C:  MOVWF  FC9
0D8E:  RRCF   FC7,W
0D90:  BNC   0D8E
....................     spi_write(make8(pageAddress,1)); 
0D92:  MOVFF  CE,D0
0D96:  MOVF   FC9,W
0D98:  MOVFF  CE,FC9
0D9C:  RRCF   FC7,W
0D9E:  BNC   0D9C
....................     spi_write(make8(pageAddress,0)); 
0DA0:  MOVFF  CD,D0
0DA4:  MOVF   FC9,W
0DA6:  MOVFF  CD,FC9
0DAA:  RRCF   FC7,W
0DAC:  BNC   0DAA
....................     spi_write(pageIndex); 
0DAE:  MOVF   FC9,W
0DB0:  MOVFF  CF,FC9
0DB4:  RRCF   FC7,W
0DB6:  BNC   0DB4
....................     spi_write(0); 
0DB8:  MOVF   FC9,W
0DBA:  CLRF   FC9
0DBC:  RRCF   FC7,W
0DBE:  BNC   0DBC
....................     spi_write(0); 
0DC0:  MOVF   FC9,W
0DC2:  CLRF   FC9
0DC4:  RRCF   FC7,W
0DC6:  BNC   0DC4
....................     spi_write(0); 
0DC8:  MOVF   FC9,W
0DCA:  CLRF   FC9
0DCC:  RRCF   FC7,W
0DCE:  BNC   0DCC
....................     spi_write(0); 
0DD0:  MOVF   FC9,W
0DD2:  CLRF   FC9
0DD4:  RRCF   FC7,W
0DD6:  BNC   0DD4
.................... 	flash_page_data = spi_read(0); 
0DD8:  MOVF   FC9,W
0DDA:  CLRF   FC9
0DDC:  RRCF   FC7,W
0DDE:  BNC   0DDC
0DE0:  MOVFF  FC9,7E
.................... 	flash_page_data2 = spi_read(0); 
0DE4:  MOVF   FC9,W
0DE6:  CLRF   FC9
0DE8:  RRCF   FC7,W
0DEA:  BNC   0DE8
0DEC:  MOVFF  FC9,7F
....................    	output_high(FLASH_CS); 
0DF0:  BCF    F94.2
0DF2:  BSF    F8B.2
.................... } 
0DF4:  RETLW  00
....................  
.................... void flash_block_erase() { 
....................    int8 i,j; 
....................    i=0xFF; 
*
0E42:  MOVLW  FF
0E44:  MOVWF  xBF
....................    do 
....................    { 
....................    i++; 
0E46:  INCF   xBF,F
....................    flash_wait_until_ready(); 
0E48:  CALL   05E2
....................    output_low(FLASH_CS); 
0E4C:  BCF    F94.2
0E4E:  BCF    F8B.2
....................    spi_write(0x50); 
0E50:  MOVF   FC9,W
0E52:  MOVLW  50
0E54:  MOVWF  FC9
0E56:  RRCF   FC7,W
0E58:  BNC   0E56
....................    j = i>>5; 
0E5A:  SWAPF  xBF,W
0E5C:  MOVWF  xC0
0E5E:  RRCF   xC0,F
0E60:  MOVLW  07
0E62:  ANDWF  xC0,F
....................    spi_write(j); 
0E64:  MOVF   FC9,W
0E66:  MOVFF  C0,FC9
0E6A:  RRCF   FC7,W
0E6C:  BNC   0E6A
....................    j = i<<3; 
0E6E:  RLCF   xBF,W
0E70:  MOVWF  xC0
0E72:  RLCF   xC0,F
0E74:  RLCF   xC0,F
0E76:  MOVLW  F8
0E78:  ANDWF  xC0,F
....................    spi_write(j); 
0E7A:  MOVF   FC9,W
0E7C:  MOVFF  C0,FC9
0E80:  RRCF   FC7,W
0E82:  BNC   0E80
....................    spi_write(0); 
0E84:  MOVF   FC9,W
0E86:  CLRF   FC9
0E88:  RRCF   FC7,W
0E8A:  BNC   0E88
....................    output_high(FLASH_CS); 
0E8C:  BCF    F94.2
0E8E:  BSF    F8B.2
....................    } while(i!=0xFF); 
0E90:  INCFSZ xBF,W
0E92:  BRA    0E46
....................    flash_wait_until_ready(); 
0E94:  CALL   05E2
.................... } 
0E98:  GOTO   1E06 (RETURN)
....................  
.................... void flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
1016:  CALL   05E2
....................    output_low(FLASH_CS); 
101A:  BCF    F94.2
101C:  BCF    F8B.2
....................    delay_cycles(20); 
101E:  MOVLW  06
1020:  MOVWF  00
1022:  DECFSZ 00,F
1024:  BRA    1022
1026:  NOP   
....................    spi_write(0x84); 
1028:  MOVF   FC9,W
102A:  MOVLW  84
102C:  MOVWF  FC9
102E:  RRCF   FC7,W
1030:  BNC   102E
....................    spi_write(0); 
1032:  MOVF   FC9,W
1034:  CLRF   FC9
1036:  RRCF   FC7,W
1038:  BNC   1036
....................    spi_write(0); 
103A:  MOVF   FC9,W
103C:  CLRF   FC9
103E:  RRCF   FC7,W
1040:  BNC   103E
....................    spi_write(PageIndex); 
1042:  MOVF   FC9,W
1044:  MOVFF  C0,FC9
1048:  RRCF   FC7,W
104A:  BNC   1048
....................    if (nData>1) { 
104C:  MOVF   xC1,W
104E:  SUBLW  01
1050:  BC    106A
....................    i=255; 
1052:  MOVLW  FF
1054:  MOVWF  xC2
....................    do { 
....................       spi_write(data); 
1056:  MOVF   FC9,W
1058:  MOVFF  BF,FC9
105C:  RRCF   FC7,W
105E:  BNC   105C
....................       i++; 
1060:  INCF   xC2,F
....................    } while(i<nData); 
1062:  MOVF   xC1,W
1064:  SUBWF  xC2,W
1066:  BNC   1056
....................    } else 
1068:  BRA    1074
....................          spi_write(data); 
106A:  MOVF   FC9,W
106C:  MOVFF  BF,FC9
1070:  RRCF   FC7,W
1072:  BNC   1070
....................    output_high(FLASH_CS); 
1074:  BCF    F94.2
1076:  BSF    F8B.2
.................... } 
1078:  RETLW  00
....................  
.................... void flash_buffer1_read(int8 PageIndex) { 
....................    int i; 
....................    flash_wait_until_ready(); 
....................    output_low(FLASH_CS); 
....................    delay_cycles(20); 
....................    spi_write(0xD4); // use 0xD4 must have 1 dummy byte after address bytes 
....................    spi_write(0); 
....................    spi_write(0); 
....................    spi_write(PageIndex); 
....................    spi_write(0); // dummy byte required 
....................    flash_page_data = spi_read(0); 
....................    flash_page_data2 = spi_read(0); 
....................    output_high(FLASH_CS);    
.................... } 
....................  
.................... void flash_set_256_page_size() { 
....................    flash_wait_until_ready(); 
107A:  CALL   05E2
....................    output_low(FLASH_CS); 
107E:  BCF    F94.2
1080:  BCF    F8B.2
....................    delay_cycles(20); 
1082:  MOVLW  06
1084:  MOVWF  00
1086:  DECFSZ 00,F
1088:  BRA    1086
108A:  NOP   
....................    spi_write(0x3D); 
108C:  MOVF   FC9,W
108E:  MOVLW  3D
1090:  MOVWF  FC9
1092:  RRCF   FC7,W
1094:  BNC   1092
....................    spi_write(0x2A); 
1096:  MOVF   FC9,W
1098:  MOVLW  2A
109A:  MOVWF  FC9
109C:  RRCF   FC7,W
109E:  BNC   109C
....................    spi_write(0x80); 
10A0:  MOVF   FC9,W
10A2:  MOVLW  80
10A4:  MOVWF  FC9
10A6:  RRCF   FC7,W
10A8:  BNC   10A6
....................    spi_write(0xA6); 
10AA:  MOVF   FC9,W
10AC:  MOVLW  A6
10AE:  MOVWF  FC9
10B0:  RRCF   FC7,W
10B2:  BNC   10B0
....................    output_high(FLASH_CS);  
10B4:  BCF    F94.2
10B6:  BSF    F8B.2
.................... } 
10B8:  GOTO   1EBC (RETURN)
....................  
.................... void flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0E9C:  MOVF   x7A,W
0E9E:  SUBLW  26
0EA0:  BNZ   0EA8
0EA2:  BCF    FD8.0
0EA4:  RLCF   xBF,F
0EA6:  RLCF   xC0,F
....................    flash_wait_until_ready(); 
0EA8:  CALL   05E2
....................    output_low(FLASH_CS); 
0EAC:  BCF    F94.2
0EAE:  BCF    F8B.2
....................    delay_cycles(20);	 
0EB0:  MOVLW  06
0EB2:  MOVWF  00
0EB4:  DECFSZ 00,F
0EB6:  BRA    0EB4
0EB8:  NOP   
....................    spi_write(0x83); 
0EBA:  MOVF   FC9,W
0EBC:  MOVLW  83
0EBE:  MOVWF  FC9
0EC0:  RRCF   FC7,W
0EC2:  BNC   0EC0
....................    spi_write(make8(pageAddress,1)); 
0EC4:  MOVFF  C0,C1
0EC8:  MOVF   FC9,W
0ECA:  MOVFF  C0,FC9
0ECE:  RRCF   FC7,W
0ED0:  BNC   0ECE
....................    spi_write(make8(pageAddress,0)); 
0ED2:  MOVFF  BF,C1
0ED6:  MOVF   FC9,W
0ED8:  MOVFF  BF,FC9
0EDC:  RRCF   FC7,W
0EDE:  BNC   0EDC
....................    spi_write(0); 
0EE0:  MOVF   FC9,W
0EE2:  CLRF   FC9
0EE4:  RRCF   FC7,W
0EE6:  BNC   0EE4
....................    output_high(FLASH_CS); 
0EE8:  BCF    F94.2
0EEA:  BSF    F8B.2
.................... } 
0EEC:  GOTO   1E32 (RETURN)
....................  
.................... void flash_write_page(int16 pageAddress) { 
....................    int8 i,check_sum; 
....................    char input_data; 
....................    disable_interrupts(GLOBAL); 
*
10BC:  BCF    FF2.6
10BE:  BCF    FF2.7
10C0:  BTFSC  FF2.7
10C2:  BRA    10BE
....................    //output_high(FLASH_CS); 
....................    flash_wait_until_ready(); 
10C4:  CALL   05E2
....................    delay_cycles(50); 
10C8:  MOVLW  10
10CA:  MOVWF  00
10CC:  DECFSZ 00,F
10CE:  BRA    10CC
10D0:  NOP   
....................    output_low(FLASH_CS); 
10D2:  BCF    F94.2
10D4:  BCF    F8B.2
....................    if (pageAddress%2) spi_write(0x82); else spi_write(0x85); 
10D6:  MOVF   xBF,W
10D8:  ANDLW  01
10DA:  MOVWF  00
10DC:  CLRF   03
10DE:  MOVF   00,W
10E0:  IORWF  03,W
10E2:  BZ    10F0
10E4:  MOVF   FC9,W
10E6:  MOVLW  82
10E8:  MOVWF  FC9
10EA:  RRCF   FC7,W
10EC:  BNC   10EA
10EE:  BRA    10FA
10F0:  MOVF   FC9,W
10F2:  MOVLW  85
10F4:  MOVWF  FC9
10F6:  RRCF   FC7,W
10F8:  BNC   10F6
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
10FA:  MOVF   x7A,W
10FC:  SUBLW  26
10FE:  BNZ   1106
1100:  BCF    FD8.0
1102:  RLCF   xBF,F
1104:  RLCF   xC0,F
....................    spi_write(make8(pageAddress,1)); 
1106:  MOVFF  C0,C4
110A:  MOVF   FC9,W
110C:  MOVFF  C0,FC9
1110:  RRCF   FC7,W
1112:  BNC   1110
....................    spi_write(make8(pageAddress,0)); 
1114:  MOVFF  BF,C4
1118:  MOVF   FC9,W
111A:  MOVFF  BF,FC9
111E:  RRCF   FC7,W
1120:  BNC   111E
....................    spi_write(0); 
1122:  MOVF   FC9,W
1124:  CLRF   FC9
1126:  RRCF   FC7,W
1128:  BNC   1126
....................    check_sum=0; 
112A:  CLRF   xC2
....................    i=0xFF; 
112C:  MOVLW  FF
112E:  MOVWF  xC1
....................    check_sum=0xCC; 
1130:  MOVLW  CC
1132:  MOVWF  xC2
....................    do { 
....................       input_data = getc(); 
1134:  BTFSS  F9E.5
1136:  BRA    1134
1138:  MOVFF  FAE,C3
....................       check_sum ^= input_data; 
113C:  MOVF   xC3,W
113E:  XORWF  xC2,F
....................       spi_write(input_data); 
1140:  MOVF   FC9,W
1142:  MOVFF  C3,FC9
1146:  RRCF   FC7,W
1148:  BNC   1146
....................       i++; 
114A:  INCF   xC1,F
....................    } while(i!=0xFF); 
114C:  INCFSZ xC1,W
114E:  BRA    1134
....................    output_high(FLASH_CS); 
1150:  BCF    F94.2
1152:  BSF    F8B.2
....................    enable_interrupts(GLOBAL); 
1154:  MOVLW  C0
1156:  IORWF  FF2,F
.................... } 
1158:  GOTO   1EEA (RETURN)
....................  
.................... void flash_read_main_memory_to_buffer1(int16 pageAddress) { 
....................    flash_wait_until_ready(); 
*
0EF0:  CALL   05E2
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
0EF4:  MOVF   x7A,W
0EF6:  SUBLW  26
0EF8:  BNZ   0F00
0EFA:  BCF    FD8.0
0EFC:  RLCF   xBF,F
0EFE:  RLCF   xC0,F
....................    output_low(FLASH_CS); 
0F00:  BCF    F94.2
0F02:  BCF    F8B.2
....................    spi_write(0x53); 
0F04:  MOVF   FC9,W
0F06:  MOVLW  53
0F08:  MOVWF  FC9
0F0A:  RRCF   FC7,W
0F0C:  BNC   0F0A
....................    spi_write(make8(pageAddress,1)); 
0F0E:  MOVFF  C0,C1
0F12:  MOVF   FC9,W
0F14:  MOVFF  C0,FC9
0F18:  RRCF   FC7,W
0F1A:  BNC   0F18
....................    spi_write(make8(pageAddress,0)); 
0F1C:  MOVFF  BF,C1
0F20:  MOVF   FC9,W
0F22:  MOVFF  BF,FC9
0F26:  RRCF   FC7,W
0F28:  BNC   0F26
....................    spi_write(0); 
0F2A:  MOVF   FC9,W
0F2C:  CLRF   FC9
0F2E:  RRCF   FC7,W
0F30:  BNC   0F2E
....................    output_high(FLASH_CS); 
0F32:  BCF    F94.2
0F34:  BSF    F8B.2
.................... } 
0F36:  GOTO   1E62 (RETURN)
....................  
.................... /* 
.................... void print_date_time() { 
....................  
.................... 	  printf("\r\n Day#%lu, ",nDay); 
....................       strcpy(tmp_str,"00:00:00"); 
....................       itoa((int8) (timer_sec/3600),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) ((timer_sec%3600)/60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) (timer_sec%60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................    	  printf("%s",tmp_str); 
.................... } 
....................  
.................... void print_page_data(int16 nPage) { 
.................... // filled output buffer with memory content in flash page memory 
....................     int8 i; 
....................     int8 j; 
....................     for(i=0;i<16;i++) { 
....................       //printf("\r\n%02X : ",i); 
....................       for (j=0;j<8;j++) { 
....................         flash_read_page(nPage,i*16+j*2); 
.................... 		output_buffer[i*16+j*2] = flash_page_data; 
.................... 		output_buffer[i*16+j*2+1] = flash_page_data2; 
.................... 		//printf("%02X %02X ",flash_page_data,flash_page_data2); 
.................... 	  } 
....................    } 
.................... } 
.................... */ 
.................... void solar_load_parameter_from_flash() { 
....................     // this section is no longer required. min/max strokes are loaded from eeprom 
....................     //flash_read_page(0,0x4E);  
.................... 	//act_min_stroke[0] = make16(flash_page_data2,flash_page_data); 
....................     //flash_read_page(0,0x50);  
.................... 	//act_max_stroke[0] = make16(flash_page_data2,flash_page_data); 
....................     flash_read_page(0,0x56);  
*
0DF6:  CLRF   xCE
0DF8:  CLRF   xCD
0DFA:  MOVLW  56
0DFC:  MOVWF  xCF
0DFE:  RCALL  0D6C
.................... 	latitude = make16(flash_page_data2,flash_page_data); 
0E00:  MOVFF  7F,AF
0E04:  MOVFF  7E,AE
....................     flash_read_page(0,0x58);  
0E08:  CLRF   xCE
0E0A:  CLRF   xCD
0E0C:  MOVLW  58
0E0E:  MOVWF  xCF
0E10:  RCALL  0D6C
.................... 	longitude = make16(flash_page_data2,flash_page_data); 
0E12:  MOVFF  7F,B1
0E16:  MOVFF  7E,B0
....................     flash_read_page(0,0x5A);  
0E1A:  CLRF   xCE
0E1C:  CLRF   xCD
0E1E:  MOVLW  5A
0E20:  MOVWF  xCF
0E22:  RCALL  0D6C
.................... 	altitude = make16(flash_page_data2,flash_page_data);	 
0E24:  MOVFF  7F,B3
0E28:  MOVFF  7E,B2
....................     flash_read_page(0,0x5C);  
0E2C:  CLRF   xCE
0E2E:  CLRF   xCD
0E30:  MOVLW  5C
0E32:  MOVWF  xCF
0E34:  RCALL  0D6C
.................... 	act_safety_stroke = make16(flash_page_data2,flash_page_data); 
0E36:  MOVFF  7F,AD
0E3A:  MOVFF  7E,AC
.................... } 
0E3E:  GOTO   2BAE (RETURN)
.................... /* 
.................... void print_fw_info() { 
....................     int8 i,j; 
.................... 	disable_interrupts(GLOBAL); 
....................     for (i=0;i<4;i++) { 
....................         printf("\r\n"); 
.................... 		for (j=0;j<8;j++) { 
....................     		flash_read_page(0,i*16+j*2); 
.................... 			printf("%c%c",flash_page_data,flash_page_data2); 
.................... 		} 
.................... 	} 
.................... 	flash_read_page(0,0x40); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................   	flash_read_page(0,0x42); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................     solar_load_parameter_from_flash(); 
.................... 	printf("\r\n Min Stroke=%lu/256 cm",act_min_stroke); 
.................... 	printf("\r\n Max Stroke=%lu/256 cm",act_max_stroke); 
.................... 	printf("\r\n Safty Stroke=%lu/256 cm",act_safety_stroke); 
.................... 	printf("\r\n Latitude=%lu/100",latitude); 
.................... 	printf("\r\n Longitude=%lu/100",longitude); 
.................... 	printf("\r\n Altitude =%lu/100",altitude); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... } 
.................... */ 
.................... void display_LED() { 
.................... 	portd.data_bus=LED_status; 
*
0144:  MOVF   21,W
0146:  ANDLW  0F
0148:  MOVWF  00
014A:  MOVLW  F0
014C:  ANDWF  F83,W
014E:  IORWF  00,W
0150:  MOVWF  F83
.................... 	delay_cycles(20); 
0152:  MOVLW  06
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  NOP   
.................... 	portd.LED_latch=1; 
015C:  BSF    F83.5
.................... 	delay_cycles(20); 
015E:  MOVLW  06
0160:  MOVWF  00
0162:  DECFSZ 00,F
0164:  BRA    0162
0166:  NOP   
.................... 	portd.LED_latch=0; 
0168:  BCF    F83.5
.................... 	delay_cycles(20); 
016A:  MOVLW  06
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
0172:  NOP   
.................... 	portd.LED_latch=1; 
0174:  BSF    F83.5
.................... } 
0176:  RETLW  00
....................  
.................... ///////////////////////////// 
.................... void stuff_data(int8 data_to_stuff) { 
.................... 	int8 stuffing_mask =0xFF; 
*
0448:  MOVLW  FF
044A:  MOVWF  xEC
.................... 	if ((data_to_stuff==0xA8) || (data_to_stuff==0xA9)) { 
044C:  MOVF   xEB,W
044E:  SUBLW  A8
0450:  BZ    0458
0452:  MOVF   xEB,W
0454:  SUBLW  A9
0456:  BNZ   0460
.................... 		printf("%c",0xA9); 
0458:  MOVLW  A9
045A:  RCALL  0440
.................... 		stuffing_mask = 0xDF; 
045C:  MOVLW  DF
045E:  MOVWF  xEC
.................... 	} 
.................... 	printf("%c",stuffing_mask&data_to_stuff); 
0460:  MOVF   xEC,W
0462:  ANDWF  xEB,W
0464:  MOVWF  xED
0466:  RCALL  0440
.................... } 
0468:  RETLW  00
.................... // send whatever in sent buffer 
.................... // packet_type:  
.................... //0= ACK,  
.................... //1=NACK,  
.................... //2=DATA, GENERIC,  
.................... //3 = BUFFER1 
.................... //4 = Acutator stat 
.................... //5 = Last acutator move pulse 
.................... //6 = SET 256 PAGE SIZE COMPLETE 
.................... //7 = BUSY 
.................... //8 = FLASH WRITE COMPLETE 
.................... //9 = DATE TIME 
.................... //10 = STATUS FLAGS 
.................... //11 = DEVICE ID 
.................... void send_data(int8 packet_type,int8 size) { 
.................... 	int8 i; 
.................... 	output_checksum=0; 
046A:  CLRF   x78
.................... 	printf("%c",0xA8); 
046C:  MOVLW  A8
046E:  RCALL  0440
.................... 	stuff_data(make8(dev_id,1)); 
0470:  MOVFF  35,EA
0474:  MOVFF  35,EB
0478:  RCALL  0448
.................... 	output_checksum ^= make8(dev_id,1); 
047A:  MOVF   35,W
047C:  XORWF  x78,F
.................... 	stuff_data(make8(dev_id,0)); 
047E:  MOVFF  34,EA
0482:  MOVFF  34,EB
0486:  RCALL  0448
.................... 	output_checksum ^= make8(dev_id,0); 
0488:  MOVF   34,W
048A:  XORWF  x78,F
.................... 	stuff_data(packet_type); 
048C:  MOVFF  E7,EB
0490:  RCALL  0448
.................... 	output_checksum ^= packet_type; 
0492:  MOVF   xE7,W
0494:  XORWF  x78,F
.................... 	if (size >0) { 
0496:  MOVF   xE8,F
0498:  BZ    04D0
....................     	i = 0xFF; 
049A:  MOVLW  FF
049C:  MOVWF  xE9
....................     	do { 
.................... 			i++; 
049E:  INCF   xE9,F
.................... 			output_checksum ^=output_buffer[i]; 
04A0:  CLRF   03
04A2:  MOVF   xE9,W
04A4:  ADDLW  54
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVF   FEF,W
04B0:  XORWF  x78,F
.................... 			stuff_data(output_buffer[i]); 
04B2:  CLRF   03
04B4:  MOVF   xE9,W
04B6:  ADDLW  54
04B8:  MOVWF  FE9
04BA:  MOVLW  00
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVFF  FEF,EA
04C4:  MOVFF  EA,EB
04C8:  RCALL  0448
.................... 		} while(i<size); 
04CA:  MOVF   xE8,W
04CC:  SUBWF  xE9,W
04CE:  BNC   049E
.................... 	} 
.................... 	stuff_data(output_checksum); 
04D0:  MOVFF  78,EB
04D4:  RCALL  0448
.................... 	printf("%c",0xA8); 
04D6:  MOVLW  A8
04D8:  RCALL  0440
.................... } 
04DA:  RETLW  00
.................... /////////////////////// send buffer 1 content 
.................... void send_buffer1_content() { 
....................  
....................    int8 i; 
....................    int8 buffer1_content; 
....................    output_checksum=0; 
*
0F3A:  CLRF   x78
....................    printf("%c",0xA8); 
0F3C:  MOVLW  A8
0F3E:  CALL   0440
....................    stuff_data(make8(dev_id,1)); 
0F42:  MOVFF  35,C1
0F46:  CLRF   18
0F48:  BTFSC  FF2.7
0F4A:  BSF    18.7
0F4C:  BCF    FF2.7
0F4E:  MOVFF  35,EB
0F52:  CALL   0448
0F56:  BTFSC  18.7
0F58:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,1); 
0F5A:  MOVF   35,W
0F5C:  XORWF  x78,F
....................    stuff_data(make8(dev_id,0)); 
0F5E:  MOVFF  34,C1
0F62:  CLRF   18
0F64:  BTFSC  FF2.7
0F66:  BSF    18.7
0F68:  BCF    FF2.7
0F6A:  MOVFF  34,EB
0F6E:  CALL   0448
0F72:  BTFSC  18.7
0F74:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,0); 
0F76:  MOVF   34,W
0F78:  XORWF  x78,F
0F7A:  CLRF   18
0F7C:  BTFSC  FF2.7
0F7E:  BSF    18.7
0F80:  BCF    FF2.7
....................    stuff_data(0x03); 
0F82:  MOVLW  03
0F84:  MOVWF  xEB
0F86:  CALL   0448
0F8A:  BTFSC  18.7
0F8C:  BSF    FF2.7
....................    output_checksum ^= 0x03; 
0F8E:  MOVLW  03
0F90:  XORWF  x78,F
....................  
....................    flash_wait_until_ready(); 
0F92:  CALL   05E2
....................    output_low(FLASH_CS); 
0F96:  BCF    F94.2
0F98:  BCF    F8B.2
....................    delay_cycles(20); 
0F9A:  MOVLW  06
0F9C:  MOVWF  00
0F9E:  DECFSZ 00,F
0FA0:  BRA    0F9E
0FA2:  NOP   
....................    spi_write(0xD1); 
0FA4:  MOVF   FC9,W
0FA6:  MOVLW  D1
0FA8:  MOVWF  FC9
0FAA:  RRCF   FC7,W
0FAC:  BNC   0FAA
....................    spi_write(0); 
0FAE:  MOVF   FC9,W
0FB0:  CLRF   FC9
0FB2:  RRCF   FC7,W
0FB4:  BNC   0FB2
....................    spi_write(0); 
0FB6:  MOVF   FC9,W
0FB8:  CLRF   FC9
0FBA:  RRCF   FC7,W
0FBC:  BNC   0FBA
....................    spi_write(0); 
0FBE:  MOVF   FC9,W
0FC0:  CLRF   FC9
0FC2:  RRCF   FC7,W
0FC4:  BNC   0FC2
....................     
....................    	i = 0xFF; 
0FC6:  MOVLW  FF
0FC8:  MOVWF  xBF
....................    	do { 
.................... 		i++; 
0FCA:  INCF   xBF,F
.................... 		buffer1_content = spi_read(0); 
0FCC:  MOVF   FC9,W
0FCE:  CLRF   FC9
0FD0:  RRCF   FC7,W
0FD2:  BNC   0FD0
0FD4:  MOVFF  FC9,C0
.................... 		output_checksum ^=buffer1_content; 
0FD8:  MOVF   xC0,W
0FDA:  XORWF  x78,F
0FDC:  CLRF   18
0FDE:  BTFSC  FF2.7
0FE0:  BSF    18.7
0FE2:  BCF    FF2.7
.................... 		stuff_data(buffer1_content); 
0FE4:  MOVFF  C0,EB
0FE8:  CALL   0448
0FEC:  BTFSC  18.7
0FEE:  BSF    FF2.7
.................... 		} while(i<255); 
0FF0:  INCFSZ xBF,W
0FF2:  BRA    0FCA
....................    output_high(FLASH_CS);   
0FF4:  BCF    F94.2
0FF6:  BSF    F8B.2
0FF8:  CLRF   18
0FFA:  BTFSC  FF2.7
0FFC:  BSF    18.7
0FFE:  BCF    FF2.7
....................  
....................    stuff_data(output_checksum); 
1000:  MOVFF  78,EB
1004:  CALL   0448
1008:  BTFSC  18.7
100A:  BSF    FF2.7
....................    printf("%c",0xA8); 
100C:  MOVLW  A8
100E:  CALL   0440
....................  
....................  
....................  
....................   
.................... } 
1012:  GOTO   1E88 (RETURN)
.................... //////////////////////////////////////////////////////////////////// 
.................... void solar_get_act_length(unsigned int8 nActuator) { 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 current_period_fraction; 
....................  
.................... 	unsigned int16 current_act_len; 
.................... 	unsigned int16 next_act_len; 
.................... 	 
....................     target_act_position =0; 
*
16E6:  CLRF   x93
16E8:  CLRF   x92
....................  
.................... 	flash_read_page(nDay,0x00);  // verify page number 
16EA:  MOVFF  2F,CB
16EE:  MOVFF  2E,CA
16F2:  MOVFF  2F,CE
16F6:  MOVFF  2E,CD
16FA:  CLRF   xCF
16FC:  CALL   0D6C
....................     if (nDay != make16(flash_page_data2,flash_page_data))  { 
1700:  MOVFF  7F,03
1704:  MOVF   x7E,W
1706:  SUBWF  2E,W
1708:  BNZ   1718
170A:  MOVF   03,W
170C:  SUBWF  2F,W
170E:  BNZ   1718
1710:  MOVF   30,F
1712:  BNZ   1718
1714:  MOVF   31,F
1716:  BZ    171A
.................... 		//printf("Error:Flash data corrupt"); 
.................... 		return; 
1718:  BRA    1CC8
.................... 	} 
....................     current_period = (timer_sec+225)/450; 
171A:  MOVLW  E1
171C:  ADDWF  22,W
171E:  MOVWF  xCA
1720:  MOVLW  00
1722:  ADDWFC 23,W
1724:  MOVWF  xCB
1726:  MOVLW  00
1728:  ADDWFC 24,W
172A:  MOVWF  xCC
172C:  MOVLW  00
172E:  ADDWFC 25,W
1730:  MOVWF  xCD
1732:  CLRF   18
1734:  BTFSC  FF2.7
1736:  BSF    18.7
1738:  BCF    FF2.7
173A:  MOVWF  xE5
173C:  MOVFF  CC,E4
1740:  MOVFF  CB,E3
1744:  MOVFF  CA,E2
1748:  CLRF   xE9
174A:  CLRF   xE8
174C:  MOVLW  01
174E:  MOVWF  xE7
1750:  MOVLW  C2
1752:  MOVWF  xE6
1754:  CALL   00AA
1758:  BTFSC  18.7
175A:  BSF    FF2.7
175C:  MOVFF  01,C3
1760:  MOVFF  00,C2
....................     current_period_fraction = (timer_sec+225)%450; 
1764:  MOVLW  E1
1766:  ADDWF  22,W
1768:  MOVWF  xCA
176A:  MOVLW  00
176C:  ADDWFC 23,W
176E:  MOVWF  xCB
1770:  MOVLW  00
1772:  ADDWFC 24,W
1774:  MOVWF  xCC
1776:  MOVLW  00
1778:  ADDWFC 25,W
177A:  MOVWF  xCD
177C:  CLRF   18
177E:  BTFSC  FF2.7
1780:  BSF    18.7
1782:  BCF    FF2.7
1784:  MOVWF  xE5
1786:  MOVFF  CC,E4
178A:  MOVFF  CB,E3
178E:  MOVFF  CA,E2
1792:  CLRF   xE9
1794:  CLRF   xE8
1796:  MOVLW  01
1798:  MOVWF  xE7
179A:  MOVLW  C2
179C:  MOVWF  xE6
179E:  CALL   00AA
17A2:  BTFSC  18.7
17A4:  BSF    FF2.7
17A6:  MOVFF  FEF,C4
17AA:  MOVFF  FEC,C5
....................     flash_read_page(nDay,0x02); // get sun rise time 
17AE:  MOVFF  2F,CB
17B2:  MOVFF  2E,CA
17B6:  MOVFF  2F,CE
17BA:  MOVFF  2E,CD
17BE:  MOVLW  02
17C0:  MOVWF  xCF
17C2:  CALL   0D6C
....................     sun_rise_period=make16(flash_page_data2,flash_page_data); 
17C6:  MOVFF  7F,C1
17CA:  MOVFF  7E,C0
.................... 	if ((current_period < sun_rise_period) || (current_period > sun_rise_period+124)) // still dark 
17CE:  MOVF   xC3,W
17D0:  SUBWF  xC1,W
17D2:  BNC   17DC
17D4:  BNZ   17FA
17D6:  MOVF   xC0,W
17D8:  SUBWF  xC2,W
17DA:  BNC   17FA
17DC:  MOVLW  7C
17DE:  ADDWF  xC0,W
17E0:  MOVWF  01
17E2:  MOVLW  00
17E4:  ADDWFC xC1,W
17E6:  MOVWF  03
17E8:  MOVF   03,W
17EA:  SUBWF  xC3,W
17EC:  BTFSS  FD8.0
17EE:  BRA    1930
17F0:  BNZ   17FA
17F2:  MOVF   xC2,W
17F4:  SUBWF  01,W
17F6:  BTFSC  FD8.0
17F8:  BRA    1930
.................... 	{ 
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]*(int32)(act_safety_stroke-act_min_stroke[nActuator]); 
17FA:  BCF    FD8.0
17FC:  RLCF   xBF,W
17FE:  CLRF   03
1800:  ADDLW  94
1802:  MOVWF  FE9
1804:  MOVLW  00
1806:  ADDWFC 03,W
1808:  MOVWF  FEA
180A:  MOVFF  FEC,03
180E:  MOVF   FED,F
1810:  MOVFF  FEF,CA
1814:  MOVFF  03,CB
1818:  CLRF   xCC
181A:  CLRF   xCD
181C:  BCF    FD8.0
181E:  RLCF   xBF,W
1820:  CLRF   03
1822:  ADDLW  A4
1824:  MOVWF  FE9
1826:  MOVLW  00
1828:  ADDWFC 03,W
182A:  MOVWF  FEA
182C:  MOVFF  FEC,03
1830:  MOVF   FED,F
1832:  MOVF   FEF,W
1834:  SUBWF  xAC,W
1836:  MOVWF  00
1838:  MOVF   03,W
183A:  SUBWFB xAD,W
183C:  MOVWF  03
183E:  MOVF   00,W
1840:  MOVFF  03,01
1844:  CLRF   02
1846:  CLRF   03
1848:  MOVFF  03,D1
184C:  MOVFF  02,D0
1850:  MOVFF  01,CF
1854:  MOVFF  00,CE
1858:  MOVFF  FEA,D3
185C:  MOVFF  FE9,D2
1860:  MOVFF  CD,D7
1864:  MOVFF  CC,D6
1868:  MOVFF  CB,D5
186C:  MOVFF  CA,D4
1870:  MOVFF  03,DB
1874:  MOVFF  02,DA
1878:  MOVFF  01,D9
187C:  MOVFF  00,D8
1880:  RCALL  1502
1882:  MOVFF  D3,FEA
1886:  MOVFF  D2,FE9
188A:  MOVFF  03,29
188E:  MOVFF  02,28
1892:  MOVFF  01,27
1896:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke[nActuator]-act_min_stroke[nActuator]); 
189A:  BCF    FD8.0
189C:  RLCF   xBF,W
189E:  CLRF   03
18A0:  ADDLW  9C
18A2:  MOVWF  FE9
18A4:  MOVLW  00
18A6:  ADDWFC 03,W
18A8:  MOVWF  FEA
18AA:  MOVFF  FEC,CB
18AE:  MOVF   FED,F
18B0:  MOVFF  FEF,CA
18B4:  BCF    FD8.0
18B6:  RLCF   xBF,W
18B8:  CLRF   03
18BA:  ADDLW  A4
18BC:  MOVWF  FE9
18BE:  MOVLW  00
18C0:  ADDWFC 03,W
18C2:  MOVWF  FEA
18C4:  MOVFF  FEC,03
18C8:  MOVF   FED,F
18CA:  MOVF   FEF,W
18CC:  SUBWF  xCA,W
18CE:  MOVWF  00
18D0:  MOVF   03,W
18D2:  SUBWFB xCB,W
18D4:  MOVWF  03
18D6:  MOVFF  00,CA
18DA:  MOVWF  xCB
18DC:  MOVFF  FEA,CD
18E0:  MOVFF  FE9,CC
18E4:  CLRF   18
18E6:  BTFSC  FF2.7
18E8:  BSF    18.7
18EA:  BCF    FF2.7
18EC:  MOVFF  29,E5
18F0:  MOVFF  28,E4
18F4:  MOVFF  27,E3
18F8:  MOVFF  26,E2
18FC:  CLRF   xE9
18FE:  CLRF   xE8
1900:  MOVWF  xE7
1902:  MOVFF  00,E6
1906:  CALL   00AA
190A:  BTFSC  18.7
190C:  BSF    FF2.7
190E:  MOVFF  CD,FEA
1912:  MOVFF  CC,FE9
1916:  MOVFF  03,29
191A:  MOVFF  02,28
191E:  MOVFF  01,27
1922:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
1926:  MOVFF  27,93
192A:  MOVFF  26,92
.................... 	} else { 
192E:  BRA    1CC8
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+4); 
1930:  MOVFF  2F,CB
1934:  MOVFF  2E,CA
1938:  MOVF   xC0,W
193A:  SUBWF  xC2,W
193C:  MOVWF  00
193E:  MOVF   xC1,W
1940:  SUBWFB xC3,W
1942:  MOVWF  03
1944:  MOVF   00,W
1946:  BCF    FD8.0
1948:  RLCF   00,F
194A:  MOVF   00,W
194C:  ADDLW  04
194E:  MOVWF  xCC
1950:  MOVFF  2F,CE
1954:  MOVFF  2E,CD
1958:  MOVWF  xCF
195A:  CALL   0D6C
.................... 		current_act_len = make16(flash_page_data2,flash_page_data); 
195E:  MOVFF  7F,C7
1962:  MOVFF  7E,C6
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+6); 
1966:  MOVFF  2F,CB
196A:  MOVFF  2E,CA
196E:  MOVF   xC0,W
1970:  SUBWF  xC2,W
1972:  MOVWF  00
1974:  MOVF   xC1,W
1976:  SUBWFB xC3,W
1978:  MOVWF  03
197A:  MOVF   00,W
197C:  BCF    FD8.0
197E:  RLCF   00,F
1980:  MOVF   00,W
1982:  ADDLW  06
1984:  MOVWF  xCC
1986:  MOVFF  2F,CE
198A:  MOVFF  2E,CD
198E:  MOVWF  xCF
1990:  CALL   0D6C
.................... 		next_act_len = make16(flash_page_data2,flash_page_data); 
1994:  MOVFF  7F,C9
1998:  MOVFF  7E,C8
.................... 		// do linear interpolation of the act len 
.................... 		if (next_act_len>current_act_len) { 
199C:  MOVF   xC7,W
199E:  SUBWF  xC9,W
19A0:  BNC   1A5A
19A2:  BNZ   19AA
19A4:  MOVF   xC8,W
19A6:  SUBWF  xC6,W
19A8:  BC    1A5A
.................... 			tick = (int32)(next_act_len-current_act_len)*(int32)(current_period_fraction); 
19AA:  MOVF   xC6,W
19AC:  SUBWF  xC8,W
19AE:  MOVWF  00
19B0:  MOVF   xC7,W
19B2:  SUBWFB xC9,W
19B4:  MOVWF  03
19B6:  MOVFF  00,CA
19BA:  MOVWF  xCB
19BC:  CLRF   xCC
19BE:  CLRF   xCD
19C0:  MOVFF  C4,00
19C4:  MOVFF  C5,01
19C8:  CLRF   02
19CA:  CLRF   03
19CC:  MOVFF  03,D1
19D0:  MOVFF  02,D0
19D4:  MOVFF  C5,CF
19D8:  MOVFF  C4,CE
19DC:  MOVFF  CD,D7
19E0:  MOVFF  CC,D6
19E4:  MOVWF  xD5
19E6:  MOVFF  CA,D4
19EA:  MOVFF  03,DB
19EE:  MOVFF  02,DA
19F2:  MOVFF  C5,D9
19F6:  MOVFF  C4,D8
19FA:  RCALL  1502
19FC:  MOVFF  03,29
1A00:  MOVFF  02,28
1A04:  MOVFF  01,27
1A08:  MOVFF  00,26
1A0C:  CLRF   18
1A0E:  BTFSC  FF2.7
1A10:  BSF    18.7
1A12:  BCF    FF2.7
.................... 			tick = tick/450; 
1A14:  MOVFF  29,E5
1A18:  MOVFF  28,E4
1A1C:  MOVFF  27,E3
1A20:  MOVFF  26,E2
1A24:  CLRF   xE9
1A26:  CLRF   xE8
1A28:  MOVLW  01
1A2A:  MOVWF  xE7
1A2C:  MOVLW  C2
1A2E:  MOVWF  xE6
1A30:  CALL   00AA
1A34:  BTFSC  18.7
1A36:  BSF    FF2.7
1A38:  MOVFF  03,29
1A3C:  MOVFF  02,28
1A40:  MOVFF  01,27
1A44:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
1A48:  MOVFF  27,C9
1A4C:  MOVFF  26,C8
.................... 			current_act_len = current_act_len + next_act_len; 
1A50:  MOVF   xC8,W
1A52:  ADDWF  xC6,F
1A54:  MOVF   xC9,W
1A56:  ADDWFC xC7,F
.................... 		} else  { 
1A58:  BRA    1B08
.................... 			tick = (int32)(current_act_len-next_act_len)*(int32)(current_period_fraction); 
1A5A:  MOVF   xC8,W
1A5C:  SUBWF  xC6,W
1A5E:  MOVWF  00
1A60:  MOVF   xC9,W
1A62:  SUBWFB xC7,W
1A64:  MOVWF  03
1A66:  MOVFF  00,CA
1A6A:  MOVWF  xCB
1A6C:  CLRF   xCC
1A6E:  CLRF   xCD
1A70:  MOVFF  C4,00
1A74:  MOVFF  C5,01
1A78:  CLRF   02
1A7A:  CLRF   03
1A7C:  MOVFF  03,D1
1A80:  MOVFF  02,D0
1A84:  MOVFF  C5,CF
1A88:  MOVFF  C4,CE
1A8C:  MOVFF  CD,D7
1A90:  MOVFF  CC,D6
1A94:  MOVWF  xD5
1A96:  MOVFF  CA,D4
1A9A:  MOVFF  03,DB
1A9E:  MOVFF  02,DA
1AA2:  MOVFF  C5,D9
1AA6:  MOVFF  C4,D8
1AAA:  RCALL  1502
1AAC:  MOVFF  03,29
1AB0:  MOVFF  02,28
1AB4:  MOVFF  01,27
1AB8:  MOVFF  00,26
1ABC:  CLRF   18
1ABE:  BTFSC  FF2.7
1AC0:  BSF    18.7
1AC2:  BCF    FF2.7
.................... 			tick = tick/450; 
1AC4:  MOVFF  29,E5
1AC8:  MOVFF  28,E4
1ACC:  MOVFF  27,E3
1AD0:  MOVFF  26,E2
1AD4:  CLRF   xE9
1AD6:  CLRF   xE8
1AD8:  MOVLW  01
1ADA:  MOVWF  xE7
1ADC:  MOVLW  C2
1ADE:  MOVWF  xE6
1AE0:  CALL   00AA
1AE4:  BTFSC  18.7
1AE6:  BSF    FF2.7
1AE8:  MOVFF  03,29
1AEC:  MOVFF  02,28
1AF0:  MOVFF  01,27
1AF4:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
1AF8:  MOVFF  27,C9
1AFC:  MOVFF  26,C8
.................... 			current_act_len = current_act_len - next_act_len; 
1B00:  MOVF   xC8,W
1B02:  SUBWF  xC6,F
1B04:  MOVF   xC9,W
1B06:  SUBWFB xC7,F
.................... 		} 
.................... 		if (current_act_len >= act_max_stroke[nActuator]) current_act_len = act_max_stroke[nActuator]; 
1B08:  BCF    FD8.0
1B0A:  RLCF   xBF,W
1B0C:  CLRF   03
1B0E:  ADDLW  9C
1B10:  MOVWF  FE9
1B12:  MOVLW  00
1B14:  ADDWFC 03,W
1B16:  MOVWF  FEA
1B18:  MOVFF  FEC,03
1B1C:  MOVF   FED,F
1B1E:  MOVFF  FEF,01
1B22:  MOVF   03,W
1B24:  SUBWF  xC7,W
1B26:  BNC   1B4E
1B28:  BNZ   1B30
1B2A:  MOVF   01,W
1B2C:  SUBWF  xC6,W
1B2E:  BNC   1B4E
1B30:  BCF    FD8.0
1B32:  RLCF   xBF,W
1B34:  CLRF   03
1B36:  ADDLW  9C
1B38:  MOVWF  FE9
1B3A:  MOVLW  00
1B3C:  ADDWFC 03,W
1B3E:  MOVWF  FEA
1B40:  MOVFF  FEC,03
1B44:  MOVF   FED,F
1B46:  MOVFF  FEF,C6
1B4A:  MOVFF  03,C7
.................... 		if (current_act_len <= act_min_stroke[nActuator]) current_act_len = act_min_stroke[nActuator]; 
1B4E:  BCF    FD8.0
1B50:  RLCF   xBF,W
1B52:  CLRF   03
1B54:  ADDLW  A4
1B56:  MOVWF  FE9
1B58:  MOVLW  00
1B5A:  ADDWFC 03,W
1B5C:  MOVWF  FEA
1B5E:  MOVFF  FEC,03
1B62:  MOVF   FED,F
1B64:  MOVFF  FEF,01
1B68:  MOVF   xC7,W
1B6A:  SUBWF  03,W
1B6C:  BNC   1B94
1B6E:  BNZ   1B76
1B70:  MOVF   xC6,W
1B72:  SUBWF  01,W
1B74:  BNC   1B94
1B76:  BCF    FD8.0
1B78:  RLCF   xBF,W
1B7A:  CLRF   03
1B7C:  ADDLW  A4
1B7E:  MOVWF  FE9
1B80:  MOVLW  00
1B82:  ADDWFC 03,W
1B84:  MOVWF  FEA
1B86:  MOVFF  FEC,03
1B8A:  MOVF   FED,F
1B8C:  MOVFF  FEF,C6
1B90:  MOVFF  03,C7
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]* (int32)(current_act_len-act_min_stroke[nActuator]); 
1B94:  BCF    FD8.0
1B96:  RLCF   xBF,W
1B98:  CLRF   03
1B9A:  ADDLW  94
1B9C:  MOVWF  FE9
1B9E:  MOVLW  00
1BA0:  ADDWFC 03,W
1BA2:  MOVWF  FEA
1BA4:  MOVFF  FEC,03
1BA8:  MOVF   FED,F
1BAA:  MOVFF  FEF,CA
1BAE:  MOVFF  03,CB
1BB2:  CLRF   xCC
1BB4:  CLRF   xCD
1BB6:  BCF    FD8.0
1BB8:  RLCF   xBF,W
1BBA:  CLRF   03
1BBC:  ADDLW  A4
1BBE:  MOVWF  FE9
1BC0:  MOVLW  00
1BC2:  ADDWFC 03,W
1BC4:  MOVWF  FEA
1BC6:  MOVFF  FEC,03
1BCA:  MOVF   FED,F
1BCC:  MOVF   FEF,W
1BCE:  SUBWF  xC6,W
1BD0:  MOVWF  00
1BD2:  MOVF   03,W
1BD4:  SUBWFB xC7,W
1BD6:  MOVWF  03
1BD8:  MOVF   00,W
1BDA:  MOVFF  03,01
1BDE:  CLRF   02
1BE0:  CLRF   03
1BE2:  MOVFF  03,D1
1BE6:  MOVFF  02,D0
1BEA:  MOVFF  01,CF
1BEE:  MOVFF  00,CE
1BF2:  MOVFF  FEA,D3
1BF6:  MOVFF  FE9,D2
1BFA:  MOVFF  CD,D7
1BFE:  MOVFF  CC,D6
1C02:  MOVFF  CB,D5
1C06:  MOVFF  CA,D4
1C0A:  MOVFF  03,DB
1C0E:  MOVFF  02,DA
1C12:  MOVFF  01,D9
1C16:  MOVFF  00,D8
1C1A:  RCALL  1502
1C1C:  MOVFF  D3,FEA
1C20:  MOVFF  D2,FE9
1C24:  MOVFF  03,29
1C28:  MOVFF  02,28
1C2C:  MOVFF  01,27
1C30:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke[nActuator]-act_min_stroke[nActuator]); 
1C34:  BCF    FD8.0
1C36:  RLCF   xBF,W
1C38:  CLRF   03
1C3A:  ADDLW  9C
1C3C:  MOVWF  FE9
1C3E:  MOVLW  00
1C40:  ADDWFC 03,W
1C42:  MOVWF  FEA
1C44:  MOVFF  FEC,CB
1C48:  MOVF   FED,F
1C4A:  MOVFF  FEF,CA
1C4E:  BCF    FD8.0
1C50:  RLCF   xBF,W
1C52:  CLRF   03
1C54:  ADDLW  A4
1C56:  MOVWF  FE9
1C58:  MOVLW  00
1C5A:  ADDWFC 03,W
1C5C:  MOVWF  FEA
1C5E:  MOVFF  FEC,03
1C62:  MOVF   FED,F
1C64:  MOVF   FEF,W
1C66:  SUBWF  xCA,W
1C68:  MOVWF  00
1C6A:  MOVF   03,W
1C6C:  SUBWFB xCB,W
1C6E:  MOVWF  03
1C70:  MOVFF  00,CA
1C74:  MOVWF  xCB
1C76:  MOVFF  FEA,CD
1C7A:  MOVFF  FE9,CC
1C7E:  CLRF   18
1C80:  BTFSC  FF2.7
1C82:  BSF    18.7
1C84:  BCF    FF2.7
1C86:  MOVFF  29,E5
1C8A:  MOVFF  28,E4
1C8E:  MOVFF  27,E3
1C92:  MOVFF  26,E2
1C96:  CLRF   xE9
1C98:  CLRF   xE8
1C9A:  MOVWF  xE7
1C9C:  MOVFF  00,E6
1CA0:  CALL   00AA
1CA4:  BTFSC  18.7
1CA6:  BSF    FF2.7
1CA8:  MOVFF  CD,FEA
1CAC:  MOVFF  CC,FE9
1CB0:  MOVFF  03,29
1CB4:  MOVFF  02,28
1CB8:  MOVFF  01,27
1CBC:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
1CC0:  MOVFF  27,93
1CC4:  MOVFF  26,92
.................... 	} 
....................  
.................... } 
1CC8:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,int8 direction,unsigned int8 nActuator) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
115C:  CLRF   xCA
115E:  CLRF   xCB
....................    unsigned int16 yyy=0;    
1160:  CLRF   xCC
1162:  CLRF   xCD
....................    output_low(CCW); 
1164:  BCF    F93.4
1166:  BCF    F8A.4
....................    output_low(EN0); 
1168:  BCF    F93.0
116A:  BCF    F8A.0
....................    output_low(EN1); 
116C:  BCF    F93.1
116E:  BCF    F8A.1
....................    output_low(EN2); 
1170:  BCF    F93.2
1172:  BCF    F8A.2
....................    output_low(EN3); 
1174:  BCF    F93.3
1176:  BCF    F8A.3
1178:  CLRF   18
117A:  BTFSC  FF2.7
117C:  BSF    18.7
117E:  BCF    FF2.7
....................    delay_ms(20); 
1180:  MOVLW  14
1182:  MOVWF  xE2
1184:  CALL   0178
1188:  BTFSC  18.7
118A:  BSF    FF2.7
....................    if (nActuator > 3) return; // actuator exceed max number allowable 
118C:  MOVF   xC9,W
118E:  SUBLW  03
1190:  BC    1194
1192:  BRA    1450
....................    flag2.is_moving =1; 
1194:  BSF    20.6
....................    switch (nActuator) { 
1196:  MOVF   xC9,W
1198:  ADDLW  FC
119A:  BC    11CA
119C:  ADDLW  04
119E:  GOTO   1452
.................... 		case 0: { flag.prev_pulse_state = input(SENSE_0); break;} 
11A2:  BSF    F92.2
11A4:  BCF    1F.2
11A6:  BTFSC  F80.2
11A8:  BSF    1F.2
11AA:  BRA    11CA
.................... 		case 1: { flag.prev_pulse_state = input(SENSE_1); break;} 
11AC:  BSF    F92.3
11AE:  BCF    1F.2
11B0:  BTFSC  F80.3
11B2:  BSF    1F.2
11B4:  BRA    11CA
.................... 		case 2: { flag.prev_pulse_state = input(SENSE_2); break;} 
11B6:  BSF    F92.4
11B8:  BCF    1F.2
11BA:  BTFSC  F80.4
11BC:  BSF    1F.2
11BE:  BRA    11CA
.................... 		case 3: { flag.prev_pulse_state = input(SENSE_3); break;} 
11C0:  BSF    F92.5
11C2:  BCF    1F.2
11C4:  BTFSC  F80.5
11C6:  BSF    1F.2
11C8:  BRA    11CA
....................    } 
....................  
....................    if (!direction)   { 
11CA:  MOVF   xC8,F
11CC:  BNZ   11D2
....................       output_high(CCW); 
11CE:  BCF    F93.4
11D0:  BSF    F8A.4
11D2:  CLRF   18
11D4:  BTFSC  FF2.7
11D6:  BSF    18.7
11D8:  BCF    FF2.7
....................    } 
....................  
....................    delay_ms(200); 
11DA:  MOVLW  C8
11DC:  MOVWF  xE2
11DE:  CALL   0178
11E2:  BTFSC  18.7
11E4:  BSF    FF2.7
....................    switch (nActuator) { 
11E6:  MOVF   xC9,W
11E8:  ADDLW  FC
11EA:  BC    120A
11EC:  ADDLW  04
11EE:  GOTO   147E
.................... 		case 0: {output_high(EN0); break;} 
11F2:  BCF    F93.0
11F4:  BSF    F8A.0
11F6:  BRA    120A
.................... 		case 1: {output_high(EN1); break;} 
11F8:  BCF    F93.1
11FA:  BSF    F8A.1
11FC:  BRA    120A
.................... 		case 2: {output_high(EN2); break;} 
11FE:  BCF    F93.2
1200:  BSF    F8A.2
1202:  BRA    120A
.................... 		case 3: {output_high(EN3); break;} 
1204:  BCF    F93.3
1206:  BSF    F8A.3
1208:  BRA    120A
....................    } 
....................    delay_ms(10); 
120A:  CLRF   18
120C:  BTFSC  FF2.7
120E:  BSF    18.7
1210:  BCF    FF2.7
1212:  MOVLW  0A
1214:  MOVWF  xE2
1216:  CALL   0178
121A:  BTFSC  18.7
121C:  BSF    FF2.7
....................  
....................    tick = timer_sec; 
121E:  MOVFF  25,29
1222:  MOVFF  24,28
1226:  MOVFF  23,27
122A:  MOVFF  22,26
....................    tick2 = timer_sec; 
122E:  MOVFF  25,2D
1232:  MOVFF  24,2C
1236:  MOVFF  23,2B
123A:  MOVFF  22,2A
....................    actuator_pulse =0; 
123E:  CLRF   x83
1240:  CLRF   x82
....................    while(1) { 
....................       restart_wdt(); 
1242:  CLRWDT
....................       xxx = (int16) (timer_sec-tick); 
1244:  MOVF   26,W
1246:  SUBWF  22,W
1248:  MOVWF  00
124A:  MOVF   27,W
124C:  SUBWFB 23,W
124E:  MOVWF  01
1250:  MOVF   28,W
1252:  SUBWFB 24,W
1254:  MOVF   29,W
1256:  SUBWFB 25,W
1258:  MOVFF  01,CB
125C:  MOVFF  00,CA
....................       yyy = (int16) (timer_sec-tick2); 
1260:  MOVF   2A,W
1262:  SUBWF  22,W
1264:  MOVWF  00
1266:  MOVF   2B,W
1268:  SUBWFB 23,W
126A:  MOVWF  01
126C:  MOVF   2C,W
126E:  SUBWFB 24,W
1270:  MOVF   2D,W
1272:  SUBWFB 25,W
1274:  MOVFF  01,CD
1278:  MOVFF  00,CC
....................    	  switch (nActuator) { 
127C:  MOVF   xC9,W
127E:  ADDLW  FC
1280:  BC    12B0
1282:  ADDLW  04
1284:  GOTO   14AA
.................... 		case 0: { flag2.current_pulse_state = input(SENSE_0); break;} 
1288:  BSF    F92.2
128A:  BCF    20.4
128C:  BTFSC  F80.2
128E:  BSF    20.4
1290:  BRA    12B0
.................... 		case 1: { flag2.current_pulse_state = input(SENSE_1); break;} 
1292:  BSF    F92.3
1294:  BCF    20.4
1296:  BTFSC  F80.3
1298:  BSF    20.4
129A:  BRA    12B0
.................... 		case 2: { flag2.current_pulse_state = input(SENSE_2); break;} 
129C:  BSF    F92.4
129E:  BCF    20.4
12A0:  BTFSC  F80.4
12A2:  BSF    20.4
12A4:  BRA    12B0
.................... 		case 3: { flag2.current_pulse_state = input(SENSE_3); break;} 
12A6:  BSF    F92.5
12A8:  BCF    20.4
12AA:  BTFSC  F80.5
12AC:  BSF    20.4
12AE:  BRA    12B0
....................       } 
....................  
.................... 	  if (flag2.allow_manual_move_act) { 
12B0:  BTFSS  20.3
12B2:  BRA    12D2
.................... 		  if (((!direction && (nButton==3)) || (direction && (nButton==5))) && flag2.button_pressed)  
12B4:  MOVF   xC8,F
12B6:  BNZ   12BE
12B8:  MOVF   4B,W
12BA:  SUBLW  03
12BC:  BZ    12C8
12BE:  MOVF   xC8,F
12C0:  BZ    12D0
12C2:  MOVF   4B,W
12C4:  SUBLW  05
12C6:  BNZ   12D0
12C8:  BTFSS  20.1
12CA:  BRA    12D0
.................... 			flag2.allow_manual_move_act=1; 
12CC:  BSF    20.3
.................... 		  else 
12CE:  BRA    12D2
.................... 			flag2.allow_manual_move_act=0;	 
12D0:  BCF    20.3
.................... 	  } 
.................... 	  if (!flag2.allow_manual_move_act) {  
12D2:  BTFSC  20.3
12D4:  BRA    1330
....................       if (flag2.abort_current_activity ==1) { 
12D6:  BTFSS  20.2
12D8:  BRA    12DE
.................... 		 flag2.abort_current_activity=0; 
12DA:  BCF    20.2
.................... 		 break; 
12DC:  BRA    1402
....................       } 
....................       if ( xxx>= time_out_sec)  
12DE:  MOVF   xC5,W
12E0:  SUBWF  xCB,W
12E2:  BNC   12EE
12E4:  BNZ   12EC
12E6:  MOVF   xC4,W
12E8:  SUBWF  xCA,W
12EA:  BNC   12EE
....................          break; 
12EC:  BRA    1402
....................        if (actuator_pulse >= nPulse) 
12EE:  MOVF   xC3,W
12F0:  SUBWF  x83,W
12F2:  BNC   1320
12F4:  BNZ   12FC
12F6:  MOVF   xC2,W
12F8:  SUBWF  x82,W
12FA:  BNC   1320
.................... 	    switch (nActuator) { 
12FC:  MOVF   xC9,W
12FE:  ADDLW  FC
1300:  BC    1320
1302:  ADDLW  04
1304:  GOTO   14D6
.................... 			case 0: {output_low(EN0); break;} 
1308:  BCF    F93.0
130A:  BCF    F8A.0
130C:  BRA    1320
.................... 			case 1: {output_low(EN1); break;} 
130E:  BCF    F93.1
1310:  BCF    F8A.1
1312:  BRA    1320
.................... 			case 2: {output_low(EN2); break;} 
1314:  BCF    F93.2
1316:  BCF    F8A.2
1318:  BRA    1320
.................... 			case 3: {output_low(EN3); break;} 
131A:  BCF    F93.3
131C:  BCF    F8A.3
131E:  BRA    1320
....................    		} 
....................       if ( yyy >=stuck_sec) 
1320:  MOVF   xC7,W
1322:  SUBWF  xCD,W
1324:  BNC   1330
1326:  BNZ   132E
1328:  MOVF   xC6,W
132A:  SUBWF  xCC,W
132C:  BNC   1330
....................          break; 
132E:  BRA    1402
....................       }    
....................       if (flag.prev_pulse_state != flag2.current_pulse_state) { 
1330:  CLRF   00
1332:  BTFSC  20.4
1334:  BSF    00.2
1336:  MOVF   1F,W
1338:  XORWF  00,W
133A:  ANDLW  04
133C:  BZ    1400
....................          tick2 = timer_sec; 
133E:  MOVFF  25,2D
1342:  MOVFF  24,2C
1346:  MOVFF  23,2B
134A:  MOVFF  22,2A
....................          flag.prev_pulse_state = flag2.current_pulse_state; 
134E:  BCF    1F.2
1350:  BTFSC  20.4
1352:  BSF    1F.2
....................          if (!direction && (current_act_position[nActuator] >0)) current_act_position[nActuator]--; 
1354:  MOVF   xC8,F
1356:  BNZ   1394
1358:  BCF    FD8.0
135A:  RLCF   xC9,W
135C:  CLRF   03
135E:  ADDLW  8A
1360:  MOVWF  FE9
1362:  MOVLW  00
1364:  ADDWFC 03,W
1366:  MOVWF  FEA
1368:  MOVFF  FEC,CF
136C:  MOVF   FED,F
136E:  MOVFF  FEF,CE
1372:  MOVF   xCE,F
1374:  BNZ   137A
1376:  MOVF   xCF,F
1378:  BZ    1394
137A:  BCF    FD8.0
137C:  RLCF   xC9,W
137E:  CLRF   03
1380:  ADDLW  8A
1382:  MOVWF  FE9
1384:  MOVLW  00
1386:  ADDWFC 03,W
1388:  MOVWF  FEA
138A:  MOVLW  FF
138C:  ADDWF  FEF,F
138E:  BC    1394
1390:  MOVF   FEE,F
1392:  DECF   FED,F
....................          if (direction && (current_act_position[nActuator] < act_full_stroke_tick[nActuator])) current_act_position[nActuator]++; 
1394:  MOVF   xC8,F
1396:  BZ    13F2
1398:  BCF    FD8.0
139A:  RLCF   xC9,W
139C:  CLRF   03
139E:  ADDLW  8A
13A0:  MOVWF  FE9
13A2:  MOVLW  00
13A4:  ADDWFC 03,W
13A6:  MOVWF  FEA
13A8:  MOVFF  FEC,CF
13AC:  MOVF   FED,F
13AE:  MOVFF  FEF,CE
13B2:  BCF    FD8.0
13B4:  RLCF   xC9,W
13B6:  CLRF   03
13B8:  ADDLW  94
13BA:  MOVWF  FE9
13BC:  MOVLW  00
13BE:  ADDWFC 03,W
13C0:  MOVWF  FEA
13C2:  MOVFF  FEC,03
13C6:  MOVF   FED,F
13C8:  MOVFF  FEF,01
13CC:  MOVF   xCF,W
13CE:  SUBWF  03,W
13D0:  BNC   13F2
13D2:  BNZ   13DA
13D4:  MOVF   01,W
13D6:  SUBWF  xCE,W
13D8:  BC    13F2
13DA:  BCF    FD8.0
13DC:  RLCF   xC9,W
13DE:  CLRF   03
13E0:  ADDLW  8A
13E2:  MOVWF  FE9
13E4:  MOVLW  00
13E6:  ADDWFC 03,W
13E8:  MOVWF  FEA
13EA:  MOVLW  01
13EC:  ADDWF  FEE,F
13EE:  BNC   13F2
13F0:  INCF   FEF,F
....................          actuator_pulse=actuator_pulse+1; 
13F2:  MOVLW  01
13F4:  ADDWF  x82,F
13F6:  MOVLW  00
13F8:  ADDWFC x83,F
.................... 		 led_status.operation = !led_status.operation; 
13FA:  BTG    21.1
.................... 		 display_LED(); 
13FC:  CALL   0144
....................       } 
....................    } 
1400:  BRA    1242
....................    flag2.abort_current_activity=0; 
1402:  BCF    20.2
....................    output_low(EN0); 
1404:  BCF    F93.0
1406:  BCF    F8A.0
....................    output_low(EN1); 
1408:  BCF    F93.1
140A:  BCF    F8A.1
....................    output_low(EN2); 
140C:  BCF    F93.2
140E:  BCF    F8A.2
....................    output_low(EN3); 
1410:  BCF    F93.3
1412:  BCF    F8A.3
....................    delay_ms(500); 
1414:  MOVLW  02
1416:  MOVWF  xCE
1418:  CLRF   18
141A:  BTFSC  FF2.7
141C:  BSF    18.7
141E:  BCF    FF2.7
1420:  MOVLW  FA
1422:  MOVWF  xE2
1424:  CALL   0178
1428:  BTFSC  18.7
142A:  BSF    FF2.7
142C:  DECFSZ xCE,F
142E:  BRA    1418
....................    output_low(CCW); 
1430:  BCF    F93.4
1432:  BCF    F8A.4
1434:  CLRF   18
1436:  BTFSC  FF2.7
1438:  BSF    18.7
143A:  BCF    FF2.7
....................    delay_ms(20); 
143C:  MOVLW  14
143E:  MOVWF  xE2
1440:  CALL   0178
1444:  BTFSC  18.7
1446:  BSF    FF2.7
....................    led_status.operation = 1; 
1448:  BSF    21.1
....................    display_LED(); 
144A:  CALL   0144
....................    flag2.is_moving =0; 
144E:  BCF    20.6
....................  
....................  
.................... } 
1450:  RETLW  00
....................  
.................... void actuator_move_execute(nActuator) { 
....................     if(current_act_position[nActuator] > (target_act_position+5))// move east 
*
1556:  BCF    FD8.0
1558:  RLCF   xBF,W
155A:  CLRF   03
155C:  ADDLW  8A
155E:  MOVWF  FE9
1560:  MOVLW  00
1562:  ADDWFC 03,W
1564:  MOVWF  FEA
1566:  MOVFF  FEC,C1
156A:  MOVF   FED,F
156C:  MOVFF  FEF,C0
1570:  MOVLW  05
1572:  ADDWF  x92,W
1574:  MOVWF  01
1576:  MOVLW  00
1578:  ADDWFC x93,W
157A:  MOVWF  03
157C:  MOVF   03,W
157E:  SUBWF  xC1,W
1580:  BNC   15CE
1582:  BNZ   158A
1584:  MOVF   xC0,W
1586:  SUBWF  01,W
1588:  BC    15CE
....................             move_act(current_act_position[nActuator]-target_act_position,4500,move_act_time_out,0,nActuator); 
158A:  BCF    FD8.0
158C:  RLCF   xBF,W
158E:  CLRF   03
1590:  ADDLW  8A
1592:  MOVWF  FE9
1594:  MOVLW  00
1596:  ADDWFC 03,W
1598:  MOVWF  FEA
159A:  MOVFF  FEC,C1
159E:  MOVF   FED,F
15A0:  MOVFF  FEF,C0
15A4:  MOVF   x92,W
15A6:  SUBWF  xC0,F
15A8:  MOVF   x93,W
15AA:  SUBWFB xC1,F
15AC:  MOVFF  C1,C3
15B0:  MOVFF  C0,C2
15B4:  MOVLW  11
15B6:  MOVWF  xC5
15B8:  MOVLW  94
15BA:  MOVWF  xC4
15BC:  MOVFF  81,C7
15C0:  MOVFF  80,C6
15C4:  CLRF   xC8
15C6:  MOVFF  BF,C9
15CA:  RCALL  115C
....................     else if((current_act_position[nActuator]+5) < target_act_position)// move west 
15CC:  BRA    16E4
15CE:  BCF    FD8.0
15D0:  RLCF   xBF,W
15D2:  CLRF   03
15D4:  ADDLW  8A
15D6:  MOVWF  FE9
15D8:  MOVLW  00
15DA:  ADDWFC 03,W
15DC:  MOVWF  FEA
15DE:  MOVFF  FEC,C1
15E2:  MOVF   FED,F
15E4:  MOVFF  FEF,C0
15E8:  MOVLW  05
15EA:  ADDWF  xC0,F
15EC:  MOVLW  00
15EE:  ADDWFC xC1,F
15F0:  MOVF   xC1,W
15F2:  SUBWF  x93,W
15F4:  BNC   1642
15F6:  BNZ   15FE
15F8:  MOVF   x92,W
15FA:  SUBWF  xC0,W
15FC:  BC    1642
....................             move_act(target_act_position-current_act_position[nActuator],4500,move_act_time_out,1,nActuator); 
15FE:  BCF    FD8.0
1600:  RLCF   xBF,W
1602:  CLRF   03
1604:  ADDLW  8A
1606:  MOVWF  FE9
1608:  MOVLW  00
160A:  ADDWFC 03,W
160C:  MOVWF  FEA
160E:  MOVFF  FEC,03
1612:  MOVF   FED,F
1614:  MOVF   FEF,W
1616:  SUBWF  x92,W
1618:  MOVWF  xC0
161A:  MOVF   03,W
161C:  SUBWFB x93,W
161E:  MOVWF  xC1
1620:  MOVWF  xC3
1622:  MOVFF  C0,C2
1626:  MOVLW  11
1628:  MOVWF  xC5
162A:  MOVLW  94
162C:  MOVWF  xC4
162E:  MOVFF  81,C7
1632:  MOVFF  80,C6
1636:  MOVLW  01
1638:  MOVWF  xC8
163A:  MOVFF  BF,C9
163E:  RCALL  115C
....................     else if (target_act_position == 0x00)  // move east all the way 
1640:  BRA    16E4
1642:  MOVF   x92,F
1644:  BNZ   1686
1646:  MOVF   x93,F
1648:  BNZ   1686
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,0,nActuator); 
164A:  BCF    FD8.0
164C:  RLCF   xBF,W
164E:  CLRF   03
1650:  ADDLW  94
1652:  MOVWF  FE9
1654:  MOVLW  00
1656:  ADDWFC 03,W
1658:  MOVWF  FEA
165A:  MOVFF  FEC,C1
165E:  MOVF   FED,F
1660:  MOVFF  FEF,C0
1664:  MOVFF  C1,C3
1668:  MOVFF  C0,C2
166C:  MOVLW  11
166E:  MOVWF  xC5
1670:  MOVLW  94
1672:  MOVWF  xC4
1674:  MOVFF  81,C7
1678:  MOVFF  80,C6
167C:  CLRF   xC8
167E:  MOVFF  BF,C9
1682:  RCALL  115C
....................     else if (target_act_position == act_full_stroke_tick[nActuator]) // move west all the way 
1684:  BRA    16E4
1686:  BCF    FD8.0
1688:  RLCF   xBF,W
168A:  CLRF   03
168C:  ADDLW  94
168E:  MOVWF  FE9
1690:  MOVLW  00
1692:  ADDWFC 03,W
1694:  MOVWF  FEA
1696:  MOVFF  FEC,03
169A:  MOVF   FED,F
169C:  MOVF   FEF,W
169E:  SUBWF  x92,W
16A0:  BNZ   16E4
16A2:  MOVF   03,W
16A4:  SUBWF  x93,W
16A6:  BNZ   16E4
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,1,nActuator); 
16A8:  BCF    FD8.0
16AA:  RLCF   xBF,W
16AC:  CLRF   03
16AE:  ADDLW  94
16B0:  MOVWF  FE9
16B2:  MOVLW  00
16B4:  ADDWFC 03,W
16B6:  MOVWF  FEA
16B8:  MOVFF  FEC,C1
16BC:  MOVF   FED,F
16BE:  MOVFF  FEF,C0
16C2:  MOVFF  C1,C3
16C6:  MOVFF  C0,C2
16CA:  MOVLW  11
16CC:  MOVWF  xC5
16CE:  MOVLW  94
16D0:  MOVWF  xC4
16D2:  MOVFF  81,C7
16D6:  MOVFF  80,C6
16DA:  MOVLW  01
16DC:  MOVWF  xC8
16DE:  MOVFF  BF,C9
16E2:  RCALL  115C
.................... } 
16E4:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... void read_device_id() { 
....................    int16 temp_mem; 
....................    int8 i; 
....................    temp_mem= &dev_id; 
*
09D6:  CLRF   xC0
09D8:  MOVLW  34
09DA:  MOVWF  xBF
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom(0xf00050+i),1); 
09DC:  CLRF   xC1
09DE:  MOVF   xC1,W
09E0:  SUBLW  01
09E2:  BNC   0A3A
09E4:  MOVF   xC1,W
09E6:  ADDWF  xBF,W
09E8:  MOVWF  xC2
09EA:  MOVLW  00
09EC:  ADDWFC xC0,W
09EE:  MOVWF  xC3
09F0:  MOVLW  50
09F2:  ADDWF  xC1,W
09F4:  MOVWF  xC4
09F6:  CLRF   xC5
09F8:  BTFSC  FD8.0
09FA:  INCF   xC5,F
09FC:  MOVLW  F0
09FE:  MOVWF  xC6
0A00:  BTFSC  FD8.0
0A02:  INCF   xC6,F
0A04:  CLRF   xC7
0A06:  BTFSC  FD8.0
0A08:  INCF   xC7,F
0A0A:  MOVFF  FF2,C8
0A0E:  BCF    FF2.7
0A10:  MOVFF  C4,FA9
0A14:  BCF    FA6.6
0A16:  BCF    FA6.7
0A18:  BSF    FA6.0
0A1A:  MOVF   FA8,W
0A1C:  BTFSC  xC8.7
0A1E:  BSF    FF2.7
0A20:  MOVWF  xC4
0A22:  MOVFF  C3,FEA
0A26:  MOVFF  C2,FE9
0A2A:  MOVFF  C4,C9
0A2E:  CLRF   xCB
0A30:  MOVLW  01
0A32:  MOVWF  xCA
0A34:  RCALL  0660
0A36:  INCF   xC1,F
0A38:  BRA    09DE
.................... } 
0A3A:  RETLW  00
....................  
.................... void write_device_id() { 
.................... 	int8 i; 
.................... 	for (i=0;i<2;i++) write_eeprom(0xf00050+i,dev_id>>(i*8)); 
*
1CCA:  CLRF   xBF
1CCC:  MOVF   xBF,W
1CCE:  SUBLW  01
1CD0:  BNC   1D3A
1CD2:  MOVLW  50
1CD4:  ADDWF  xBF,W
1CD6:  MOVWF  xC0
1CD8:  CLRF   xC1
1CDA:  BTFSC  FD8.0
1CDC:  INCF   xC1,F
1CDE:  MOVLW  F0
1CE0:  MOVWF  xC2
1CE2:  BTFSC  FD8.0
1CE4:  INCF   xC2,F
1CE6:  CLRF   xC3
1CE8:  BTFSC  FD8.0
1CEA:  INCF   xC3,F
1CEC:  MOVF   xBF,W
1CEE:  MULLW  08
1CF0:  MOVFF  FF3,00
1CF4:  MOVFF  35,C5
1CF8:  MOVFF  34,C4
1CFC:  MOVF   00,F
1CFE:  BZ    1D0A
1D00:  BCF    FD8.0
1D02:  RRCF   xC5,F
1D04:  RRCF   xC4,F
1D06:  DECFSZ 00,F
1D08:  BRA    1D00
1D0A:  MOVFF  C0,FA9
1D0E:  MOVFF  C4,FA8
1D12:  BCF    FA6.6
1D14:  BCF    FA6.7
1D16:  BSF    FA6.2
1D18:  MOVFF  FF2,00
1D1C:  BCF    FF2.7
1D1E:  MOVLB  F
1D20:  MOVLW  55
1D22:  MOVWF  FA7
1D24:  MOVLW  AA
1D26:  MOVWF  FA7
1D28:  BSF    FA6.1
1D2A:  BTFSC  FA6.1
1D2C:  BRA    1D2A
1D2E:  BCF    FA6.2
1D30:  MOVF   00,W
1D32:  IORWF  FF2,F
1D34:  MOVLB  0
1D36:  INCF   xBF,F
1D38:  BRA    1CCC
.................... } 
1D3A:  GOTO   24EA (RETURN)
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int8 i,j; 
....................    int16 temp_mem;    
....................  
....................    temp_mem= &timer_sec; 
*
067A:  CLRF   xBE
067C:  MOVLW  22
067E:  MOVWF  xBD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
0680:  CLRF   xBB
0682:  MOVF   xBB,W
0684:  SUBLW  03
0686:  BNC   06CA
0688:  MOVF   xBB,W
068A:  ADDWF  xBD,W
068C:  MOVWF  xBF
068E:  MOVLW  00
0690:  ADDWFC xBE,W
0692:  MOVWF  xC0
0694:  MOVLW  20
0696:  ADDWF  xBB,W
0698:  MOVWF  xC1
069A:  MOVFF  FF2,C2
069E:  BCF    FF2.7
06A0:  MOVFF  C1,FA9
06A4:  BCF    FA6.6
06A6:  BCF    FA6.7
06A8:  BSF    FA6.0
06AA:  MOVF   FA8,W
06AC:  BTFSC  xC2.7
06AE:  BSF    FF2.7
06B0:  MOVWF  xC1
06B2:  MOVFF  C0,FEA
06B6:  MOVFF  BF,FE9
06BA:  MOVFF  C1,C9
06BE:  CLRF   xCB
06C0:  MOVLW  01
06C2:  MOVWF  xCA
06C4:  RCALL  0660
06C6:  INCF   xBB,F
06C8:  BRA    0682
....................  
....................    temp_mem= &nDay; 
06CA:  CLRF   xBE
06CC:  MOVLW  2E
06CE:  MOVWF  xBD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i+4),1); 
06D0:  CLRF   xBB
06D2:  MOVF   xBB,W
06D4:  SUBLW  03
06D6:  BNC   071C
06D8:  MOVF   xBB,W
06DA:  ADDWF  xBD,W
06DC:  MOVWF  xBF
06DE:  MOVLW  00
06E0:  ADDWFC xBE,W
06E2:  MOVWF  xC0
06E4:  MOVLW  20
06E6:  ADDWF  xBB,W
06E8:  ADDLW  04
06EA:  MOVWF  xC1
06EC:  MOVFF  FF2,C2
06F0:  BCF    FF2.7
06F2:  MOVFF  C1,FA9
06F6:  BCF    FA6.6
06F8:  BCF    FA6.7
06FA:  BSF    FA6.0
06FC:  MOVF   FA8,W
06FE:  BTFSC  xC2.7
0700:  BSF    FF2.7
0702:  MOVWF  xC1
0704:  MOVFF  C0,FEA
0708:  MOVFF  BF,FE9
070C:  MOVFF  C1,C9
0710:  CLRF   xCB
0712:  MOVLW  01
0714:  MOVWF  xCA
0716:  RCALL  0660
0718:  INCF   xBB,F
071A:  BRA    06D2
....................  
....................  
....................    temp_mem= &startup_counter; 
071C:  CLRF   xBE
071E:  MOVLW  32
0720:  MOVWF  xBD
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
0722:  CLRF   xBB
0724:  MOVF   xBB,W
0726:  SUBLW  01
0728:  BNC   076C
072A:  MOVF   xBB,W
072C:  ADDWF  xBD,W
072E:  MOVWF  xBF
0730:  MOVLW  00
0732:  ADDWFC xBE,W
0734:  MOVWF  xC0
0736:  MOVLW  30
0738:  ADDWF  xBB,W
073A:  MOVWF  xC1
073C:  MOVFF  FF2,C2
0740:  BCF    FF2.7
0742:  MOVFF  C1,FA9
0746:  BCF    FA6.6
0748:  BCF    FA6.7
074A:  BSF    FA6.0
074C:  MOVF   FA8,W
074E:  BTFSC  xC2.7
0750:  BSF    FF2.7
0752:  MOVWF  xC1
0754:  MOVFF  C0,FEA
0758:  MOVFF  BF,FE9
075C:  MOVFF  C1,C9
0760:  CLRF   xCB
0762:  MOVLW  01
0764:  MOVWF  xCA
0766:  RCALL  0660
0768:  INCF   xBB,F
076A:  BRA    0724
....................  
....................    for (j=0;j<4;j++) { 
076C:  CLRF   xBC
076E:  MOVF   xBC,W
0770:  SUBLW  03
0772:  BTFSS  FD8.0
0774:  BRA    09D2
....................    		temp_mem= &act_full_stroke_tick[j]; 
0776:  BCF    FD8.0
0778:  RLCF   xBC,W
077A:  CLRF   03
077C:  ADDLW  94
077E:  MOVWF  01
0780:  MOVLW  00
0782:  ADDWFC 03,F
0784:  MOVFF  01,BD
0788:  MOVFF  03,BE
.................... 	   	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i+j*2),1); 
078C:  CLRF   xBB
078E:  MOVF   xBB,W
0790:  SUBLW  01
0792:  BNC   07D8
0794:  MOVF   xBB,W
0796:  ADDWF  xBD,W
0798:  MOVWF  xBF
079A:  MOVLW  00
079C:  ADDWFC xBE,W
079E:  MOVWF  xC0
07A0:  BCF    FD8.0
07A2:  RLCF   xBC,W
07A4:  ADDWF  xBB,W
07A6:  MOVWF  xC1
07A8:  MOVFF  FF2,C2
07AC:  BCF    FF2.7
07AE:  MOVFF  C1,FA9
07B2:  BCF    FA6.6
07B4:  BCF    FA6.7
07B6:  BSF    FA6.0
07B8:  MOVF   FA8,W
07BA:  BTFSC  xC2.7
07BC:  BSF    FF2.7
07BE:  MOVWF  xC1
07C0:  MOVFF  C0,FEA
07C4:  MOVFF  BF,FE9
07C8:  MOVFF  C1,C9
07CC:  CLRF   xCB
07CE:  MOVLW  01
07D0:  MOVWF  xCA
07D2:  RCALL  0660
07D4:  INCF   xBB,F
07D6:  BRA    078E
....................    		if (act_full_stroke_tick[j] > MAX_FULL_STROKE) act_full_stroke_tick[j] = MAX_FULL_STROKE; 
07D8:  BCF    FD8.0
07DA:  RLCF   xBC,W
07DC:  CLRF   03
07DE:  ADDLW  94
07E0:  MOVWF  FE9
07E2:  MOVLW  00
07E4:  ADDWFC 03,W
07E6:  MOVWF  FEA
07E8:  MOVFF  FEC,C0
07EC:  MOVF   FED,F
07EE:  MOVFF  FEF,BF
07F2:  MOVF   xC0,W
07F4:  SUBLW  16
07F6:  BC    081C
07F8:  XORLW  FF
07FA:  BNZ   0802
07FC:  MOVF   xBF,W
07FE:  SUBLW  70
0800:  BC    081C
0802:  BCF    FD8.0
0804:  RLCF   xBC,W
0806:  CLRF   03
0808:  ADDLW  94
080A:  MOVWF  FE9
080C:  MOVLW  00
080E:  ADDWFC 03,W
0810:  MOVWF  FEA
0812:  MOVLW  17
0814:  MOVWF  FEC
0816:  MOVF   FED,F
0818:  MOVLW  70
081A:  MOVWF  FEF
....................    		temp_mem= &current_act_position[j]; 
081C:  BCF    FD8.0
081E:  RLCF   xBC,W
0820:  CLRF   03
0822:  ADDLW  8A
0824:  MOVWF  01
0826:  MOVLW  00
0828:  ADDWFC 03,F
082A:  MOVFF  01,BD
082E:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2),1); 
0832:  CLRF   xBB
0834:  MOVF   xBB,W
0836:  SUBLW  01
0838:  BNC   0882
083A:  MOVF   xBB,W
083C:  ADDWF  xBD,W
083E:  MOVWF  xBF
0840:  MOVLW  00
0842:  ADDWFC xBE,W
0844:  MOVWF  xC0
0846:  MOVLW  10
0848:  ADDWF  xBB,W
084A:  MOVWF  xC1
084C:  BCF    FD8.0
084E:  RLCF   xBC,W
0850:  ADDWF  xC1,F
0852:  MOVFF  FF2,C2
0856:  BCF    FF2.7
0858:  MOVFF  C1,FA9
085C:  BCF    FA6.6
085E:  BCF    FA6.7
0860:  BSF    FA6.0
0862:  MOVF   FA8,W
0864:  BTFSC  xC2.7
0866:  BSF    FF2.7
0868:  MOVWF  xC1
086A:  MOVFF  C0,FEA
086E:  MOVFF  BF,FE9
0872:  MOVFF  C1,C9
0876:  CLRF   xCB
0878:  MOVLW  01
087A:  MOVWF  xCA
087C:  RCALL  0660
087E:  INCF   xBB,F
0880:  BRA    0834
....................    		if (current_act_position[j] > act_full_stroke_tick[j]) current_act_position[j] = act_full_stroke_tick[j]; 
0882:  BCF    FD8.0
0884:  RLCF   xBC,W
0886:  CLRF   03
0888:  ADDLW  8A
088A:  MOVWF  FE9
088C:  MOVLW  00
088E:  ADDWFC 03,W
0890:  MOVWF  FEA
0892:  MOVFF  FEC,C0
0896:  MOVF   FED,F
0898:  MOVFF  FEF,BF
089C:  BCF    FD8.0
089E:  RLCF   xBC,W
08A0:  CLRF   03
08A2:  ADDLW  94
08A4:  MOVWF  FE9
08A6:  MOVLW  00
08A8:  ADDWFC 03,W
08AA:  MOVWF  FEA
08AC:  MOVFF  FEC,03
08B0:  MOVF   FED,F
08B2:  MOVFF  FEF,01
08B6:  MOVF   03,W
08B8:  SUBWF  xC0,W
08BA:  BNC   0902
08BC:  BNZ   08C4
08BE:  MOVF   xBF,W
08C0:  SUBWF  01,W
08C2:  BC    0902
08C4:  BCF    FD8.0
08C6:  RLCF   xBC,W
08C8:  CLRF   03
08CA:  ADDLW  8A
08CC:  MOVWF  01
08CE:  MOVLW  00
08D0:  ADDWFC 03,F
08D2:  MOVFF  03,C0
08D6:  BCF    FD8.0
08D8:  RLCF   xBC,W
08DA:  CLRF   03
08DC:  ADDLW  94
08DE:  MOVWF  FE9
08E0:  MOVLW  00
08E2:  ADDWFC 03,W
08E4:  MOVWF  FEA
08E6:  MOVFF  FEC,03
08EA:  MOVF   FED,F
08EC:  MOVFF  FEF,C1
08F0:  MOVFF  C0,FEA
08F4:  MOVFF  01,FE9
08F8:  MOVFF  03,FEC
08FC:  MOVF   FED,F
08FE:  MOVFF  C1,FEF
....................    		temp_mem= &act_min_stroke[j]; 
0902:  BCF    FD8.0
0904:  RLCF   xBC,W
0906:  CLRF   03
0908:  ADDLW  A4
090A:  MOVWF  01
090C:  MOVLW  00
090E:  ADDWFC 03,F
0910:  MOVFF  01,BD
0914:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_ACT_MIN_LEN+i+j*2),1); 
0918:  CLRF   xBB
091A:  MOVF   xBB,W
091C:  SUBLW  01
091E:  BNC   0968
0920:  MOVF   xBB,W
0922:  ADDWF  xBD,W
0924:  MOVWF  xBF
0926:  MOVLW  00
0928:  ADDWFC xBE,W
092A:  MOVWF  xC0
092C:  MOVLW  60
092E:  ADDWF  xBB,W
0930:  MOVWF  xC1
0932:  BCF    FD8.0
0934:  RLCF   xBC,W
0936:  ADDWF  xC1,F
0938:  MOVFF  FF2,C2
093C:  BCF    FF2.7
093E:  MOVFF  C1,FA9
0942:  BCF    FA6.6
0944:  BCF    FA6.7
0946:  BSF    FA6.0
0948:  MOVF   FA8,W
094A:  BTFSC  xC2.7
094C:  BSF    FF2.7
094E:  MOVWF  xC1
0950:  MOVFF  C0,FEA
0954:  MOVFF  BF,FE9
0958:  MOVFF  C1,C9
095C:  CLRF   xCB
095E:  MOVLW  01
0960:  MOVWF  xCA
0962:  RCALL  0660
0964:  INCF   xBB,F
0966:  BRA    091A
....................    		temp_mem= &act_max_stroke[j]; 
0968:  BCF    FD8.0
096A:  RLCF   xBC,W
096C:  CLRF   03
096E:  ADDLW  9C
0970:  MOVWF  01
0972:  MOVLW  00
0974:  ADDWFC 03,F
0976:  MOVFF  01,BD
097A:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_ACT_MAX_LEN+i+j*2),1); 
097E:  CLRF   xBB
0980:  MOVF   xBB,W
0982:  SUBLW  01
0984:  BNC   09CE
0986:  MOVF   xBB,W
0988:  ADDWF  xBD,W
098A:  MOVWF  xBF
098C:  MOVLW  00
098E:  ADDWFC xBE,W
0990:  MOVWF  xC0
0992:  MOVLW  70
0994:  ADDWF  xBB,W
0996:  MOVWF  xC1
0998:  BCF    FD8.0
099A:  RLCF   xBC,W
099C:  ADDWF  xC1,F
099E:  MOVFF  FF2,C2
09A2:  BCF    FF2.7
09A4:  MOVFF  C1,FA9
09A8:  BCF    FA6.6
09AA:  BCF    FA6.7
09AC:  BSF    FA6.0
09AE:  MOVF   FA8,W
09B0:  BTFSC  xC2.7
09B2:  BSF    FF2.7
09B4:  MOVWF  xC1
09B6:  MOVFF  C0,FEA
09BA:  MOVFF  BF,FE9
09BE:  MOVFF  C1,C9
09C2:  CLRF   xCB
09C4:  MOVLW  01
09C6:  MOVWF  xCA
09C8:  RCALL  0660
09CA:  INCF   xBB,F
09CC:  BRA    0980
....................  
....................    } 
09CE:  INCF   xBC,F
09D0:  BRA    076E
....................  
....................  
.................... } 
09D2:  GOTO   2B32 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i,j; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0A3C:  CLRF   xC0
0A3E:  MOVF   xC0,W
0A40:  SUBLW  03
0A42:  BNC   0AA4
0A44:  MOVLW  20
0A46:  ADDWF  xC0,W
0A48:  MOVWF  xC2
0A4A:  MOVF   xC0,W
0A4C:  MULLW  08
0A4E:  MOVFF  FF3,C3
0A52:  MOVFF  25,C7
0A56:  MOVFF  24,C6
0A5A:  MOVFF  23,C5
0A5E:  MOVFF  22,C4
0A62:  MOVF   xC3,F
0A64:  BZ    0A74
0A66:  BCF    FD8.0
0A68:  RRCF   xC7,F
0A6A:  RRCF   xC6,F
0A6C:  RRCF   xC5,F
0A6E:  RRCF   xC4,F
0A70:  DECFSZ xC3,F
0A72:  BRA    0A66
0A74:  MOVFF  C2,FA9
0A78:  MOVFF  C4,FA8
0A7C:  BCF    FA6.6
0A7E:  BCF    FA6.7
0A80:  BSF    FA6.2
0A82:  MOVFF  FF2,00
0A86:  BCF    FF2.7
0A88:  MOVLB  F
0A8A:  MOVLW  55
0A8C:  MOVWF  FA7
0A8E:  MOVLW  AA
0A90:  MOVWF  FA7
0A92:  BSF    FA6.1
0A94:  BTFSC  FA6.1
0A96:  BRA    0A94
0A98:  BCF    FA6.2
0A9A:  MOVF   00,W
0A9C:  IORWF  FF2,F
0A9E:  MOVLB  0
0AA0:  INCF   xC0,F
0AA2:  BRA    0A3E
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i+4,nDay>>(i*8)); 
0AA4:  CLRF   xC0
0AA6:  MOVF   xC0,W
0AA8:  SUBLW  03
0AAA:  BNC   0B0E
0AAC:  MOVLW  20
0AAE:  ADDWF  xC0,W
0AB0:  ADDLW  04
0AB2:  MOVWF  xC2
0AB4:  MOVF   xC0,W
0AB6:  MULLW  08
0AB8:  MOVFF  FF3,C3
0ABC:  MOVFF  31,C7
0AC0:  MOVFF  30,C6
0AC4:  MOVFF  2F,C5
0AC8:  MOVFF  2E,C4
0ACC:  MOVF   xC3,F
0ACE:  BZ    0ADE
0AD0:  BCF    FD8.0
0AD2:  RRCF   xC7,F
0AD4:  RRCF   xC6,F
0AD6:  RRCF   xC5,F
0AD8:  RRCF   xC4,F
0ADA:  DECFSZ xC3,F
0ADC:  BRA    0AD0
0ADE:  MOVFF  C2,FA9
0AE2:  MOVFF  C4,FA8
0AE6:  BCF    FA6.6
0AE8:  BCF    FA6.7
0AEA:  BSF    FA6.2
0AEC:  MOVFF  FF2,00
0AF0:  BCF    FF2.7
0AF2:  MOVLB  F
0AF4:  MOVLW  55
0AF6:  MOVWF  FA7
0AF8:  MOVLW  AA
0AFA:  MOVWF  FA7
0AFC:  BSF    FA6.1
0AFE:  BTFSC  FA6.1
0B00:  BRA    0AFE
0B02:  BCF    FA6.2
0B04:  MOVF   00,W
0B06:  IORWF  FF2,F
0B08:  MOVLB  0
0B0A:  INCF   xC0,F
0B0C:  BRA    0AA6
....................  
....................    for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2,current_act_position[j]>>(i*8)); 
0B0E:  CLRF   xC1
0B10:  MOVF   xC1,W
0B12:  SUBLW  03
0B14:  BNC   0B8E
0B16:  CLRF   xC0
0B18:  MOVF   xC0,W
0B1A:  SUBLW  01
0B1C:  BNC   0B8A
0B1E:  MOVLW  10
0B20:  ADDWF  xC0,W
0B22:  MOVWF  xC2
0B24:  BCF    FD8.0
0B26:  RLCF   xC1,W
0B28:  ADDWF  xC2,F
0B2A:  BCF    FD8.0
0B2C:  RLCF   xC1,W
0B2E:  CLRF   03
0B30:  ADDLW  8A
0B32:  MOVWF  FE9
0B34:  MOVLW  00
0B36:  ADDWFC 03,W
0B38:  MOVWF  FEA
0B3A:  MOVFF  FEC,C4
0B3E:  MOVF   FED,F
0B40:  MOVFF  FEF,C3
0B44:  MOVF   xC0,W
0B46:  MULLW  08
0B48:  MOVFF  FF3,00
0B4C:  MOVF   00,F
0B4E:  BZ    0B5A
0B50:  BCF    FD8.0
0B52:  RRCF   xC4,F
0B54:  RRCF   xC3,F
0B56:  DECFSZ 00,F
0B58:  BRA    0B50
0B5A:  MOVFF  C2,FA9
0B5E:  MOVFF  C3,FA8
0B62:  BCF    FA6.6
0B64:  BCF    FA6.7
0B66:  BSF    FA6.2
0B68:  MOVFF  FF2,00
0B6C:  BCF    FF2.7
0B6E:  MOVLB  F
0B70:  MOVLW  55
0B72:  MOVWF  FA7
0B74:  MOVLW  AA
0B76:  MOVWF  FA7
0B78:  BSF    FA6.1
0B7A:  BTFSC  FA6.1
0B7C:  BRA    0B7A
0B7E:  BCF    FA6.2
0B80:  MOVF   00,W
0B82:  IORWF  FF2,F
0B84:  MOVLB  0
0B86:  INCF   xC0,F
0B88:  BRA    0B18
0B8A:  INCF   xC1,F
0B8C:  BRA    0B10
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
0B8E:  CLRF   xC0
0B90:  MOVF   xC0,W
0B92:  SUBLW  01
0B94:  BNC   0BEA
0B96:  MOVLW  30
0B98:  ADDWF  xC0,W
0B9A:  MOVWF  xC2
0B9C:  MOVF   xC0,W
0B9E:  MULLW  08
0BA0:  MOVFF  FF3,00
0BA4:  MOVFF  33,C4
0BA8:  MOVFF  32,C3
0BAC:  MOVF   00,F
0BAE:  BZ    0BBA
0BB0:  BCF    FD8.0
0BB2:  RRCF   xC4,F
0BB4:  RRCF   xC3,F
0BB6:  DECFSZ 00,F
0BB8:  BRA    0BB0
0BBA:  MOVFF  C2,FA9
0BBE:  MOVFF  C3,FA8
0BC2:  BCF    FA6.6
0BC4:  BCF    FA6.7
0BC6:  BSF    FA6.2
0BC8:  MOVFF  FF2,00
0BCC:  BCF    FF2.7
0BCE:  MOVLB  F
0BD0:  MOVLW  55
0BD2:  MOVWF  FA7
0BD4:  MOVLW  AA
0BD6:  MOVWF  FA7
0BD8:  BSF    FA6.1
0BDA:  BTFSC  FA6.1
0BDC:  BRA    0BDA
0BDE:  BCF    FA6.2
0BE0:  MOVF   00,W
0BE2:  IORWF  FF2,F
0BE4:  MOVLB  0
0BE6:  INCF   xC0,F
0BE8:  BRA    0B90
....................    if (write_cal ==1) { 
0BEA:  DECFSZ xBF,W
0BEC:  BRA    0D6A
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i+j*2,act_full_stroke_tick[j]>>(i*8)); 
0BEE:  CLRF   xC1
0BF0:  MOVF   xC1,W
0BF2:  SUBLW  03
0BF4:  BNC   0C6A
0BF6:  CLRF   xC0
0BF8:  MOVF   xC0,W
0BFA:  SUBLW  01
0BFC:  BNC   0C66
0BFE:  BCF    FD8.0
0C00:  RLCF   xC1,W
0C02:  ADDWF  xC0,W
0C04:  MOVWF  xC2
0C06:  BCF    FD8.0
0C08:  RLCF   xC1,W
0C0A:  CLRF   03
0C0C:  ADDLW  94
0C0E:  MOVWF  FE9
0C10:  MOVLW  00
0C12:  ADDWFC 03,W
0C14:  MOVWF  FEA
0C16:  MOVFF  FEC,C4
0C1A:  MOVF   FED,F
0C1C:  MOVFF  FEF,C3
0C20:  MOVF   xC0,W
0C22:  MULLW  08
0C24:  MOVFF  FF3,00
0C28:  MOVF   00,F
0C2A:  BZ    0C36
0C2C:  BCF    FD8.0
0C2E:  RRCF   xC4,F
0C30:  RRCF   xC3,F
0C32:  DECFSZ 00,F
0C34:  BRA    0C2C
0C36:  MOVFF  C2,FA9
0C3A:  MOVFF  C3,FA8
0C3E:  BCF    FA6.6
0C40:  BCF    FA6.7
0C42:  BSF    FA6.2
0C44:  MOVFF  FF2,00
0C48:  BCF    FF2.7
0C4A:  MOVLB  F
0C4C:  MOVLW  55
0C4E:  MOVWF  FA7
0C50:  MOVLW  AA
0C52:  MOVWF  FA7
0C54:  BSF    FA6.1
0C56:  BTFSC  FA6.1
0C58:  BRA    0C56
0C5A:  BCF    FA6.2
0C5C:  MOVF   00,W
0C5E:  IORWF  FF2,F
0C60:  MOVLB  0
0C62:  INCF   xC0,F
0C64:  BRA    0BF8
0C66:  INCF   xC1,F
0C68:  BRA    0BF0
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_ACT_MIN_LEN+i+j*2,act_min_stroke[j]>>(i*8)); 
0C6A:  CLRF   xC1
0C6C:  MOVF   xC1,W
0C6E:  SUBLW  03
0C70:  BNC   0CEA
0C72:  CLRF   xC0
0C74:  MOVF   xC0,W
0C76:  SUBLW  01
0C78:  BNC   0CE6
0C7A:  MOVLW  60
0C7C:  ADDWF  xC0,W
0C7E:  MOVWF  xC2
0C80:  BCF    FD8.0
0C82:  RLCF   xC1,W
0C84:  ADDWF  xC2,F
0C86:  BCF    FD8.0
0C88:  RLCF   xC1,W
0C8A:  CLRF   03
0C8C:  ADDLW  A4
0C8E:  MOVWF  FE9
0C90:  MOVLW  00
0C92:  ADDWFC 03,W
0C94:  MOVWF  FEA
0C96:  MOVFF  FEC,C4
0C9A:  MOVF   FED,F
0C9C:  MOVFF  FEF,C3
0CA0:  MOVF   xC0,W
0CA2:  MULLW  08
0CA4:  MOVFF  FF3,00
0CA8:  MOVF   00,F
0CAA:  BZ    0CB6
0CAC:  BCF    FD8.0
0CAE:  RRCF   xC4,F
0CB0:  RRCF   xC3,F
0CB2:  DECFSZ 00,F
0CB4:  BRA    0CAC
0CB6:  MOVFF  C2,FA9
0CBA:  MOVFF  C3,FA8
0CBE:  BCF    FA6.6
0CC0:  BCF    FA6.7
0CC2:  BSF    FA6.2
0CC4:  MOVFF  FF2,00
0CC8:  BCF    FF2.7
0CCA:  MOVLB  F
0CCC:  MOVLW  55
0CCE:  MOVWF  FA7
0CD0:  MOVLW  AA
0CD2:  MOVWF  FA7
0CD4:  BSF    FA6.1
0CD6:  BTFSC  FA6.1
0CD8:  BRA    0CD6
0CDA:  BCF    FA6.2
0CDC:  MOVF   00,W
0CDE:  IORWF  FF2,F
0CE0:  MOVLB  0
0CE2:  INCF   xC0,F
0CE4:  BRA    0C74
0CE6:  INCF   xC1,F
0CE8:  BRA    0C6C
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_ACT_MAX_LEN+i+j*2,act_max_stroke[j]>>(i*8)); 
0CEA:  CLRF   xC1
0CEC:  MOVF   xC1,W
0CEE:  SUBLW  03
0CF0:  BNC   0D6A
0CF2:  CLRF   xC0
0CF4:  MOVF   xC0,W
0CF6:  SUBLW  01
0CF8:  BNC   0D66
0CFA:  MOVLW  70
0CFC:  ADDWF  xC0,W
0CFE:  MOVWF  xC2
0D00:  BCF    FD8.0
0D02:  RLCF   xC1,W
0D04:  ADDWF  xC2,F
0D06:  BCF    FD8.0
0D08:  RLCF   xC1,W
0D0A:  CLRF   03
0D0C:  ADDLW  9C
0D0E:  MOVWF  FE9
0D10:  MOVLW  00
0D12:  ADDWFC 03,W
0D14:  MOVWF  FEA
0D16:  MOVFF  FEC,C4
0D1A:  MOVF   FED,F
0D1C:  MOVFF  FEF,C3
0D20:  MOVF   xC0,W
0D22:  MULLW  08
0D24:  MOVFF  FF3,00
0D28:  MOVF   00,F
0D2A:  BZ    0D36
0D2C:  BCF    FD8.0
0D2E:  RRCF   xC4,F
0D30:  RRCF   xC3,F
0D32:  DECFSZ 00,F
0D34:  BRA    0D2C
0D36:  MOVFF  C2,FA9
0D3A:  MOVFF  C3,FA8
0D3E:  BCF    FA6.6
0D40:  BCF    FA6.7
0D42:  BSF    FA6.2
0D44:  MOVFF  FF2,00
0D48:  BCF    FF2.7
0D4A:  MOVLB  F
0D4C:  MOVLW  55
0D4E:  MOVWF  FA7
0D50:  MOVLW  AA
0D52:  MOVWF  FA7
0D54:  BSF    FA6.1
0D56:  BTFSC  FA6.1
0D58:  BRA    0D56
0D5A:  BCF    FA6.2
0D5C:  MOVF   00,W
0D5E:  IORWF  FF2,F
0D60:  MOVLB  0
0D62:  INCF   xC0,F
0D64:  BRA    0CF4
0D66:  INCF   xC1,F
0D68:  BRA    0CEC
....................    } 
....................  
.................... } 
0D6A:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////// 
.................... void button_scan() { 
....................    int8 i; 
....................     flag2.button_pressed=0; 
*
01A0:  BCF    20.1
....................    for(i=0;i<6;i++) { 
01A2:  CLRF   xE2
01A4:  MOVF   xE2,W
01A6:  SUBLW  05
01A8:  BNC   01E0
....................       portd.data_bus=i; 
01AA:  MOVF   xE2,W
01AC:  ANDLW  0F
01AE:  MOVWF  00
01B0:  MOVLW  F0
01B2:  ANDWF  F83,W
01B4:  IORWF  00,W
01B6:  MOVWF  F83
....................       portd.MUX_en =0; 
01B8:  BCF    F83.6
....................       delay_cycles(20); 
01BA:  MOVLW  06
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  NOP   
....................       if (!input(PIN_E0)) { 
01C4:  BSF    F96.0
01C6:  BTFSC  F84.0
01C8:  BRA    01D0
....................          flag2.button_pressed=1; 
01CA:  BSF    20.1
....................          nButton=i; 
01CC:  MOVFF  E2,4B
....................       }  
....................       delay_cycles(20); 
01D0:  MOVLW  06
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  NOP   
....................       portd.MUX_en =1; 
01DA:  BSF    F83.6
....................    } 
01DC:  INCF   xE2,F
01DE:  BRA    01A4
....................    restart_wdt(); 
01E0:  CLRWDT
.................... } 
01E2:  RETLW  00
....................  
....................  
.................... ////////////////////////////////// 
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       //set_timer1(get_timer1()+0x7FB8); 
....................      #asm 
....................       MOVLW 0x00; 
01E4:  MOVLW  00
....................       MOVWF TMR1; 
01E6:  MOVWF  FCE
....................       MOVLW 0x80; 
01E8:  MOVLW  80
....................       MOVWF TMR1H; 
01EA:  MOVWF  FCF
....................      #endasm 
....................       timer_sec+=1;  
01EC:  MOVLW  01
01EE:  ADDWF  22,F
01F0:  MOVLW  00
01F2:  ADDWFC 23,F
01F4:  ADDWFC 24,F
01F6:  ADDWFC 25,F
....................      last_command +=1; 
01F8:  MOVLW  01
01FA:  ADDWF  4C,F
01FC:  MOVLW  00
01FE:  ADDWFC 4D,F
0200:  ADDWFC 4E,F
0202:  ADDWFC 4F,F
....................       if (timer_sec>=86400) { 
0204:  MOVF   25,F
0206:  BNZ   0222
0208:  MOVF   24,W
020A:  SUBLW  00
020C:  BC    0268
020E:  XORLW  FF
0210:  BNZ   0222
0212:  MOVF   23,W
0214:  SUBLW  50
0216:  BC    0268
0218:  XORLW  FF
021A:  BNZ   0222
021C:  MOVF   22,W
021E:  SUBLW  7F
0220:  BC    0268
....................       nDay = (nDay%1461)+1; 
0222:  MOVFF  31,E5
0226:  MOVFF  30,E4
022A:  MOVFF  2F,E3
022E:  MOVFF  2E,E2
0232:  CLRF   xE9
0234:  CLRF   xE8
0236:  MOVLW  05
0238:  MOVWF  xE7
023A:  MOVLW  B5
023C:  MOVWF  xE6
023E:  RCALL  00AA
0240:  MOVFF  FEF,E2
0244:  MOVFF  FEC,E3
0248:  MOVFF  FEC,E4
024C:  MOVFF  FEC,E5
0250:  MOVLW  01
0252:  ADDWF  xE2,W
0254:  MOVWF  2E
0256:  MOVLW  00
0258:  ADDWFC xE3,W
025A:  MOVWF  2F
025C:  MOVLW  00
025E:  ADDWFC xE4,W
0260:  MOVWF  30
0262:  MOVLW  00
0264:  ADDWFC xE5,W
0266:  MOVWF  31
....................      } 
....................      timer_sec = timer_sec % 86400; 
0268:  MOVFF  25,E5
026C:  MOVFF  24,E4
0270:  MOVFF  23,E3
0274:  MOVFF  22,E2
0278:  CLRF   xE9
027A:  MOVLW  01
027C:  MOVWF  xE8
027E:  MOVLW  51
0280:  MOVWF  xE7
0282:  MOVLW  80
0284:  MOVWF  xE6
0286:  RCALL  00AA
0288:  MOVFF  FEF,22
028C:  MOVFF  FEC,23
0290:  MOVFF  FEC,24
0294:  MOVFF  FEC,25
....................      if (last_command > 180)// if no command recv in 3 minutes, reset the RS232 
0298:  MOVF   4F,F
029A:  BNZ   02AA
029C:  MOVF   4E,F
029E:  BNZ   02AA
02A0:  MOVF   4D,F
02A2:  BNZ   02AA
02A4:  MOVF   4C,W
02A6:  SUBLW  B4
02A8:  BC    02B6
....................      {    init_rs232(); 
02AA:  RCALL  0124
....................        last_command =0; 
02AC:  CLRF   4F
02AE:  CLRF   4E
02B0:  CLRF   4D
02B2:  CLRF   4C
....................        cmd_len =0; 
02B4:  CLRF   4A
....................       }    
....................  
....................      if ((read_adc()+read_adc()+read_adc()+read_adc())/4<600) { 
02B6:  BSF    FC2.2
02B8:  BTFSC  FC2.2
02BA:  BRA    02B8
02BC:  MOVFF  FC4,03
02C0:  MOVFF  FC3,E2
02C4:  MOVFF  FC4,E3
02C8:  BSF    FC2.2
02CA:  BTFSC  FC2.2
02CC:  BRA    02CA
02CE:  MOVFF  FC4,03
02D2:  MOVF   FC3,W
02D4:  ADDWF  xE2,F
02D6:  MOVF   FC4,W
02D8:  ADDWFC xE3,F
02DA:  BSF    FC2.2
02DC:  BTFSC  FC2.2
02DE:  BRA    02DC
02E0:  MOVFF  FC4,03
02E4:  MOVF   FC3,W
02E6:  ADDWF  xE2,F
02E8:  MOVF   FC4,W
02EA:  ADDWFC xE3,F
02EC:  BSF    FC2.2
02EE:  BTFSC  FC2.2
02F0:  BRA    02EE
02F2:  MOVFF  FC4,03
02F6:  MOVF   FC3,W
02F8:  ADDWF  xE2,F
02FA:  MOVF   FC4,W
02FC:  ADDWFC xE3,F
02FE:  RRCF   xE3,F
0300:  RRCF   xE2,F
0302:  RRCF   xE3,F
0304:  RRCF   xE2,F
0306:  MOVLW  3F
0308:  ANDWF  xE3,F
030A:  MOVF   xE3,W
030C:  SUBLW  02
030E:  BNC   0336
0310:  BNZ   0318
0312:  MOVF   xE2,W
0314:  SUBLW  57
0316:  BNC   0336
....................        if (flag2.is_moving) flag2.abort_current_activity=1; 
0318:  BTFSC  20.6
031A:  BSF    20.2
....................        flag2.power = 0; 
031C:  BCF    20.5
....................        disable_interrupts(INT_RDA); 
031E:  BCF    F9D.5
....................        led_status =0xFE; 
0320:  MOVLW  FE
0322:  MOVWF  21
....................        display_LED(); 
0324:  RCALL  0144
....................        delay_ms(10); 
0326:  MOVLW  0A
0328:  MOVWF  xE2
032A:  RCALL  0178
....................        led_status =0xFF; 
032C:  MOVLW  FF
032E:  MOVWF  21
....................        display_LED(); 
0330:  RCALL  0144
....................          return; 
0332:  BRA    043A
....................      } else { 
0334:  BRA    0340
....................        if (flag2.power==0) { 
0336:  BTFSC  20.5
0338:  BRA    033E
....................          enable_interrupts(INT_RDA); 
033A:  BSF    F9D.5
....................          init_rs232(); 
033C:  RCALL  0124
....................        } 
....................        flag2.power=1; 
033E:  BSF    20.5
....................      } 
....................  
....................       flag.update_time = true; 
0340:  BSF    1F.1
....................       if (flag2.en_operate == 1) { 
0342:  BTFSS  20.0
0344:  BRA    0432
....................         led_status.power = !led_status.power; // blink power led 
0346:  BTG    21.0
....................       // display morning, noon, evening 
....................        if(timer_sec >64800 || timer_sec <21600) { 
0348:  MOVF   25,F
034A:  BNZ   0376
034C:  MOVF   24,F
034E:  BNZ   0376
0350:  MOVF   23,W
0352:  SUBLW  FC
0354:  BC    0360
0356:  XORLW  FF
0358:  BNZ   0376
035A:  MOVF   22,W
035C:  SUBLW  20
035E:  BNC   0376
0360:  MOVF   25,F
0362:  BNZ   0380
0364:  MOVF   24,F
0366:  BNZ   0380
0368:  MOVF   23,W
036A:  SUBLW  54
036C:  BNC   0380
036E:  BNZ   0376
0370:  MOVF   22,W
0372:  SUBLW  5F
0374:  BNC   0380
....................          led_status.aux=3; 
0376:  MOVLW  F3
0378:  ANDWF  21,W
037A:  IORLW  0C
037C:  MOVWF  21
....................       } else if ( timer_sec < 36000 ) { 
037E:  BRA    03C6
0380:  MOVF   25,F
0382:  BNZ   03A0
0384:  MOVF   24,F
0386:  BNZ   03A0
0388:  MOVF   23,W
038A:  SUBLW  8C
038C:  BNC   03A0
038E:  BNZ   0396
0390:  MOVF   22,W
0392:  SUBLW  9F
0394:  BNC   03A0
....................          led_status.aux=2; 
0396:  MOVLW  F3
0398:  ANDWF  21,W
039A:  IORLW  08
039C:  MOVWF  21
....................       } else if ( timer_sec < 50400) { 
039E:  BRA    03C6
03A0:  MOVF   25,F
03A2:  BNZ   03BE
03A4:  MOVF   24,F
03A6:  BNZ   03BE
03A8:  MOVF   23,W
03AA:  SUBLW  C4
03AC:  BNC   03BE
03AE:  BNZ   03B6
03B0:  MOVF   22,W
03B2:  SUBLW  DF
03B4:  BNC   03BE
....................          led_status.aux=0; 
03B6:  MOVLW  F3
03B8:  ANDWF  21,W
03BA:  MOVWF  21
....................       } else { 
03BC:  BRA    03C6
....................          led_status.aux=1; 
03BE:  MOVLW  F3
03C0:  ANDWF  21,W
03C2:  IORLW  04
03C4:  MOVWF  21
....................       } 
....................  
....................         display_LED(); 
03C6:  RCALL  0144
....................         switch ((unsigned int16) (timer_sec % 450)) { 
03C8:  MOVFF  25,E5
03CC:  MOVFF  24,E4
03D0:  MOVFF  23,E3
03D4:  MOVFF  22,E2
03D8:  CLRF   xE9
03DA:  CLRF   xE8
03DC:  MOVLW  01
03DE:  MOVWF  xE7
03E0:  MOVLW  C2
03E2:  MOVWF  xE6
03E4:  RCALL  00AA
03E6:  MOVFF  FEF,00
03EA:  MOVFF  FEC,01
03EE:  MOVFF  FEC,02
03F2:  MOVFF  FEC,03
03F6:  MOVF   01,W
03F8:  MOVWF  03
03FA:  BNZ   0400
03FC:  MOVF   00,F
03FE:  BZ    0422
0400:  MOVF   03,W
0402:  BNZ   040A
0404:  MOVLW  6E
0406:  SUBWF  00,W
0408:  BZ    0426
040A:  MOVF   03,W
040C:  BNZ   0414
040E:  MOVLW  DC
0410:  SUBWF  00,W
0412:  BZ    042A
0414:  MOVLW  01
0416:  SUBWF  03,W
0418:  BNZ   0420
041A:  MOVLW  4A
041C:  SUBWF  00,W
041E:  BZ    042E
0420:  BRA    0432
....................          case 0: {   bit_set(actuator_move_mask,0); break;} 
0422:  BSF    xB4.0
0424:  BRA    0432
....................          case 110: {   bit_set(actuator_move_mask,1); break;} 
0426:  BSF    xB4.1
0428:  BRA    0432
....................          case 220: {   bit_set(actuator_move_mask,2); break;} 
042A:  BSF    xB4.2
042C:  BRA    0432
....................          case 330: {   bit_set(actuator_move_mask,3); break;} 
042E:  BSF    xB4.3
0430:  BRA    0432
....................         } 
....................      } 
....................      button_scan(); 
0432:  RCALL  01A0
....................      if (nButton == 0) flag2.abort_current_activity=1; 
0434:  MOVF   4B,F
0436:  BTFSC  FD8.2
0438:  BSF    20.2
....................  
.................... } 
....................  
043A:  BCF    F9E.0
043C:  GOTO   0064
.................... void init_spi() { 
....................    setup_spi(spi_master |spi_h_to_l | spi_clk_div_16 ); 
*
0596:  BCF    FC6.5
0598:  BCF    F94.5
059A:  BSF    F94.4
059C:  BCF    F94.3
059E:  MOVLW  31
05A0:  MOVWF  FC6
05A2:  MOVLW  40
05A4:  MOVWF  FC7
....................     SSPSTAT = 0xC0; 
05A6:  MOVLW  C0
05A8:  MOVWF  FC7
.................... } 
05AA:  GOTO   2A1E (RETURN)
....................  
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................    int8 i; 
....................    int8 checksum =0x00; 
*
04DC:  CLRF   xE4
....................    int16 msg_addr; 
....................  
....................    c=getc(); 
04DE:  BTFSS  F9E.5
04E0:  BRA    04DE
04E2:  MOVFF  FAE,E2
....................    switch (c) {    
04E6:  MOVF   xE2,W
04E8:  XORLW  A8
04EA:  BZ    04F2
04EC:  XORLW  01
04EE:  BZ    0562
04F0:  BRA    0568
....................     case(0xA8):{ if(cmd_len>=4) { 
04F2:  MOVF   4A,W
04F4:  SUBLW  03
04F6:  BC    055E
....................                   for(i=0;i<cmd_len;i++) 
04F8:  CLRF   xE3
04FA:  MOVF   4A,W
04FC:  SUBWF  xE3,W
04FE:  BC    0516
....................                   { 
....................                   checksum ^= cmd_msg[i]; 
0500:  CLRF   03
0502:  MOVF   xE3,W
0504:  ADDLW  36
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVF   FEF,W
0510:  XORWF  xE4,F
....................                   } 
0512:  INCF   xE3,F
0514:  BRA    04FA
....................                if (checksum != 0x00) {cmd_len=0; return;} 
0516:  MOVF   xE4,F
0518:  BZ    051E
051A:  CLRF   4A
051C:  BRA    0590
....................                msg_addr = make16(cmd_msg[0],cmd_msg[1]); // address 
051E:  MOVFF  36,E6
0522:  MOVFF  37,E5
....................                if (msg_addr != 0xFFFE && msg_addr != dev_id) {cmd_len=0; return;} // address not correct, just ignore this command 
0526:  MOVF   xE5,W
0528:  SUBLW  FE
052A:  BNZ   0532
052C:  INCFSZ xE6,W
052E:  BRA    0532
0530:  BRA    0542
0532:  MOVF   34,W
0534:  SUBWF  xE5,W
0536:  BNZ   053E
0538:  MOVF   35,W
053A:  SUBWF  xE6,W
053C:  BZ    0542
053E:  CLRF   4A
0540:  BRA    0590
....................                command_byte = cmd_msg[2]; 
0542:  MOVFF  38,51
....................                aux_command = make16(cmd_msg[3],cmd_msg[4]); 
0546:  MOVFF  39,53
054A:  MOVFF  3A,52
....................                if (flag2.is_moving) send_data(7,0); // send BUSY 
054E:  BTFSS  20.6
0550:  BRA    055C
0552:  MOVLW  07
0554:  MOVWF  xE7
0556:  CLRF   xE8
0558:  RCALL  046A
....................                else flag.cmd_posted=true; 
055A:  BRA    055E
055C:  BSF    1F.3
....................                  
....................              }        
....................                 cmd_len =0; 
055E:  CLRF   4A
....................              break;} 
0560:  BRA    0590
....................     case(0xA9): {de_stuffing_mask = 0x20; break;} 
0562:  MOVLW  20
0564:  MOVWF  50
0566:  BRA    0590
....................      default:     {if(cmd_len<=MAX_CMD_LEN) { 
0568:  MOVF   4A,W
056A:  SUBLW  12
056C:  BNC   058C
....................                cmd_msg[cmd_len++]=c|de_stuffing_mask; 
056E:  MOVF   4A,W
0570:  INCF   4A,F
0572:  CLRF   03
0574:  ADDLW  36
0576:  MOVWF  FE9
0578:  MOVLW  00
057A:  ADDWFC 03,W
057C:  MOVWF  FEA
057E:  MOVF   xE2,W
0580:  IORWF  50,W
0582:  MOVWF  FEF
....................                last_command =0;  
0584:  CLRF   4F
0586:  CLRF   4E
0588:  CLRF   4D
058A:  CLRF   4C
....................             } 
....................             de_stuffing_mask = 0x00; 
058C:  CLRF   50
....................             break; } 
058E:  BRA    0590
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
0590:  BCF    F9E.5
0592:  GOTO   0064
.................... void process_cmd_msg() { 
....................    int8 i,j; 
....................     int16 temp_mem; 
....................     flag.cmd_posted =false; 
*
1D5E:  BCF    1F.3
....................     last_command =0;     
1D60:  CLRF   4F
1D62:  CLRF   4E
1D64:  CLRF   4D
1D66:  CLRF   4C
....................     switch(command_byte) { 
1D68:  MOVF   51,W
1D6A:  XORLW  80
1D6C:  BZ    1E02
1D6E:  XORLW  02
1D70:  BZ    1E1E
1D72:  XORLW  01
1D74:  BTFSC  FD8.2
1D76:  BRA    1E4E
1D78:  XORLW  07
1D7A:  BTFSC  FD8.2
1D7C:  BRA    1E7C
1D7E:  XORLW  01
1D80:  BTFSC  FD8.2
1D82:  BRA    1E8E
1D84:  XORLW  0B
1D86:  BTFSC  FD8.2
1D88:  BRA    1EB8
1D8A:  XORLW  01
1D8C:  BTFSC  FD8.2
1D8E:  BRA    1ED4
1D90:  XORLW  BF
1D92:  BTFSC  FD8.2
1D94:  BRA    1F22
1D96:  XORLW  01
1D98:  BTFSC  FD8.2
1D9A:  BRA    1F44
1D9C:  XORLW  03
1D9E:  BTFSC  FD8.2
1DA0:  BRA    1F66
1DA2:  XORLW  12
1DA4:  BTFSC  FD8.2
1DA6:  BRA    1FA6
1DA8:  XORLW  01
1DAA:  BTFSC  FD8.2
1DAC:  BRA    2020
1DAE:  XORLW  03
1DB0:  BTFSC  FD8.2
1DB2:  BRA    2098
1DB4:  XORLW  01
1DB6:  BTFSC  FD8.2
1DB8:  BRA    2210
1DBA:  XORLW  07
1DBC:  BTFSC  FD8.2
1DBE:  BRA    22C8
1DC0:  XORLW  01
1DC2:  BTFSC  FD8.2
1DC4:  BRA    235A
1DC6:  XORLW  03
1DC8:  BTFSC  FD8.2
1DCA:  BRA    23C8
1DCC:  XORLW  01
1DCE:  BTFSC  FD8.2
1DD0:  BRA    23FA
1DD2:  XORLW  0F
1DD4:  BTFSC  FD8.2
1DD6:  BRA    242A
1DD8:  XORLW  38
1DDA:  BTFSC  FD8.2
1DDC:  BRA    245A
1DDE:  XORLW  01
1DE0:  BTFSC  FD8.2
1DE2:  BRA    24A4
1DE4:  XORLW  03
1DE6:  BTFSC  FD8.2
1DE8:  BRA    24DE
1DEA:  XORLW  01
1DEC:  BTFSC  FD8.2
1DEE:  BRA    2500
1DF0:  XORLW  12
1DF2:  BTFSC  FD8.2
1DF4:  BRA    2536
1DF6:  XORLW  03
1DF8:  BTFSC  FD8.2
1DFA:  GOTO   258E
1DFE:  GOTO   25E6
.................... // level 8 is for flash related 
....................       // 0x80 = block erase 
....................       case 0x80: { flash_block_erase();  send_data(0,0); break; } 
1E02:  GOTO   0E42
1E06:  CLRF   18
1E08:  BTFSC  FF2.7
1E0A:  BSF    18.7
1E0C:  BCF    FF2.7
1E0E:  CLRF   xE7
1E10:  CLRF   xE8
1E12:  CALL   046A
1E16:  BTFSC  18.7
1E18:  BSF    FF2.7
1E1A:  GOTO   25E6
....................       // 0x82  = write buffer 1 to flash page 
....................      case 0x82: { disable_interrupts(GLOBAL); 
1E1E:  BCF    FF2.6
1E20:  BCF    FF2.7
1E22:  BTFSC  FF2.7
1E24:  BRA    1E20
....................                   flash_write_buffer1_to_main_memory(aux_command); 
1E26:  MOVFF  53,C0
1E2A:  MOVFF  52,BF
1E2E:  GOTO   0E9C
1E32:  CLRF   18
1E34:  BTFSC  FF2.7
1E36:  BSF    18.7
1E38:  BCF    FF2.7
....................                send_data(0,0); 
1E3A:  CLRF   xE7
1E3C:  CLRF   xE8
1E3E:  CALL   046A
1E42:  BTFSC  18.7
1E44:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL); 
1E46:  MOVLW  C0
1E48:  IORWF  FF2,F
....................                   break;  
1E4A:  GOTO   25E6
....................              } 
....................      // 0x83 = read page to buffer 1 
....................      case 0x83: { 
....................                   disable_interrupts(GLOBAL); 
1E4E:  BCF    FF2.6
1E50:  BCF    FF2.7
1E52:  BTFSC  FF2.7
1E54:  BRA    1E50
....................                   flash_read_main_memory_to_buffer1(aux_command); 
1E56:  MOVFF  53,C0
1E5A:  MOVFF  52,BF
1E5E:  GOTO   0EF0
1E62:  CLRF   18
1E64:  BTFSC  FF2.7
1E66:  BSF    18.7
1E68:  BCF    FF2.7
....................                  send_data(0,0); 
1E6A:  CLRF   xE7
1E6C:  CLRF   xE8
1E6E:  CALL   046A
1E72:  BTFSC  18.7
1E74:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL);    
1E76:  MOVLW  C0
1E78:  IORWF  FF2,F
....................                 break; 
1E7A:  BRA    25E6
....................               }    
....................      // 0x84 = Buffer1 read 
....................      case 0x84: { //buffer1 read 
....................                   disable_interrupts(GLOBAL); 
1E7C:  BCF    FF2.6
1E7E:  BCF    FF2.7
1E80:  BTFSC  FF2.7
1E82:  BRA    1E7E
....................                 send_buffer1_content(); 
1E84:  GOTO   0F3A
....................                   enable_interrupts(GLOBAL);          
1E88:  MOVLW  C0
1E8A:  IORWF  FF2,F
....................                   break;   } 
1E8C:  BRA    25E6
....................  
....................      case 0x85: { //test code 
....................                   disable_interrupts(GLOBAL); 
1E8E:  BCF    FF2.6
1E90:  BCF    FF2.7
1E92:  BTFSC  FF2.7
1E94:  BRA    1E90
....................                flash_buffer1_write(0,0,255); 
1E96:  CLRF   xBF
1E98:  CLRF   xC0
1E9A:  MOVLW  FF
1E9C:  MOVWF  xC1
1E9E:  CALL   1016
....................                flash_buffer1_write(0x55,0x10,0x08); 
1EA2:  MOVLW  55
1EA4:  MOVWF  xBF
1EA6:  MOVLW  10
1EA8:  MOVWF  xC0
1EAA:  MOVLW  08
1EAC:  MOVWF  xC1
1EAE:  CALL   1016
....................                   enable_interrupts(GLOBAL);          
1EB2:  MOVLW  C0
1EB4:  IORWF  FF2,F
....................                   break;   } 
1EB6:  BRA    25E6
....................  
....................  
....................      // 0x8E = set flash page size = 256 
....................       case 0x8E: {  flash_set_256_page_size(); send_data(6,0); break; } 
1EB8:  GOTO   107A
1EBC:  CLRF   18
1EBE:  BTFSC  FF2.7
1EC0:  BSF    18.7
1EC2:  BCF    FF2.7
1EC4:  MOVLW  06
1EC6:  MOVWF  xE7
1EC8:  CLRF   xE8
1ECA:  CALL   046A
1ECE:  BTFSC  18.7
1ED0:  BSF    FF2.7
1ED2:  BRA    25E6
....................      // 0x8F = flash write page 
....................      case 0x8F: { 
....................                   disable_interrupts(GLOBAL); 
1ED4:  BCF    FF2.6
1ED6:  BCF    FF2.7
1ED8:  BTFSC  FF2.7
1EDA:  BRA    1ED6
....................                 setup_WDT(WDT_OFF); 
1EDC:  BCF    FD1.0
....................                   flash_write_page(aux_command); 
1EDE:  MOVFF  53,C0
1EE2:  MOVFF  52,BF
1EE6:  GOTO   10BC
....................                memcpy(output_buffer,&aux_command,2); 
1EEA:  CLRF   FEA
1EEC:  MOVLW  54
1EEE:  MOVWF  FE9
1EF0:  CLRF   FE2
1EF2:  MOVLW  52
1EF4:  MOVWF  FE1
1EF6:  MOVLW  02
1EF8:  MOVWF  01
1EFA:  MOVFF  FE6,FEE
1EFE:  DECFSZ 01,F
1F00:  BRA    1EFA
1F02:  CLRF   18
1F04:  BTFSC  FF2.7
1F06:  BSF    18.7
1F08:  BCF    FF2.7
....................                 send_data(8,1); 
1F0A:  MOVLW  08
1F0C:  MOVWF  xE7
1F0E:  MOVLW  01
1F10:  MOVWF  xE8
1F12:  CALL   046A
1F16:  BTFSC  18.7
1F18:  BSF    FF2.7
....................                 setup_WDT(WDT_ON); 
1F1A:  BSF    FD1.0
....................                   enable_interrupts(GLOBAL); 
1F1C:  MOVLW  C0
1F1E:  IORWF  FF2,F
....................                   break;}      
1F20:  BRA    25E6
.................... // level 3 = date and time setup 
....................      case 0x30: { // set date 
....................          nDay= aux_command;  send_data(0,0);break;    } 
1F22:  CLRF   31
1F24:  CLRF   30
1F26:  MOVFF  53,2F
1F2A:  MOVFF  52,2E
1F2E:  CLRF   18
1F30:  BTFSC  FF2.7
1F32:  BSF    18.7
1F34:  BCF    FF2.7
1F36:  CLRF   xE7
1F38:  CLRF   xE8
1F3A:  CALL   046A
1F3E:  BTFSC  18.7
1F40:  BSF    FF2.7
1F42:  BRA    25E6
....................      case 0x31: { // set low byte of time 
....................        timer_sec = aux_command; // rouding to 60 sec 
1F44:  CLRF   25
1F46:  CLRF   24
1F48:  MOVFF  53,23
1F4C:  MOVFF  52,22
1F50:  CLRF   18
1F52:  BTFSC  FF2.7
1F54:  BSF    18.7
1F56:  BCF    FF2.7
....................        send_data(0,0); 
1F58:  CLRF   xE7
1F5A:  CLRF   xE8
1F5C:  CALL   046A
1F60:  BTFSC  18.7
1F62:  BSF    FF2.7
....................          break;    } 
1F64:  BRA    25E6
....................      case 0x32: { // set high byte of time 
....................          temp_mem = &timer_sec; 
1F66:  CLRF   xBE
1F68:  MOVLW  22
1F6A:  MOVWF  xBD
....................        memcpy(temp_mem+2,&aux_command,2); 
1F6C:  MOVLW  02
1F6E:  ADDWF  xBD,W
1F70:  MOVWF  xBF
1F72:  MOVLW  00
1F74:  ADDWFC xBE,W
1F76:  MOVWF  xC0
1F78:  MOVWF  FEA
1F7A:  MOVFF  BF,FE9
1F7E:  CLRF   FE2
1F80:  MOVLW  52
1F82:  MOVWF  FE1
1F84:  MOVLW  02
1F86:  MOVWF  01
1F88:  MOVFF  FE6,FEE
1F8C:  DECFSZ 01,F
1F8E:  BRA    1F88
1F90:  CLRF   18
1F92:  BTFSC  FF2.7
1F94:  BSF    18.7
1F96:  BCF    FF2.7
....................        send_data(0,0); 
1F98:  CLRF   xE7
1F9A:  CLRF   xE8
1F9C:  CALL   046A
1FA0:  BTFSC  18.7
1FA2:  BSF    FF2.7
....................          break;    } 
1FA4:  BRA    25E6
.................... // level 2 = actuator control 
....................       // 0x20 = move east 
....................      case 0x20: { if (flag2.is_moving) {send_data(1,0); break;} 
1FA6:  BTFSS  20.6
1FA8:  BRA    1FC2
1FAA:  CLRF   18
1FAC:  BTFSC  FF2.7
1FAE:  BSF    18.7
1FB0:  BCF    FF2.7
1FB2:  MOVLW  01
1FB4:  MOVWF  xE7
1FB6:  CLRF   xE8
1FB8:  CALL   046A
1FBC:  BTFSC  18.7
1FBE:  BSF    FF2.7
1FC0:  BRA    25E6
1FC2:  CLRF   18
1FC4:  BTFSC  FF2.7
1FC6:  BSF    18.7
1FC8:  BCF    FF2.7
....................         send_data(0,0);  
1FCA:  CLRF   xE7
1FCC:  CLRF   xE8
1FCE:  CALL   046A
1FD2:  BTFSC  18.7
1FD4:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,1,(int8)(aux_command>>14));  
1FD6:  MOVFF  52,BF
1FDA:  MOVF   53,W
1FDC:  ANDLW  3F
1FDE:  MOVWF  xC0
1FE0:  SWAPF  53,W
1FE2:  MOVWF  02
1FE4:  CLRF   03
1FE6:  RRCF   02,F
1FE8:  RRCF   02,F
1FEA:  MOVLW  03
1FEC:  ANDWF  02,F
1FEE:  MOVFF  02,C1
1FF2:  MOVFF  C0,C3
1FF6:  MOVFF  52,C2
1FFA:  MOVLW  23
1FFC:  MOVWF  xC5
1FFE:  MOVLW  28
2000:  MOVWF  xC4
2002:  MOVFF  81,C7
2006:  MOVFF  80,C6
200A:  MOVLW  01
200C:  MOVWF  xC8
200E:  MOVFF  02,C9
2012:  CALL   115C
....................        last_actuator_pulse = actuator_pulse; 
2016:  MOVFF  83,85
201A:  MOVFF  82,84
....................       break;    } 
201E:  BRA    25E6
....................      // 0x21 = move west 
....................      case 0x21: {  if (flag2.is_moving) {send_data(1,0); break;} 
2020:  BTFSS  20.6
2022:  BRA    203C
2024:  CLRF   18
2026:  BTFSC  FF2.7
2028:  BSF    18.7
202A:  BCF    FF2.7
202C:  MOVLW  01
202E:  MOVWF  xE7
2030:  CLRF   xE8
2032:  CALL   046A
2036:  BTFSC  18.7
2038:  BSF    FF2.7
203A:  BRA    25E6
203C:  CLRF   18
203E:  BTFSC  FF2.7
2040:  BSF    18.7
2042:  BCF    FF2.7
....................       send_data(0,0); 
2044:  CLRF   xE7
2046:  CLRF   xE8
2048:  CALL   046A
204C:  BTFSC  18.7
204E:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,0,(int8)(aux_command>>14));  
2050:  MOVFF  52,BF
2054:  MOVF   53,W
2056:  ANDLW  3F
2058:  MOVWF  xC0
205A:  SWAPF  53,W
205C:  MOVWF  02
205E:  CLRF   03
2060:  RRCF   02,F
2062:  RRCF   02,F
2064:  MOVLW  03
2066:  ANDWF  02,F
2068:  MOVFF  02,C1
206C:  MOVFF  C0,C3
2070:  MOVFF  52,C2
2074:  MOVLW  23
2076:  MOVWF  xC5
2078:  MOVLW  28
207A:  MOVWF  xC4
207C:  MOVFF  81,C7
2080:  MOVFF  80,C6
2084:  CLRF   xC8
2086:  MOVFF  02,C9
208A:  CALL   115C
....................        last_actuator_pulse = actuator_pulse; 
208E:  MOVFF  83,85
2092:  MOVFF  82,84
....................       break;    } 
2096:  BRA    25E6
....................      // 0x22 = go home 
....................       case 0x22: {  if (flag2.is_moving) {send_data(1,0); break;} 
2098:  BTFSS  20.6
209A:  BRA    20B4
209C:  CLRF   18
209E:  BTFSC  FF2.7
20A0:  BSF    18.7
20A2:  BCF    FF2.7
20A4:  MOVLW  01
20A6:  MOVWF  xE7
20A8:  CLRF   xE8
20AA:  CALL   046A
20AE:  BTFSC  18.7
20B0:  BSF    FF2.7
20B2:  BRA    25E6
20B4:  CLRF   18
20B6:  BTFSC  FF2.7
20B8:  BSF    18.7
20BA:  BCF    FF2.7
....................                send_data(0,0); 
20BC:  CLRF   xE7
20BE:  CLRF   xE8
20C0:  CALL   046A
20C4:  BTFSC  18.7
20C6:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[(int8) aux_command]*(int32)(act_safety_stroke-act_min_stroke[(int8) aux_command]); 
20C8:  BCF    FD8.0
20CA:  RLCF   52,W
20CC:  CLRF   03
20CE:  ADDLW  94
20D0:  MOVWF  FE9
20D2:  MOVLW  00
20D4:  ADDWFC 03,W
20D6:  MOVWF  FEA
20D8:  MOVFF  FEC,03
20DC:  MOVF   FED,F
20DE:  MOVFF  FEF,BF
20E2:  MOVFF  03,C0
20E6:  CLRF   xC1
20E8:  CLRF   xC2
20EA:  BCF    FD8.0
20EC:  RLCF   52,W
20EE:  CLRF   03
20F0:  ADDLW  A4
20F2:  MOVWF  FE9
20F4:  MOVLW  00
20F6:  ADDWFC 03,W
20F8:  MOVWF  FEA
20FA:  MOVFF  FEC,03
20FE:  MOVF   FED,F
2100:  MOVF   FEF,W
2102:  SUBWF  xAC,W
2104:  MOVWF  00
2106:  MOVF   03,W
2108:  SUBWFB xAD,W
210A:  MOVWF  03
210C:  MOVF   00,W
210E:  MOVFF  03,01
2112:  CLRF   02
2114:  CLRF   03
2116:  MOVFF  03,C6
211A:  MOVFF  02,C5
211E:  MOVFF  01,C4
2122:  MOVFF  00,C3
2126:  MOVFF  FEA,C8
212A:  MOVFF  FE9,C7
212E:  MOVFF  C2,D7
2132:  MOVFF  C1,D6
2136:  MOVFF  C0,D5
213A:  MOVFF  BF,D4
213E:  MOVFF  03,DB
2142:  MOVFF  02,DA
2146:  MOVFF  01,D9
214A:  MOVFF  00,D8
214E:  CALL   1502
2152:  MOVFF  C8,FEA
2156:  MOVFF  C7,FE9
215A:  MOVFF  03,29
215E:  MOVFF  02,28
2162:  MOVFF  01,27
2166:  MOVFF  00,26
....................                tick = tick/(act_max_stroke[(int8) aux_command]-act_min_stroke[(int8) aux_command]); 
216A:  BCF    FD8.0
216C:  RLCF   52,W
216E:  CLRF   03
2170:  ADDLW  9C
2172:  MOVWF  FE9
2174:  MOVLW  00
2176:  ADDWFC 03,W
2178:  MOVWF  FEA
217A:  MOVFF  FEC,C0
217E:  MOVF   FED,F
2180:  MOVFF  FEF,BF
2184:  BCF    FD8.0
2186:  RLCF   52,W
2188:  CLRF   03
218A:  ADDLW  A4
218C:  MOVWF  FE9
218E:  MOVLW  00
2190:  ADDWFC 03,W
2192:  MOVWF  FEA
2194:  MOVFF  FEC,03
2198:  MOVF   FED,F
219A:  MOVF   FEF,W
219C:  SUBWF  xBF,W
219E:  MOVWF  00
21A0:  MOVF   03,W
21A2:  SUBWFB xC0,W
21A4:  MOVWF  03
21A6:  MOVFF  00,BF
21AA:  MOVWF  xC0
21AC:  MOVFF  FEA,C2
21B0:  MOVFF  FE9,C1
21B4:  CLRF   18
21B6:  BTFSC  FF2.7
21B8:  BSF    18.7
21BA:  BCF    FF2.7
21BC:  MOVFF  29,E5
21C0:  MOVFF  28,E4
21C4:  MOVFF  27,E3
21C8:  MOVFF  26,E2
21CC:  CLRF   xE9
21CE:  CLRF   xE8
21D0:  MOVWF  xE7
21D2:  MOVFF  00,E6
21D6:  CALL   00AA
21DA:  BTFSC  18.7
21DC:  BSF    FF2.7
21DE:  MOVFF  C2,FEA
21E2:  MOVFF  C1,FE9
21E6:  MOVFF  03,29
21EA:  MOVFF  02,28
21EE:  MOVFF  01,27
21F2:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
21F6:  MOVFF  27,93
21FA:  MOVFF  26,92
....................                actuator_move_execute((int8) aux_command); 
21FE:  MOVFF  52,BF
2202:  CALL   1556
....................                    last_actuator_pulse = actuator_pulse; 
2206:  MOVFF  83,85
220A:  MOVFF  82,84
....................                break; } 
220E:  BRA    25E6
....................      // 0x23 = cal act 
....................      case 0x23: {  if (flag2.is_moving) {send_data(1,0); break;} 
2210:  BTFSS  20.6
2212:  BRA    222C
2214:  CLRF   18
2216:  BTFSC  FF2.7
2218:  BSF    18.7
221A:  BCF    FF2.7
221C:  MOVLW  01
221E:  MOVWF  xE7
2220:  CLRF   xE8
2222:  CALL   046A
2226:  BTFSC  18.7
2228:  BSF    FF2.7
222A:  BRA    25E6
222C:  CLRF   18
222E:  BTFSC  FF2.7
2230:  BSF    18.7
2232:  BCF    FF2.7
....................                send_data(0,0); 
2234:  CLRF   xE7
2236:  CLRF   xE8
2238:  CALL   046A
223C:  BTFSC  18.7
223E:  BSF    FF2.7
....................                   move_act(MAX_FULL_STROKE,9000,move_act_time_out,1,(int8) aux_command); // move actuator to west 
2240:  MOVLW  17
2242:  MOVWF  xC3
2244:  MOVLW  70
2246:  MOVWF  xC2
2248:  MOVLW  23
224A:  MOVWF  xC5
224C:  MOVLW  28
224E:  MOVWF  xC4
2250:  MOVFF  81,C7
2254:  MOVFF  80,C6
2258:  MOVLW  01
225A:  MOVWF  xC8
225C:  MOVFF  52,C9
2260:  CALL   115C
....................                   move_act(MAX_FULL_STROKE,9000,move_act_time_out,0,(int8) aux_command); // move actuator to home position 
2264:  MOVLW  17
2266:  MOVWF  xC3
2268:  MOVLW  70
226A:  MOVWF  xC2
226C:  MOVLW  23
226E:  MOVWF  xC5
2270:  MOVLW  28
2272:  MOVWF  xC4
2274:  MOVFF  81,C7
2278:  MOVFF  80,C6
227C:  CLRF   xC8
227E:  MOVFF  52,C9
2282:  CALL   115C
....................                   act_full_stroke_tick[(int8) aux_command]= actuator_pulse; 
2286:  BCF    FD8.0
2288:  RLCF   52,W
228A:  CLRF   03
228C:  ADDLW  94
228E:  MOVWF  FE9
2290:  MOVLW  00
2292:  ADDWFC 03,W
2294:  MOVWF  FEA
2296:  MOVFF  83,FEC
229A:  MOVF   FED,F
229C:  MOVFF  82,FEF
....................                   current_act_position[(int8) aux_command] =0; 
22A0:  BCF    FD8.0
22A2:  RLCF   52,W
22A4:  CLRF   03
22A6:  ADDLW  8A
22A8:  MOVWF  FE9
22AA:  MOVLW  00
22AC:  ADDWFC 03,W
22AE:  MOVWF  FEA
22B0:  CLRF   FEC
22B2:  MOVF   FED,F
22B4:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
22B6:  MOVLW  01
22B8:  MOVWF  xBF
22BA:  CALL   0A3C
....................                 last_actuator_pulse = actuator_pulse; 
22BE:  MOVFF  83,85
22C2:  MOVFF  82,84
....................                   break; } 
22C6:  BRA    25E6
....................      // 0x24 = report actuator stat 
....................      case 0x24: {   
.................... //               memcpy(output_buffer,&act_min_stroke,2); 
.................... //               memcpy(output_buffer+2,&act_max_stroke,2); 
.................... //               memcpy(output_buffer+4,&act_safety_stroke,2); 
.................... //               memcpy(output_buffer+6,act_full_stroke_tick,8); 
.................... //               memcpy(output_buffer+14,current_act_position,8); 
....................  
....................                memcpy(output_buffer,act_min_stroke,8); 
22C8:  CLRF   FEA
22CA:  MOVLW  54
22CC:  MOVWF  FE9
22CE:  CLRF   FE2
22D0:  MOVLW  A4
22D2:  MOVWF  FE1
22D4:  MOVLW  08
22D6:  MOVWF  01
22D8:  MOVFF  FE6,FEE
22DC:  DECFSZ 01,F
22DE:  BRA    22D8
....................                memcpy(output_buffer+8,act_max_stroke,8); 
22E0:  CLRF   FEA
22E2:  MOVLW  5C
22E4:  MOVWF  FE9
22E6:  CLRF   FE2
22E8:  MOVLW  9C
22EA:  MOVWF  FE1
22EC:  MOVLW  08
22EE:  MOVWF  01
22F0:  MOVFF  FE6,FEE
22F4:  DECFSZ 01,F
22F6:  BRA    22F0
....................                memcpy(output_buffer+16,&act_safety_stroke,2); 
22F8:  CLRF   FEA
22FA:  MOVLW  64
22FC:  MOVWF  FE9
22FE:  CLRF   FE2
2300:  MOVLW  AC
2302:  MOVWF  FE1
2304:  MOVLW  02
2306:  MOVWF  01
2308:  MOVFF  FE6,FEE
230C:  DECFSZ 01,F
230E:  BRA    2308
....................                memcpy(output_buffer+18,act_full_stroke_tick,8); 
2310:  CLRF   FEA
2312:  MOVLW  66
2314:  MOVWF  FE9
2316:  CLRF   FE2
2318:  MOVLW  94
231A:  MOVWF  FE1
231C:  MOVLW  08
231E:  MOVWF  01
2320:  MOVFF  FE6,FEE
2324:  DECFSZ 01,F
2326:  BRA    2320
....................                memcpy(output_buffer+26,current_act_position,8); 
2328:  CLRF   FEA
232A:  MOVLW  6E
232C:  MOVWF  FE9
232E:  CLRF   FE2
2330:  MOVLW  8A
2332:  MOVWF  FE1
2334:  MOVLW  08
2336:  MOVWF  01
2338:  MOVFF  FE6,FEE
233C:  DECFSZ 01,F
233E:  BRA    2338
2340:  CLRF   18
2342:  BTFSC  FF2.7
2344:  BSF    18.7
2346:  BCF    FF2.7
....................  
....................                send_data(4,33); 
2348:  MOVLW  04
234A:  MOVWF  xE7
234C:  MOVLW  21
234E:  MOVWF  xE8
2350:  CALL   046A
2354:  BTFSC  18.7
2356:  BSF    FF2.7
....................                break; 
2358:  BRA    25E6
....................               }    
....................       // 0x25 = execute move on actuator to target position 
....................      case 0x25: {   if (flag2.is_moving) {send_data(1,0); break;} 
235A:  BTFSS  20.6
235C:  BRA    2376
235E:  CLRF   18
2360:  BTFSC  FF2.7
2362:  BSF    18.7
2364:  BCF    FF2.7
2366:  MOVLW  01
2368:  MOVWF  xE7
236A:  CLRF   xE8
236C:  CALL   046A
2370:  BTFSC  18.7
2372:  BSF    FF2.7
2374:  BRA    25E6
2376:  CLRF   18
2378:  BTFSC  FF2.7
237A:  BSF    18.7
237C:  BCF    FF2.7
....................                send_data(0,0); 
237E:  CLRF   xE7
2380:  CLRF   xE8
2382:  CALL   046A
2386:  BTFSC  18.7
2388:  BSF    FF2.7
....................                   if (act_full_stroke_tick[(int8) aux_command] > 0x10) { 
238A:  BCF    FD8.0
238C:  RLCF   52,W
238E:  CLRF   03
2390:  ADDLW  94
2392:  MOVWF  FE9
2394:  MOVLW  00
2396:  ADDWFC 03,W
2398:  MOVWF  FEA
239A:  MOVFF  FEC,C0
239E:  MOVF   FED,F
23A0:  MOVFF  FEF,BF
23A4:  MOVF   xC0,F
23A6:  BNZ   23AE
23A8:  MOVF   xBF,W
23AA:  SUBLW  10
23AC:  BC    23BE
....................                   solar_get_act_length((int8) aux_command); 
23AE:  MOVFF  52,BF
23B2:  CALL   16E6
....................                 actuator_move_execute((int8) aux_command); 
23B6:  MOVFF  52,BF
23BA:  CALL   1556
....................                } 
....................                 last_actuator_pulse = actuator_pulse; 
23BE:  MOVFF  83,85
23C2:  MOVFF  82,84
....................                   break;    } 
23C6:  BRA    25E6
....................  
....................      case 0x26: { // report last_actuator_move  
....................                memcpy(output_buffer,&last_actuator_pulse,2); 
23C8:  CLRF   FEA
23CA:  MOVLW  54
23CC:  MOVWF  FE9
23CE:  CLRF   FE2
23D0:  MOVLW  84
23D2:  MOVWF  FE1
23D4:  MOVLW  02
23D6:  MOVWF  01
23D8:  MOVFF  FE6,FEE
23DC:  DECFSZ 01,F
23DE:  BRA    23D8
23E0:  CLRF   18
23E2:  BTFSC  FF2.7
23E4:  BSF    18.7
23E6:  BCF    FF2.7
....................                send_data(5,1); 
23E8:  MOVLW  05
23EA:  MOVWF  xE7
23EC:  MOVLW  01
23EE:  MOVWF  xE8
23F0:  CALL   046A
23F4:  BTFSC  18.7
23F6:  BSF    FF2.7
....................                 break; 
23F8:  BRA    25E6
....................             }    
....................  
.................... // new command 
.................... 	 case 0x27: { // set min actuator len ( len_in_cm x 256 ) 
.................... 				act_min_stroke[(int8) (aux_command & 0x0003)]=aux_command&0xFFFC; 
23FA:  MOVF   52,W
23FC:  ANDLW  03
23FE:  MOVWF  00
2400:  CLRF   03
2402:  MOVF   00,W
2404:  BCF    FD8.0
2406:  RLCF   00,F
2408:  MOVF   00,W
240A:  CLRF   03
240C:  ADDLW  A4
240E:  MOVWF  FE9
2410:  MOVLW  00
2412:  ADDWFC 03,W
2414:  MOVWF  FEA
2416:  MOVF   52,W
2418:  ANDLW  FC
241A:  MOVWF  FEF
241C:  MOVFF  53,FEC
.................... 				write_eeprom_data(1); 
2420:  MOVLW  01
2422:  MOVWF  xBF
2424:  CALL   0A3C
.................... 				break; 
2428:  BRA    25E6
.................... 		}	 
....................  
.................... 	 case 0x28: { 
.................... 				act_max_stroke[(int8) (aux_command & 0x0003)]=aux_command&0xFFFC; 
242A:  MOVF   52,W
242C:  ANDLW  03
242E:  MOVWF  00
2430:  CLRF   03
2432:  MOVF   00,W
2434:  BCF    FD8.0
2436:  RLCF   00,F
2438:  MOVF   00,W
243A:  CLRF   03
243C:  ADDLW  9C
243E:  MOVWF  FE9
2440:  MOVLW  00
2442:  ADDWFC 03,W
2444:  MOVWF  FEA
2446:  MOVF   52,W
2448:  ANDLW  FC
244A:  MOVWF  FEF
244C:  MOVFF  53,FEC
.................... 				write_eeprom_data(1); 
2450:  MOVLW  01
2452:  MOVWF  xBF
2454:  CALL   0A3C
.................... 				break; 
2458:  BRA    25E6
.................... 		}	 
....................  
....................   
.................... // level 1 command is for generic status 
....................      case 0x10: { memcpy(output_buffer,&nDay,4); 
245A:  CLRF   FEA
245C:  MOVLW  54
245E:  MOVWF  FE9
2460:  CLRF   FE2
2462:  MOVLW  2E
2464:  MOVWF  FE1
2466:  MOVLW  04
2468:  MOVWF  01
246A:  MOVFF  FE6,FEE
246E:  DECFSZ 01,F
2470:  BRA    246A
....................                    memcpy(output_buffer+4,&timer_sec,4); 
2472:  CLRF   FEA
2474:  MOVLW  58
2476:  MOVWF  FE9
2478:  CLRF   FE2
247A:  MOVLW  22
247C:  MOVWF  FE1
247E:  MOVLW  04
2480:  MOVWF  01
2482:  MOVFF  FE6,FEE
2486:  DECFSZ 01,F
2488:  BRA    2482
248A:  CLRF   18
248C:  BTFSC  FF2.7
248E:  BSF    18.7
2490:  BCF    FF2.7
....................                send_data(9,7); 
2492:  MOVLW  09
2494:  MOVWF  xE7
2496:  MOVLW  07
2498:  MOVWF  xE8
249A:  CALL   046A
249E:  BTFSC  18.7
24A0:  BSF    FF2.7
....................                break; } 
24A2:  BRA    25E6
....................       // report status flag 
....................      case 0x11: { memcpy(output_buffer,&flag,1); 
24A4:  CLRF   FEA
24A6:  MOVLW  54
24A8:  MOVWF  FE9
24AA:  CLRF   FE2
24AC:  MOVLW  1F
24AE:  MOVWF  FE1
24B0:  MOVFF  FE6,FEE
....................                    memcpy(output_buffer+1,&flag2,1); 
24B4:  CLRF   FEA
24B6:  MOVLW  55
24B8:  MOVWF  FE9
24BA:  CLRF   FE2
24BC:  MOVLW  20
24BE:  MOVWF  FE1
24C0:  MOVFF  FE6,FEE
24C4:  CLRF   18
24C6:  BTFSC  FF2.7
24C8:  BSF    18.7
24CA:  BCF    FF2.7
....................                send_data(10,1); 
24CC:  MOVLW  0A
24CE:  MOVWF  xE7
24D0:  MOVLW  01
24D2:  MOVWF  xE8
24D4:  CALL   046A
24D8:  BTFSC  18.7
24DA:  BSF    FF2.7
....................                break; } 
24DC:  BRA    25E6
....................      case 0x12: { //write device id 
....................                dev_id = aux_command; 
24DE:  MOVFF  53,35
24E2:  MOVFF  52,34
....................                write_device_id(); 
24E6:  GOTO   1CCA
24EA:  CLRF   18
24EC:  BTFSC  FF2.7
24EE:  BSF    18.7
24F0:  BCF    FF2.7
....................                send_data(0,0); 
24F2:  CLRF   xE7
24F4:  CLRF   xE8
24F6:  CALL   046A
24FA:  BTFSC  18.7
24FC:  BSF    FF2.7
....................                break; 
24FE:  BRA    25E6
....................                } 
....................       case 0x13: { // read device_id 
....................                read_device_id(); 
2500:  CALL   09D6
....................                memcpy(output_buffer,&dev_id,2); 
2504:  CLRF   FEA
2506:  MOVLW  54
2508:  MOVWF  FE9
250A:  CLRF   FE2
250C:  MOVLW  34
250E:  MOVWF  FE1
2510:  MOVLW  02
2512:  MOVWF  01
2514:  MOVFF  FE6,FEE
2518:  DECFSZ 01,F
251A:  BRA    2514
251C:  CLRF   18
251E:  BTFSC  FF2.7
2520:  BSF    18.7
2522:  BCF    FF2.7
....................                send_data(11,1); 
2524:  MOVLW  0B
2526:  MOVWF  xE7
2528:  MOVLW  01
252A:  MOVWF  xE8
252C:  CALL   046A
2530:  BTFSC  18.7
2532:  BSF    FF2.7
....................                break;  
2534:  BRA    25E6
....................              } 
....................  
....................  
.................... // level 0 communication control 
....................      case 0x01: {  // close/open communication port 
....................                 if (aux_command ==0x0000) {  
2536:  MOVF   52,F
2538:  BNZ   2544
253A:  MOVF   53,F
253C:  BNZ   2544
....................                   output_low(TX_EN); 
253E:  BCF    F96.1
2540:  BCF    F8D.1
....................                } else if (aux_command ==0x0001) { 
2542:  BRA    258C
2544:  DECFSZ 52,W
2546:  BRA    2576
2548:  MOVF   53,F
254A:  BNZ   2576
....................                   output_high(TX_EN); 
254C:  BCF    F96.1
254E:  BSF    F8D.1
....................                   delay_us(900); 
2550:  MOVLW  04
2552:  MOVWF  xBF
2554:  MOVLW  E0
2556:  MOVWF  xC0
2558:  GOTO   1D3E
255C:  DECFSZ xBF,F
255E:  BRA    2554
2560:  CLRF   18
2562:  BTFSC  FF2.7
2564:  BSF    18.7
2566:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
2568:  CLRF   xE7
256A:  CLRF   xE8
256C:  CALL   046A
2570:  BTFSC  18.7
2572:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
2574:  BRA    258C
2576:  CLRF   18
2578:  BTFSC  FF2.7
257A:  BSF    18.7
257C:  BCF    FF2.7
257E:  MOVLW  01
2580:  MOVWF  xE7
2582:  CLRF   xE8
2584:  CALL   046A
2588:  BTFSC  18.7
258A:  BSF    FF2.7
....................                break; 
258C:  BRA    25E6
....................              }    
....................  
....................      case 0x02: {  // enable/disable operation 
....................                 if (aux_command ==0x0000) {  
258E:  MOVF   52,F
2590:  BNZ   25AE
2592:  MOVF   53,F
2594:  BNZ   25AE
....................                   flag2.en_operate=0; 
2596:  BCF    20.0
2598:  CLRF   18
259A:  BTFSC  FF2.7
259C:  BSF    18.7
259E:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
25A0:  CLRF   xE7
25A2:  CLRF   xE8
25A4:  CALL   046A
25A8:  BTFSC  18.7
25AA:  BSF    FF2.7
....................                } else if (aux_command ==0x0001) { 
25AC:  BRA    25E4
25AE:  DECFSZ 52,W
25B0:  BRA    25CE
25B2:  MOVF   53,F
25B4:  BNZ   25CE
....................                   flag2.en_operate=1; 
25B6:  BSF    20.0
25B8:  CLRF   18
25BA:  BTFSC  FF2.7
25BC:  BSF    18.7
25BE:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
25C0:  CLRF   xE7
25C2:  CLRF   xE8
25C4:  CALL   046A
25C8:  BTFSC  18.7
25CA:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
25CC:  BRA    25E4
25CE:  CLRF   18
25D0:  BTFSC  FF2.7
25D2:  BSF    18.7
25D4:  BCF    FF2.7
25D6:  MOVLW  01
25D8:  MOVWF  xE7
25DA:  CLRF   xE8
25DC:  CALL   046A
25E0:  BTFSC  18.7
25E2:  BSF    FF2.7
....................                break; 
25E4:  BRA    25E6
....................              }    
....................  
....................  
....................  
....................    } 
....................  
.................... } 
25E6:  GOTO   2BB8 (RETURN)
....................  
.................... /* 
.................... void process_cmd_msg(){ 
....................    int8 i,j; 
....................    flag.cmd_posted =false; 
....................    last_command =0; 
....................    printf("\r\n>%s\r\n",cmd_msg); 
....................    switch (cmd_msg[0]) { 
....................       case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Block erase\r\n"); 
....................          flash_block_erase(); 
....................          break; } 
....................  
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
....................         setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
....................          print_page_data(atol(cmd_msg)); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'b': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Write buffer1 -> PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_buffer1_to_main_memory(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'c': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Read PAGE %ld -> buffer1",atol(cmd_msg)); 
....................          flash_read_main_memory_to_buffer1(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'f': { 
....................          disable_interrupts(GLOBAL); 
....................        setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n WRITE PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_page(atol(cmd_msg)); 
....................        printf("\r\n."); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'g': { 
....................          print_date_time(); 
....................          break; 
....................       } 
....................  
....................       case 'w': { //buffer1 read 
....................          disable_interrupts(GLOBAL); 
....................        printf("\r\n Buffer1:"); 
....................        for(i=0;i<16;i++) { 
....................             printf("\r\n%02X : ",i*16); 
....................             for (j=0;j<8;j++) { 
....................               flash_buffer1_read(i*16+j*2); 
....................             printf("%02X %02X ",flash_page_data,flash_page_data2); 
....................             restart_wdt(); 
....................             } 
....................        } 
....................          enable_interrupts(GLOBAL);          
....................          break;    
....................      } 
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
....................          break;    } 
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
....................          break;    } 
....................       case 'p': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Set 256 page size\r\n"); 
....................          flash_set_256_page_size(); 
....................          break; } 
....................  
....................      case 'z': { 
....................        print_fw_info(); 
....................        printf("\r\n startup = %ld",startup_counter); 
....................        break; 
....................      } 
....................      case 'd': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          nDay= atol(cmd_msg); 
....................          break;    } 
....................      case 't': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          timer_sec = atoi32(cmd_msg); 
....................        timer_sec = timer_sec; // rouding to 60 sec 
....................          break;    } 
....................      case 'l': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          solar_get_act_length(atoi(cmd_msg)); 
....................        disable_interrupts(GLOBAL); 
....................        printf("\r\n Act#%d Len=%lu Now=%lu\r\n",atoi(cmd_msg), target_act_position, current_act_position[atoi(cmd_msg)]); 
....................        enable_interrupts(GLOBAL); 
....................        actuator_move_execute(atoi(cmd_msg)); 
....................          break;    } 
....................       case 'h' : { //return home 
....................         memcpy(cmd_msg,cmd_msg+1,18); 
....................          if(strlen(cmd_msg)>0) { 
....................         flag2.en_operate =0; 
....................          move_act(2000,9000,move_act_time_out,1,atoi(cmd_msg)); // move actuator to west 
....................          move_act(2000,9000,move_act_time_out,0,atoi(cmd_msg)); // move actuator to home position 
....................          act_full_stroke_tick[atoi(cmd_msg)]= actuator_pulse; 
....................          current_act_position[atoi(cmd_msg)] =0; 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................         flag2.en_operate =1;  
....................        } 
....................  
....................          break; 
....................       } 
....................         
....................       case 'j': { 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................          break; 
....................       } 
....................  
....................      case 'o': { 
....................        flag2.en_operate = !flag2.en_operate; 
....................        if (flag2.en_operate) printf("\r\n Normal operation"); else printf("\r\n Halt operation"); 
....................        break; 
....................      } 
....................  
....................       case 'y': { //adc conversion 
....................          set_adc_channel(0); 
....................          delay_us(20); 
....................        wall_pwr_read =read_adc(); 
....................          printf("\r\nADC= %lu",wall_pwr_read); 
....................          break; 
....................       } 
....................       case 'k': { 
....................        disable_interrupts(GLOBAL); 
....................          while(1); 
....................          break; 
....................       } 
....................  
....................  
....................  
....................       }// end case       
.................... } 
....................  
.................... */ 
.................... ////////////////////////////////////// 
.................... void button_menu() { 
....................    int8 k; 
....................    int8 target_act=0; 
25EA:  CLRF   xBC
....................     flag2.en_operate = 0; // enter halt operation 
25EC:  BCF    20.0
....................    LED_status.power = 0; // always red 
25EE:  BCF    21.0
....................    LED_status.operation =0; 
25F0:  BCF    21.1
....................    LED_status.aux =3; // both turned off 
25F2:  MOVLW  F3
25F4:  ANDWF  21,W
25F6:  IORLW  0C
25F8:  MOVWF  21
....................    display_LED(); 
25FA:  CALL   0144
....................     flag2.abort_current_activity =0; 
25FE:  BCF    20.2
....................    while(flag2.button_pressed ==1)   button_scan(); 
2600:  BTFSS  20.1
2602:  BRA    2616
2604:  CLRF   18
2606:  BTFSC  FF2.7
2608:  BSF    18.7
260A:  BCF    FF2.7
260C:  CALL   01A0
2610:  BTFSC  18.7
2612:  BSF    FF2.7
2614:  BRA    2600
2616:  CLRF   18
2618:  BTFSC  FF2.7
261A:  BSF    18.7
261C:  BCF    FF2.7
....................    delay_ms(10); 
261E:  MOVLW  0A
2620:  MOVWF  xE2
2622:  CALL   0178
2626:  BTFSC  18.7
2628:  BSF    FF2.7
....................    // button release 
....................  
....................     while(1) { 
....................       nButton =-1; 
262A:  MOVLW  FF
262C:  MOVWF  4B
262E:  CLRF   18
2630:  BTFSC  FF2.7
2632:  BSF    18.7
2634:  BCF    FF2.7
....................       button_scan(); 
2636:  CALL   01A0
263A:  BTFSC  18.7
263C:  BSF    FF2.7
....................       restart_wdt(); 
263E:  CLRWDT
....................       if (nButton != -1){ 
2640:  MOVF   4B,W
2642:  SUBLW  FF
2644:  BTFSC  FD8.2
2646:  BRA    2912
....................       switch (nButton) { 
2648:  MOVF   4B,W
264A:  ADDLW  FA
264C:  BTFSC  FD8.0
264E:  BRA    2912
2650:  ADDLW  06
2652:  GOTO   2918
....................          case 0: { // operate/halt button  
....................                while (flag2.button_pressed ==1) button_scan(); 
2656:  BTFSS  20.1
2658:  BRA    266C
265A:  CLRF   18
265C:  BTFSC  FF2.7
265E:  BSF    18.7
2660:  BCF    FF2.7
2662:  CALL   01A0
2666:  BTFSC  18.7
2668:  BSF    FF2.7
266A:  BRA    2656
266C:  CLRF   18
266E:  BTFSC  FF2.7
2670:  BSF    18.7
2672:  BCF    FF2.7
....................                delay_ms(10); 
2674:  MOVLW  0A
2676:  MOVWF  xE2
2678:  CALL   0178
267C:  BTFSC  18.7
267E:  BSF    FF2.7
....................                nButton=-1; 
2680:  MOVLW  FF
2682:  MOVWF  4B
....................                flag2.en_operate =1; 
2684:  BSF    20.0
....................                flag2.abort_current_activity =0; 
2686:  BCF    20.2
....................                init_rs232(); 
2688:  CALL   0124
....................                return;} 
268C:  BRA    2914
....................          case 1: { // actuator select button 
....................                while (flag2.button_pressed ==1) button_scan(); 
268E:  BTFSS  20.1
2690:  BRA    26A4
2692:  CLRF   18
2694:  BTFSC  FF2.7
2696:  BSF    18.7
2698:  BCF    FF2.7
269A:  CALL   01A0
269E:  BTFSC  18.7
26A0:  BSF    FF2.7
26A2:  BRA    268E
26A4:  CLRF   18
26A6:  BTFSC  FF2.7
26A8:  BSF    18.7
26AA:  BCF    FF2.7
....................                delay_ms(10); 
26AC:  MOVLW  0A
26AE:  MOVWF  xE2
26B0:  CALL   0178
26B4:  BTFSC  18.7
26B6:  BSF    FF2.7
....................                target_act++; 
26B8:  INCF   xBC,F
....................                target_act = target_act%4; 
26BA:  MOVLW  03
26BC:  ANDWF  xBC,F
....................                LED_status.aux=target_act ^ 0xFF ; 
26BE:  MOVF   xBC,W
26C0:  XORLW  FF
26C2:  ANDLW  03
26C4:  MOVWF  00
26C6:  BCF    FD8.0
26C8:  RLCF   00,F
26CA:  RLCF   00,F
26CC:  MOVLW  F3
26CE:  ANDWF  21,W
26D0:  IORWF  00,W
26D2:  MOVWF  21
....................                display_LED(); 
26D4:  CALL   0144
....................                break;} 
26D8:  BRA    2912
....................             case 2: { //return home 
....................                   move_act(2000,9000,move_act_time_out,1,target_act); // move actuator to west 
26DA:  MOVLW  07
26DC:  MOVWF  xC3
26DE:  MOVLW  D0
26E0:  MOVWF  xC2
26E2:  MOVLW  23
26E4:  MOVWF  xC5
26E6:  MOVLW  28
26E8:  MOVWF  xC4
26EA:  MOVFF  81,C7
26EE:  MOVFF  80,C6
26F2:  MOVLW  01
26F4:  MOVWF  xC8
26F6:  MOVFF  BC,C9
26FA:  CALL   115C
....................                   move_act(2000,9000,move_act_time_out,0,target_act); // move actuator to home position 
26FE:  MOVLW  07
2700:  MOVWF  xC3
2702:  MOVLW  D0
2704:  MOVWF  xC2
2706:  MOVLW  23
2708:  MOVWF  xC5
270A:  MOVLW  28
270C:  MOVWF  xC4
270E:  MOVFF  81,C7
2712:  MOVFF  80,C6
2716:  CLRF   xC8
2718:  MOVFF  BC,C9
271C:  CALL   115C
....................                   act_full_stroke_tick[target_act]= actuator_pulse; 
2720:  BCF    FD8.0
2722:  RLCF   xBC,W
2724:  CLRF   03
2726:  ADDLW  94
2728:  MOVWF  FE9
272A:  MOVLW  00
272C:  ADDWFC 03,W
272E:  MOVWF  FEA
2730:  MOVFF  83,FEC
2734:  MOVF   FED,F
2736:  MOVFF  82,FEF
....................                   current_act_position[target_act] =0; 
273A:  BCF    FD8.0
273C:  RLCF   xBC,W
273E:  CLRF   03
2740:  ADDLW  8A
2742:  MOVWF  FE9
2744:  MOVLW  00
2746:  ADDWFC 03,W
2748:  MOVWF  FEA
274A:  CLRF   FEC
274C:  MOVF   FED,F
274E:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
2750:  MOVLW  01
2752:  MOVWF  xBF
2754:  CALL   0A3C
....................                   break; 
2758:  BRA    2912
....................                   } 
....................          case 3: { // move east 
....................                flag2.allow_manual_move_act=1; 
275A:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,0,target_act); 
275C:  CLRF   xC3
275E:  MOVLW  0A
2760:  MOVWF  xC2
2762:  MOVLW  11
2764:  MOVWF  xC5
2766:  MOVLW  94
2768:  MOVWF  xC4
276A:  MOVFF  81,C7
276E:  MOVFF  80,C6
2772:  CLRF   xC8
2774:  MOVFF  BC,C9
2778:  CALL   115C
....................                flag2.allow_manual_move_act=0; 
277C:  BCF    20.3
....................                break; } 
277E:  BRA    2912
....................          case 4: { // move safty 
....................                 while (flag2.button_pressed ==1) button_scan(); 
2780:  BTFSS  20.1
2782:  BRA    2796
2784:  CLRF   18
2786:  BTFSC  FF2.7
2788:  BSF    18.7
278A:  BCF    FF2.7
278C:  CALL   01A0
2790:  BTFSC  18.7
2792:  BSF    FF2.7
2794:  BRA    2780
2796:  CLRF   18
2798:  BTFSC  FF2.7
279A:  BSF    18.7
279C:  BCF    FF2.7
....................                delay_ms(10); 
279E:  MOVLW  0A
27A0:  MOVWF  xE2
27A2:  CALL   0178
27A6:  BTFSC  18.7
27A8:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[target_act]*(int32)(act_safety_stroke-act_min_stroke[target_act]); 
27AA:  BCF    FD8.0
27AC:  RLCF   xBC,W
27AE:  CLRF   03
27B0:  ADDLW  94
27B2:  MOVWF  FE9
27B4:  MOVLW  00
27B6:  ADDWFC 03,W
27B8:  MOVWF  FEA
27BA:  MOVFF  FEC,03
27BE:  MOVF   FED,F
27C0:  MOVFF  FEF,BD
27C4:  MOVFF  03,BE
27C8:  CLRF   xBF
27CA:  CLRF   xC0
27CC:  BCF    FD8.0
27CE:  RLCF   xBC,W
27D0:  CLRF   03
27D2:  ADDLW  A4
27D4:  MOVWF  FE9
27D6:  MOVLW  00
27D8:  ADDWFC 03,W
27DA:  MOVWF  FEA
27DC:  MOVFF  FEC,03
27E0:  MOVF   FED,F
27E2:  MOVF   FEF,W
27E4:  SUBWF  xAC,W
27E6:  MOVWF  00
27E8:  MOVF   03,W
27EA:  SUBWFB xAD,W
27EC:  MOVWF  03
27EE:  MOVF   00,W
27F0:  MOVFF  03,01
27F4:  CLRF   02
27F6:  CLRF   03
27F8:  MOVFF  03,C4
27FC:  MOVFF  02,C3
2800:  MOVFF  01,C2
2804:  MOVFF  00,C1
2808:  MOVFF  FEA,C6
280C:  MOVFF  FE9,C5
2810:  MOVFF  C0,D7
2814:  MOVFF  BF,D6
2818:  MOVFF  BE,D5
281C:  MOVFF  BD,D4
2820:  MOVFF  03,DB
2824:  MOVFF  02,DA
2828:  MOVFF  01,D9
282C:  MOVFF  00,D8
2830:  CALL   1502
2834:  MOVFF  C6,FEA
2838:  MOVFF  C5,FE9
283C:  MOVFF  03,29
2840:  MOVFF  02,28
2844:  MOVFF  01,27
2848:  MOVFF  00,26
....................                tick = tick/(act_max_stroke[target_act]-act_min_stroke[target_act]); 
284C:  BCF    FD8.0
284E:  RLCF   xBC,W
2850:  CLRF   03
2852:  ADDLW  9C
2854:  MOVWF  FE9
2856:  MOVLW  00
2858:  ADDWFC 03,W
285A:  MOVWF  FEA
285C:  MOVFF  FEC,BE
2860:  MOVF   FED,F
2862:  MOVFF  FEF,BD
2866:  BCF    FD8.0
2868:  RLCF   xBC,W
286A:  CLRF   03
286C:  ADDLW  A4
286E:  MOVWF  FE9
2870:  MOVLW  00
2872:  ADDWFC 03,W
2874:  MOVWF  FEA
2876:  MOVFF  FEC,03
287A:  MOVF   FED,F
287C:  MOVF   FEF,W
287E:  SUBWF  xBD,W
2880:  MOVWF  00
2882:  MOVF   03,W
2884:  SUBWFB xBE,W
2886:  MOVWF  03
2888:  MOVFF  00,BD
288C:  MOVWF  xBE
288E:  MOVFF  FEA,C0
2892:  MOVFF  FE9,BF
2896:  CLRF   18
2898:  BTFSC  FF2.7
289A:  BSF    18.7
289C:  BCF    FF2.7
289E:  MOVFF  29,E5
28A2:  MOVFF  28,E4
28A6:  MOVFF  27,E3
28AA:  MOVFF  26,E2
28AE:  CLRF   xE9
28B0:  CLRF   xE8
28B2:  MOVWF  xE7
28B4:  MOVFF  00,E6
28B8:  CALL   00AA
28BC:  BTFSC  18.7
28BE:  BSF    FF2.7
28C0:  MOVFF  C0,FEA
28C4:  MOVFF  BF,FE9
28C8:  MOVFF  03,29
28CC:  MOVFF  02,28
28D0:  MOVFF  01,27
28D4:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
28D8:  MOVFF  27,93
28DC:  MOVFF  26,92
....................                actuator_move_execute(target_act); 
28E0:  MOVFF  BC,BF
28E4:  CALL   1556
....................                break; } 
28E8:  BRA    2912
....................          case 5: { // move west 
....................                flag2.allow_manual_move_act=1; 
28EA:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,1,target_act); 
28EC:  CLRF   xC3
28EE:  MOVLW  0A
28F0:  MOVWF  xC2
28F2:  MOVLW  11
28F4:  MOVWF  xC5
28F6:  MOVLW  94
28F8:  MOVWF  xC4
28FA:  MOVFF  81,C7
28FE:  MOVFF  80,C6
2902:  MOVLW  01
2904:  MOVWF  xC8
2906:  MOVFF  BC,C9
290A:  CALL   115C
....................                flag2.allow_manual_move_act=0; 
290E:  BCF    20.3
....................                break; } 
2910:  BRA    2912
....................  
....................          } 
....................           
....................       } 
....................       } 
2912:  BRA    262A
....................        
.................... } 
2914:  GOTO   2C3A (RETURN)
....................  
.................... ////////////////////////////////////// 
.................... void main() { 
*
2948:  CLRF   FF8
294A:  BCF    FD0.7
294C:  BSF    08.7
294E:  CLRF   FEA
2950:  CLRF   FE9
2952:  MOVLW  03
2954:  MOVWF  FAF
2956:  MOVLW  A2
2958:  MOVWF  FAC
295A:  MOVLW  90
295C:  MOVWF  FAB
295E:  BSF    F94.4
2960:  BCF    F94.5
2962:  BCF    F94.3
2964:  BCF    F8B.3
2966:  BSF    FC1.0
2968:  BSF    FC1.1
296A:  BSF    FC1.2
296C:  BCF    FC1.3
296E:  MOVLW  07
2970:  MOVWF  FB4
2972:  CLRF   19
2974:  CLRF   1A
2976:  CLRF   22
2978:  CLRF   23
297A:  CLRF   24
297C:  CLRF   25
297E:  CLRF   26
2980:  CLRF   27
2982:  CLRF   28
2984:  CLRF   29
2986:  CLRF   2A
2988:  CLRF   2B
298A:  CLRF   2C
298C:  CLRF   2D
298E:  MOVLW  01
2990:  MOVWF  2E
2992:  CLRF   2F
2994:  CLRF   30
2996:  CLRF   31
2998:  CLRF   32
299A:  CLRF   33
299C:  MOVLW  75
299E:  MOVWF  34
29A0:  CLRF   35
29A2:  CLRF   4A
29A4:  MOVLW  FF
29A6:  MOVWF  4B
29A8:  CLRF   4C
29AA:  CLRF   4D
29AC:  CLRF   4E
29AE:  CLRF   4F
29B0:  CLRF   50
29B2:  CLRF   51
29B4:  CLRF   x7D
29B6:  CLRF   x7E
29B8:  CLRF   x7F
29BA:  MOVLW  02
29BC:  MOVWF  x80
29BE:  CLRF   x81
29C0:  CLRF   x82
29C2:  CLRF   x83
29C4:  CLRF   x8A
29C6:  CLRF   x8B
29C8:  CLRF   x8C
29CA:  CLRF   x8D
29CC:  CLRF   x8E
29CE:  CLRF   x8F
29D0:  CLRF   x90
29D2:  CLRF   x91
29D4:  CLRF   x92
29D6:  CLRF   x93
29D8:  CLRF   x94
29DA:  CLRF   x95
29DC:  CLRF   x96
29DE:  CLRF   x97
29E0:  CLRF   x98
29E2:  CLRF   x99
29E4:  CLRF   x9A
29E6:  CLRF   x9B
29E8:  CLRF   x9C
29EA:  CLRF   x9D
29EC:  CLRF   x9E
29EE:  CLRF   x9F
29F0:  CLRF   xA0
29F2:  CLRF   xA1
29F4:  CLRF   xA2
29F6:  CLRF   xA3
29F8:  CLRF   xA4
29FA:  CLRF   xA5
29FC:  CLRF   xA6
29FE:  CLRF   xA7
2A00:  CLRF   xA8
2A02:  CLRF   xA9
2A04:  CLRF   xAA
2A06:  CLRF   xAB
2A08:  CLRF   xAC
2A0A:  CLRF   xAD
2A0C:  CLRF   xAE
2A0E:  CLRF   xAF
2A10:  CLRF   xB0
2A12:  CLRF   xB1
2A14:  CLRF   xB2
2A16:  CLRF   xB3
2A18:  CLRF   xB4
....................    int16 relay_time,kk; 
....................    int8 act_loop,i; 
....................    init_spi(); 
2A1A:  GOTO   0596
....................     setup_adc_ports(AN0); 
2A1E:  BCF    FC1.0
2A20:  BSF    FC1.1
2A22:  BSF    FC1.2
2A24:  BSF    FC1.3
....................     setup_adc(ADC_CLOCK_INTERNAL); 
2A26:  BCF    FC1.6
2A28:  BSF    FC2.6
2A2A:  BSF    FC2.7
2A2C:  BSF    FC1.7
2A2E:  BSF    FC2.0
....................     set_adc_channel(0); 
2A30:  MOVLW  00
2A32:  MOVWF  01
2A34:  MOVF   FC2,W
2A36:  ANDLW  C7
2A38:  IORWF  01,W
2A3A:  MOVWF  FC2
....................    set_tris_a(0xFF); 
2A3C:  MOVLW  FF
2A3E:  MOVWF  F92
....................    set_tris_b(0xFF); 
2A40:  MOVWF  F93
....................    set_tris_d(0x00); 
2A42:  MOVLW  00
2A44:  MOVWF  F95
....................     led_status =0xF0; 
2A46:  MOVLW  F0
2A48:  MOVWF  21
....................    display_LED(); 
2A4A:  CALL   0144
....................    delay_ms(5000); 
2A4E:  MOVLW  14
2A50:  MOVWF  xBB
2A52:  CLRF   18
2A54:  BTFSC  FF2.7
2A56:  BSF    18.7
2A58:  BCF    FF2.7
2A5A:  MOVLW  FA
2A5C:  MOVWF  xE2
2A5E:  CALL   0178
2A62:  BTFSC  18.7
2A64:  BSF    FF2.7
2A66:  DECFSZ xBB,F
2A68:  BRA    2A52
....................    flag2.is_moving =0; 
2A6A:  BCF    20.6
....................    while((read_adc()+read_adc()+read_adc()+read_adc())/4 < 650) { 
2A6C:  BSF    FC2.2
2A6E:  BTFSC  FC2.2
2A70:  BRA    2A6E
2A72:  MOVFF  FC4,03
2A76:  MOVFF  FC3,BB
2A7A:  MOVFF  FC4,BC
2A7E:  BSF    FC2.2
2A80:  BTFSC  FC2.2
2A82:  BRA    2A80
2A84:  MOVFF  FC4,03
2A88:  MOVF   FC3,W
2A8A:  ADDWF  xBB,F
2A8C:  MOVF   FC4,W
2A8E:  ADDWFC xBC,F
2A90:  BSF    FC2.2
2A92:  BTFSC  FC2.2
2A94:  BRA    2A92
2A96:  MOVFF  FC4,03
2A9A:  MOVF   FC3,W
2A9C:  ADDWF  xBB,F
2A9E:  MOVF   FC4,W
2AA0:  ADDWFC xBC,F
2AA2:  BSF    FC2.2
2AA4:  BTFSC  FC2.2
2AA6:  BRA    2AA4
2AA8:  MOVFF  FC4,03
2AAC:  MOVF   FC3,W
2AAE:  ADDWF  xBB,F
2AB0:  MOVF   FC4,W
2AB2:  ADDWFC xBC,F
2AB4:  RRCF   xBC,F
2AB6:  RRCF   xBB,F
2AB8:  RRCF   xBC,F
2ABA:  RRCF   xBB,F
2ABC:  MOVLW  3F
2ABE:  ANDWF  xBC,F
2AC0:  MOVF   xBC,W
2AC2:  SUBLW  02
2AC4:  BNC   2B08
2AC6:  BNZ   2ACE
2AC8:  MOVF   xBB,W
2ACA:  SUBLW  89
2ACC:  BNC   2B08
....................        led_status =0xFE; 
2ACE:  MOVLW  FE
2AD0:  MOVWF  21
....................        display_LED(); 
2AD2:  CALL   0144
2AD6:  CLRF   18
2AD8:  BTFSC  FF2.7
2ADA:  BSF    18.7
2ADC:  BCF    FF2.7
....................        delay_ms(2); 
2ADE:  MOVLW  02
2AE0:  MOVWF  xE2
2AE2:  CALL   0178
2AE6:  BTFSC  18.7
2AE8:  BSF    FF2.7
....................        led_status =0xFF; 
2AEA:  MOVLW  FF
2AEC:  MOVWF  21
....................        display_LED();          
2AEE:  CALL   0144
2AF2:  CLRF   18
2AF4:  BTFSC  FF2.7
2AF6:  BSF    18.7
2AF8:  BCF    FF2.7
....................        delay_ms(50); 
2AFA:  MOVLW  32
2AFC:  MOVWF  xE2
2AFE:  CALL   0178
2B02:  BTFSC  18.7
2B04:  BSF    FF2.7
....................    } // trap here  until voltage level is good 
2B06:  BRA    2A6C
2B08:  CLRF   18
2B0A:  BTFSC  FF2.7
2B0C:  BSF    18.7
2B0E:  BCF    FF2.7
....................    delay_ms(200); 
2B10:  MOVLW  C8
2B12:  MOVWF  xE2
2B14:  CALL   0178
2B18:  BTFSC  18.7
2B1A:  BSF    FF2.7
....................    flag2.power=1; 
2B1C:  BSF    20.5
....................  
....................  
....................    output_low(TX_EN); 
2B1E:  BCF    F96.1
2B20:  BCF    F8D.1
....................  
....................  
....................    flash_wait_until_ready(); 
2B22:  CALL   05E2
....................    flash_read_mfg_id(); 
2B26:  GOTO   0606
....................    flash_read_stat(); // stat & 0xBF == 0x9C means device ready 
2B2A:  CALL   05AE
....................     // check flash readiness here // 
....................     //if (flash_mfg_id[1]==0x24) //4MBit 
....................     //if (flash_mfg_id[1]==0x26) //16MBit 
....................  
....................    read_eeprom_data(); 
2B2E:  GOTO   067A
....................    read_device_id(); 
2B32:  CALL   09D6
....................    //print_fw_info(); 
....................     T1CON = 0b00001111;  // 0b10011011 
2B36:  MOVLW  0F
2B38:  MOVWF  FCD
....................     enable_interrupts(INT_RDA); 
2B3A:  BSF    F9D.5
....................     enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
2B3C:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
2B3E:  MOVLW  C0
2B40:  IORWF  FF2,F
....................    init_rs232(); 
2B42:  CALL   0124
....................    relay_time =0; 
2B46:  CLRF   xB6
2B48:  CLRF   xB5
....................    flag2.en_operate =1; 
2B4A:  BSF    20.0
....................    flag2.button_pressed=0; 
2B4C:  BCF    20.1
....................    flag2.allow_manual_move_act=0; 
2B4E:  BCF    20.3
....................    LED_status =0x00; 
2B50:  CLRF   21
2B52:  CLRF   18
2B54:  BTFSC  FF2.7
2B56:  BSF    18.7
2B58:  BCF    FF2.7
....................  
....................    delay_ms(200); 
2B5A:  MOVLW  C8
2B5C:  MOVWF  xE2
2B5E:  CALL   0178
2B62:  BTFSC  18.7
2B64:  BSF    FF2.7
....................    while(read_eeprom((int8)0xf00040)!=0x34); 
2B66:  MOVFF  FF2,BB
2B6A:  BCF    FF2.7
2B6C:  MOVLW  40
2B6E:  MOVWF  FA9
2B70:  BCF    FA6.6
2B72:  BCF    FA6.7
2B74:  BSF    FA6.0
2B76:  MOVF   FA8,W
2B78:  BTFSC  xBB.7
2B7A:  BSF    FF2.7
2B7C:  SUBLW  34
2B7E:  BNZ   2B66
....................    while(read_eeprom((int8)0xf00041)!=0x12); 
2B80:  MOVFF  FF2,BB
2B84:  BCF    FF2.7
2B86:  MOVLW  41
2B88:  MOVWF  FA9
2B8A:  BCF    FA6.6
2B8C:  BCF    FA6.7
2B8E:  BSF    FA6.0
2B90:  MOVF   FA8,W
2B92:  BTFSC  xBB.7
2B94:  BSF    FF2.7
2B96:  SUBLW  12
2B98:  BNZ   2B80
....................    display_LED(); 
2B9A:  CALL   0144
....................    startup_counter++; 
2B9E:  INCF   32,F
2BA0:  BTFSC  FD8.2
2BA2:  INCF   33,F
....................    write_eeprom_data(0); 
2BA4:  CLRF   xBF
2BA6:  CALL   0A3C
....................    solar_load_parameter_from_flash(); 
2BAA:  GOTO   0DF6
....................    setup_wdt(WDT_ON); 
2BAE:  BSF    FD1.0
....................  
....................    while(1) { 
....................       if (flag.cmd_posted==1) process_cmd_msg(); 
2BB0:  BTFSS  1F.3
2BB2:  BRA    2BB8
2BB4:  GOTO   1D5E
....................       if (bit_test(RCSTA,1)==1) init_rs232(); 
2BB8:  BTFSS  FAB.1
2BBA:  BRA    2BC0
2BBC:  CALL   0124
....................       for(act_loop=0;act_loop<4;act_loop++) 
2BC0:  CLRF   xB9
2BC2:  MOVF   xB9,W
2BC4:  SUBLW  03
2BC6:  BNC   2C34
....................       { 
....................          if (bit_test(actuator_move_mask,act_loop)==1){ 
2BC8:  MOVFF  B4,00
2BCC:  MOVF   xB9,W
2BCE:  MOVWF  01
2BD0:  BZ    2BDA
2BD2:  BCF    FD8.0
2BD4:  RRCF   00,F
2BD6:  DECFSZ 01,F
2BD8:  BRA    2BD2
2BDA:  BTFSS  00.0
2BDC:  BRA    2C30
....................             if (act_full_stroke_tick[act_loop]>0x0010) { 
2BDE:  BCF    FD8.0
2BE0:  RLCF   xB9,W
2BE2:  CLRF   03
2BE4:  ADDLW  94
2BE6:  MOVWF  FE9
2BE8:  MOVLW  00
2BEA:  ADDWFC 03,W
2BEC:  MOVWF  FEA
2BEE:  MOVFF  FEC,BC
2BF2:  MOVF   FED,F
2BF4:  MOVFF  FEF,BB
2BF8:  MOVF   xBC,F
2BFA:  BNZ   2C02
2BFC:  MOVF   xBB,W
2BFE:  SUBLW  10
2C00:  BC    2C30
....................                solar_get_act_length(act_loop); 
2C02:  MOVFF  B9,BF
2C06:  CALL   16E6
....................              actuator_move_execute(act_loop); 
2C0A:  MOVFF  B9,BF
2C0E:  CALL   1556
....................                bit_clear(actuator_move_mask,act_loop); 
2C12:  MOVLW  01
2C14:  MOVWF  00
2C16:  MOVF   xB9,W
2C18:  MOVWF  01
2C1A:  BZ    2C24
2C1C:  BCF    FD8.0
2C1E:  RLCF   00,F
2C20:  DECFSZ 01,F
2C22:  BRA    2C1C
2C24:  MOVF   00,W
2C26:  XORLW  FF
2C28:  ANDWF  xB4,F
....................             write_eeprom_data(0); 
2C2A:  CLRF   xBF
2C2C:  CALL   0A3C
....................             //print_date_time(); 
....................          }  
....................          } 
....................       } 
2C30:  INCF   xB9,F
2C32:  BRA    2BC2
....................  
....................       if (nButton==0) { 
2C34:  MOVF   4B,F
2C36:  BNZ   2C3A
....................           button_menu(); 
2C38:  BRA    25EA
....................       } 
....................       restart_wdt(); 
2C3A:  CLRWDT
....................         kk = read_adc(); 
2C3C:  BSF    FC2.2
2C3E:  BTFSC  FC2.2
2C40:  BRA    2C3E
2C42:  MOVFF  FC3,B7
2C46:  MOVFF  FC4,B8
....................        if ((read_adc()+read_adc()+read_adc()+read_adc())/4 < 600) sleep(); 
2C4A:  BSF    FC2.2
2C4C:  BTFSC  FC2.2
2C4E:  BRA    2C4C
2C50:  MOVFF  FC4,03
2C54:  MOVFF  FC3,BB
2C58:  MOVFF  FC4,BC
2C5C:  BSF    FC2.2
2C5E:  BTFSC  FC2.2
2C60:  BRA    2C5E
2C62:  MOVFF  FC4,03
2C66:  MOVF   FC3,W
2C68:  ADDWF  xBB,F
2C6A:  MOVF   FC4,W
2C6C:  ADDWFC xBC,F
2C6E:  BSF    FC2.2
2C70:  BTFSC  FC2.2
2C72:  BRA    2C70
2C74:  MOVFF  FC4,03
2C78:  MOVF   FC3,W
2C7A:  ADDWF  xBB,F
2C7C:  MOVF   FC4,W
2C7E:  ADDWFC xBC,F
2C80:  BSF    FC2.2
2C82:  BTFSC  FC2.2
2C84:  BRA    2C82
2C86:  MOVFF  FC4,03
2C8A:  MOVF   FC3,W
2C8C:  ADDWF  xBB,F
2C8E:  MOVF   FC4,W
2C90:  ADDWFC xBC,F
2C92:  RRCF   xBC,F
2C94:  RRCF   xBB,F
2C96:  RRCF   xBC,F
2C98:  RRCF   xBB,F
2C9A:  MOVLW  3F
2C9C:  ANDWF  xBC,F
2C9E:  MOVF   xBC,W
2CA0:  SUBLW  02
2CA2:  BNC   2CAE
2CA4:  BNZ   2CAC
2CA6:  MOVF   xBB,W
2CA8:  SUBLW  57
2CAA:  BTFSC  FD8.0
2CAC:  SLEEP 
....................    } 
2CAE:  BRA    2BB0
....................  
.................... DEAD_TRAP: while(1); 
2CB0:  BRA    2CB0
.................... } 
2CB2:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E000   WRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 7E 04 7F 03 80 02 81 01 

F00010: 00 00 01 00 02 00 03 00 

F00020: 00 00 00 00 01 00 00 00 

F00030: 00 00 

F00040: 34 12 

F00050: FE FF 

F00060: 80 4C 81 4C 82 4C 83 4C 

F00070: 80 7B 81 7B 82 7B 83 7B 
