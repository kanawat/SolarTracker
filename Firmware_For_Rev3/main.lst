CCS PCH C Compiler, Version 4.093, 5967               17-Sep-12 23:18

               Filename: main.lst

               ROM used: 11516 bytes (35%)
                         Largest free fragment is 21248
               RAM used: 189 (12%) at main() level
                         239 (16%) worst case
               Stack:    9 worst case (5 in main + 4 for interrupts)

*
0000:  GOTO   2994
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   01E4
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04E0
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  MOVFF  0D,FE9
007C:  MOVFF  08,FEA
0080:  BSF    08.7
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #define NETWORK_COMM 1 
.................... #include <solar_lib.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <math.h> 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20,NOLVP,WRT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
0178:  CLRF   FEA
017A:  MOVLW  E2
017C:  MOVWF  FE9
017E:  MOVF   FEF,W
0180:  BZ    019E
0182:  MOVLW  03
0184:  MOVWF  01
0186:  CLRF   00
0188:  DECFSZ 00,F
018A:  BRA    0188
018C:  DECFSZ 01,F
018E:  BRA    0186
0190:  MOVLW  3C
0192:  MOVWF  00
0194:  DECFSZ 00,F
0196:  BRA    0194
0198:  BRA    019A
019A:  DECFSZ FEF,F
019C:  BRA    0182
019E:  RETLW  00
*
1D42:  MOVLW  07
1D44:  SUBWF  xC0,F
1D46:  BNC   1D5E
1D48:  CLRF   FEA
1D4A:  MOVLW  C0
1D4C:  MOVWF  FE9
1D4E:  BCF    FD8.0
1D50:  RRCF   FEF,F
1D52:  MOVF   FEF,W
1D54:  BZ    1D5E
1D56:  BRA    1D5A
1D58:  BRA    1D5A
1D5A:  DECFSZ FEF,F
1D5C:  BRA    1D58
1D5E:  GOTO   25A8 (RETURN)
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N,BITS=8) 
*
0444:  BTFSS  F9E.4
0446:  BRA    0444
0448:  MOVWF  FAD
044A:  RETLW  00
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, BITS=8, MSB_FIRST, IDLE=0) 
....................  
....................  
....................  
....................  
....................  
.................... struct port_d_map{ 
....................    int8 data_bus:4; //0:3 
....................    boolean rs;     //4 
....................    boolean LED_latch;  //5 
....................    boolean MUX_en;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte SSPCON2 = 0xFC5 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1  = 0xFCE 
.................... #byte T1CON = 0xFCD 
....................  
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1 PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3 PIN_B3 
.................... #define CCW PIN_B4 
.................... #define SENSE_0     PIN_A2 
.................... #define SENSE_1     PIN_A3 
.................... #define SENSE_2     PIN_A4 
.................... #define SENSE_3     PIN_A5 
.................... #define WALL_PWR    PIN_A0 //input 
.................... #define FLASH_CS PIN_C2 
.................... #define TX_EN PIN_E1 
....................  
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00010 
.................... #define ADDR_TIME           0xf00020 
.................... #define ADDR_START_COUNTER  0xf00030 
.................... #define ADDR_ACT_MIN_LEN    0xf00060 
.................... #define ADDR_ACT_MAX_LEN    0xf00070 
....................  
.................... #define MAX_FULL_STROKE 6000 
.................... #rom ADDR_FULL_STROKE={0x047E,0x037F,0x0280,0x0181} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000,0x0001,0x0002,0x0003} 
.................... #rom ADDR_TIME={0x0000,0x0000,0x0001,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... #rom 0xf00040 ={0x1234} // to check if eeprom can be read properly 
.................... #rom 0xf00050 ={0xFFFE} // device ID 
.................... #rom ADDR_ACT_MIN_LEN={0x4C80,0x4C81,0x4C82,0x4C83} 
.................... #rom ADDR_ACT_MAX_LEN={0x7B80,0x7B81,0x7B82,0x7B83} 
....................  
.................... ////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////// flag 
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct flag2 { 
....................    boolean en_operate; 
....................    boolean button_pressed; 
....................    boolean abort_current_activity; 
....................    boolean allow_manual_move_act; 
....................    boolean current_pulse_state; 
....................    boolean power; 
....................    boolean is_moving; 
....................    boolean unused3; 
.................... } flag2; 
....................  
.................... struct LED_status { 
....................   boolean power; 
....................   boolean operation; 
....................   int8 aux:2; 
....................   int8 unused:4; 
.................... } LED_status; 
....................  
.................... /////////////////////////// timer_related 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... unsigned int32 nDay=1; 
.................... unsigned int16 startup_counter=0; 
.................... /////////////////////////// command processing 
.................... int16 dev_id = 0x0075; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... int8 nButton=-1; 
.................... unsigned int32 last_command =0; 
.................... int8 de_stuffing_mask = 0x00; 
.................... int8 command_byte=0x00; 
.................... int16 aux_command; 
.................... int8 output_buffer[36]; 
.................... int8 output_checksum; 
.................... /////////////////////////// flash_related_variable 
.................... int8 flash_mfg_id[4]; 
.................... int8 flash_stat=0; 
.................... int8 flash_page_data=0; 
.................... int8 flash_page_data2=0; 
.................... /////////////////////////// actuator related 
.................... int16 move_act_time_out=2; 
.................... int16 actuator_pulse=0; 
.................... int16 last_actuator_pulse; 
.................... float act_len; 
.................... unsigned int16 current_act_position[4]={0,0,0,0}; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int16 act_full_stroke_tick[4]={0,0,0,0}; 
.................... unsigned int16 act_max_stroke[4]={0,0,0,0}; 
.................... unsigned int16 act_min_stroke[4]={0,0,0,0}; 
.................... unsigned int16 act_safety_stroke=0; 
.................... unsigned int16 latitude=0; 
.................... unsigned int16 longitude=0; 
.................... unsigned int16 altitude=0; 
.................... int8 actuator_move_mask=0x00; 
.................... ///////////////////PROTOTYPE/////////////////////////////////// 
.................... void button_scan(); 
.................... void stuff_data(int8 data_to_stuff); 
.................... void send_data(int8 packet_type,int8 size); 
.................... void process_cmd_msg(); 
.................... ///////////////////////////////////////////////////// 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
0124:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
0126:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
0128:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
012A:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
012C:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
012E:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
0130:  BCF    FAC.5
....................    delay_cycles(10); 
0132:  MOVLW  03
0134:  MOVWF  00
0136:  DECFSZ 00,F
0138:  BRA    0136
....................    bit_set(RCSTA,4); //CREN=1 
013A:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
013C:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
013E:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
0140:  BSF    F9D.5
....................  
.................... } 
0142:  RETLW  00
....................  
....................  
.................... void flash_read_mfg_id() { 
.................... 		output_low(FLASH_CS); 
*
060A:  BCF    F94.2
060C:  BCF    F8B.2
.................... 		delay_cycles(20); 
060E:  MOVLW  06
0610:  MOVWF  00
0612:  DECFSZ 00,F
0614:  BRA    0612
0616:  NOP   
.................... 		spi_write(0x9F); 
0618:  MOVF   FC9,W
061A:  MOVLW  9F
061C:  MOVWF  FC9
061E:  RRCF   FC7,W
0620:  BNC   061E
.................... 		flash_mfg_id[0] = spi_read(0); 
0622:  MOVF   FC9,W
0624:  CLRF   FC9
0626:  RRCF   FC7,W
0628:  BNC   0626
062A:  MOVFF  FC9,79
.................... 		flash_mfg_id[1] = spi_read(0); 
062E:  MOVF   FC9,W
0630:  CLRF   FC9
0632:  RRCF   FC7,W
0634:  BNC   0632
0636:  MOVFF  FC9,7A
.................... 		flash_mfg_id[2] = spi_read(0); 
063A:  MOVF   FC9,W
063C:  CLRF   FC9
063E:  RRCF   FC7,W
0640:  BNC   063E
0642:  MOVFF  FC9,7B
.................... 		flash_mfg_id[3] = spi_read(0); 
0646:  MOVF   FC9,W
0648:  CLRF   FC9
064A:  RRCF   FC7,W
064C:  BNC   064A
064E:  MOVFF  FC9,7C
.................... 		delay_cycles(20); 
0652:  MOVLW  06
0654:  MOVWF  00
0656:  DECFSZ 00,F
0658:  BRA    0656
065A:  NOP   
.................... 		output_high(FLASH_CS); 
065C:  BCF    F94.2
065E:  BSF    F8B.2
.................... } 
0660:  GOTO   2B76 (RETURN)
....................  
.................... void flash_read_stat() { 
.................... 		output_low(FLASH_CS); 
*
05B2:  BCF    F94.2
05B4:  BCF    F8B.2
.................... 		delay_cycles(20); 
05B6:  MOVLW  06
05B8:  MOVWF  00
05BA:  DECFSZ 00,F
05BC:  BRA    05BA
05BE:  NOP   
.................... 		spi_write(0xD7); 
05C0:  MOVF   FC9,W
05C2:  MOVLW  D7
05C4:  MOVWF  FC9
05C6:  RRCF   FC7,W
05C8:  BNC   05C6
.................... 		flash_stat = spi_read(0); 
05CA:  MOVF   FC9,W
05CC:  CLRF   FC9
05CE:  RRCF   FC7,W
05D0:  BNC   05CE
05D2:  MOVFF  FC9,7D
.................... 		delay_cycles(20); 
05D6:  MOVLW  06
05D8:  MOVWF  00
05DA:  DECFSZ 00,F
05DC:  BRA    05DA
05DE:  NOP   
.................... 		output_high(FLASH_CS); 
05E0:  BCF    F94.2
05E2:  BSF    F8B.2
.................... } 
05E4:  RETLW  00
....................  
.................... void flash_wait_until_ready() { 
....................    int8 wait_loop=0; 
05E6:  CLRF   xD0
....................    for ( wait_loop=0; wait_loop<0xFF; wait_loop++) { 
05E8:  CLRF   xD0
05EA:  INCFSZ xD0,W
05EC:  BRA    05F0
05EE:  BRA    0608
.................... 	 flash_read_stat(); 
05F0:  RCALL  05B2
....................      if ((flash_stat & 0xBF)==0x9C) break; 
05F2:  MOVF   x7D,W
05F4:  ANDLW  BF
05F6:  SUBLW  9C
05F8:  BNZ   05FC
05FA:  BRA    0608
.................... 	 delay_cycles(100); 
05FC:  MOVLW  21
05FE:  MOVWF  00
0600:  DECFSZ 00,F
0602:  BRA    0600
....................    } 
0604:  INCF   xD0,F
0606:  BRA    05EA
.................... } 
0608:  RETLW  00
....................  
.................... void flash_read_page(int16 pageAddress, int8 pageIndex) { 
....................  
.................... 	//pageAddress <<= 1; 
.................... 	//pageAddress &= 0xFE; 
....................     if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0D70:  MOVF   x7A,W
0D72:  SUBLW  26
0D74:  BNZ   0D7C
0D76:  BCF    FD8.0
0D78:  RLCF   xCD,F
0D7A:  RLCF   xCE,F
.................... 	flash_wait_until_ready(); 
0D7C:  RCALL  05E6
....................    	output_low(FLASH_CS); 
0D7E:  BCF    F94.2
0D80:  BCF    F8B.2
.................... 	delay_cycles(20); 
0D82:  MOVLW  06
0D84:  MOVWF  00
0D86:  DECFSZ 00,F
0D88:  BRA    0D86
0D8A:  NOP   
....................    	spi_write(0xD2); 
0D8C:  MOVF   FC9,W
0D8E:  MOVLW  D2
0D90:  MOVWF  FC9
0D92:  RRCF   FC7,W
0D94:  BNC   0D92
....................     spi_write(make8(pageAddress,1)); 
0D96:  MOVFF  CE,D0
0D9A:  MOVF   FC9,W
0D9C:  MOVFF  CE,FC9
0DA0:  RRCF   FC7,W
0DA2:  BNC   0DA0
....................     spi_write(make8(pageAddress,0)); 
0DA4:  MOVFF  CD,D0
0DA8:  MOVF   FC9,W
0DAA:  MOVFF  CD,FC9
0DAE:  RRCF   FC7,W
0DB0:  BNC   0DAE
....................     spi_write(pageIndex); 
0DB2:  MOVF   FC9,W
0DB4:  MOVFF  CF,FC9
0DB8:  RRCF   FC7,W
0DBA:  BNC   0DB8
....................     spi_write(0); 
0DBC:  MOVF   FC9,W
0DBE:  CLRF   FC9
0DC0:  RRCF   FC7,W
0DC2:  BNC   0DC0
....................     spi_write(0); 
0DC4:  MOVF   FC9,W
0DC6:  CLRF   FC9
0DC8:  RRCF   FC7,W
0DCA:  BNC   0DC8
....................     spi_write(0); 
0DCC:  MOVF   FC9,W
0DCE:  CLRF   FC9
0DD0:  RRCF   FC7,W
0DD2:  BNC   0DD0
....................     spi_write(0); 
0DD4:  MOVF   FC9,W
0DD6:  CLRF   FC9
0DD8:  RRCF   FC7,W
0DDA:  BNC   0DD8
.................... 	flash_page_data = spi_read(0); 
0DDC:  MOVF   FC9,W
0DDE:  CLRF   FC9
0DE0:  RRCF   FC7,W
0DE2:  BNC   0DE0
0DE4:  MOVFF  FC9,7E
.................... 	flash_page_data2 = spi_read(0); 
0DE8:  MOVF   FC9,W
0DEA:  CLRF   FC9
0DEC:  RRCF   FC7,W
0DEE:  BNC   0DEC
0DF0:  MOVFF  FC9,7F
....................    	output_high(FLASH_CS); 
0DF4:  BCF    F94.2
0DF6:  BSF    F8B.2
.................... } 
0DF8:  RETLW  00
....................  
.................... void flash_block_erase() { 
....................    int8 i,j; 
....................    i=0xFF; 
*
0E46:  MOVLW  FF
0E48:  MOVWF  xBF
....................    do 
....................    { 
....................    i++; 
0E4A:  INCF   xBF,F
....................    flash_wait_until_ready(); 
0E4C:  CALL   05E6
....................    output_low(FLASH_CS); 
0E50:  BCF    F94.2
0E52:  BCF    F8B.2
....................    spi_write(0x50); 
0E54:  MOVF   FC9,W
0E56:  MOVLW  50
0E58:  MOVWF  FC9
0E5A:  RRCF   FC7,W
0E5C:  BNC   0E5A
....................    j = i>>5; 
0E5E:  SWAPF  xBF,W
0E60:  MOVWF  xC0
0E62:  RRCF   xC0,F
0E64:  MOVLW  07
0E66:  ANDWF  xC0,F
....................    spi_write(j); 
0E68:  MOVF   FC9,W
0E6A:  MOVFF  C0,FC9
0E6E:  RRCF   FC7,W
0E70:  BNC   0E6E
....................    j = i<<3; 
0E72:  RLCF   xBF,W
0E74:  MOVWF  xC0
0E76:  RLCF   xC0,F
0E78:  RLCF   xC0,F
0E7A:  MOVLW  F8
0E7C:  ANDWF  xC0,F
....................    spi_write(j); 
0E7E:  MOVF   FC9,W
0E80:  MOVFF  C0,FC9
0E84:  RRCF   FC7,W
0E86:  BNC   0E84
....................    spi_write(0); 
0E88:  MOVF   FC9,W
0E8A:  CLRF   FC9
0E8C:  RRCF   FC7,W
0E8E:  BNC   0E8C
....................    output_high(FLASH_CS); 
0E90:  BCF    F94.2
0E92:  BSF    F8B.2
....................    } while(i!=0xFF); 
0E94:  INCFSZ xBF,W
0E96:  BRA    0E4A
....................    flash_wait_until_ready(); 
0E98:  CALL   05E6
.................... } 
0E9C:  GOTO   1E0A (RETURN)
....................  
.................... void flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
101A:  CALL   05E6
....................    output_low(FLASH_CS); 
101E:  BCF    F94.2
1020:  BCF    F8B.2
....................    delay_cycles(20); 
1022:  MOVLW  06
1024:  MOVWF  00
1026:  DECFSZ 00,F
1028:  BRA    1026
102A:  NOP   
....................    spi_write(0x84); 
102C:  MOVF   FC9,W
102E:  MOVLW  84
1030:  MOVWF  FC9
1032:  RRCF   FC7,W
1034:  BNC   1032
....................    spi_write(0); 
1036:  MOVF   FC9,W
1038:  CLRF   FC9
103A:  RRCF   FC7,W
103C:  BNC   103A
....................    spi_write(0); 
103E:  MOVF   FC9,W
1040:  CLRF   FC9
1042:  RRCF   FC7,W
1044:  BNC   1042
....................    spi_write(PageIndex); 
1046:  MOVF   FC9,W
1048:  MOVFF  C0,FC9
104C:  RRCF   FC7,W
104E:  BNC   104C
....................    if (nData>1) { 
1050:  MOVF   xC1,W
1052:  SUBLW  01
1054:  BC    106E
....................    i=255; 
1056:  MOVLW  FF
1058:  MOVWF  xC2
....................    do { 
....................       spi_write(data); 
105A:  MOVF   FC9,W
105C:  MOVFF  BF,FC9
1060:  RRCF   FC7,W
1062:  BNC   1060
....................       i++; 
1064:  INCF   xC2,F
....................    } while(i<nData); 
1066:  MOVF   xC1,W
1068:  SUBWF  xC2,W
106A:  BNC   105A
....................    } else 
106C:  BRA    1078
....................          spi_write(data); 
106E:  MOVF   FC9,W
1070:  MOVFF  BF,FC9
1074:  RRCF   FC7,W
1076:  BNC   1074
....................    output_high(FLASH_CS); 
1078:  BCF    F94.2
107A:  BSF    F8B.2
.................... } 
107C:  RETLW  00
....................  
.................... void flash_buffer1_read(int8 PageIndex) { 
....................    int i; 
....................    flash_wait_until_ready(); 
....................    output_low(FLASH_CS); 
....................    delay_cycles(20); 
....................    spi_write(0xD4); // use 0xD4 must have 1 dummy byte after address bytes 
....................    spi_write(0); 
....................    spi_write(0); 
....................    spi_write(PageIndex); 
....................    spi_write(0); // dummy byte required 
....................    flash_page_data = spi_read(0); 
....................    flash_page_data2 = spi_read(0); 
....................    output_high(FLASH_CS);    
.................... } 
....................  
.................... void flash_set_256_page_size() { 
....................    flash_wait_until_ready(); 
107E:  CALL   05E6
....................    output_low(FLASH_CS); 
1082:  BCF    F94.2
1084:  BCF    F8B.2
....................    delay_cycles(20); 
1086:  MOVLW  06
1088:  MOVWF  00
108A:  DECFSZ 00,F
108C:  BRA    108A
108E:  NOP   
....................    spi_write(0x3D); 
1090:  MOVF   FC9,W
1092:  MOVLW  3D
1094:  MOVWF  FC9
1096:  RRCF   FC7,W
1098:  BNC   1096
....................    spi_write(0x2A); 
109A:  MOVF   FC9,W
109C:  MOVLW  2A
109E:  MOVWF  FC9
10A0:  RRCF   FC7,W
10A2:  BNC   10A0
....................    spi_write(0x80); 
10A4:  MOVF   FC9,W
10A6:  MOVLW  80
10A8:  MOVWF  FC9
10AA:  RRCF   FC7,W
10AC:  BNC   10AA
....................    spi_write(0xA6); 
10AE:  MOVF   FC9,W
10B0:  MOVLW  A6
10B2:  MOVWF  FC9
10B4:  RRCF   FC7,W
10B6:  BNC   10B4
....................    output_high(FLASH_CS);  
10B8:  BCF    F94.2
10BA:  BSF    F8B.2
.................... } 
10BC:  GOTO   1EC4 (RETURN)
....................  
.................... void flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0EA0:  MOVF   x7A,W
0EA2:  SUBLW  26
0EA4:  BNZ   0EAC
0EA6:  BCF    FD8.0
0EA8:  RLCF   xBF,F
0EAA:  RLCF   xC0,F
....................    flash_wait_until_ready(); 
0EAC:  CALL   05E6
....................    output_low(FLASH_CS); 
0EB0:  BCF    F94.2
0EB2:  BCF    F8B.2
....................    delay_cycles(20);	 
0EB4:  MOVLW  06
0EB6:  MOVWF  00
0EB8:  DECFSZ 00,F
0EBA:  BRA    0EB8
0EBC:  NOP   
....................    spi_write(0x83); 
0EBE:  MOVF   FC9,W
0EC0:  MOVLW  83
0EC2:  MOVWF  FC9
0EC4:  RRCF   FC7,W
0EC6:  BNC   0EC4
....................    spi_write(make8(pageAddress,1)); 
0EC8:  MOVFF  C0,C1
0ECC:  MOVF   FC9,W
0ECE:  MOVFF  C0,FC9
0ED2:  RRCF   FC7,W
0ED4:  BNC   0ED2
....................    spi_write(make8(pageAddress,0)); 
0ED6:  MOVFF  BF,C1
0EDA:  MOVF   FC9,W
0EDC:  MOVFF  BF,FC9
0EE0:  RRCF   FC7,W
0EE2:  BNC   0EE0
....................    spi_write(0); 
0EE4:  MOVF   FC9,W
0EE6:  CLRF   FC9
0EE8:  RRCF   FC7,W
0EEA:  BNC   0EE8
....................    output_high(FLASH_CS); 
0EEC:  BCF    F94.2
0EEE:  BSF    F8B.2
.................... } 
0EF0:  GOTO   1E36 (RETURN)
....................  
.................... void flash_write_page(int16 pageAddress) { 
....................    int8 i,check_sum; 
....................    char input_data; 
....................    disable_interrupts(GLOBAL); 
*
10C0:  BCF    FF2.6
10C2:  BCF    FF2.7
10C4:  BTFSC  FF2.7
10C6:  BRA    10C2
....................    //output_high(FLASH_CS); 
....................    flash_wait_until_ready(); 
10C8:  CALL   05E6
....................    delay_cycles(50); 
10CC:  MOVLW  10
10CE:  MOVWF  00
10D0:  DECFSZ 00,F
10D2:  BRA    10D0
10D4:  NOP   
....................    output_low(FLASH_CS); 
10D6:  BCF    F94.2
10D8:  BCF    F8B.2
....................    if (pageAddress%2) spi_write(0x82); else spi_write(0x85); 
10DA:  MOVF   xBF,W
10DC:  ANDLW  01
10DE:  MOVWF  00
10E0:  CLRF   03
10E2:  MOVF   00,W
10E4:  IORWF  03,W
10E6:  BZ    10F4
10E8:  MOVF   FC9,W
10EA:  MOVLW  82
10EC:  MOVWF  FC9
10EE:  RRCF   FC7,W
10F0:  BNC   10EE
10F2:  BRA    10FE
10F4:  MOVF   FC9,W
10F6:  MOVLW  85
10F8:  MOVWF  FC9
10FA:  RRCF   FC7,W
10FC:  BNC   10FA
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
10FE:  MOVF   x7A,W
1100:  SUBLW  26
1102:  BNZ   110A
1104:  BCF    FD8.0
1106:  RLCF   xBF,F
1108:  RLCF   xC0,F
....................    spi_write(make8(pageAddress,1)); 
110A:  MOVFF  C0,C4
110E:  MOVF   FC9,W
1110:  MOVFF  C0,FC9
1114:  RRCF   FC7,W
1116:  BNC   1114
....................    spi_write(make8(pageAddress,0)); 
1118:  MOVFF  BF,C4
111C:  MOVF   FC9,W
111E:  MOVFF  BF,FC9
1122:  RRCF   FC7,W
1124:  BNC   1122
....................    spi_write(0); 
1126:  MOVF   FC9,W
1128:  CLRF   FC9
112A:  RRCF   FC7,W
112C:  BNC   112A
....................    check_sum=0; 
112E:  CLRF   xC2
....................    i=0xFF; 
1130:  MOVLW  FF
1132:  MOVWF  xC1
....................    check_sum=0xCC; 
1134:  MOVLW  CC
1136:  MOVWF  xC2
....................    do { 
....................       input_data = getc(); 
1138:  BTFSS  F9E.5
113A:  BRA    1138
113C:  MOVFF  FAE,C3
....................       check_sum ^= input_data; 
1140:  MOVF   xC3,W
1142:  XORWF  xC2,F
....................       spi_write(input_data); 
1144:  MOVF   FC9,W
1146:  MOVFF  C3,FC9
114A:  RRCF   FC7,W
114C:  BNC   114A
....................       i++; 
114E:  INCF   xC1,F
....................    } while(i!=0xFF); 
1150:  INCFSZ xC1,W
1152:  BRA    1138
....................    output_high(FLASH_CS); 
1154:  BCF    F94.2
1156:  BSF    F8B.2
....................    enable_interrupts(GLOBAL); 
1158:  MOVLW  C0
115A:  IORWF  FF2,F
.................... } 
115C:  GOTO   1EF2 (RETURN)
....................  
.................... void flash_read_main_memory_to_buffer1(int16 pageAddress) { 
....................    flash_wait_until_ready(); 
*
0EF4:  CALL   05E6
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
0EF8:  MOVF   x7A,W
0EFA:  SUBLW  26
0EFC:  BNZ   0F04
0EFE:  BCF    FD8.0
0F00:  RLCF   xBF,F
0F02:  RLCF   xC0,F
....................    output_low(FLASH_CS); 
0F04:  BCF    F94.2
0F06:  BCF    F8B.2
....................    spi_write(0x53); 
0F08:  MOVF   FC9,W
0F0A:  MOVLW  53
0F0C:  MOVWF  FC9
0F0E:  RRCF   FC7,W
0F10:  BNC   0F0E
....................    spi_write(make8(pageAddress,1)); 
0F12:  MOVFF  C0,C1
0F16:  MOVF   FC9,W
0F18:  MOVFF  C0,FC9
0F1C:  RRCF   FC7,W
0F1E:  BNC   0F1C
....................    spi_write(make8(pageAddress,0)); 
0F20:  MOVFF  BF,C1
0F24:  MOVF   FC9,W
0F26:  MOVFF  BF,FC9
0F2A:  RRCF   FC7,W
0F2C:  BNC   0F2A
....................    spi_write(0); 
0F2E:  MOVF   FC9,W
0F30:  CLRF   FC9
0F32:  RRCF   FC7,W
0F34:  BNC   0F32
....................    output_high(FLASH_CS); 
0F36:  BCF    F94.2
0F38:  BSF    F8B.2
.................... } 
0F3A:  GOTO   1E66 (RETURN)
....................  
.................... /* 
.................... void print_date_time() { 
....................  
.................... 	  printf("\r\n Day#%lu, ",nDay); 
....................       strcpy(tmp_str,"00:00:00"); 
....................       itoa((int8) (timer_sec/3600),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) ((timer_sec%3600)/60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) (timer_sec%60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................    	  printf("%s",tmp_str); 
.................... } 
....................  
.................... void print_page_data(int16 nPage) { 
.................... // filled output buffer with memory content in flash page memory 
....................     int8 i; 
....................     int8 j; 
....................     for(i=0;i<16;i++) { 
....................       //printf("\r\n%02X : ",i); 
....................       for (j=0;j<8;j++) { 
....................         flash_read_page(nPage,i*16+j*2); 
.................... 		output_buffer[i*16+j*2] = flash_page_data; 
.................... 		output_buffer[i*16+j*2+1] = flash_page_data2; 
.................... 		//printf("%02X %02X ",flash_page_data,flash_page_data2); 
.................... 	  } 
....................    } 
.................... } 
.................... */ 
.................... void solar_load_parameter_from_flash() { 
....................     // this section is no longer required. min/max strokes are loaded from eeprom 
....................     //flash_read_page(0,0x4E);  
.................... 	//act_min_stroke[0] = make16(flash_page_data2,flash_page_data); 
....................     //flash_read_page(0,0x50);  
.................... 	//act_max_stroke[0] = make16(flash_page_data2,flash_page_data); 
....................     flash_read_page(0,0x56);  
*
0DFA:  CLRF   xCE
0DFC:  CLRF   xCD
0DFE:  MOVLW  56
0E00:  MOVWF  xCF
0E02:  RCALL  0D70
.................... 	latitude = make16(flash_page_data2,flash_page_data); 
0E04:  MOVFF  7F,AF
0E08:  MOVFF  7E,AE
....................     flash_read_page(0,0x58);  
0E0C:  CLRF   xCE
0E0E:  CLRF   xCD
0E10:  MOVLW  58
0E12:  MOVWF  xCF
0E14:  RCALL  0D70
.................... 	longitude = make16(flash_page_data2,flash_page_data); 
0E16:  MOVFF  7F,B1
0E1A:  MOVFF  7E,B0
....................     flash_read_page(0,0x5A);  
0E1E:  CLRF   xCE
0E20:  CLRF   xCD
0E22:  MOVLW  5A
0E24:  MOVWF  xCF
0E26:  RCALL  0D70
.................... 	altitude = make16(flash_page_data2,flash_page_data);	 
0E28:  MOVFF  7F,B3
0E2C:  MOVFF  7E,B2
....................     flash_read_page(0,0x5C);  
0E30:  CLRF   xCE
0E32:  CLRF   xCD
0E34:  MOVLW  5C
0E36:  MOVWF  xCF
0E38:  RCALL  0D70
.................... 	act_safety_stroke = make16(flash_page_data2,flash_page_data); 
0E3A:  MOVFF  7F,AD
0E3E:  MOVFF  7E,AC
.................... } 
0E42:  GOTO   2BFA (RETURN)
.................... /* 
.................... void print_fw_info() { 
....................     int8 i,j; 
.................... 	disable_interrupts(GLOBAL); 
....................     for (i=0;i<4;i++) { 
....................         printf("\r\n"); 
.................... 		for (j=0;j<8;j++) { 
....................     		flash_read_page(0,i*16+j*2); 
.................... 			printf("%c%c",flash_page_data,flash_page_data2); 
.................... 		} 
.................... 	} 
.................... 	flash_read_page(0,0x40); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................   	flash_read_page(0,0x42); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................     solar_load_parameter_from_flash(); 
.................... 	printf("\r\n Min Stroke=%lu/256 cm",act_min_stroke); 
.................... 	printf("\r\n Max Stroke=%lu/256 cm",act_max_stroke); 
.................... 	printf("\r\n Safty Stroke=%lu/256 cm",act_safety_stroke); 
.................... 	printf("\r\n Latitude=%lu/100",latitude); 
.................... 	printf("\r\n Longitude=%lu/100",longitude); 
.................... 	printf("\r\n Altitude =%lu/100",altitude); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... } 
.................... */ 
.................... void display_LED() { 
.................... 	portd.data_bus=LED_status; 
*
0144:  MOVF   21,W
0146:  ANDLW  0F
0148:  MOVWF  00
014A:  MOVLW  F0
014C:  ANDWF  F83,W
014E:  IORWF  00,W
0150:  MOVWF  F83
.................... 	delay_cycles(20); 
0152:  MOVLW  06
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  NOP   
.................... 	portd.LED_latch=1; 
015C:  BSF    F83.5
.................... 	delay_cycles(20); 
015E:  MOVLW  06
0160:  MOVWF  00
0162:  DECFSZ 00,F
0164:  BRA    0162
0166:  NOP   
.................... 	portd.LED_latch=0; 
0168:  BCF    F83.5
.................... 	delay_cycles(20); 
016A:  MOVLW  06
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
0172:  NOP   
.................... 	portd.LED_latch=1; 
0174:  BSF    F83.5
.................... } 
0176:  RETLW  00
....................  
.................... ///////////////////////////// 
.................... void stuff_data(int8 data_to_stuff) { 
.................... 	int8 stuffing_mask =0xFF; 
*
044C:  MOVLW  FF
044E:  MOVWF  xEC
.................... 	if ((data_to_stuff==0xA8) || (data_to_stuff==0xA9)) { 
0450:  MOVF   xEB,W
0452:  SUBLW  A8
0454:  BZ    045C
0456:  MOVF   xEB,W
0458:  SUBLW  A9
045A:  BNZ   0464
.................... 		printf("%c",0xA9); 
045C:  MOVLW  A9
045E:  RCALL  0444
.................... 		stuffing_mask = 0xDF; 
0460:  MOVLW  DF
0462:  MOVWF  xEC
.................... 	} 
.................... 	printf("%c",stuffing_mask&data_to_stuff); 
0464:  MOVF   xEC,W
0466:  ANDWF  xEB,W
0468:  MOVWF  xED
046A:  RCALL  0444
.................... } 
046C:  RETLW  00
.................... // send whatever in sent buffer 
.................... // packet_type:  
.................... //0= ACK,  
.................... //1=NACK,  
.................... //2=DATA, GENERIC,  
.................... //3 = BUFFER1 
.................... //4 = Acutator stat 
.................... //5 = Last acutator move pulse 
.................... //6 = SET 256 PAGE SIZE COMPLETE 
.................... //7 = BUSY 
.................... //8 = FLASH WRITE COMPLETE 
.................... //9 = DATE TIME 
.................... //10 = STATUS FLAGS 
.................... //11 = DEVICE ID 
.................... //12 = target act 
.................... void send_data(int8 packet_type,int8 size) { 
.................... 	int8 i; 
.................... 	output_checksum=0; 
046E:  CLRF   x78
.................... 	printf("%c",0xA8); 
0470:  MOVLW  A8
0472:  RCALL  0444
.................... 	stuff_data(make8(dev_id,1)); 
0474:  MOVFF  35,EA
0478:  MOVFF  35,EB
047C:  RCALL  044C
.................... 	output_checksum ^= make8(dev_id,1); 
047E:  MOVF   35,W
0480:  XORWF  x78,F
.................... 	stuff_data(make8(dev_id,0)); 
0482:  MOVFF  34,EA
0486:  MOVFF  34,EB
048A:  RCALL  044C
.................... 	output_checksum ^= make8(dev_id,0); 
048C:  MOVF   34,W
048E:  XORWF  x78,F
.................... 	stuff_data(packet_type); 
0490:  MOVFF  E7,EB
0494:  RCALL  044C
.................... 	output_checksum ^= packet_type; 
0496:  MOVF   xE7,W
0498:  XORWF  x78,F
.................... 	if (size >0) { 
049A:  MOVF   xE8,F
049C:  BZ    04D4
....................     	i = 0xFF; 
049E:  MOVLW  FF
04A0:  MOVWF  xE9
....................     	do { 
.................... 			i++; 
04A2:  INCF   xE9,F
.................... 			output_checksum ^=output_buffer[i]; 
04A4:  CLRF   03
04A6:  MOVF   xE9,W
04A8:  ADDLW  54
04AA:  MOVWF  FE9
04AC:  MOVLW  00
04AE:  ADDWFC 03,W
04B0:  MOVWF  FEA
04B2:  MOVF   FEF,W
04B4:  XORWF  x78,F
.................... 			stuff_data(output_buffer[i]); 
04B6:  CLRF   03
04B8:  MOVF   xE9,W
04BA:  ADDLW  54
04BC:  MOVWF  FE9
04BE:  MOVLW  00
04C0:  ADDWFC 03,W
04C2:  MOVWF  FEA
04C4:  MOVFF  FEF,EA
04C8:  MOVFF  EA,EB
04CC:  RCALL  044C
.................... 		} while(i<size); 
04CE:  MOVF   xE8,W
04D0:  SUBWF  xE9,W
04D2:  BNC   04A2
.................... 	} 
.................... 	stuff_data(output_checksum); 
04D4:  MOVFF  78,EB
04D8:  RCALL  044C
.................... 	printf("%c",0xA8); 
04DA:  MOVLW  A8
04DC:  RCALL  0444
.................... } 
04DE:  RETLW  00
.................... /////////////////////// send buffer 1 content 
.................... void send_buffer1_content() { 
....................  
....................    int8 i; 
....................    int8 buffer1_content; 
....................    output_checksum=0; 
*
0F3E:  CLRF   x78
....................    printf("%c",0xA8); 
0F40:  MOVLW  A8
0F42:  CALL   0444
....................    stuff_data(make8(dev_id,1)); 
0F46:  MOVFF  35,C1
0F4A:  CLRF   18
0F4C:  BTFSC  FF2.7
0F4E:  BSF    18.7
0F50:  BCF    FF2.7
0F52:  MOVFF  35,EB
0F56:  CALL   044C
0F5A:  BTFSC  18.7
0F5C:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,1); 
0F5E:  MOVF   35,W
0F60:  XORWF  x78,F
....................    stuff_data(make8(dev_id,0)); 
0F62:  MOVFF  34,C1
0F66:  CLRF   18
0F68:  BTFSC  FF2.7
0F6A:  BSF    18.7
0F6C:  BCF    FF2.7
0F6E:  MOVFF  34,EB
0F72:  CALL   044C
0F76:  BTFSC  18.7
0F78:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,0); 
0F7A:  MOVF   34,W
0F7C:  XORWF  x78,F
0F7E:  CLRF   18
0F80:  BTFSC  FF2.7
0F82:  BSF    18.7
0F84:  BCF    FF2.7
....................    stuff_data(0x03); 
0F86:  MOVLW  03
0F88:  MOVWF  xEB
0F8A:  CALL   044C
0F8E:  BTFSC  18.7
0F90:  BSF    FF2.7
....................    output_checksum ^= 0x03; 
0F92:  MOVLW  03
0F94:  XORWF  x78,F
....................  
....................    flash_wait_until_ready(); 
0F96:  CALL   05E6
....................    output_low(FLASH_CS); 
0F9A:  BCF    F94.2
0F9C:  BCF    F8B.2
....................    delay_cycles(20); 
0F9E:  MOVLW  06
0FA0:  MOVWF  00
0FA2:  DECFSZ 00,F
0FA4:  BRA    0FA2
0FA6:  NOP   
....................    spi_write(0xD1); 
0FA8:  MOVF   FC9,W
0FAA:  MOVLW  D1
0FAC:  MOVWF  FC9
0FAE:  RRCF   FC7,W
0FB0:  BNC   0FAE
....................    spi_write(0); 
0FB2:  MOVF   FC9,W
0FB4:  CLRF   FC9
0FB6:  RRCF   FC7,W
0FB8:  BNC   0FB6
....................    spi_write(0); 
0FBA:  MOVF   FC9,W
0FBC:  CLRF   FC9
0FBE:  RRCF   FC7,W
0FC0:  BNC   0FBE
....................    spi_write(0); 
0FC2:  MOVF   FC9,W
0FC4:  CLRF   FC9
0FC6:  RRCF   FC7,W
0FC8:  BNC   0FC6
....................     
....................    	i = 0xFF; 
0FCA:  MOVLW  FF
0FCC:  MOVWF  xBF
....................    	do { 
.................... 		i++; 
0FCE:  INCF   xBF,F
.................... 		buffer1_content = spi_read(0); 
0FD0:  MOVF   FC9,W
0FD2:  CLRF   FC9
0FD4:  RRCF   FC7,W
0FD6:  BNC   0FD4
0FD8:  MOVFF  FC9,C0
.................... 		output_checksum ^=buffer1_content; 
0FDC:  MOVF   xC0,W
0FDE:  XORWF  x78,F
0FE0:  CLRF   18
0FE2:  BTFSC  FF2.7
0FE4:  BSF    18.7
0FE6:  BCF    FF2.7
.................... 		stuff_data(buffer1_content); 
0FE8:  MOVFF  C0,EB
0FEC:  CALL   044C
0FF0:  BTFSC  18.7
0FF2:  BSF    FF2.7
.................... 		} while(i<255); 
0FF4:  INCFSZ xBF,W
0FF6:  BRA    0FCE
....................    output_high(FLASH_CS);   
0FF8:  BCF    F94.2
0FFA:  BSF    F8B.2
0FFC:  CLRF   18
0FFE:  BTFSC  FF2.7
1000:  BSF    18.7
1002:  BCF    FF2.7
....................  
....................    stuff_data(output_checksum); 
1004:  MOVFF  78,EB
1008:  CALL   044C
100C:  BTFSC  18.7
100E:  BSF    FF2.7
....................    printf("%c",0xA8); 
1010:  MOVLW  A8
1012:  CALL   0444
....................  
....................  
....................  
....................   
.................... } 
1016:  GOTO   1E8E (RETURN)
.................... //////////////////////////////////////////////////////////////////// 
.................... void solar_get_act_length(unsigned int8 nActuator) { 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 current_period_fraction; 
....................  
.................... 	unsigned int16 current_act_len; 
.................... 	unsigned int16 next_act_len; 
.................... 	 
....................     target_act_position =0; 
*
16EA:  CLRF   x93
16EC:  CLRF   x92
....................  
.................... 	flash_read_page(nDay,0x00);  // verify page number 
16EE:  MOVFF  2F,CB
16F2:  MOVFF  2E,CA
16F6:  MOVFF  2F,CE
16FA:  MOVFF  2E,CD
16FE:  CLRF   xCF
1700:  CALL   0D70
....................     if (nDay != make16(flash_page_data2,flash_page_data))  { 
1704:  MOVFF  7F,03
1708:  MOVF   x7E,W
170A:  SUBWF  2E,W
170C:  BNZ   171C
170E:  MOVF   03,W
1710:  SUBWF  2F,W
1712:  BNZ   171C
1714:  MOVF   30,F
1716:  BNZ   171C
1718:  MOVF   31,F
171A:  BZ    171E
.................... 		//printf("Error:Flash data corrupt"); 
.................... 		return; 
171C:  BRA    1CCC
.................... 	} 
....................     current_period = (timer_sec+225)/450; 
171E:  MOVLW  E1
1720:  ADDWF  22,W
1722:  MOVWF  xCA
1724:  MOVLW  00
1726:  ADDWFC 23,W
1728:  MOVWF  xCB
172A:  MOVLW  00
172C:  ADDWFC 24,W
172E:  MOVWF  xCC
1730:  MOVLW  00
1732:  ADDWFC 25,W
1734:  MOVWF  xCD
1736:  CLRF   18
1738:  BTFSC  FF2.7
173A:  BSF    18.7
173C:  BCF    FF2.7
173E:  MOVWF  xE5
1740:  MOVFF  CC,E4
1744:  MOVFF  CB,E3
1748:  MOVFF  CA,E2
174C:  CLRF   xE9
174E:  CLRF   xE8
1750:  MOVLW  01
1752:  MOVWF  xE7
1754:  MOVLW  C2
1756:  MOVWF  xE6
1758:  CALL   00AA
175C:  BTFSC  18.7
175E:  BSF    FF2.7
1760:  MOVFF  01,C3
1764:  MOVFF  00,C2
....................     current_period_fraction = (timer_sec+225)%450; 
1768:  MOVLW  E1
176A:  ADDWF  22,W
176C:  MOVWF  xCA
176E:  MOVLW  00
1770:  ADDWFC 23,W
1772:  MOVWF  xCB
1774:  MOVLW  00
1776:  ADDWFC 24,W
1778:  MOVWF  xCC
177A:  MOVLW  00
177C:  ADDWFC 25,W
177E:  MOVWF  xCD
1780:  CLRF   18
1782:  BTFSC  FF2.7
1784:  BSF    18.7
1786:  BCF    FF2.7
1788:  MOVWF  xE5
178A:  MOVFF  CC,E4
178E:  MOVFF  CB,E3
1792:  MOVFF  CA,E2
1796:  CLRF   xE9
1798:  CLRF   xE8
179A:  MOVLW  01
179C:  MOVWF  xE7
179E:  MOVLW  C2
17A0:  MOVWF  xE6
17A2:  CALL   00AA
17A6:  BTFSC  18.7
17A8:  BSF    FF2.7
17AA:  MOVFF  FEF,C4
17AE:  MOVFF  FEC,C5
....................     flash_read_page(nDay,0x02); // get sun rise time 
17B2:  MOVFF  2F,CB
17B6:  MOVFF  2E,CA
17BA:  MOVFF  2F,CE
17BE:  MOVFF  2E,CD
17C2:  MOVLW  02
17C4:  MOVWF  xCF
17C6:  CALL   0D70
....................     sun_rise_period=make16(flash_page_data2,flash_page_data); 
17CA:  MOVFF  7F,C1
17CE:  MOVFF  7E,C0
.................... 	if ((current_period < sun_rise_period) || (current_period > sun_rise_period+124)) // still dark 
17D2:  MOVF   xC3,W
17D4:  SUBWF  xC1,W
17D6:  BNC   17E0
17D8:  BNZ   17FE
17DA:  MOVF   xC0,W
17DC:  SUBWF  xC2,W
17DE:  BNC   17FE
17E0:  MOVLW  7C
17E2:  ADDWF  xC0,W
17E4:  MOVWF  01
17E6:  MOVLW  00
17E8:  ADDWFC xC1,W
17EA:  MOVWF  03
17EC:  MOVF   03,W
17EE:  SUBWF  xC3,W
17F0:  BTFSS  FD8.0
17F2:  BRA    1934
17F4:  BNZ   17FE
17F6:  MOVF   xC2,W
17F8:  SUBWF  01,W
17FA:  BTFSC  FD8.0
17FC:  BRA    1934
.................... 	{ 
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]*(int32)(act_safety_stroke-act_min_stroke[nActuator]); 
17FE:  BCF    FD8.0
1800:  RLCF   xBF,W
1802:  CLRF   03
1804:  ADDLW  94
1806:  MOVWF  FE9
1808:  MOVLW  00
180A:  ADDWFC 03,W
180C:  MOVWF  FEA
180E:  MOVFF  FEC,03
1812:  MOVF   FED,F
1814:  MOVFF  FEF,CA
1818:  MOVFF  03,CB
181C:  CLRF   xCC
181E:  CLRF   xCD
1820:  BCF    FD8.0
1822:  RLCF   xBF,W
1824:  CLRF   03
1826:  ADDLW  A4
1828:  MOVWF  FE9
182A:  MOVLW  00
182C:  ADDWFC 03,W
182E:  MOVWF  FEA
1830:  MOVFF  FEC,03
1834:  MOVF   FED,F
1836:  MOVF   FEF,W
1838:  SUBWF  xAC,W
183A:  MOVWF  00
183C:  MOVF   03,W
183E:  SUBWFB xAD,W
1840:  MOVWF  03
1842:  MOVF   00,W
1844:  MOVFF  03,01
1848:  CLRF   02
184A:  CLRF   03
184C:  MOVFF  03,D1
1850:  MOVFF  02,D0
1854:  MOVFF  01,CF
1858:  MOVFF  00,CE
185C:  MOVFF  FEA,D3
1860:  MOVFF  FE9,D2
1864:  MOVFF  CD,D7
1868:  MOVFF  CC,D6
186C:  MOVFF  CB,D5
1870:  MOVFF  CA,D4
1874:  MOVFF  03,DB
1878:  MOVFF  02,DA
187C:  MOVFF  01,D9
1880:  MOVFF  00,D8
1884:  RCALL  1506
1886:  MOVFF  D3,FEA
188A:  MOVFF  D2,FE9
188E:  MOVFF  03,29
1892:  MOVFF  02,28
1896:  MOVFF  01,27
189A:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke[nActuator]-act_min_stroke[nActuator]); 
189E:  BCF    FD8.0
18A0:  RLCF   xBF,W
18A2:  CLRF   03
18A4:  ADDLW  9C
18A6:  MOVWF  FE9
18A8:  MOVLW  00
18AA:  ADDWFC 03,W
18AC:  MOVWF  FEA
18AE:  MOVFF  FEC,CB
18B2:  MOVF   FED,F
18B4:  MOVFF  FEF,CA
18B8:  BCF    FD8.0
18BA:  RLCF   xBF,W
18BC:  CLRF   03
18BE:  ADDLW  A4
18C0:  MOVWF  FE9
18C2:  MOVLW  00
18C4:  ADDWFC 03,W
18C6:  MOVWF  FEA
18C8:  MOVFF  FEC,03
18CC:  MOVF   FED,F
18CE:  MOVF   FEF,W
18D0:  SUBWF  xCA,W
18D2:  MOVWF  00
18D4:  MOVF   03,W
18D6:  SUBWFB xCB,W
18D8:  MOVWF  03
18DA:  MOVFF  00,CA
18DE:  MOVWF  xCB
18E0:  MOVFF  FEA,CD
18E4:  MOVFF  FE9,CC
18E8:  CLRF   18
18EA:  BTFSC  FF2.7
18EC:  BSF    18.7
18EE:  BCF    FF2.7
18F0:  MOVFF  29,E5
18F4:  MOVFF  28,E4
18F8:  MOVFF  27,E3
18FC:  MOVFF  26,E2
1900:  CLRF   xE9
1902:  CLRF   xE8
1904:  MOVWF  xE7
1906:  MOVFF  00,E6
190A:  CALL   00AA
190E:  BTFSC  18.7
1910:  BSF    FF2.7
1912:  MOVFF  CD,FEA
1916:  MOVFF  CC,FE9
191A:  MOVFF  03,29
191E:  MOVFF  02,28
1922:  MOVFF  01,27
1926:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
192A:  MOVFF  27,93
192E:  MOVFF  26,92
.................... 	} else { 
1932:  BRA    1CCC
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+4); 
1934:  MOVFF  2F,CB
1938:  MOVFF  2E,CA
193C:  MOVF   xC0,W
193E:  SUBWF  xC2,W
1940:  MOVWF  00
1942:  MOVF   xC1,W
1944:  SUBWFB xC3,W
1946:  MOVWF  03
1948:  MOVF   00,W
194A:  BCF    FD8.0
194C:  RLCF   00,F
194E:  MOVF   00,W
1950:  ADDLW  04
1952:  MOVWF  xCC
1954:  MOVFF  2F,CE
1958:  MOVFF  2E,CD
195C:  MOVWF  xCF
195E:  CALL   0D70
.................... 		current_act_len = make16(flash_page_data2,flash_page_data); 
1962:  MOVFF  7F,C7
1966:  MOVFF  7E,C6
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+6); 
196A:  MOVFF  2F,CB
196E:  MOVFF  2E,CA
1972:  MOVF   xC0,W
1974:  SUBWF  xC2,W
1976:  MOVWF  00
1978:  MOVF   xC1,W
197A:  SUBWFB xC3,W
197C:  MOVWF  03
197E:  MOVF   00,W
1980:  BCF    FD8.0
1982:  RLCF   00,F
1984:  MOVF   00,W
1986:  ADDLW  06
1988:  MOVWF  xCC
198A:  MOVFF  2F,CE
198E:  MOVFF  2E,CD
1992:  MOVWF  xCF
1994:  CALL   0D70
.................... 		next_act_len = make16(flash_page_data2,flash_page_data); 
1998:  MOVFF  7F,C9
199C:  MOVFF  7E,C8
.................... 		// do linear interpolation of the act len 
.................... 		if (next_act_len>current_act_len) { 
19A0:  MOVF   xC7,W
19A2:  SUBWF  xC9,W
19A4:  BNC   1A5E
19A6:  BNZ   19AE
19A8:  MOVF   xC8,W
19AA:  SUBWF  xC6,W
19AC:  BC    1A5E
.................... 			tick = (int32)(next_act_len-current_act_len)*(int32)(current_period_fraction); 
19AE:  MOVF   xC6,W
19B0:  SUBWF  xC8,W
19B2:  MOVWF  00
19B4:  MOVF   xC7,W
19B6:  SUBWFB xC9,W
19B8:  MOVWF  03
19BA:  MOVFF  00,CA
19BE:  MOVWF  xCB
19C0:  CLRF   xCC
19C2:  CLRF   xCD
19C4:  MOVFF  C4,00
19C8:  MOVFF  C5,01
19CC:  CLRF   02
19CE:  CLRF   03
19D0:  MOVFF  03,D1
19D4:  MOVFF  02,D0
19D8:  MOVFF  C5,CF
19DC:  MOVFF  C4,CE
19E0:  MOVFF  CD,D7
19E4:  MOVFF  CC,D6
19E8:  MOVWF  xD5
19EA:  MOVFF  CA,D4
19EE:  MOVFF  03,DB
19F2:  MOVFF  02,DA
19F6:  MOVFF  C5,D9
19FA:  MOVFF  C4,D8
19FE:  RCALL  1506
1A00:  MOVFF  03,29
1A04:  MOVFF  02,28
1A08:  MOVFF  01,27
1A0C:  MOVFF  00,26
1A10:  CLRF   18
1A12:  BTFSC  FF2.7
1A14:  BSF    18.7
1A16:  BCF    FF2.7
.................... 			tick = tick/450; 
1A18:  MOVFF  29,E5
1A1C:  MOVFF  28,E4
1A20:  MOVFF  27,E3
1A24:  MOVFF  26,E2
1A28:  CLRF   xE9
1A2A:  CLRF   xE8
1A2C:  MOVLW  01
1A2E:  MOVWF  xE7
1A30:  MOVLW  C2
1A32:  MOVWF  xE6
1A34:  CALL   00AA
1A38:  BTFSC  18.7
1A3A:  BSF    FF2.7
1A3C:  MOVFF  03,29
1A40:  MOVFF  02,28
1A44:  MOVFF  01,27
1A48:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
1A4C:  MOVFF  27,C9
1A50:  MOVFF  26,C8
.................... 			current_act_len = current_act_len + next_act_len; 
1A54:  MOVF   xC8,W
1A56:  ADDWF  xC6,F
1A58:  MOVF   xC9,W
1A5A:  ADDWFC xC7,F
.................... 		} else  { 
1A5C:  BRA    1B0C
.................... 			tick = (int32)(current_act_len-next_act_len)*(int32)(current_period_fraction); 
1A5E:  MOVF   xC8,W
1A60:  SUBWF  xC6,W
1A62:  MOVWF  00
1A64:  MOVF   xC9,W
1A66:  SUBWFB xC7,W
1A68:  MOVWF  03
1A6A:  MOVFF  00,CA
1A6E:  MOVWF  xCB
1A70:  CLRF   xCC
1A72:  CLRF   xCD
1A74:  MOVFF  C4,00
1A78:  MOVFF  C5,01
1A7C:  CLRF   02
1A7E:  CLRF   03
1A80:  MOVFF  03,D1
1A84:  MOVFF  02,D0
1A88:  MOVFF  C5,CF
1A8C:  MOVFF  C4,CE
1A90:  MOVFF  CD,D7
1A94:  MOVFF  CC,D6
1A98:  MOVWF  xD5
1A9A:  MOVFF  CA,D4
1A9E:  MOVFF  03,DB
1AA2:  MOVFF  02,DA
1AA6:  MOVFF  C5,D9
1AAA:  MOVFF  C4,D8
1AAE:  RCALL  1506
1AB0:  MOVFF  03,29
1AB4:  MOVFF  02,28
1AB8:  MOVFF  01,27
1ABC:  MOVFF  00,26
1AC0:  CLRF   18
1AC2:  BTFSC  FF2.7
1AC4:  BSF    18.7
1AC6:  BCF    FF2.7
.................... 			tick = tick/450; 
1AC8:  MOVFF  29,E5
1ACC:  MOVFF  28,E4
1AD0:  MOVFF  27,E3
1AD4:  MOVFF  26,E2
1AD8:  CLRF   xE9
1ADA:  CLRF   xE8
1ADC:  MOVLW  01
1ADE:  MOVWF  xE7
1AE0:  MOVLW  C2
1AE2:  MOVWF  xE6
1AE4:  CALL   00AA
1AE8:  BTFSC  18.7
1AEA:  BSF    FF2.7
1AEC:  MOVFF  03,29
1AF0:  MOVFF  02,28
1AF4:  MOVFF  01,27
1AF8:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
1AFC:  MOVFF  27,C9
1B00:  MOVFF  26,C8
.................... 			current_act_len = current_act_len - next_act_len; 
1B04:  MOVF   xC8,W
1B06:  SUBWF  xC6,F
1B08:  MOVF   xC9,W
1B0A:  SUBWFB xC7,F
.................... 		} 
.................... 		if (current_act_len >= act_max_stroke[nActuator]) current_act_len = act_max_stroke[nActuator]; 
1B0C:  BCF    FD8.0
1B0E:  RLCF   xBF,W
1B10:  CLRF   03
1B12:  ADDLW  9C
1B14:  MOVWF  FE9
1B16:  MOVLW  00
1B18:  ADDWFC 03,W
1B1A:  MOVWF  FEA
1B1C:  MOVFF  FEC,03
1B20:  MOVF   FED,F
1B22:  MOVFF  FEF,01
1B26:  MOVF   03,W
1B28:  SUBWF  xC7,W
1B2A:  BNC   1B52
1B2C:  BNZ   1B34
1B2E:  MOVF   01,W
1B30:  SUBWF  xC6,W
1B32:  BNC   1B52
1B34:  BCF    FD8.0
1B36:  RLCF   xBF,W
1B38:  CLRF   03
1B3A:  ADDLW  9C
1B3C:  MOVWF  FE9
1B3E:  MOVLW  00
1B40:  ADDWFC 03,W
1B42:  MOVWF  FEA
1B44:  MOVFF  FEC,03
1B48:  MOVF   FED,F
1B4A:  MOVFF  FEF,C6
1B4E:  MOVFF  03,C7
.................... 		if (current_act_len <= act_min_stroke[nActuator]) current_act_len = act_min_stroke[nActuator]; 
1B52:  BCF    FD8.0
1B54:  RLCF   xBF,W
1B56:  CLRF   03
1B58:  ADDLW  A4
1B5A:  MOVWF  FE9
1B5C:  MOVLW  00
1B5E:  ADDWFC 03,W
1B60:  MOVWF  FEA
1B62:  MOVFF  FEC,03
1B66:  MOVF   FED,F
1B68:  MOVFF  FEF,01
1B6C:  MOVF   xC7,W
1B6E:  SUBWF  03,W
1B70:  BNC   1B98
1B72:  BNZ   1B7A
1B74:  MOVF   xC6,W
1B76:  SUBWF  01,W
1B78:  BNC   1B98
1B7A:  BCF    FD8.0
1B7C:  RLCF   xBF,W
1B7E:  CLRF   03
1B80:  ADDLW  A4
1B82:  MOVWF  FE9
1B84:  MOVLW  00
1B86:  ADDWFC 03,W
1B88:  MOVWF  FEA
1B8A:  MOVFF  FEC,03
1B8E:  MOVF   FED,F
1B90:  MOVFF  FEF,C6
1B94:  MOVFF  03,C7
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]* (int32)(current_act_len-act_min_stroke[nActuator]); 
1B98:  BCF    FD8.0
1B9A:  RLCF   xBF,W
1B9C:  CLRF   03
1B9E:  ADDLW  94
1BA0:  MOVWF  FE9
1BA2:  MOVLW  00
1BA4:  ADDWFC 03,W
1BA6:  MOVWF  FEA
1BA8:  MOVFF  FEC,03
1BAC:  MOVF   FED,F
1BAE:  MOVFF  FEF,CA
1BB2:  MOVFF  03,CB
1BB6:  CLRF   xCC
1BB8:  CLRF   xCD
1BBA:  BCF    FD8.0
1BBC:  RLCF   xBF,W
1BBE:  CLRF   03
1BC0:  ADDLW  A4
1BC2:  MOVWF  FE9
1BC4:  MOVLW  00
1BC6:  ADDWFC 03,W
1BC8:  MOVWF  FEA
1BCA:  MOVFF  FEC,03
1BCE:  MOVF   FED,F
1BD0:  MOVF   FEF,W
1BD2:  SUBWF  xC6,W
1BD4:  MOVWF  00
1BD6:  MOVF   03,W
1BD8:  SUBWFB xC7,W
1BDA:  MOVWF  03
1BDC:  MOVF   00,W
1BDE:  MOVFF  03,01
1BE2:  CLRF   02
1BE4:  CLRF   03
1BE6:  MOVFF  03,D1
1BEA:  MOVFF  02,D0
1BEE:  MOVFF  01,CF
1BF2:  MOVFF  00,CE
1BF6:  MOVFF  FEA,D3
1BFA:  MOVFF  FE9,D2
1BFE:  MOVFF  CD,D7
1C02:  MOVFF  CC,D6
1C06:  MOVFF  CB,D5
1C0A:  MOVFF  CA,D4
1C0E:  MOVFF  03,DB
1C12:  MOVFF  02,DA
1C16:  MOVFF  01,D9
1C1A:  MOVFF  00,D8
1C1E:  RCALL  1506
1C20:  MOVFF  D3,FEA
1C24:  MOVFF  D2,FE9
1C28:  MOVFF  03,29
1C2C:  MOVFF  02,28
1C30:  MOVFF  01,27
1C34:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke[nActuator]-act_min_stroke[nActuator]); 
1C38:  BCF    FD8.0
1C3A:  RLCF   xBF,W
1C3C:  CLRF   03
1C3E:  ADDLW  9C
1C40:  MOVWF  FE9
1C42:  MOVLW  00
1C44:  ADDWFC 03,W
1C46:  MOVWF  FEA
1C48:  MOVFF  FEC,CB
1C4C:  MOVF   FED,F
1C4E:  MOVFF  FEF,CA
1C52:  BCF    FD8.0
1C54:  RLCF   xBF,W
1C56:  CLRF   03
1C58:  ADDLW  A4
1C5A:  MOVWF  FE9
1C5C:  MOVLW  00
1C5E:  ADDWFC 03,W
1C60:  MOVWF  FEA
1C62:  MOVFF  FEC,03
1C66:  MOVF   FED,F
1C68:  MOVF   FEF,W
1C6A:  SUBWF  xCA,W
1C6C:  MOVWF  00
1C6E:  MOVF   03,W
1C70:  SUBWFB xCB,W
1C72:  MOVWF  03
1C74:  MOVFF  00,CA
1C78:  MOVWF  xCB
1C7A:  MOVFF  FEA,CD
1C7E:  MOVFF  FE9,CC
1C82:  CLRF   18
1C84:  BTFSC  FF2.7
1C86:  BSF    18.7
1C88:  BCF    FF2.7
1C8A:  MOVFF  29,E5
1C8E:  MOVFF  28,E4
1C92:  MOVFF  27,E3
1C96:  MOVFF  26,E2
1C9A:  CLRF   xE9
1C9C:  CLRF   xE8
1C9E:  MOVWF  xE7
1CA0:  MOVFF  00,E6
1CA4:  CALL   00AA
1CA8:  BTFSC  18.7
1CAA:  BSF    FF2.7
1CAC:  MOVFF  CD,FEA
1CB0:  MOVFF  CC,FE9
1CB4:  MOVFF  03,29
1CB8:  MOVFF  02,28
1CBC:  MOVFF  01,27
1CC0:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
1CC4:  MOVFF  27,93
1CC8:  MOVFF  26,92
.................... 	} 
....................  
.................... } 
1CCC:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,int8 direction,unsigned int8 nActuator) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
1160:  CLRF   xCA
1162:  CLRF   xCB
....................    unsigned int16 yyy=0;    
1164:  CLRF   xCC
1166:  CLRF   xCD
....................    output_low(CCW); 
1168:  BCF    F93.4
116A:  BCF    F8A.4
....................    output_low(EN0); 
116C:  BCF    F93.0
116E:  BCF    F8A.0
....................    output_low(EN1); 
1170:  BCF    F93.1
1172:  BCF    F8A.1
....................    output_low(EN2); 
1174:  BCF    F93.2
1176:  BCF    F8A.2
....................    output_low(EN3); 
1178:  BCF    F93.3
117A:  BCF    F8A.3
117C:  CLRF   18
117E:  BTFSC  FF2.7
1180:  BSF    18.7
1182:  BCF    FF2.7
....................    delay_ms(20); 
1184:  MOVLW  14
1186:  MOVWF  xE2
1188:  CALL   0178
118C:  BTFSC  18.7
118E:  BSF    FF2.7
....................    if (nActuator > 3) return; // actuator exceed max number allowable 
1190:  MOVF   xC9,W
1192:  SUBLW  03
1194:  BC    1198
1196:  BRA    1454
....................    flag2.is_moving =1; 
1198:  BSF    20.6
....................    switch (nActuator) { 
119A:  MOVF   xC9,W
119C:  ADDLW  FC
119E:  BC    11CE
11A0:  ADDLW  04
11A2:  GOTO   1456
.................... 		case 0: { flag.prev_pulse_state = input(SENSE_0); break;} 
11A6:  BSF    F92.2
11A8:  BCF    1F.2
11AA:  BTFSC  F80.2
11AC:  BSF    1F.2
11AE:  BRA    11CE
.................... 		case 1: { flag.prev_pulse_state = input(SENSE_1); break;} 
11B0:  BSF    F92.3
11B2:  BCF    1F.2
11B4:  BTFSC  F80.3
11B6:  BSF    1F.2
11B8:  BRA    11CE
.................... 		case 2: { flag.prev_pulse_state = input(SENSE_2); break;} 
11BA:  BSF    F92.4
11BC:  BCF    1F.2
11BE:  BTFSC  F80.4
11C0:  BSF    1F.2
11C2:  BRA    11CE
.................... 		case 3: { flag.prev_pulse_state = input(SENSE_3); break;} 
11C4:  BSF    F92.5
11C6:  BCF    1F.2
11C8:  BTFSC  F80.5
11CA:  BSF    1F.2
11CC:  BRA    11CE
....................    } 
....................  
....................    if (!direction)   { 
11CE:  MOVF   xC8,F
11D0:  BNZ   11D6
....................       output_high(CCW); 
11D2:  BCF    F93.4
11D4:  BSF    F8A.4
11D6:  CLRF   18
11D8:  BTFSC  FF2.7
11DA:  BSF    18.7
11DC:  BCF    FF2.7
....................    } 
....................  
....................    delay_ms(200); 
11DE:  MOVLW  C8
11E0:  MOVWF  xE2
11E2:  CALL   0178
11E6:  BTFSC  18.7
11E8:  BSF    FF2.7
....................    switch (nActuator) { 
11EA:  MOVF   xC9,W
11EC:  ADDLW  FC
11EE:  BC    120E
11F0:  ADDLW  04
11F2:  GOTO   1482
.................... 		case 0: {output_high(EN0); break;} 
11F6:  BCF    F93.0
11F8:  BSF    F8A.0
11FA:  BRA    120E
.................... 		case 1: {output_high(EN1); break;} 
11FC:  BCF    F93.1
11FE:  BSF    F8A.1
1200:  BRA    120E
.................... 		case 2: {output_high(EN2); break;} 
1202:  BCF    F93.2
1204:  BSF    F8A.2
1206:  BRA    120E
.................... 		case 3: {output_high(EN3); break;} 
1208:  BCF    F93.3
120A:  BSF    F8A.3
120C:  BRA    120E
....................    } 
....................    delay_ms(10); 
120E:  CLRF   18
1210:  BTFSC  FF2.7
1212:  BSF    18.7
1214:  BCF    FF2.7
1216:  MOVLW  0A
1218:  MOVWF  xE2
121A:  CALL   0178
121E:  BTFSC  18.7
1220:  BSF    FF2.7
....................  
....................    tick = timer_sec; 
1222:  MOVFF  25,29
1226:  MOVFF  24,28
122A:  MOVFF  23,27
122E:  MOVFF  22,26
....................    tick2 = timer_sec; 
1232:  MOVFF  25,2D
1236:  MOVFF  24,2C
123A:  MOVFF  23,2B
123E:  MOVFF  22,2A
....................    actuator_pulse =0; 
1242:  CLRF   x83
1244:  CLRF   x82
....................    while(1) { 
....................       restart_wdt(); 
1246:  CLRWDT
....................       xxx = (int16) (timer_sec-tick); 
1248:  MOVF   26,W
124A:  SUBWF  22,W
124C:  MOVWF  00
124E:  MOVF   27,W
1250:  SUBWFB 23,W
1252:  MOVWF  01
1254:  MOVF   28,W
1256:  SUBWFB 24,W
1258:  MOVF   29,W
125A:  SUBWFB 25,W
125C:  MOVFF  01,CB
1260:  MOVFF  00,CA
....................       yyy = (int16) (timer_sec-tick2); 
1264:  MOVF   2A,W
1266:  SUBWF  22,W
1268:  MOVWF  00
126A:  MOVF   2B,W
126C:  SUBWFB 23,W
126E:  MOVWF  01
1270:  MOVF   2C,W
1272:  SUBWFB 24,W
1274:  MOVF   2D,W
1276:  SUBWFB 25,W
1278:  MOVFF  01,CD
127C:  MOVFF  00,CC
....................    	  switch (nActuator) { 
1280:  MOVF   xC9,W
1282:  ADDLW  FC
1284:  BC    12B4
1286:  ADDLW  04
1288:  GOTO   14AE
.................... 		case 0: { flag2.current_pulse_state = input(SENSE_0); break;} 
128C:  BSF    F92.2
128E:  BCF    20.4
1290:  BTFSC  F80.2
1292:  BSF    20.4
1294:  BRA    12B4
.................... 		case 1: { flag2.current_pulse_state = input(SENSE_1); break;} 
1296:  BSF    F92.3
1298:  BCF    20.4
129A:  BTFSC  F80.3
129C:  BSF    20.4
129E:  BRA    12B4
.................... 		case 2: { flag2.current_pulse_state = input(SENSE_2); break;} 
12A0:  BSF    F92.4
12A2:  BCF    20.4
12A4:  BTFSC  F80.4
12A6:  BSF    20.4
12A8:  BRA    12B4
.................... 		case 3: { flag2.current_pulse_state = input(SENSE_3); break;} 
12AA:  BSF    F92.5
12AC:  BCF    20.4
12AE:  BTFSC  F80.5
12B0:  BSF    20.4
12B2:  BRA    12B4
....................       } 
....................  
.................... 	  if (flag2.allow_manual_move_act) { 
12B4:  BTFSS  20.3
12B6:  BRA    12D6
.................... 		  if (((!direction && (nButton==3)) || (direction && (nButton==5))) && flag2.button_pressed)  
12B8:  MOVF   xC8,F
12BA:  BNZ   12C2
12BC:  MOVF   4B,W
12BE:  SUBLW  03
12C0:  BZ    12CC
12C2:  MOVF   xC8,F
12C4:  BZ    12D4
12C6:  MOVF   4B,W
12C8:  SUBLW  05
12CA:  BNZ   12D4
12CC:  BTFSS  20.1
12CE:  BRA    12D4
.................... 			flag2.allow_manual_move_act=1; 
12D0:  BSF    20.3
.................... 		  else 
12D2:  BRA    12D6
.................... 			flag2.allow_manual_move_act=0;	 
12D4:  BCF    20.3
.................... 	  } 
.................... 	  if (!flag2.allow_manual_move_act) {  
12D6:  BTFSC  20.3
12D8:  BRA    1334
....................       if (flag2.abort_current_activity ==1) { 
12DA:  BTFSS  20.2
12DC:  BRA    12E2
.................... 		 flag2.abort_current_activity=0; 
12DE:  BCF    20.2
.................... 		 break; 
12E0:  BRA    1406
....................       } 
....................       if ( xxx>= time_out_sec)  
12E2:  MOVF   xC5,W
12E4:  SUBWF  xCB,W
12E6:  BNC   12F2
12E8:  BNZ   12F0
12EA:  MOVF   xC4,W
12EC:  SUBWF  xCA,W
12EE:  BNC   12F2
....................          break; 
12F0:  BRA    1406
....................        if (actuator_pulse >= nPulse) 
12F2:  MOVF   xC3,W
12F4:  SUBWF  x83,W
12F6:  BNC   1324
12F8:  BNZ   1300
12FA:  MOVF   xC2,W
12FC:  SUBWF  x82,W
12FE:  BNC   1324
.................... 	    switch (nActuator) { 
1300:  MOVF   xC9,W
1302:  ADDLW  FC
1304:  BC    1324
1306:  ADDLW  04
1308:  GOTO   14DA
.................... 			case 0: {output_low(EN0); break;} 
130C:  BCF    F93.0
130E:  BCF    F8A.0
1310:  BRA    1324
.................... 			case 1: {output_low(EN1); break;} 
1312:  BCF    F93.1
1314:  BCF    F8A.1
1316:  BRA    1324
.................... 			case 2: {output_low(EN2); break;} 
1318:  BCF    F93.2
131A:  BCF    F8A.2
131C:  BRA    1324
.................... 			case 3: {output_low(EN3); break;} 
131E:  BCF    F93.3
1320:  BCF    F8A.3
1322:  BRA    1324
....................    		} 
....................       if ( yyy >=stuck_sec) 
1324:  MOVF   xC7,W
1326:  SUBWF  xCD,W
1328:  BNC   1334
132A:  BNZ   1332
132C:  MOVF   xC6,W
132E:  SUBWF  xCC,W
1330:  BNC   1334
....................          break; 
1332:  BRA    1406
....................       }    
....................       if (flag.prev_pulse_state != flag2.current_pulse_state) { 
1334:  CLRF   00
1336:  BTFSC  20.4
1338:  BSF    00.2
133A:  MOVF   1F,W
133C:  XORWF  00,W
133E:  ANDLW  04
1340:  BZ    1404
....................          tick2 = timer_sec; 
1342:  MOVFF  25,2D
1346:  MOVFF  24,2C
134A:  MOVFF  23,2B
134E:  MOVFF  22,2A
....................          flag.prev_pulse_state = flag2.current_pulse_state; 
1352:  BCF    1F.2
1354:  BTFSC  20.4
1356:  BSF    1F.2
....................          if (!direction && (current_act_position[nActuator] >0)) current_act_position[nActuator]--; 
1358:  MOVF   xC8,F
135A:  BNZ   1398
135C:  BCF    FD8.0
135E:  RLCF   xC9,W
1360:  CLRF   03
1362:  ADDLW  8A
1364:  MOVWF  FE9
1366:  MOVLW  00
1368:  ADDWFC 03,W
136A:  MOVWF  FEA
136C:  MOVFF  FEC,CF
1370:  MOVF   FED,F
1372:  MOVFF  FEF,CE
1376:  MOVF   xCE,F
1378:  BNZ   137E
137A:  MOVF   xCF,F
137C:  BZ    1398
137E:  BCF    FD8.0
1380:  RLCF   xC9,W
1382:  CLRF   03
1384:  ADDLW  8A
1386:  MOVWF  FE9
1388:  MOVLW  00
138A:  ADDWFC 03,W
138C:  MOVWF  FEA
138E:  MOVLW  FF
1390:  ADDWF  FEF,F
1392:  BC    1398
1394:  MOVF   FEE,F
1396:  DECF   FED,F
....................          if (direction && (current_act_position[nActuator] < act_full_stroke_tick[nActuator])) current_act_position[nActuator]++; 
1398:  MOVF   xC8,F
139A:  BZ    13F6
139C:  BCF    FD8.0
139E:  RLCF   xC9,W
13A0:  CLRF   03
13A2:  ADDLW  8A
13A4:  MOVWF  FE9
13A6:  MOVLW  00
13A8:  ADDWFC 03,W
13AA:  MOVWF  FEA
13AC:  MOVFF  FEC,CF
13B0:  MOVF   FED,F
13B2:  MOVFF  FEF,CE
13B6:  BCF    FD8.0
13B8:  RLCF   xC9,W
13BA:  CLRF   03
13BC:  ADDLW  94
13BE:  MOVWF  FE9
13C0:  MOVLW  00
13C2:  ADDWFC 03,W
13C4:  MOVWF  FEA
13C6:  MOVFF  FEC,03
13CA:  MOVF   FED,F
13CC:  MOVFF  FEF,01
13D0:  MOVF   xCF,W
13D2:  SUBWF  03,W
13D4:  BNC   13F6
13D6:  BNZ   13DE
13D8:  MOVF   01,W
13DA:  SUBWF  xCE,W
13DC:  BC    13F6
13DE:  BCF    FD8.0
13E0:  RLCF   xC9,W
13E2:  CLRF   03
13E4:  ADDLW  8A
13E6:  MOVWF  FE9
13E8:  MOVLW  00
13EA:  ADDWFC 03,W
13EC:  MOVWF  FEA
13EE:  MOVLW  01
13F0:  ADDWF  FEE,F
13F2:  BNC   13F6
13F4:  INCF   FEF,F
....................          actuator_pulse=actuator_pulse+1; 
13F6:  MOVLW  01
13F8:  ADDWF  x82,F
13FA:  MOVLW  00
13FC:  ADDWFC x83,F
.................... 		 led_status.operation = !led_status.operation; 
13FE:  BTG    21.1
.................... 		 display_LED(); 
1400:  CALL   0144
....................       } 
....................    } 
1404:  BRA    1246
....................    flag2.abort_current_activity=0; 
1406:  BCF    20.2
....................    output_low(EN0); 
1408:  BCF    F93.0
140A:  BCF    F8A.0
....................    output_low(EN1); 
140C:  BCF    F93.1
140E:  BCF    F8A.1
....................    output_low(EN2); 
1410:  BCF    F93.2
1412:  BCF    F8A.2
....................    output_low(EN3); 
1414:  BCF    F93.3
1416:  BCF    F8A.3
....................    delay_ms(500); 
1418:  MOVLW  02
141A:  MOVWF  xCE
141C:  CLRF   18
141E:  BTFSC  FF2.7
1420:  BSF    18.7
1422:  BCF    FF2.7
1424:  MOVLW  FA
1426:  MOVWF  xE2
1428:  CALL   0178
142C:  BTFSC  18.7
142E:  BSF    FF2.7
1430:  DECFSZ xCE,F
1432:  BRA    141C
....................    output_low(CCW); 
1434:  BCF    F93.4
1436:  BCF    F8A.4
1438:  CLRF   18
143A:  BTFSC  FF2.7
143C:  BSF    18.7
143E:  BCF    FF2.7
....................    delay_ms(20); 
1440:  MOVLW  14
1442:  MOVWF  xE2
1444:  CALL   0178
1448:  BTFSC  18.7
144A:  BSF    FF2.7
....................    led_status.operation = 1; 
144C:  BSF    21.1
....................    display_LED(); 
144E:  CALL   0144
....................    flag2.is_moving =0; 
1452:  BCF    20.6
....................  
....................  
.................... } 
1454:  RETLW  00
....................  
.................... void actuator_move_execute(nActuator) { 
....................     if(current_act_position[nActuator] > (target_act_position+5))// move east 
*
155A:  BCF    FD8.0
155C:  RLCF   xBF,W
155E:  CLRF   03
1560:  ADDLW  8A
1562:  MOVWF  FE9
1564:  MOVLW  00
1566:  ADDWFC 03,W
1568:  MOVWF  FEA
156A:  MOVFF  FEC,C1
156E:  MOVF   FED,F
1570:  MOVFF  FEF,C0
1574:  MOVLW  05
1576:  ADDWF  x92,W
1578:  MOVWF  01
157A:  MOVLW  00
157C:  ADDWFC x93,W
157E:  MOVWF  03
1580:  MOVF   03,W
1582:  SUBWF  xC1,W
1584:  BNC   15D2
1586:  BNZ   158E
1588:  MOVF   xC0,W
158A:  SUBWF  01,W
158C:  BC    15D2
....................             move_act(current_act_position[nActuator]-target_act_position,4500,move_act_time_out,0,nActuator); 
158E:  BCF    FD8.0
1590:  RLCF   xBF,W
1592:  CLRF   03
1594:  ADDLW  8A
1596:  MOVWF  FE9
1598:  MOVLW  00
159A:  ADDWFC 03,W
159C:  MOVWF  FEA
159E:  MOVFF  FEC,C1
15A2:  MOVF   FED,F
15A4:  MOVFF  FEF,C0
15A8:  MOVF   x92,W
15AA:  SUBWF  xC0,F
15AC:  MOVF   x93,W
15AE:  SUBWFB xC1,F
15B0:  MOVFF  C1,C3
15B4:  MOVFF  C0,C2
15B8:  MOVLW  11
15BA:  MOVWF  xC5
15BC:  MOVLW  94
15BE:  MOVWF  xC4
15C0:  MOVFF  81,C7
15C4:  MOVFF  80,C6
15C8:  CLRF   xC8
15CA:  MOVFF  BF,C9
15CE:  RCALL  1160
....................     else if((current_act_position[nActuator]+5) < target_act_position)// move west 
15D0:  BRA    16E8
15D2:  BCF    FD8.0
15D4:  RLCF   xBF,W
15D6:  CLRF   03
15D8:  ADDLW  8A
15DA:  MOVWF  FE9
15DC:  MOVLW  00
15DE:  ADDWFC 03,W
15E0:  MOVWF  FEA
15E2:  MOVFF  FEC,C1
15E6:  MOVF   FED,F
15E8:  MOVFF  FEF,C0
15EC:  MOVLW  05
15EE:  ADDWF  xC0,F
15F0:  MOVLW  00
15F2:  ADDWFC xC1,F
15F4:  MOVF   xC1,W
15F6:  SUBWF  x93,W
15F8:  BNC   1646
15FA:  BNZ   1602
15FC:  MOVF   x92,W
15FE:  SUBWF  xC0,W
1600:  BC    1646
....................             move_act(target_act_position-current_act_position[nActuator],4500,move_act_time_out,1,nActuator); 
1602:  BCF    FD8.0
1604:  RLCF   xBF,W
1606:  CLRF   03
1608:  ADDLW  8A
160A:  MOVWF  FE9
160C:  MOVLW  00
160E:  ADDWFC 03,W
1610:  MOVWF  FEA
1612:  MOVFF  FEC,03
1616:  MOVF   FED,F
1618:  MOVF   FEF,W
161A:  SUBWF  x92,W
161C:  MOVWF  xC0
161E:  MOVF   03,W
1620:  SUBWFB x93,W
1622:  MOVWF  xC1
1624:  MOVWF  xC3
1626:  MOVFF  C0,C2
162A:  MOVLW  11
162C:  MOVWF  xC5
162E:  MOVLW  94
1630:  MOVWF  xC4
1632:  MOVFF  81,C7
1636:  MOVFF  80,C6
163A:  MOVLW  01
163C:  MOVWF  xC8
163E:  MOVFF  BF,C9
1642:  RCALL  1160
....................     else if (target_act_position == 0x00)  // move east all the way 
1644:  BRA    16E8
1646:  MOVF   x92,F
1648:  BNZ   168A
164A:  MOVF   x93,F
164C:  BNZ   168A
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,0,nActuator); 
164E:  BCF    FD8.0
1650:  RLCF   xBF,W
1652:  CLRF   03
1654:  ADDLW  94
1656:  MOVWF  FE9
1658:  MOVLW  00
165A:  ADDWFC 03,W
165C:  MOVWF  FEA
165E:  MOVFF  FEC,C1
1662:  MOVF   FED,F
1664:  MOVFF  FEF,C0
1668:  MOVFF  C1,C3
166C:  MOVFF  C0,C2
1670:  MOVLW  11
1672:  MOVWF  xC5
1674:  MOVLW  94
1676:  MOVWF  xC4
1678:  MOVFF  81,C7
167C:  MOVFF  80,C6
1680:  CLRF   xC8
1682:  MOVFF  BF,C9
1686:  RCALL  1160
....................     else if (target_act_position == act_full_stroke_tick[nActuator]) // move west all the way 
1688:  BRA    16E8
168A:  BCF    FD8.0
168C:  RLCF   xBF,W
168E:  CLRF   03
1690:  ADDLW  94
1692:  MOVWF  FE9
1694:  MOVLW  00
1696:  ADDWFC 03,W
1698:  MOVWF  FEA
169A:  MOVFF  FEC,03
169E:  MOVF   FED,F
16A0:  MOVF   FEF,W
16A2:  SUBWF  x92,W
16A4:  BNZ   16E8
16A6:  MOVF   03,W
16A8:  SUBWF  x93,W
16AA:  BNZ   16E8
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,1,nActuator); 
16AC:  BCF    FD8.0
16AE:  RLCF   xBF,W
16B0:  CLRF   03
16B2:  ADDLW  94
16B4:  MOVWF  FE9
16B6:  MOVLW  00
16B8:  ADDWFC 03,W
16BA:  MOVWF  FEA
16BC:  MOVFF  FEC,C1
16C0:  MOVF   FED,F
16C2:  MOVFF  FEF,C0
16C6:  MOVFF  C1,C3
16CA:  MOVFF  C0,C2
16CE:  MOVLW  11
16D0:  MOVWF  xC5
16D2:  MOVLW  94
16D4:  MOVWF  xC4
16D6:  MOVFF  81,C7
16DA:  MOVFF  80,C6
16DE:  MOVLW  01
16E0:  MOVWF  xC8
16E2:  MOVFF  BF,C9
16E6:  RCALL  1160
.................... } 
16E8:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... void read_device_id() { 
....................    int16 temp_mem; 
....................    int8 i; 
....................    temp_mem= &dev_id; 
*
09DA:  CLRF   xC0
09DC:  MOVLW  34
09DE:  MOVWF  xBF
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom(0xf00050+i),1); 
09E0:  CLRF   xC1
09E2:  MOVF   xC1,W
09E4:  SUBLW  01
09E6:  BNC   0A3E
09E8:  MOVF   xC1,W
09EA:  ADDWF  xBF,W
09EC:  MOVWF  xC2
09EE:  MOVLW  00
09F0:  ADDWFC xC0,W
09F2:  MOVWF  xC3
09F4:  MOVLW  50
09F6:  ADDWF  xC1,W
09F8:  MOVWF  xC4
09FA:  CLRF   xC5
09FC:  BTFSC  FD8.0
09FE:  INCF   xC5,F
0A00:  MOVLW  F0
0A02:  MOVWF  xC6
0A04:  BTFSC  FD8.0
0A06:  INCF   xC6,F
0A08:  CLRF   xC7
0A0A:  BTFSC  FD8.0
0A0C:  INCF   xC7,F
0A0E:  MOVFF  FF2,C8
0A12:  BCF    FF2.7
0A14:  MOVFF  C4,FA9
0A18:  BCF    FA6.6
0A1A:  BCF    FA6.7
0A1C:  BSF    FA6.0
0A1E:  MOVF   FA8,W
0A20:  BTFSC  xC8.7
0A22:  BSF    FF2.7
0A24:  MOVWF  xC4
0A26:  MOVFF  C3,FEA
0A2A:  MOVFF  C2,FE9
0A2E:  MOVFF  C4,C9
0A32:  CLRF   xCB
0A34:  MOVLW  01
0A36:  MOVWF  xCA
0A38:  RCALL  0664
0A3A:  INCF   xC1,F
0A3C:  BRA    09E2
.................... } 
0A3E:  RETLW  00
....................  
.................... void write_device_id() { 
.................... 	int8 i; 
.................... 	for (i=0;i<2;i++) write_eeprom(0xf00050+i,dev_id>>(i*8)); 
*
1CCE:  CLRF   xBF
1CD0:  MOVF   xBF,W
1CD2:  SUBLW  01
1CD4:  BNC   1D3E
1CD6:  MOVLW  50
1CD8:  ADDWF  xBF,W
1CDA:  MOVWF  xC0
1CDC:  CLRF   xC1
1CDE:  BTFSC  FD8.0
1CE0:  INCF   xC1,F
1CE2:  MOVLW  F0
1CE4:  MOVWF  xC2
1CE6:  BTFSC  FD8.0
1CE8:  INCF   xC2,F
1CEA:  CLRF   xC3
1CEC:  BTFSC  FD8.0
1CEE:  INCF   xC3,F
1CF0:  MOVF   xBF,W
1CF2:  MULLW  08
1CF4:  MOVFF  FF3,00
1CF8:  MOVFF  35,C5
1CFC:  MOVFF  34,C4
1D00:  MOVF   00,F
1D02:  BZ    1D0E
1D04:  BCF    FD8.0
1D06:  RRCF   xC5,F
1D08:  RRCF   xC4,F
1D0A:  DECFSZ 00,F
1D0C:  BRA    1D04
1D0E:  MOVFF  C0,FA9
1D12:  MOVFF  C4,FA8
1D16:  BCF    FA6.6
1D18:  BCF    FA6.7
1D1A:  BSF    FA6.2
1D1C:  MOVFF  FF2,00
1D20:  BCF    FF2.7
1D22:  MOVLB  F
1D24:  MOVLW  55
1D26:  MOVWF  FA7
1D28:  MOVLW  AA
1D2A:  MOVWF  FA7
1D2C:  BSF    FA6.1
1D2E:  BTFSC  FA6.1
1D30:  BRA    1D2E
1D32:  BCF    FA6.2
1D34:  MOVF   00,W
1D36:  IORWF  FF2,F
1D38:  MOVLB  0
1D3A:  INCF   xBF,F
1D3C:  BRA    1CD0
.................... } 
1D3E:  GOTO   2536 (RETURN)
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int8 i,j; 
....................    int16 temp_mem;    
....................  
....................    temp_mem= &timer_sec; 
*
067E:  CLRF   xBE
0680:  MOVLW  22
0682:  MOVWF  xBD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
0684:  CLRF   xBB
0686:  MOVF   xBB,W
0688:  SUBLW  03
068A:  BNC   06CE
068C:  MOVF   xBB,W
068E:  ADDWF  xBD,W
0690:  MOVWF  xBF
0692:  MOVLW  00
0694:  ADDWFC xBE,W
0696:  MOVWF  xC0
0698:  MOVLW  20
069A:  ADDWF  xBB,W
069C:  MOVWF  xC1
069E:  MOVFF  FF2,C2
06A2:  BCF    FF2.7
06A4:  MOVFF  C1,FA9
06A8:  BCF    FA6.6
06AA:  BCF    FA6.7
06AC:  BSF    FA6.0
06AE:  MOVF   FA8,W
06B0:  BTFSC  xC2.7
06B2:  BSF    FF2.7
06B4:  MOVWF  xC1
06B6:  MOVFF  C0,FEA
06BA:  MOVFF  BF,FE9
06BE:  MOVFF  C1,C9
06C2:  CLRF   xCB
06C4:  MOVLW  01
06C6:  MOVWF  xCA
06C8:  RCALL  0664
06CA:  INCF   xBB,F
06CC:  BRA    0686
....................  
....................    temp_mem= &nDay; 
06CE:  CLRF   xBE
06D0:  MOVLW  2E
06D2:  MOVWF  xBD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i+4),1); 
06D4:  CLRF   xBB
06D6:  MOVF   xBB,W
06D8:  SUBLW  03
06DA:  BNC   0720
06DC:  MOVF   xBB,W
06DE:  ADDWF  xBD,W
06E0:  MOVWF  xBF
06E2:  MOVLW  00
06E4:  ADDWFC xBE,W
06E6:  MOVWF  xC0
06E8:  MOVLW  20
06EA:  ADDWF  xBB,W
06EC:  ADDLW  04
06EE:  MOVWF  xC1
06F0:  MOVFF  FF2,C2
06F4:  BCF    FF2.7
06F6:  MOVFF  C1,FA9
06FA:  BCF    FA6.6
06FC:  BCF    FA6.7
06FE:  BSF    FA6.0
0700:  MOVF   FA8,W
0702:  BTFSC  xC2.7
0704:  BSF    FF2.7
0706:  MOVWF  xC1
0708:  MOVFF  C0,FEA
070C:  MOVFF  BF,FE9
0710:  MOVFF  C1,C9
0714:  CLRF   xCB
0716:  MOVLW  01
0718:  MOVWF  xCA
071A:  RCALL  0664
071C:  INCF   xBB,F
071E:  BRA    06D6
....................  
....................  
....................    temp_mem= &startup_counter; 
0720:  CLRF   xBE
0722:  MOVLW  32
0724:  MOVWF  xBD
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
0726:  CLRF   xBB
0728:  MOVF   xBB,W
072A:  SUBLW  01
072C:  BNC   0770
072E:  MOVF   xBB,W
0730:  ADDWF  xBD,W
0732:  MOVWF  xBF
0734:  MOVLW  00
0736:  ADDWFC xBE,W
0738:  MOVWF  xC0
073A:  MOVLW  30
073C:  ADDWF  xBB,W
073E:  MOVWF  xC1
0740:  MOVFF  FF2,C2
0744:  BCF    FF2.7
0746:  MOVFF  C1,FA9
074A:  BCF    FA6.6
074C:  BCF    FA6.7
074E:  BSF    FA6.0
0750:  MOVF   FA8,W
0752:  BTFSC  xC2.7
0754:  BSF    FF2.7
0756:  MOVWF  xC1
0758:  MOVFF  C0,FEA
075C:  MOVFF  BF,FE9
0760:  MOVFF  C1,C9
0764:  CLRF   xCB
0766:  MOVLW  01
0768:  MOVWF  xCA
076A:  RCALL  0664
076C:  INCF   xBB,F
076E:  BRA    0728
....................  
....................    for (j=0;j<4;j++) { 
0770:  CLRF   xBC
0772:  MOVF   xBC,W
0774:  SUBLW  03
0776:  BTFSS  FD8.0
0778:  BRA    09D6
....................    		temp_mem= &act_full_stroke_tick[j]; 
077A:  BCF    FD8.0
077C:  RLCF   xBC,W
077E:  CLRF   03
0780:  ADDLW  94
0782:  MOVWF  01
0784:  MOVLW  00
0786:  ADDWFC 03,F
0788:  MOVFF  01,BD
078C:  MOVFF  03,BE
.................... 	   	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i+j*2),1); 
0790:  CLRF   xBB
0792:  MOVF   xBB,W
0794:  SUBLW  01
0796:  BNC   07DC
0798:  MOVF   xBB,W
079A:  ADDWF  xBD,W
079C:  MOVWF  xBF
079E:  MOVLW  00
07A0:  ADDWFC xBE,W
07A2:  MOVWF  xC0
07A4:  BCF    FD8.0
07A6:  RLCF   xBC,W
07A8:  ADDWF  xBB,W
07AA:  MOVWF  xC1
07AC:  MOVFF  FF2,C2
07B0:  BCF    FF2.7
07B2:  MOVFF  C1,FA9
07B6:  BCF    FA6.6
07B8:  BCF    FA6.7
07BA:  BSF    FA6.0
07BC:  MOVF   FA8,W
07BE:  BTFSC  xC2.7
07C0:  BSF    FF2.7
07C2:  MOVWF  xC1
07C4:  MOVFF  C0,FEA
07C8:  MOVFF  BF,FE9
07CC:  MOVFF  C1,C9
07D0:  CLRF   xCB
07D2:  MOVLW  01
07D4:  MOVWF  xCA
07D6:  RCALL  0664
07D8:  INCF   xBB,F
07DA:  BRA    0792
....................    		if (act_full_stroke_tick[j] > MAX_FULL_STROKE) act_full_stroke_tick[j] = MAX_FULL_STROKE; 
07DC:  BCF    FD8.0
07DE:  RLCF   xBC,W
07E0:  CLRF   03
07E2:  ADDLW  94
07E4:  MOVWF  FE9
07E6:  MOVLW  00
07E8:  ADDWFC 03,W
07EA:  MOVWF  FEA
07EC:  MOVFF  FEC,C0
07F0:  MOVF   FED,F
07F2:  MOVFF  FEF,BF
07F6:  MOVF   xC0,W
07F8:  SUBLW  16
07FA:  BC    0820
07FC:  XORLW  FF
07FE:  BNZ   0806
0800:  MOVF   xBF,W
0802:  SUBLW  70
0804:  BC    0820
0806:  BCF    FD8.0
0808:  RLCF   xBC,W
080A:  CLRF   03
080C:  ADDLW  94
080E:  MOVWF  FE9
0810:  MOVLW  00
0812:  ADDWFC 03,W
0814:  MOVWF  FEA
0816:  MOVLW  17
0818:  MOVWF  FEC
081A:  MOVF   FED,F
081C:  MOVLW  70
081E:  MOVWF  FEF
....................    		temp_mem= &current_act_position[j]; 
0820:  BCF    FD8.0
0822:  RLCF   xBC,W
0824:  CLRF   03
0826:  ADDLW  8A
0828:  MOVWF  01
082A:  MOVLW  00
082C:  ADDWFC 03,F
082E:  MOVFF  01,BD
0832:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2),1); 
0836:  CLRF   xBB
0838:  MOVF   xBB,W
083A:  SUBLW  01
083C:  BNC   0886
083E:  MOVF   xBB,W
0840:  ADDWF  xBD,W
0842:  MOVWF  xBF
0844:  MOVLW  00
0846:  ADDWFC xBE,W
0848:  MOVWF  xC0
084A:  MOVLW  10
084C:  ADDWF  xBB,W
084E:  MOVWF  xC1
0850:  BCF    FD8.0
0852:  RLCF   xBC,W
0854:  ADDWF  xC1,F
0856:  MOVFF  FF2,C2
085A:  BCF    FF2.7
085C:  MOVFF  C1,FA9
0860:  BCF    FA6.6
0862:  BCF    FA6.7
0864:  BSF    FA6.0
0866:  MOVF   FA8,W
0868:  BTFSC  xC2.7
086A:  BSF    FF2.7
086C:  MOVWF  xC1
086E:  MOVFF  C0,FEA
0872:  MOVFF  BF,FE9
0876:  MOVFF  C1,C9
087A:  CLRF   xCB
087C:  MOVLW  01
087E:  MOVWF  xCA
0880:  RCALL  0664
0882:  INCF   xBB,F
0884:  BRA    0838
....................    		if (current_act_position[j] > act_full_stroke_tick[j]) current_act_position[j] = act_full_stroke_tick[j]; 
0886:  BCF    FD8.0
0888:  RLCF   xBC,W
088A:  CLRF   03
088C:  ADDLW  8A
088E:  MOVWF  FE9
0890:  MOVLW  00
0892:  ADDWFC 03,W
0894:  MOVWF  FEA
0896:  MOVFF  FEC,C0
089A:  MOVF   FED,F
089C:  MOVFF  FEF,BF
08A0:  BCF    FD8.0
08A2:  RLCF   xBC,W
08A4:  CLRF   03
08A6:  ADDLW  94
08A8:  MOVWF  FE9
08AA:  MOVLW  00
08AC:  ADDWFC 03,W
08AE:  MOVWF  FEA
08B0:  MOVFF  FEC,03
08B4:  MOVF   FED,F
08B6:  MOVFF  FEF,01
08BA:  MOVF   03,W
08BC:  SUBWF  xC0,W
08BE:  BNC   0906
08C0:  BNZ   08C8
08C2:  MOVF   xBF,W
08C4:  SUBWF  01,W
08C6:  BC    0906
08C8:  BCF    FD8.0
08CA:  RLCF   xBC,W
08CC:  CLRF   03
08CE:  ADDLW  8A
08D0:  MOVWF  01
08D2:  MOVLW  00
08D4:  ADDWFC 03,F
08D6:  MOVFF  03,C0
08DA:  BCF    FD8.0
08DC:  RLCF   xBC,W
08DE:  CLRF   03
08E0:  ADDLW  94
08E2:  MOVWF  FE9
08E4:  MOVLW  00
08E6:  ADDWFC 03,W
08E8:  MOVWF  FEA
08EA:  MOVFF  FEC,03
08EE:  MOVF   FED,F
08F0:  MOVFF  FEF,C1
08F4:  MOVFF  C0,FEA
08F8:  MOVFF  01,FE9
08FC:  MOVFF  03,FEC
0900:  MOVF   FED,F
0902:  MOVFF  C1,FEF
....................    		temp_mem= &act_min_stroke[j]; 
0906:  BCF    FD8.0
0908:  RLCF   xBC,W
090A:  CLRF   03
090C:  ADDLW  A4
090E:  MOVWF  01
0910:  MOVLW  00
0912:  ADDWFC 03,F
0914:  MOVFF  01,BD
0918:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_ACT_MIN_LEN+i+j*2),1); 
091C:  CLRF   xBB
091E:  MOVF   xBB,W
0920:  SUBLW  01
0922:  BNC   096C
0924:  MOVF   xBB,W
0926:  ADDWF  xBD,W
0928:  MOVWF  xBF
092A:  MOVLW  00
092C:  ADDWFC xBE,W
092E:  MOVWF  xC0
0930:  MOVLW  60
0932:  ADDWF  xBB,W
0934:  MOVWF  xC1
0936:  BCF    FD8.0
0938:  RLCF   xBC,W
093A:  ADDWF  xC1,F
093C:  MOVFF  FF2,C2
0940:  BCF    FF2.7
0942:  MOVFF  C1,FA9
0946:  BCF    FA6.6
0948:  BCF    FA6.7
094A:  BSF    FA6.0
094C:  MOVF   FA8,W
094E:  BTFSC  xC2.7
0950:  BSF    FF2.7
0952:  MOVWF  xC1
0954:  MOVFF  C0,FEA
0958:  MOVFF  BF,FE9
095C:  MOVFF  C1,C9
0960:  CLRF   xCB
0962:  MOVLW  01
0964:  MOVWF  xCA
0966:  RCALL  0664
0968:  INCF   xBB,F
096A:  BRA    091E
....................    		temp_mem= &act_max_stroke[j]; 
096C:  BCF    FD8.0
096E:  RLCF   xBC,W
0970:  CLRF   03
0972:  ADDLW  9C
0974:  MOVWF  01
0976:  MOVLW  00
0978:  ADDWFC 03,F
097A:  MOVFF  01,BD
097E:  MOVFF  03,BE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_ACT_MAX_LEN+i+j*2),1); 
0982:  CLRF   xBB
0984:  MOVF   xBB,W
0986:  SUBLW  01
0988:  BNC   09D2
098A:  MOVF   xBB,W
098C:  ADDWF  xBD,W
098E:  MOVWF  xBF
0990:  MOVLW  00
0992:  ADDWFC xBE,W
0994:  MOVWF  xC0
0996:  MOVLW  70
0998:  ADDWF  xBB,W
099A:  MOVWF  xC1
099C:  BCF    FD8.0
099E:  RLCF   xBC,W
09A0:  ADDWF  xC1,F
09A2:  MOVFF  FF2,C2
09A6:  BCF    FF2.7
09A8:  MOVFF  C1,FA9
09AC:  BCF    FA6.6
09AE:  BCF    FA6.7
09B0:  BSF    FA6.0
09B2:  MOVF   FA8,W
09B4:  BTFSC  xC2.7
09B6:  BSF    FF2.7
09B8:  MOVWF  xC1
09BA:  MOVFF  C0,FEA
09BE:  MOVFF  BF,FE9
09C2:  MOVFF  C1,C9
09C6:  CLRF   xCB
09C8:  MOVLW  01
09CA:  MOVWF  xCA
09CC:  RCALL  0664
09CE:  INCF   xBB,F
09D0:  BRA    0984
....................  
....................    } 
09D2:  INCF   xBC,F
09D4:  BRA    0772
....................  
....................  
.................... } 
09D6:  GOTO   2B7E (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i,j; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0A40:  CLRF   xC0
0A42:  MOVF   xC0,W
0A44:  SUBLW  03
0A46:  BNC   0AA8
0A48:  MOVLW  20
0A4A:  ADDWF  xC0,W
0A4C:  MOVWF  xC2
0A4E:  MOVF   xC0,W
0A50:  MULLW  08
0A52:  MOVFF  FF3,C3
0A56:  MOVFF  25,C7
0A5A:  MOVFF  24,C6
0A5E:  MOVFF  23,C5
0A62:  MOVFF  22,C4
0A66:  MOVF   xC3,F
0A68:  BZ    0A78
0A6A:  BCF    FD8.0
0A6C:  RRCF   xC7,F
0A6E:  RRCF   xC6,F
0A70:  RRCF   xC5,F
0A72:  RRCF   xC4,F
0A74:  DECFSZ xC3,F
0A76:  BRA    0A6A
0A78:  MOVFF  C2,FA9
0A7C:  MOVFF  C4,FA8
0A80:  BCF    FA6.6
0A82:  BCF    FA6.7
0A84:  BSF    FA6.2
0A86:  MOVFF  FF2,00
0A8A:  BCF    FF2.7
0A8C:  MOVLB  F
0A8E:  MOVLW  55
0A90:  MOVWF  FA7
0A92:  MOVLW  AA
0A94:  MOVWF  FA7
0A96:  BSF    FA6.1
0A98:  BTFSC  FA6.1
0A9A:  BRA    0A98
0A9C:  BCF    FA6.2
0A9E:  MOVF   00,W
0AA0:  IORWF  FF2,F
0AA2:  MOVLB  0
0AA4:  INCF   xC0,F
0AA6:  BRA    0A42
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i+4,nDay>>(i*8)); 
0AA8:  CLRF   xC0
0AAA:  MOVF   xC0,W
0AAC:  SUBLW  03
0AAE:  BNC   0B12
0AB0:  MOVLW  20
0AB2:  ADDWF  xC0,W
0AB4:  ADDLW  04
0AB6:  MOVWF  xC2
0AB8:  MOVF   xC0,W
0ABA:  MULLW  08
0ABC:  MOVFF  FF3,C3
0AC0:  MOVFF  31,C7
0AC4:  MOVFF  30,C6
0AC8:  MOVFF  2F,C5
0ACC:  MOVFF  2E,C4
0AD0:  MOVF   xC3,F
0AD2:  BZ    0AE2
0AD4:  BCF    FD8.0
0AD6:  RRCF   xC7,F
0AD8:  RRCF   xC6,F
0ADA:  RRCF   xC5,F
0ADC:  RRCF   xC4,F
0ADE:  DECFSZ xC3,F
0AE0:  BRA    0AD4
0AE2:  MOVFF  C2,FA9
0AE6:  MOVFF  C4,FA8
0AEA:  BCF    FA6.6
0AEC:  BCF    FA6.7
0AEE:  BSF    FA6.2
0AF0:  MOVFF  FF2,00
0AF4:  BCF    FF2.7
0AF6:  MOVLB  F
0AF8:  MOVLW  55
0AFA:  MOVWF  FA7
0AFC:  MOVLW  AA
0AFE:  MOVWF  FA7
0B00:  BSF    FA6.1
0B02:  BTFSC  FA6.1
0B04:  BRA    0B02
0B06:  BCF    FA6.2
0B08:  MOVF   00,W
0B0A:  IORWF  FF2,F
0B0C:  MOVLB  0
0B0E:  INCF   xC0,F
0B10:  BRA    0AAA
....................  
....................    for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2,current_act_position[j]>>(i*8)); 
0B12:  CLRF   xC1
0B14:  MOVF   xC1,W
0B16:  SUBLW  03
0B18:  BNC   0B92
0B1A:  CLRF   xC0
0B1C:  MOVF   xC0,W
0B1E:  SUBLW  01
0B20:  BNC   0B8E
0B22:  MOVLW  10
0B24:  ADDWF  xC0,W
0B26:  MOVWF  xC2
0B28:  BCF    FD8.0
0B2A:  RLCF   xC1,W
0B2C:  ADDWF  xC2,F
0B2E:  BCF    FD8.0
0B30:  RLCF   xC1,W
0B32:  CLRF   03
0B34:  ADDLW  8A
0B36:  MOVWF  FE9
0B38:  MOVLW  00
0B3A:  ADDWFC 03,W
0B3C:  MOVWF  FEA
0B3E:  MOVFF  FEC,C4
0B42:  MOVF   FED,F
0B44:  MOVFF  FEF,C3
0B48:  MOVF   xC0,W
0B4A:  MULLW  08
0B4C:  MOVFF  FF3,00
0B50:  MOVF   00,F
0B52:  BZ    0B5E
0B54:  BCF    FD8.0
0B56:  RRCF   xC4,F
0B58:  RRCF   xC3,F
0B5A:  DECFSZ 00,F
0B5C:  BRA    0B54
0B5E:  MOVFF  C2,FA9
0B62:  MOVFF  C3,FA8
0B66:  BCF    FA6.6
0B68:  BCF    FA6.7
0B6A:  BSF    FA6.2
0B6C:  MOVFF  FF2,00
0B70:  BCF    FF2.7
0B72:  MOVLB  F
0B74:  MOVLW  55
0B76:  MOVWF  FA7
0B78:  MOVLW  AA
0B7A:  MOVWF  FA7
0B7C:  BSF    FA6.1
0B7E:  BTFSC  FA6.1
0B80:  BRA    0B7E
0B82:  BCF    FA6.2
0B84:  MOVF   00,W
0B86:  IORWF  FF2,F
0B88:  MOVLB  0
0B8A:  INCF   xC0,F
0B8C:  BRA    0B1C
0B8E:  INCF   xC1,F
0B90:  BRA    0B14
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
0B92:  CLRF   xC0
0B94:  MOVF   xC0,W
0B96:  SUBLW  01
0B98:  BNC   0BEE
0B9A:  MOVLW  30
0B9C:  ADDWF  xC0,W
0B9E:  MOVWF  xC2
0BA0:  MOVF   xC0,W
0BA2:  MULLW  08
0BA4:  MOVFF  FF3,00
0BA8:  MOVFF  33,C4
0BAC:  MOVFF  32,C3
0BB0:  MOVF   00,F
0BB2:  BZ    0BBE
0BB4:  BCF    FD8.0
0BB6:  RRCF   xC4,F
0BB8:  RRCF   xC3,F
0BBA:  DECFSZ 00,F
0BBC:  BRA    0BB4
0BBE:  MOVFF  C2,FA9
0BC2:  MOVFF  C3,FA8
0BC6:  BCF    FA6.6
0BC8:  BCF    FA6.7
0BCA:  BSF    FA6.2
0BCC:  MOVFF  FF2,00
0BD0:  BCF    FF2.7
0BD2:  MOVLB  F
0BD4:  MOVLW  55
0BD6:  MOVWF  FA7
0BD8:  MOVLW  AA
0BDA:  MOVWF  FA7
0BDC:  BSF    FA6.1
0BDE:  BTFSC  FA6.1
0BE0:  BRA    0BDE
0BE2:  BCF    FA6.2
0BE4:  MOVF   00,W
0BE6:  IORWF  FF2,F
0BE8:  MOVLB  0
0BEA:  INCF   xC0,F
0BEC:  BRA    0B94
....................    if (write_cal ==1) { 
0BEE:  DECFSZ xBF,W
0BF0:  BRA    0D6E
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i+j*2,act_full_stroke_tick[j]>>(i*8)); 
0BF2:  CLRF   xC1
0BF4:  MOVF   xC1,W
0BF6:  SUBLW  03
0BF8:  BNC   0C6E
0BFA:  CLRF   xC0
0BFC:  MOVF   xC0,W
0BFE:  SUBLW  01
0C00:  BNC   0C6A
0C02:  BCF    FD8.0
0C04:  RLCF   xC1,W
0C06:  ADDWF  xC0,W
0C08:  MOVWF  xC2
0C0A:  BCF    FD8.0
0C0C:  RLCF   xC1,W
0C0E:  CLRF   03
0C10:  ADDLW  94
0C12:  MOVWF  FE9
0C14:  MOVLW  00
0C16:  ADDWFC 03,W
0C18:  MOVWF  FEA
0C1A:  MOVFF  FEC,C4
0C1E:  MOVF   FED,F
0C20:  MOVFF  FEF,C3
0C24:  MOVF   xC0,W
0C26:  MULLW  08
0C28:  MOVFF  FF3,00
0C2C:  MOVF   00,F
0C2E:  BZ    0C3A
0C30:  BCF    FD8.0
0C32:  RRCF   xC4,F
0C34:  RRCF   xC3,F
0C36:  DECFSZ 00,F
0C38:  BRA    0C30
0C3A:  MOVFF  C2,FA9
0C3E:  MOVFF  C3,FA8
0C42:  BCF    FA6.6
0C44:  BCF    FA6.7
0C46:  BSF    FA6.2
0C48:  MOVFF  FF2,00
0C4C:  BCF    FF2.7
0C4E:  MOVLB  F
0C50:  MOVLW  55
0C52:  MOVWF  FA7
0C54:  MOVLW  AA
0C56:  MOVWF  FA7
0C58:  BSF    FA6.1
0C5A:  BTFSC  FA6.1
0C5C:  BRA    0C5A
0C5E:  BCF    FA6.2
0C60:  MOVF   00,W
0C62:  IORWF  FF2,F
0C64:  MOVLB  0
0C66:  INCF   xC0,F
0C68:  BRA    0BFC
0C6A:  INCF   xC1,F
0C6C:  BRA    0BF4
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_ACT_MIN_LEN+i+j*2,act_min_stroke[j]>>(i*8)); 
0C6E:  CLRF   xC1
0C70:  MOVF   xC1,W
0C72:  SUBLW  03
0C74:  BNC   0CEE
0C76:  CLRF   xC0
0C78:  MOVF   xC0,W
0C7A:  SUBLW  01
0C7C:  BNC   0CEA
0C7E:  MOVLW  60
0C80:  ADDWF  xC0,W
0C82:  MOVWF  xC2
0C84:  BCF    FD8.0
0C86:  RLCF   xC1,W
0C88:  ADDWF  xC2,F
0C8A:  BCF    FD8.0
0C8C:  RLCF   xC1,W
0C8E:  CLRF   03
0C90:  ADDLW  A4
0C92:  MOVWF  FE9
0C94:  MOVLW  00
0C96:  ADDWFC 03,W
0C98:  MOVWF  FEA
0C9A:  MOVFF  FEC,C4
0C9E:  MOVF   FED,F
0CA0:  MOVFF  FEF,C3
0CA4:  MOVF   xC0,W
0CA6:  MULLW  08
0CA8:  MOVFF  FF3,00
0CAC:  MOVF   00,F
0CAE:  BZ    0CBA
0CB0:  BCF    FD8.0
0CB2:  RRCF   xC4,F
0CB4:  RRCF   xC3,F
0CB6:  DECFSZ 00,F
0CB8:  BRA    0CB0
0CBA:  MOVFF  C2,FA9
0CBE:  MOVFF  C3,FA8
0CC2:  BCF    FA6.6
0CC4:  BCF    FA6.7
0CC6:  BSF    FA6.2
0CC8:  MOVFF  FF2,00
0CCC:  BCF    FF2.7
0CCE:  MOVLB  F
0CD0:  MOVLW  55
0CD2:  MOVWF  FA7
0CD4:  MOVLW  AA
0CD6:  MOVWF  FA7
0CD8:  BSF    FA6.1
0CDA:  BTFSC  FA6.1
0CDC:  BRA    0CDA
0CDE:  BCF    FA6.2
0CE0:  MOVF   00,W
0CE2:  IORWF  FF2,F
0CE4:  MOVLB  0
0CE6:  INCF   xC0,F
0CE8:  BRA    0C78
0CEA:  INCF   xC1,F
0CEC:  BRA    0C70
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_ACT_MAX_LEN+i+j*2,act_max_stroke[j]>>(i*8)); 
0CEE:  CLRF   xC1
0CF0:  MOVF   xC1,W
0CF2:  SUBLW  03
0CF4:  BNC   0D6E
0CF6:  CLRF   xC0
0CF8:  MOVF   xC0,W
0CFA:  SUBLW  01
0CFC:  BNC   0D6A
0CFE:  MOVLW  70
0D00:  ADDWF  xC0,W
0D02:  MOVWF  xC2
0D04:  BCF    FD8.0
0D06:  RLCF   xC1,W
0D08:  ADDWF  xC2,F
0D0A:  BCF    FD8.0
0D0C:  RLCF   xC1,W
0D0E:  CLRF   03
0D10:  ADDLW  9C
0D12:  MOVWF  FE9
0D14:  MOVLW  00
0D16:  ADDWFC 03,W
0D18:  MOVWF  FEA
0D1A:  MOVFF  FEC,C4
0D1E:  MOVF   FED,F
0D20:  MOVFF  FEF,C3
0D24:  MOVF   xC0,W
0D26:  MULLW  08
0D28:  MOVFF  FF3,00
0D2C:  MOVF   00,F
0D2E:  BZ    0D3A
0D30:  BCF    FD8.0
0D32:  RRCF   xC4,F
0D34:  RRCF   xC3,F
0D36:  DECFSZ 00,F
0D38:  BRA    0D30
0D3A:  MOVFF  C2,FA9
0D3E:  MOVFF  C3,FA8
0D42:  BCF    FA6.6
0D44:  BCF    FA6.7
0D46:  BSF    FA6.2
0D48:  MOVFF  FF2,00
0D4C:  BCF    FF2.7
0D4E:  MOVLB  F
0D50:  MOVLW  55
0D52:  MOVWF  FA7
0D54:  MOVLW  AA
0D56:  MOVWF  FA7
0D58:  BSF    FA6.1
0D5A:  BTFSC  FA6.1
0D5C:  BRA    0D5A
0D5E:  BCF    FA6.2
0D60:  MOVF   00,W
0D62:  IORWF  FF2,F
0D64:  MOVLB  0
0D66:  INCF   xC0,F
0D68:  BRA    0CF8
0D6A:  INCF   xC1,F
0D6C:  BRA    0CF0
....................    } 
....................  
.................... } 
0D6E:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////// 
.................... void button_scan() { 
....................    int8 i; 
....................     flag2.button_pressed=0; 
*
01A0:  BCF    20.1
....................    for(i=0;i<6;i++) { 
01A2:  CLRF   xE2
01A4:  MOVF   xE2,W
01A6:  SUBLW  05
01A8:  BNC   01E0
....................       portd.data_bus=i; 
01AA:  MOVF   xE2,W
01AC:  ANDLW  0F
01AE:  MOVWF  00
01B0:  MOVLW  F0
01B2:  ANDWF  F83,W
01B4:  IORWF  00,W
01B6:  MOVWF  F83
....................       portd.MUX_en =0; 
01B8:  BCF    F83.6
....................       delay_cycles(20); 
01BA:  MOVLW  06
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  NOP   
....................       if (!input(PIN_E0)) { 
01C4:  BSF    F96.0
01C6:  BTFSC  F84.0
01C8:  BRA    01D0
....................          flag2.button_pressed=1; 
01CA:  BSF    20.1
....................          nButton=i; 
01CC:  MOVFF  E2,4B
....................       }  
....................       delay_cycles(20); 
01D0:  MOVLW  06
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  NOP   
....................       portd.MUX_en =1; 
01DA:  BSF    F83.6
....................    } 
01DC:  INCF   xE2,F
01DE:  BRA    01A4
....................    restart_wdt(); 
01E0:  CLRWDT
.................... } 
01E2:  RETLW  00
....................  
....................  
.................... ////////////////////////////////// 
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       //set_timer1(get_timer1()+0x7FB8); 
....................      #asm 
....................       MOVLW 0x00; 
01E4:  MOVLW  00
....................       MOVWF TMR1; 
01E6:  MOVWF  FCE
....................       MOVLW 0x80; 
01E8:  MOVLW  80
....................       MOVWF TMR1H; 
01EA:  MOVWF  FCF
....................      #endasm 
....................       timer_sec+=1;  
01EC:  MOVLW  01
01EE:  ADDWF  22,F
01F0:  MOVLW  00
01F2:  ADDWFC 23,F
01F4:  ADDWFC 24,F
01F6:  ADDWFC 25,F
....................      last_command +=1; 
01F8:  MOVLW  01
01FA:  ADDWF  4C,F
01FC:  MOVLW  00
01FE:  ADDWFC 4D,F
0200:  ADDWFC 4E,F
0202:  ADDWFC 4F,F
....................       if (timer_sec>=86400) { 
0204:  MOVF   25,F
0206:  BNZ   0222
0208:  MOVF   24,W
020A:  SUBLW  00
020C:  BC    0268
020E:  XORLW  FF
0210:  BNZ   0222
0212:  MOVF   23,W
0214:  SUBLW  50
0216:  BC    0268
0218:  XORLW  FF
021A:  BNZ   0222
021C:  MOVF   22,W
021E:  SUBLW  7F
0220:  BC    0268
....................       nDay = (nDay%1461)+1; 
0222:  MOVFF  31,E5
0226:  MOVFF  30,E4
022A:  MOVFF  2F,E3
022E:  MOVFF  2E,E2
0232:  CLRF   xE9
0234:  CLRF   xE8
0236:  MOVLW  05
0238:  MOVWF  xE7
023A:  MOVLW  B5
023C:  MOVWF  xE6
023E:  RCALL  00AA
0240:  MOVFF  FEF,E2
0244:  MOVFF  FEC,E3
0248:  MOVFF  FEC,E4
024C:  MOVFF  FEC,E5
0250:  MOVLW  01
0252:  ADDWF  xE2,W
0254:  MOVWF  2E
0256:  MOVLW  00
0258:  ADDWFC xE3,W
025A:  MOVWF  2F
025C:  MOVLW  00
025E:  ADDWFC xE4,W
0260:  MOVWF  30
0262:  MOVLW  00
0264:  ADDWFC xE5,W
0266:  MOVWF  31
....................      } 
....................      timer_sec = timer_sec % 86400; 
0268:  MOVFF  25,E5
026C:  MOVFF  24,E4
0270:  MOVFF  23,E3
0274:  MOVFF  22,E2
0278:  CLRF   xE9
027A:  MOVLW  01
027C:  MOVWF  xE8
027E:  MOVLW  51
0280:  MOVWF  xE7
0282:  MOVLW  80
0284:  MOVWF  xE6
0286:  RCALL  00AA
0288:  MOVFF  FEF,22
028C:  MOVFF  FEC,23
0290:  MOVFF  FEC,24
0294:  MOVFF  FEC,25
....................      if (last_command > 180)// if no command recv in 3 minutes, reset the RS232 
0298:  MOVF   4F,F
029A:  BNZ   02AA
029C:  MOVF   4E,F
029E:  BNZ   02AA
02A0:  MOVF   4D,F
02A2:  BNZ   02AA
02A4:  MOVF   4C,W
02A6:  SUBLW  B4
02A8:  BC    02BA
....................      {    init_rs232(); 
02AA:  RCALL  0124
....................        last_command =0; 
02AC:  CLRF   4F
02AE:  CLRF   4E
02B0:  CLRF   4D
02B2:  CLRF   4C
....................        cmd_len =0; 
02B4:  CLRF   4A
.................... 	   output_low(TX_EN); 
02B6:  BCF    F96.1
02B8:  BCF    F8D.1
....................       }    
....................  
....................  
....................      if ((read_adc()+read_adc()+read_adc()+read_adc())/4<600) { 
02BA:  BSF    FC2.2
02BC:  BTFSC  FC2.2
02BE:  BRA    02BC
02C0:  MOVFF  FC4,03
02C4:  MOVFF  FC3,E2
02C8:  MOVFF  FC4,E3
02CC:  BSF    FC2.2
02CE:  BTFSC  FC2.2
02D0:  BRA    02CE
02D2:  MOVFF  FC4,03
02D6:  MOVF   FC3,W
02D8:  ADDWF  xE2,F
02DA:  MOVF   FC4,W
02DC:  ADDWFC xE3,F
02DE:  BSF    FC2.2
02E0:  BTFSC  FC2.2
02E2:  BRA    02E0
02E4:  MOVFF  FC4,03
02E8:  MOVF   FC3,W
02EA:  ADDWF  xE2,F
02EC:  MOVF   FC4,W
02EE:  ADDWFC xE3,F
02F0:  BSF    FC2.2
02F2:  BTFSC  FC2.2
02F4:  BRA    02F2
02F6:  MOVFF  FC4,03
02FA:  MOVF   FC3,W
02FC:  ADDWF  xE2,F
02FE:  MOVF   FC4,W
0300:  ADDWFC xE3,F
0302:  RRCF   xE3,F
0304:  RRCF   xE2,F
0306:  RRCF   xE3,F
0308:  RRCF   xE2,F
030A:  MOVLW  3F
030C:  ANDWF  xE3,F
030E:  MOVF   xE3,W
0310:  SUBLW  02
0312:  BNC   033A
0314:  BNZ   031C
0316:  MOVF   xE2,W
0318:  SUBLW  57
031A:  BNC   033A
....................        if (flag2.is_moving) flag2.abort_current_activity=1; 
031C:  BTFSC  20.6
031E:  BSF    20.2
....................        flag2.power = 0; 
0320:  BCF    20.5
....................        disable_interrupts(INT_RDA); 
0322:  BCF    F9D.5
....................        led_status =0xFE; 
0324:  MOVLW  FE
0326:  MOVWF  21
....................        display_LED(); 
0328:  RCALL  0144
....................        delay_ms(10); 
032A:  MOVLW  0A
032C:  MOVWF  xE2
032E:  RCALL  0178
....................        led_status =0xFF; 
0330:  MOVLW  FF
0332:  MOVWF  21
....................        display_LED(); 
0334:  RCALL  0144
....................          return; 
0336:  BRA    043E
....................      } else { 
0338:  BRA    0344
....................        if (flag2.power==0) { 
033A:  BTFSC  20.5
033C:  BRA    0342
....................          enable_interrupts(INT_RDA); 
033E:  BSF    F9D.5
....................          init_rs232(); 
0340:  RCALL  0124
....................        } 
....................        flag2.power=1; 
0342:  BSF    20.5
....................      } 
....................  
....................       flag.update_time = true; 
0344:  BSF    1F.1
....................       if (flag2.en_operate == 1) { 
0346:  BTFSS  20.0
0348:  BRA    0436
....................         led_status.power = !led_status.power; // blink power led 
034A:  BTG    21.0
....................       // display morning, noon, evening 
....................        if(timer_sec >64800 || timer_sec <21600) { 
034C:  MOVF   25,F
034E:  BNZ   037A
0350:  MOVF   24,F
0352:  BNZ   037A
0354:  MOVF   23,W
0356:  SUBLW  FC
0358:  BC    0364
035A:  XORLW  FF
035C:  BNZ   037A
035E:  MOVF   22,W
0360:  SUBLW  20
0362:  BNC   037A
0364:  MOVF   25,F
0366:  BNZ   0384
0368:  MOVF   24,F
036A:  BNZ   0384
036C:  MOVF   23,W
036E:  SUBLW  54
0370:  BNC   0384
0372:  BNZ   037A
0374:  MOVF   22,W
0376:  SUBLW  5F
0378:  BNC   0384
....................          led_status.aux=3; 
037A:  MOVLW  F3
037C:  ANDWF  21,W
037E:  IORLW  0C
0380:  MOVWF  21
....................       } else if ( timer_sec < 36000 ) { 
0382:  BRA    03CA
0384:  MOVF   25,F
0386:  BNZ   03A4
0388:  MOVF   24,F
038A:  BNZ   03A4
038C:  MOVF   23,W
038E:  SUBLW  8C
0390:  BNC   03A4
0392:  BNZ   039A
0394:  MOVF   22,W
0396:  SUBLW  9F
0398:  BNC   03A4
....................          led_status.aux=2; 
039A:  MOVLW  F3
039C:  ANDWF  21,W
039E:  IORLW  08
03A0:  MOVWF  21
....................       } else if ( timer_sec < 50400) { 
03A2:  BRA    03CA
03A4:  MOVF   25,F
03A6:  BNZ   03C2
03A8:  MOVF   24,F
03AA:  BNZ   03C2
03AC:  MOVF   23,W
03AE:  SUBLW  C4
03B0:  BNC   03C2
03B2:  BNZ   03BA
03B4:  MOVF   22,W
03B6:  SUBLW  DF
03B8:  BNC   03C2
....................          led_status.aux=0; 
03BA:  MOVLW  F3
03BC:  ANDWF  21,W
03BE:  MOVWF  21
....................       } else { 
03C0:  BRA    03CA
....................          led_status.aux=1; 
03C2:  MOVLW  F3
03C4:  ANDWF  21,W
03C6:  IORLW  04
03C8:  MOVWF  21
....................       } 
....................  
....................         display_LED(); 
03CA:  RCALL  0144
....................         switch ((unsigned int16) (timer_sec % 450)) { 
03CC:  MOVFF  25,E5
03D0:  MOVFF  24,E4
03D4:  MOVFF  23,E3
03D8:  MOVFF  22,E2
03DC:  CLRF   xE9
03DE:  CLRF   xE8
03E0:  MOVLW  01
03E2:  MOVWF  xE7
03E4:  MOVLW  C2
03E6:  MOVWF  xE6
03E8:  RCALL  00AA
03EA:  MOVFF  FEF,00
03EE:  MOVFF  FEC,01
03F2:  MOVFF  FEC,02
03F6:  MOVFF  FEC,03
03FA:  MOVF   01,W
03FC:  MOVWF  03
03FE:  BNZ   0404
0400:  MOVF   00,F
0402:  BZ    0426
0404:  MOVF   03,W
0406:  BNZ   040E
0408:  MOVLW  6E
040A:  SUBWF  00,W
040C:  BZ    042A
040E:  MOVF   03,W
0410:  BNZ   0418
0412:  MOVLW  DC
0414:  SUBWF  00,W
0416:  BZ    042E
0418:  MOVLW  01
041A:  SUBWF  03,W
041C:  BNZ   0424
041E:  MOVLW  4A
0420:  SUBWF  00,W
0422:  BZ    0432
0424:  BRA    0436
....................          case 0: {   bit_set(actuator_move_mask,0); break;} 
0426:  BSF    xB4.0
0428:  BRA    0436
....................          case 110: {   bit_set(actuator_move_mask,1); break;} 
042A:  BSF    xB4.1
042C:  BRA    0436
....................          case 220: {   bit_set(actuator_move_mask,2); break;} 
042E:  BSF    xB4.2
0430:  BRA    0436
....................          case 330: {   bit_set(actuator_move_mask,3); break;} 
0432:  BSF    xB4.3
0434:  BRA    0436
....................         } 
....................      } 
....................      button_scan(); 
0436:  RCALL  01A0
....................      if (nButton == 0) flag2.abort_current_activity=1; 
0438:  MOVF   4B,F
043A:  BTFSC  FD8.2
043C:  BSF    20.2
....................  
.................... } 
....................  
043E:  BCF    F9E.0
0440:  GOTO   0064
.................... void init_spi() { 
....................    setup_spi(spi_master |spi_h_to_l | spi_clk_div_16 ); 
*
059A:  BCF    FC6.5
059C:  BCF    F94.5
059E:  BSF    F94.4
05A0:  BCF    F94.3
05A2:  MOVLW  31
05A4:  MOVWF  FC6
05A6:  MOVLW  40
05A8:  MOVWF  FC7
....................     SSPSTAT = 0xC0; 
05AA:  MOVLW  C0
05AC:  MOVWF  FC7
.................... } 
05AE:  GOTO   2A6A (RETURN)
....................  
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................    int8 i; 
....................    int8 checksum =0x00; 
*
04E0:  CLRF   xE4
....................    int16 msg_addr; 
....................  
....................    c=getc(); 
04E2:  BTFSS  F9E.5
04E4:  BRA    04E2
04E6:  MOVFF  FAE,E2
....................    switch (c) {    
04EA:  MOVF   xE2,W
04EC:  XORLW  A8
04EE:  BZ    04F6
04F0:  XORLW  01
04F2:  BZ    0566
04F4:  BRA    056C
....................     case(0xA8):{ if(cmd_len>=4) { 
04F6:  MOVF   4A,W
04F8:  SUBLW  03
04FA:  BC    0562
....................                   for(i=0;i<cmd_len;i++) 
04FC:  CLRF   xE3
04FE:  MOVF   4A,W
0500:  SUBWF  xE3,W
0502:  BC    051A
....................                   { 
....................                   checksum ^= cmd_msg[i]; 
0504:  CLRF   03
0506:  MOVF   xE3,W
0508:  ADDLW  36
050A:  MOVWF  FE9
050C:  MOVLW  00
050E:  ADDWFC 03,W
0510:  MOVWF  FEA
0512:  MOVF   FEF,W
0514:  XORWF  xE4,F
....................                   } 
0516:  INCF   xE3,F
0518:  BRA    04FE
....................                if (checksum != 0x00) {cmd_len=0; return;} 
051A:  MOVF   xE4,F
051C:  BZ    0522
051E:  CLRF   4A
0520:  BRA    0594
....................                msg_addr = make16(cmd_msg[0],cmd_msg[1]); // address 
0522:  MOVFF  36,E6
0526:  MOVFF  37,E5
....................                if (msg_addr != 0xFFFE && msg_addr != dev_id) {cmd_len=0; return;} // address not correct, just ignore this command 
052A:  MOVF   xE5,W
052C:  SUBLW  FE
052E:  BNZ   0536
0530:  INCFSZ xE6,W
0532:  BRA    0536
0534:  BRA    0546
0536:  MOVF   34,W
0538:  SUBWF  xE5,W
053A:  BNZ   0542
053C:  MOVF   35,W
053E:  SUBWF  xE6,W
0540:  BZ    0546
0542:  CLRF   4A
0544:  BRA    0594
....................                command_byte = cmd_msg[2]; 
0546:  MOVFF  38,51
....................                aux_command = make16(cmd_msg[3],cmd_msg[4]); 
054A:  MOVFF  39,53
054E:  MOVFF  3A,52
....................                if (flag2.is_moving) send_data(7,0); // send BUSY 
0552:  BTFSS  20.6
0554:  BRA    0560
0556:  MOVLW  07
0558:  MOVWF  xE7
055A:  CLRF   xE8
055C:  RCALL  046E
....................                else flag.cmd_posted=true; 
055E:  BRA    0562
0560:  BSF    1F.3
....................                  
....................              }        
....................                 cmd_len =0; 
0562:  CLRF   4A
....................              break;} 
0564:  BRA    0594
....................     case(0xA9): {de_stuffing_mask = 0x20; break;} 
0566:  MOVLW  20
0568:  MOVWF  50
056A:  BRA    0594
....................      default:     {if(cmd_len<=MAX_CMD_LEN) { 
056C:  MOVF   4A,W
056E:  SUBLW  12
0570:  BNC   0590
....................                cmd_msg[cmd_len++]=c|de_stuffing_mask; 
0572:  MOVF   4A,W
0574:  INCF   4A,F
0576:  CLRF   03
0578:  ADDLW  36
057A:  MOVWF  FE9
057C:  MOVLW  00
057E:  ADDWFC 03,W
0580:  MOVWF  FEA
0582:  MOVF   xE2,W
0584:  IORWF  50,W
0586:  MOVWF  FEF
....................                last_command =0;  
0588:  CLRF   4F
058A:  CLRF   4E
058C:  CLRF   4D
058E:  CLRF   4C
....................             } 
....................             de_stuffing_mask = 0x00; 
0590:  CLRF   50
....................             break; } 
0592:  BRA    0594
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
0594:  BCF    F9E.5
0596:  GOTO   0064
.................... void process_cmd_msg() { 
....................    int8 i,j; 
....................     int16 temp_mem; 
....................     flag.cmd_posted =false; 
*
1D62:  BCF    1F.3
....................     last_command =0;     
1D64:  CLRF   4F
1D66:  CLRF   4E
1D68:  CLRF   4D
1D6A:  CLRF   4C
....................     switch(command_byte) { 
1D6C:  MOVF   51,W
1D6E:  XORLW  80
1D70:  BZ    1E06
1D72:  XORLW  02
1D74:  BZ    1E22
1D76:  XORLW  01
1D78:  BTFSC  FD8.2
1D7A:  BRA    1E52
1D7C:  XORLW  07
1D7E:  BTFSC  FD8.2
1D80:  BRA    1E82
1D82:  XORLW  01
1D84:  BTFSC  FD8.2
1D86:  BRA    1E96
1D88:  XORLW  0B
1D8A:  BTFSC  FD8.2
1D8C:  BRA    1EC0
1D8E:  XORLW  01
1D90:  BTFSC  FD8.2
1D92:  BRA    1EDC
1D94:  XORLW  BF
1D96:  BTFSC  FD8.2
1D98:  BRA    1F2A
1D9A:  XORLW  01
1D9C:  BTFSC  FD8.2
1D9E:  BRA    1F4C
1DA0:  XORLW  03
1DA2:  BTFSC  FD8.2
1DA4:  BRA    1F6E
1DA6:  XORLW  12
1DA8:  BTFSC  FD8.2
1DAA:  BRA    1FAE
1DAC:  XORLW  01
1DAE:  BTFSC  FD8.2
1DB0:  BRA    2028
1DB2:  XORLW  03
1DB4:  BTFSC  FD8.2
1DB6:  BRA    20A0
1DB8:  XORLW  01
1DBA:  BTFSC  FD8.2
1DBC:  BRA    2218
1DBE:  XORLW  07
1DC0:  BTFSC  FD8.2
1DC2:  BRA    22D0
1DC4:  XORLW  01
1DC6:  BTFSC  FD8.2
1DC8:  BRA    2362
1DCA:  XORLW  03
1DCC:  BTFSC  FD8.2
1DCE:  BRA    23EC
1DD0:  XORLW  01
1DD2:  BTFSC  FD8.2
1DD4:  BRA    241E
1DD6:  XORLW  0F
1DD8:  BTFSC  FD8.2
1DDA:  BRA    2462
1DDC:  XORLW  38
1DDE:  BTFSC  FD8.2
1DE0:  BRA    24A6
1DE2:  XORLW  01
1DE4:  BTFSC  FD8.2
1DE6:  BRA    24F0
1DE8:  XORLW  03
1DEA:  BTFSC  FD8.2
1DEC:  BRA    252A
1DEE:  XORLW  01
1DF0:  BTFSC  FD8.2
1DF2:  BRA    254C
1DF4:  XORLW  12
1DF6:  BTFSC  FD8.2
1DF8:  BRA    2582
1DFA:  XORLW  03
1DFC:  BTFSC  FD8.2
1DFE:  GOTO   25DA
1E02:  GOTO   2632
.................... // level 8 is for flash related 
....................       // 0x80 = block erase 
....................       case 0x80: { flash_block_erase();  send_data(0,0); break; } 
1E06:  GOTO   0E46
1E0A:  CLRF   18
1E0C:  BTFSC  FF2.7
1E0E:  BSF    18.7
1E10:  BCF    FF2.7
1E12:  CLRF   xE7
1E14:  CLRF   xE8
1E16:  CALL   046E
1E1A:  BTFSC  18.7
1E1C:  BSF    FF2.7
1E1E:  GOTO   2632
....................       // 0x82  = write buffer 1 to flash page 
....................      case 0x82: { disable_interrupts(GLOBAL); 
1E22:  BCF    FF2.6
1E24:  BCF    FF2.7
1E26:  BTFSC  FF2.7
1E28:  BRA    1E24
....................                   flash_write_buffer1_to_main_memory(aux_command); 
1E2A:  MOVFF  53,C0
1E2E:  MOVFF  52,BF
1E32:  GOTO   0EA0
1E36:  CLRF   18
1E38:  BTFSC  FF2.7
1E3A:  BSF    18.7
1E3C:  BCF    FF2.7
....................                send_data(0,0); 
1E3E:  CLRF   xE7
1E40:  CLRF   xE8
1E42:  CALL   046E
1E46:  BTFSC  18.7
1E48:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL); 
1E4A:  MOVLW  C0
1E4C:  IORWF  FF2,F
....................                   break;  
1E4E:  GOTO   2632
....................              } 
....................      // 0x83 = read page to buffer 1 
....................      case 0x83: { 
....................                   disable_interrupts(GLOBAL); 
1E52:  BCF    FF2.6
1E54:  BCF    FF2.7
1E56:  BTFSC  FF2.7
1E58:  BRA    1E54
....................                   flash_read_main_memory_to_buffer1(aux_command); 
1E5A:  MOVFF  53,C0
1E5E:  MOVFF  52,BF
1E62:  GOTO   0EF4
1E66:  CLRF   18
1E68:  BTFSC  FF2.7
1E6A:  BSF    18.7
1E6C:  BCF    FF2.7
....................                  send_data(0,0); 
1E6E:  CLRF   xE7
1E70:  CLRF   xE8
1E72:  CALL   046E
1E76:  BTFSC  18.7
1E78:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL);    
1E7A:  MOVLW  C0
1E7C:  IORWF  FF2,F
....................                 break; 
1E7E:  GOTO   2632
....................               }    
....................      // 0x84 = Buffer1 read 
....................      case 0x84: { //buffer1 read 
....................                   disable_interrupts(GLOBAL); 
1E82:  BCF    FF2.6
1E84:  BCF    FF2.7
1E86:  BTFSC  FF2.7
1E88:  BRA    1E84
....................                 send_buffer1_content(); 
1E8A:  GOTO   0F3E
....................                   enable_interrupts(GLOBAL);          
1E8E:  MOVLW  C0
1E90:  IORWF  FF2,F
....................                   break;   } 
1E92:  GOTO   2632
....................  
....................      case 0x85: { //test code 
....................                   disable_interrupts(GLOBAL); 
1E96:  BCF    FF2.6
1E98:  BCF    FF2.7
1E9A:  BTFSC  FF2.7
1E9C:  BRA    1E98
....................                flash_buffer1_write(0,0,255); 
1E9E:  CLRF   xBF
1EA0:  CLRF   xC0
1EA2:  MOVLW  FF
1EA4:  MOVWF  xC1
1EA6:  CALL   101A
....................                flash_buffer1_write(0x55,0x10,0x08); 
1EAA:  MOVLW  55
1EAC:  MOVWF  xBF
1EAE:  MOVLW  10
1EB0:  MOVWF  xC0
1EB2:  MOVLW  08
1EB4:  MOVWF  xC1
1EB6:  CALL   101A
....................                   enable_interrupts(GLOBAL);          
1EBA:  MOVLW  C0
1EBC:  IORWF  FF2,F
....................                   break;   } 
1EBE:  BRA    2632
....................  
....................  
....................      // 0x8E = set flash page size = 256 
....................       case 0x8E: {  flash_set_256_page_size(); send_data(6,0); break; } 
1EC0:  GOTO   107E
1EC4:  CLRF   18
1EC6:  BTFSC  FF2.7
1EC8:  BSF    18.7
1ECA:  BCF    FF2.7
1ECC:  MOVLW  06
1ECE:  MOVWF  xE7
1ED0:  CLRF   xE8
1ED2:  CALL   046E
1ED6:  BTFSC  18.7
1ED8:  BSF    FF2.7
1EDA:  BRA    2632
....................      // 0x8F = flash write page 
....................      case 0x8F: { 
....................                   disable_interrupts(GLOBAL); 
1EDC:  BCF    FF2.6
1EDE:  BCF    FF2.7
1EE0:  BTFSC  FF2.7
1EE2:  BRA    1EDE
....................                 setup_WDT(WDT_OFF); 
1EE4:  BCF    FD1.0
....................                   flash_write_page(aux_command); 
1EE6:  MOVFF  53,C0
1EEA:  MOVFF  52,BF
1EEE:  GOTO   10C0
....................                memcpy(output_buffer,&aux_command,2); 
1EF2:  CLRF   FEA
1EF4:  MOVLW  54
1EF6:  MOVWF  FE9
1EF8:  CLRF   FE2
1EFA:  MOVLW  52
1EFC:  MOVWF  FE1
1EFE:  MOVLW  02
1F00:  MOVWF  01
1F02:  MOVFF  FE6,FEE
1F06:  DECFSZ 01,F
1F08:  BRA    1F02
1F0A:  CLRF   18
1F0C:  BTFSC  FF2.7
1F0E:  BSF    18.7
1F10:  BCF    FF2.7
....................                 send_data(8,1); 
1F12:  MOVLW  08
1F14:  MOVWF  xE7
1F16:  MOVLW  01
1F18:  MOVWF  xE8
1F1A:  CALL   046E
1F1E:  BTFSC  18.7
1F20:  BSF    FF2.7
....................                 setup_WDT(WDT_ON); 
1F22:  BSF    FD1.0
....................                   enable_interrupts(GLOBAL); 
1F24:  MOVLW  C0
1F26:  IORWF  FF2,F
....................                   break;}      
1F28:  BRA    2632
.................... // level 3 = date and time setup 
....................      case 0x30: { // set date 
....................          nDay= aux_command;  send_data(0,0);break;    } 
1F2A:  CLRF   31
1F2C:  CLRF   30
1F2E:  MOVFF  53,2F
1F32:  MOVFF  52,2E
1F36:  CLRF   18
1F38:  BTFSC  FF2.7
1F3A:  BSF    18.7
1F3C:  BCF    FF2.7
1F3E:  CLRF   xE7
1F40:  CLRF   xE8
1F42:  CALL   046E
1F46:  BTFSC  18.7
1F48:  BSF    FF2.7
1F4A:  BRA    2632
....................      case 0x31: { // set low byte of time 
....................        timer_sec = aux_command; // rouding to 60 sec 
1F4C:  CLRF   25
1F4E:  CLRF   24
1F50:  MOVFF  53,23
1F54:  MOVFF  52,22
1F58:  CLRF   18
1F5A:  BTFSC  FF2.7
1F5C:  BSF    18.7
1F5E:  BCF    FF2.7
....................        send_data(0,0); 
1F60:  CLRF   xE7
1F62:  CLRF   xE8
1F64:  CALL   046E
1F68:  BTFSC  18.7
1F6A:  BSF    FF2.7
....................          break;    } 
1F6C:  BRA    2632
....................      case 0x32: { // set high byte of time 
....................          temp_mem = &timer_sec; 
1F6E:  CLRF   xBE
1F70:  MOVLW  22
1F72:  MOVWF  xBD
....................        memcpy(temp_mem+2,&aux_command,2); 
1F74:  MOVLW  02
1F76:  ADDWF  xBD,W
1F78:  MOVWF  xBF
1F7A:  MOVLW  00
1F7C:  ADDWFC xBE,W
1F7E:  MOVWF  xC0
1F80:  MOVWF  FEA
1F82:  MOVFF  BF,FE9
1F86:  CLRF   FE2
1F88:  MOVLW  52
1F8A:  MOVWF  FE1
1F8C:  MOVLW  02
1F8E:  MOVWF  01
1F90:  MOVFF  FE6,FEE
1F94:  DECFSZ 01,F
1F96:  BRA    1F90
1F98:  CLRF   18
1F9A:  BTFSC  FF2.7
1F9C:  BSF    18.7
1F9E:  BCF    FF2.7
....................        send_data(0,0); 
1FA0:  CLRF   xE7
1FA2:  CLRF   xE8
1FA4:  CALL   046E
1FA8:  BTFSC  18.7
1FAA:  BSF    FF2.7
....................          break;    } 
1FAC:  BRA    2632
.................... // level 2 = actuator control 
....................       // 0x20 = move east 
....................      case 0x20: { if (flag2.is_moving) {send_data(1,0); break;} 
1FAE:  BTFSS  20.6
1FB0:  BRA    1FCA
1FB2:  CLRF   18
1FB4:  BTFSC  FF2.7
1FB6:  BSF    18.7
1FB8:  BCF    FF2.7
1FBA:  MOVLW  01
1FBC:  MOVWF  xE7
1FBE:  CLRF   xE8
1FC0:  CALL   046E
1FC4:  BTFSC  18.7
1FC6:  BSF    FF2.7
1FC8:  BRA    2632
1FCA:  CLRF   18
1FCC:  BTFSC  FF2.7
1FCE:  BSF    18.7
1FD0:  BCF    FF2.7
....................         send_data(0,0);  
1FD2:  CLRF   xE7
1FD4:  CLRF   xE8
1FD6:  CALL   046E
1FDA:  BTFSC  18.7
1FDC:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,1,(int8)(aux_command>>14));  
1FDE:  MOVFF  52,BF
1FE2:  MOVF   53,W
1FE4:  ANDLW  3F
1FE6:  MOVWF  xC0
1FE8:  SWAPF  53,W
1FEA:  MOVWF  02
1FEC:  CLRF   03
1FEE:  RRCF   02,F
1FF0:  RRCF   02,F
1FF2:  MOVLW  03
1FF4:  ANDWF  02,F
1FF6:  MOVFF  02,C1
1FFA:  MOVFF  C0,C3
1FFE:  MOVFF  52,C2
2002:  MOVLW  23
2004:  MOVWF  xC5
2006:  MOVLW  28
2008:  MOVWF  xC4
200A:  MOVFF  81,C7
200E:  MOVFF  80,C6
2012:  MOVLW  01
2014:  MOVWF  xC8
2016:  MOVFF  02,C9
201A:  CALL   1160
....................        last_actuator_pulse = actuator_pulse; 
201E:  MOVFF  83,85
2022:  MOVFF  82,84
....................       break;    } 
2026:  BRA    2632
....................      // 0x21 = move west 
....................      case 0x21: {  if (flag2.is_moving) {send_data(1,0); break;} 
2028:  BTFSS  20.6
202A:  BRA    2044
202C:  CLRF   18
202E:  BTFSC  FF2.7
2030:  BSF    18.7
2032:  BCF    FF2.7
2034:  MOVLW  01
2036:  MOVWF  xE7
2038:  CLRF   xE8
203A:  CALL   046E
203E:  BTFSC  18.7
2040:  BSF    FF2.7
2042:  BRA    2632
2044:  CLRF   18
2046:  BTFSC  FF2.7
2048:  BSF    18.7
204A:  BCF    FF2.7
....................       send_data(0,0); 
204C:  CLRF   xE7
204E:  CLRF   xE8
2050:  CALL   046E
2054:  BTFSC  18.7
2056:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,0,(int8)(aux_command>>14));  
2058:  MOVFF  52,BF
205C:  MOVF   53,W
205E:  ANDLW  3F
2060:  MOVWF  xC0
2062:  SWAPF  53,W
2064:  MOVWF  02
2066:  CLRF   03
2068:  RRCF   02,F
206A:  RRCF   02,F
206C:  MOVLW  03
206E:  ANDWF  02,F
2070:  MOVFF  02,C1
2074:  MOVFF  C0,C3
2078:  MOVFF  52,C2
207C:  MOVLW  23
207E:  MOVWF  xC5
2080:  MOVLW  28
2082:  MOVWF  xC4
2084:  MOVFF  81,C7
2088:  MOVFF  80,C6
208C:  CLRF   xC8
208E:  MOVFF  02,C9
2092:  CALL   1160
....................        last_actuator_pulse = actuator_pulse; 
2096:  MOVFF  83,85
209A:  MOVFF  82,84
....................       break;    } 
209E:  BRA    2632
....................      // 0x22 = go home 
....................       case 0x22: {  if (flag2.is_moving) {send_data(1,0); break;} 
20A0:  BTFSS  20.6
20A2:  BRA    20BC
20A4:  CLRF   18
20A6:  BTFSC  FF2.7
20A8:  BSF    18.7
20AA:  BCF    FF2.7
20AC:  MOVLW  01
20AE:  MOVWF  xE7
20B0:  CLRF   xE8
20B2:  CALL   046E
20B6:  BTFSC  18.7
20B8:  BSF    FF2.7
20BA:  BRA    2632
20BC:  CLRF   18
20BE:  BTFSC  FF2.7
20C0:  BSF    18.7
20C2:  BCF    FF2.7
....................                send_data(0,0); 
20C4:  CLRF   xE7
20C6:  CLRF   xE8
20C8:  CALL   046E
20CC:  BTFSC  18.7
20CE:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[(int8) aux_command]*(int32)(act_safety_stroke-act_min_stroke[(int8) aux_command]); 
20D0:  BCF    FD8.0
20D2:  RLCF   52,W
20D4:  CLRF   03
20D6:  ADDLW  94
20D8:  MOVWF  FE9
20DA:  MOVLW  00
20DC:  ADDWFC 03,W
20DE:  MOVWF  FEA
20E0:  MOVFF  FEC,03
20E4:  MOVF   FED,F
20E6:  MOVFF  FEF,BF
20EA:  MOVFF  03,C0
20EE:  CLRF   xC1
20F0:  CLRF   xC2
20F2:  BCF    FD8.0
20F4:  RLCF   52,W
20F6:  CLRF   03
20F8:  ADDLW  A4
20FA:  MOVWF  FE9
20FC:  MOVLW  00
20FE:  ADDWFC 03,W
2100:  MOVWF  FEA
2102:  MOVFF  FEC,03
2106:  MOVF   FED,F
2108:  MOVF   FEF,W
210A:  SUBWF  xAC,W
210C:  MOVWF  00
210E:  MOVF   03,W
2110:  SUBWFB xAD,W
2112:  MOVWF  03
2114:  MOVF   00,W
2116:  MOVFF  03,01
211A:  CLRF   02
211C:  CLRF   03
211E:  MOVFF  03,C6
2122:  MOVFF  02,C5
2126:  MOVFF  01,C4
212A:  MOVFF  00,C3
212E:  MOVFF  FEA,C8
2132:  MOVFF  FE9,C7
2136:  MOVFF  C2,D7
213A:  MOVFF  C1,D6
213E:  MOVFF  C0,D5
2142:  MOVFF  BF,D4
2146:  MOVFF  03,DB
214A:  MOVFF  02,DA
214E:  MOVFF  01,D9
2152:  MOVFF  00,D8
2156:  CALL   1506
215A:  MOVFF  C8,FEA
215E:  MOVFF  C7,FE9
2162:  MOVFF  03,29
2166:  MOVFF  02,28
216A:  MOVFF  01,27
216E:  MOVFF  00,26
....................                tick = tick/(act_max_stroke[(int8) aux_command]-act_min_stroke[(int8) aux_command]); 
2172:  BCF    FD8.0
2174:  RLCF   52,W
2176:  CLRF   03
2178:  ADDLW  9C
217A:  MOVWF  FE9
217C:  MOVLW  00
217E:  ADDWFC 03,W
2180:  MOVWF  FEA
2182:  MOVFF  FEC,C0
2186:  MOVF   FED,F
2188:  MOVFF  FEF,BF
218C:  BCF    FD8.0
218E:  RLCF   52,W
2190:  CLRF   03
2192:  ADDLW  A4
2194:  MOVWF  FE9
2196:  MOVLW  00
2198:  ADDWFC 03,W
219A:  MOVWF  FEA
219C:  MOVFF  FEC,03
21A0:  MOVF   FED,F
21A2:  MOVF   FEF,W
21A4:  SUBWF  xBF,W
21A6:  MOVWF  00
21A8:  MOVF   03,W
21AA:  SUBWFB xC0,W
21AC:  MOVWF  03
21AE:  MOVFF  00,BF
21B2:  MOVWF  xC0
21B4:  MOVFF  FEA,C2
21B8:  MOVFF  FE9,C1
21BC:  CLRF   18
21BE:  BTFSC  FF2.7
21C0:  BSF    18.7
21C2:  BCF    FF2.7
21C4:  MOVFF  29,E5
21C8:  MOVFF  28,E4
21CC:  MOVFF  27,E3
21D0:  MOVFF  26,E2
21D4:  CLRF   xE9
21D6:  CLRF   xE8
21D8:  MOVWF  xE7
21DA:  MOVFF  00,E6
21DE:  CALL   00AA
21E2:  BTFSC  18.7
21E4:  BSF    FF2.7
21E6:  MOVFF  C2,FEA
21EA:  MOVFF  C1,FE9
21EE:  MOVFF  03,29
21F2:  MOVFF  02,28
21F6:  MOVFF  01,27
21FA:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
21FE:  MOVFF  27,93
2202:  MOVFF  26,92
....................                actuator_move_execute((int8) aux_command); 
2206:  MOVFF  52,BF
220A:  CALL   155A
....................                    last_actuator_pulse = actuator_pulse; 
220E:  MOVFF  83,85
2212:  MOVFF  82,84
....................                break; } 
2216:  BRA    2632
....................      // 0x23 = cal act 
....................      case 0x23: {  if (flag2.is_moving) {send_data(1,0); break;} 
2218:  BTFSS  20.6
221A:  BRA    2234
221C:  CLRF   18
221E:  BTFSC  FF2.7
2220:  BSF    18.7
2222:  BCF    FF2.7
2224:  MOVLW  01
2226:  MOVWF  xE7
2228:  CLRF   xE8
222A:  CALL   046E
222E:  BTFSC  18.7
2230:  BSF    FF2.7
2232:  BRA    2632
2234:  CLRF   18
2236:  BTFSC  FF2.7
2238:  BSF    18.7
223A:  BCF    FF2.7
....................                send_data(0,0); 
223C:  CLRF   xE7
223E:  CLRF   xE8
2240:  CALL   046E
2244:  BTFSC  18.7
2246:  BSF    FF2.7
....................                   move_act(MAX_FULL_STROKE,9000,move_act_time_out,1,(int8) aux_command); // move actuator to west 
2248:  MOVLW  17
224A:  MOVWF  xC3
224C:  MOVLW  70
224E:  MOVWF  xC2
2250:  MOVLW  23
2252:  MOVWF  xC5
2254:  MOVLW  28
2256:  MOVWF  xC4
2258:  MOVFF  81,C7
225C:  MOVFF  80,C6
2260:  MOVLW  01
2262:  MOVWF  xC8
2264:  MOVFF  52,C9
2268:  CALL   1160
....................                   move_act(MAX_FULL_STROKE,9000,move_act_time_out,0,(int8) aux_command); // move actuator to home position 
226C:  MOVLW  17
226E:  MOVWF  xC3
2270:  MOVLW  70
2272:  MOVWF  xC2
2274:  MOVLW  23
2276:  MOVWF  xC5
2278:  MOVLW  28
227A:  MOVWF  xC4
227C:  MOVFF  81,C7
2280:  MOVFF  80,C6
2284:  CLRF   xC8
2286:  MOVFF  52,C9
228A:  CALL   1160
....................                   act_full_stroke_tick[(int8) aux_command]= actuator_pulse; 
228E:  BCF    FD8.0
2290:  RLCF   52,W
2292:  CLRF   03
2294:  ADDLW  94
2296:  MOVWF  FE9
2298:  MOVLW  00
229A:  ADDWFC 03,W
229C:  MOVWF  FEA
229E:  MOVFF  83,FEC
22A2:  MOVF   FED,F
22A4:  MOVFF  82,FEF
....................                   current_act_position[(int8) aux_command] =0; 
22A8:  BCF    FD8.0
22AA:  RLCF   52,W
22AC:  CLRF   03
22AE:  ADDLW  8A
22B0:  MOVWF  FE9
22B2:  MOVLW  00
22B4:  ADDWFC 03,W
22B6:  MOVWF  FEA
22B8:  CLRF   FEC
22BA:  MOVF   FED,F
22BC:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
22BE:  MOVLW  01
22C0:  MOVWF  xBF
22C2:  CALL   0A40
....................                 last_actuator_pulse = actuator_pulse; 
22C6:  MOVFF  83,85
22CA:  MOVFF  82,84
....................                   break; } 
22CE:  BRA    2632
....................      // 0x24 = report actuator stat 
....................      case 0x24: {   
.................... //               memcpy(output_buffer,&act_min_stroke,2); 
.................... //               memcpy(output_buffer+2,&act_max_stroke,2); 
.................... //               memcpy(output_buffer+4,&act_safety_stroke,2); 
.................... //               memcpy(output_buffer+6,act_full_stroke_tick,8); 
.................... //               memcpy(output_buffer+14,current_act_position,8); 
....................  
....................                memcpy(output_buffer,act_min_stroke,8); 
22D0:  CLRF   FEA
22D2:  MOVLW  54
22D4:  MOVWF  FE9
22D6:  CLRF   FE2
22D8:  MOVLW  A4
22DA:  MOVWF  FE1
22DC:  MOVLW  08
22DE:  MOVWF  01
22E0:  MOVFF  FE6,FEE
22E4:  DECFSZ 01,F
22E6:  BRA    22E0
....................                memcpy(output_buffer+8,act_max_stroke,8); 
22E8:  CLRF   FEA
22EA:  MOVLW  5C
22EC:  MOVWF  FE9
22EE:  CLRF   FE2
22F0:  MOVLW  9C
22F2:  MOVWF  FE1
22F4:  MOVLW  08
22F6:  MOVWF  01
22F8:  MOVFF  FE6,FEE
22FC:  DECFSZ 01,F
22FE:  BRA    22F8
....................                memcpy(output_buffer+16,&act_safety_stroke,2); 
2300:  CLRF   FEA
2302:  MOVLW  64
2304:  MOVWF  FE9
2306:  CLRF   FE2
2308:  MOVLW  AC
230A:  MOVWF  FE1
230C:  MOVLW  02
230E:  MOVWF  01
2310:  MOVFF  FE6,FEE
2314:  DECFSZ 01,F
2316:  BRA    2310
....................                memcpy(output_buffer+18,act_full_stroke_tick,8); 
2318:  CLRF   FEA
231A:  MOVLW  66
231C:  MOVWF  FE9
231E:  CLRF   FE2
2320:  MOVLW  94
2322:  MOVWF  FE1
2324:  MOVLW  08
2326:  MOVWF  01
2328:  MOVFF  FE6,FEE
232C:  DECFSZ 01,F
232E:  BRA    2328
....................                memcpy(output_buffer+26,current_act_position,8); 
2330:  CLRF   FEA
2332:  MOVLW  6E
2334:  MOVWF  FE9
2336:  CLRF   FE2
2338:  MOVLW  8A
233A:  MOVWF  FE1
233C:  MOVLW  08
233E:  MOVWF  01
2340:  MOVFF  FE6,FEE
2344:  DECFSZ 01,F
2346:  BRA    2340
2348:  CLRF   18
234A:  BTFSC  FF2.7
234C:  BSF    18.7
234E:  BCF    FF2.7
....................  
....................                send_data(4,33); 
2350:  MOVLW  04
2352:  MOVWF  xE7
2354:  MOVLW  21
2356:  MOVWF  xE8
2358:  CALL   046E
235C:  BTFSC  18.7
235E:  BSF    FF2.7
....................                break; 
2360:  BRA    2632
....................               }    
....................       // 0x25 = execute move on actuator to target position 
....................      case 0x25: {   if (flag2.is_moving) {send_data(1,0); break;} 
2362:  BTFSS  20.6
2364:  BRA    237E
2366:  CLRF   18
2368:  BTFSC  FF2.7
236A:  BSF    18.7
236C:  BCF    FF2.7
236E:  MOVLW  01
2370:  MOVWF  xE7
2372:  CLRF   xE8
2374:  CALL   046E
2378:  BTFSC  18.7
237A:  BSF    FF2.7
237C:  BRA    2632
....................               // send_data(0,0); 
....................                   if (act_full_stroke_tick[(int8) aux_command] > 0x10) { 
237E:  BCF    FD8.0
2380:  RLCF   52,W
2382:  CLRF   03
2384:  ADDLW  94
2386:  MOVWF  FE9
2388:  MOVLW  00
238A:  ADDWFC 03,W
238C:  MOVWF  FEA
238E:  MOVFF  FEC,C0
2392:  MOVF   FED,F
2394:  MOVFF  FEF,BF
2398:  MOVF   xC0,F
239A:  BNZ   23A2
239C:  MOVF   xBF,W
239E:  SUBLW  10
23A0:  BC    23E2
....................                   solar_get_act_length((int8) aux_command); 
23A2:  MOVFF  52,BF
23A6:  CALL   16EA
.................... 				memcpy(output_buffer,&target_act_position,2); 
23AA:  CLRF   FEA
23AC:  MOVLW  54
23AE:  MOVWF  FE9
23B0:  CLRF   FE2
23B2:  MOVLW  92
23B4:  MOVWF  FE1
23B6:  MOVLW  02
23B8:  MOVWF  01
23BA:  MOVFF  FE6,FEE
23BE:  DECFSZ 01,F
23C0:  BRA    23BA
23C2:  CLRF   18
23C4:  BTFSC  FF2.7
23C6:  BSF    18.7
23C8:  BCF    FF2.7
.................... 				send_data(11,1); 
23CA:  MOVLW  0B
23CC:  MOVWF  xE7
23CE:  MOVLW  01
23D0:  MOVWF  xE8
23D2:  CALL   046E
23D6:  BTFSC  18.7
23D8:  BSF    FF2.7
....................                 actuator_move_execute((int8) aux_command); 
23DA:  MOVFF  52,BF
23DE:  CALL   155A
....................                } 
....................                 last_actuator_pulse = actuator_pulse; 
23E2:  MOVFF  83,85
23E6:  MOVFF  82,84
....................                   break;    } 
23EA:  BRA    2632
....................  
....................      case 0x26: { // report last_actuator_move  
....................                memcpy(output_buffer,&last_actuator_pulse,2); 
23EC:  CLRF   FEA
23EE:  MOVLW  54
23F0:  MOVWF  FE9
23F2:  CLRF   FE2
23F4:  MOVLW  84
23F6:  MOVWF  FE1
23F8:  MOVLW  02
23FA:  MOVWF  01
23FC:  MOVFF  FE6,FEE
2400:  DECFSZ 01,F
2402:  BRA    23FC
2404:  CLRF   18
2406:  BTFSC  FF2.7
2408:  BSF    18.7
240A:  BCF    FF2.7
....................                send_data(5,1); 
240C:  MOVLW  05
240E:  MOVWF  xE7
2410:  MOVLW  01
2412:  MOVWF  xE8
2414:  CALL   046E
2418:  BTFSC  18.7
241A:  BSF    FF2.7
....................                 break; 
241C:  BRA    2632
....................             }    
....................  
.................... // new command 
.................... 	 case 0x27: { // set min actuator len ( len_in_cm x 256 ) 
.................... 				act_min_stroke[(int8) (aux_command & 0x0003)]=aux_command&0xFFFC; 
241E:  MOVF   52,W
2420:  ANDLW  03
2422:  MOVWF  00
2424:  CLRF   03
2426:  MOVF   00,W
2428:  BCF    FD8.0
242A:  RLCF   00,F
242C:  MOVF   00,W
242E:  CLRF   03
2430:  ADDLW  A4
2432:  MOVWF  FE9
2434:  MOVLW  00
2436:  ADDWFC 03,W
2438:  MOVWF  FEA
243A:  MOVF   52,W
243C:  ANDLW  FC
243E:  MOVWF  FEF
2440:  MOVFF  53,FEC
.................... 				write_eeprom_data(1); 
2444:  MOVLW  01
2446:  MOVWF  xBF
2448:  CALL   0A40
244C:  CLRF   18
244E:  BTFSC  FF2.7
2450:  BSF    18.7
2452:  BCF    FF2.7
.................... 				send_data(0,0); 
2454:  CLRF   xE7
2456:  CLRF   xE8
2458:  CALL   046E
245C:  BTFSC  18.7
245E:  BSF    FF2.7
.................... 				break; 
2460:  BRA    2632
.................... 		}	 
....................  
.................... 	 case 0x28: { 
.................... 				act_max_stroke[(int8) (aux_command & 0x0003)]=aux_command&0xFFFC; 
2462:  MOVF   52,W
2464:  ANDLW  03
2466:  MOVWF  00
2468:  CLRF   03
246A:  MOVF   00,W
246C:  BCF    FD8.0
246E:  RLCF   00,F
2470:  MOVF   00,W
2472:  CLRF   03
2474:  ADDLW  9C
2476:  MOVWF  FE9
2478:  MOVLW  00
247A:  ADDWFC 03,W
247C:  MOVWF  FEA
247E:  MOVF   52,W
2480:  ANDLW  FC
2482:  MOVWF  FEF
2484:  MOVFF  53,FEC
.................... 				write_eeprom_data(1); 
2488:  MOVLW  01
248A:  MOVWF  xBF
248C:  CALL   0A40
2490:  CLRF   18
2492:  BTFSC  FF2.7
2494:  BSF    18.7
2496:  BCF    FF2.7
.................... 				send_data(0,0); 
2498:  CLRF   xE7
249A:  CLRF   xE8
249C:  CALL   046E
24A0:  BTFSC  18.7
24A2:  BSF    FF2.7
.................... 				break; 
24A4:  BRA    2632
.................... 		}	 
....................  
....................  
....................  
....................   
.................... // level 1 command is for generic status 
....................      case 0x10: { memcpy(output_buffer,&nDay,4); 
24A6:  CLRF   FEA
24A8:  MOVLW  54
24AA:  MOVWF  FE9
24AC:  CLRF   FE2
24AE:  MOVLW  2E
24B0:  MOVWF  FE1
24B2:  MOVLW  04
24B4:  MOVWF  01
24B6:  MOVFF  FE6,FEE
24BA:  DECFSZ 01,F
24BC:  BRA    24B6
....................                    memcpy(output_buffer+4,&timer_sec,4); 
24BE:  CLRF   FEA
24C0:  MOVLW  58
24C2:  MOVWF  FE9
24C4:  CLRF   FE2
24C6:  MOVLW  22
24C8:  MOVWF  FE1
24CA:  MOVLW  04
24CC:  MOVWF  01
24CE:  MOVFF  FE6,FEE
24D2:  DECFSZ 01,F
24D4:  BRA    24CE
24D6:  CLRF   18
24D8:  BTFSC  FF2.7
24DA:  BSF    18.7
24DC:  BCF    FF2.7
....................                send_data(9,7); 
24DE:  MOVLW  09
24E0:  MOVWF  xE7
24E2:  MOVLW  07
24E4:  MOVWF  xE8
24E6:  CALL   046E
24EA:  BTFSC  18.7
24EC:  BSF    FF2.7
....................                break; } 
24EE:  BRA    2632
....................       // report status flag 
....................      case 0x11: { memcpy(output_buffer,&flag,1); 
24F0:  CLRF   FEA
24F2:  MOVLW  54
24F4:  MOVWF  FE9
24F6:  CLRF   FE2
24F8:  MOVLW  1F
24FA:  MOVWF  FE1
24FC:  MOVFF  FE6,FEE
....................                    memcpy(output_buffer+1,&flag2,1); 
2500:  CLRF   FEA
2502:  MOVLW  55
2504:  MOVWF  FE9
2506:  CLRF   FE2
2508:  MOVLW  20
250A:  MOVWF  FE1
250C:  MOVFF  FE6,FEE
2510:  CLRF   18
2512:  BTFSC  FF2.7
2514:  BSF    18.7
2516:  BCF    FF2.7
....................                send_data(10,1); 
2518:  MOVLW  0A
251A:  MOVWF  xE7
251C:  MOVLW  01
251E:  MOVWF  xE8
2520:  CALL   046E
2524:  BTFSC  18.7
2526:  BSF    FF2.7
....................                break; } 
2528:  BRA    2632
....................      case 0x12: { //write device id 
....................                dev_id = aux_command; 
252A:  MOVFF  53,35
252E:  MOVFF  52,34
....................                write_device_id(); 
2532:  GOTO   1CCE
2536:  CLRF   18
2538:  BTFSC  FF2.7
253A:  BSF    18.7
253C:  BCF    FF2.7
....................                send_data(0,0); 
253E:  CLRF   xE7
2540:  CLRF   xE8
2542:  CALL   046E
2546:  BTFSC  18.7
2548:  BSF    FF2.7
....................                break; 
254A:  BRA    2632
....................                } 
....................       case 0x13: { // read device_id 
....................                read_device_id(); 
254C:  CALL   09DA
....................                memcpy(output_buffer,&dev_id,2); 
2550:  CLRF   FEA
2552:  MOVLW  54
2554:  MOVWF  FE9
2556:  CLRF   FE2
2558:  MOVLW  34
255A:  MOVWF  FE1
255C:  MOVLW  02
255E:  MOVWF  01
2560:  MOVFF  FE6,FEE
2564:  DECFSZ 01,F
2566:  BRA    2560
2568:  CLRF   18
256A:  BTFSC  FF2.7
256C:  BSF    18.7
256E:  BCF    FF2.7
....................                send_data(11,1); 
2570:  MOVLW  0B
2572:  MOVWF  xE7
2574:  MOVLW  01
2576:  MOVWF  xE8
2578:  CALL   046E
257C:  BTFSC  18.7
257E:  BSF    FF2.7
....................                break;  
2580:  BRA    2632
....................              } 
....................  
....................  
.................... // level 0 communication control 
....................      case 0x01: {  // close/open communication port 
....................                 if (aux_command ==0x0000) {  
2582:  MOVF   52,F
2584:  BNZ   2590
2586:  MOVF   53,F
2588:  BNZ   2590
....................                   output_low(TX_EN); 
258A:  BCF    F96.1
258C:  BCF    F8D.1
....................                } else if (aux_command ==0x0001) { 
258E:  BRA    25D8
2590:  DECFSZ 52,W
2592:  BRA    25C2
2594:  MOVF   53,F
2596:  BNZ   25C2
....................                   output_high(TX_EN); 
2598:  BCF    F96.1
259A:  BSF    F8D.1
....................                   delay_us(900); 
259C:  MOVLW  04
259E:  MOVWF  xBF
25A0:  MOVLW  E0
25A2:  MOVWF  xC0
25A4:  GOTO   1D42
25A8:  DECFSZ xBF,F
25AA:  BRA    25A0
25AC:  CLRF   18
25AE:  BTFSC  FF2.7
25B0:  BSF    18.7
25B2:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
25B4:  CLRF   xE7
25B6:  CLRF   xE8
25B8:  CALL   046E
25BC:  BTFSC  18.7
25BE:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
25C0:  BRA    25D8
25C2:  CLRF   18
25C4:  BTFSC  FF2.7
25C6:  BSF    18.7
25C8:  BCF    FF2.7
25CA:  MOVLW  01
25CC:  MOVWF  xE7
25CE:  CLRF   xE8
25D0:  CALL   046E
25D4:  BTFSC  18.7
25D6:  BSF    FF2.7
....................                break; 
25D8:  BRA    2632
....................              }    
....................  
....................      case 0x02: {  // enable/disable operation 
....................                 if (aux_command ==0x0000) {  
25DA:  MOVF   52,F
25DC:  BNZ   25FA
25DE:  MOVF   53,F
25E0:  BNZ   25FA
....................                   flag2.en_operate=0; 
25E2:  BCF    20.0
25E4:  CLRF   18
25E6:  BTFSC  FF2.7
25E8:  BSF    18.7
25EA:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
25EC:  CLRF   xE7
25EE:  CLRF   xE8
25F0:  CALL   046E
25F4:  BTFSC  18.7
25F6:  BSF    FF2.7
....................                } else if (aux_command ==0x0001) { 
25F8:  BRA    2630
25FA:  DECFSZ 52,W
25FC:  BRA    261A
25FE:  MOVF   53,F
2600:  BNZ   261A
....................                   flag2.en_operate=1; 
2602:  BSF    20.0
2604:  CLRF   18
2606:  BTFSC  FF2.7
2608:  BSF    18.7
260A:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
260C:  CLRF   xE7
260E:  CLRF   xE8
2610:  CALL   046E
2614:  BTFSC  18.7
2616:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
2618:  BRA    2630
261A:  CLRF   18
261C:  BTFSC  FF2.7
261E:  BSF    18.7
2620:  BCF    FF2.7
2622:  MOVLW  01
2624:  MOVWF  xE7
2626:  CLRF   xE8
2628:  CALL   046E
262C:  BTFSC  18.7
262E:  BSF    FF2.7
....................                break; 
2630:  BRA    2632
....................              }    
....................  
....................  
....................  
....................    } 
....................  
.................... } 
2632:  GOTO   2C04 (RETURN)
....................  
.................... /* 
.................... void process_cmd_msg(){ 
....................    int8 i,j; 
....................    flag.cmd_posted =false; 
....................    last_command =0; 
....................    printf("\r\n>%s\r\n",cmd_msg); 
....................    switch (cmd_msg[0]) { 
....................       case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Block erase\r\n"); 
....................          flash_block_erase(); 
....................          break; } 
....................  
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
....................         setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
....................          print_page_data(atol(cmd_msg)); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'b': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Write buffer1 -> PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_buffer1_to_main_memory(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'c': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Read PAGE %ld -> buffer1",atol(cmd_msg)); 
....................          flash_read_main_memory_to_buffer1(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'f': { 
....................          disable_interrupts(GLOBAL); 
....................        setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n WRITE PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_page(atol(cmd_msg)); 
....................        printf("\r\n."); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'g': { 
....................          print_date_time(); 
....................          break; 
....................       } 
....................  
....................       case 'w': { //buffer1 read 
....................          disable_interrupts(GLOBAL); 
....................        printf("\r\n Buffer1:"); 
....................        for(i=0;i<16;i++) { 
....................             printf("\r\n%02X : ",i*16); 
....................             for (j=0;j<8;j++) { 
....................               flash_buffer1_read(i*16+j*2); 
....................             printf("%02X %02X ",flash_page_data,flash_page_data2); 
....................             restart_wdt(); 
....................             } 
....................        } 
....................          enable_interrupts(GLOBAL);          
....................          break;    
....................      } 
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
....................          break;    } 
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
....................          break;    } 
....................       case 'p': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Set 256 page size\r\n"); 
....................          flash_set_256_page_size(); 
....................          break; } 
....................  
....................      case 'z': { 
....................        print_fw_info(); 
....................        printf("\r\n startup = %ld",startup_counter); 
....................        break; 
....................      } 
....................      case 'd': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          nDay= atol(cmd_msg); 
....................          break;    } 
....................      case 't': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          timer_sec = atoi32(cmd_msg); 
....................        timer_sec = timer_sec; // rouding to 60 sec 
....................          break;    } 
....................      case 'l': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          solar_get_act_length(atoi(cmd_msg)); 
....................        disable_interrupts(GLOBAL); 
....................        printf("\r\n Act#%d Len=%lu Now=%lu\r\n",atoi(cmd_msg), target_act_position, current_act_position[atoi(cmd_msg)]); 
....................        enable_interrupts(GLOBAL); 
....................        actuator_move_execute(atoi(cmd_msg)); 
....................          break;    } 
....................       case 'h' : { //return home 
....................         memcpy(cmd_msg,cmd_msg+1,18); 
....................          if(strlen(cmd_msg)>0) { 
....................         flag2.en_operate =0; 
....................          move_act(2000,9000,move_act_time_out,1,atoi(cmd_msg)); // move actuator to west 
....................          move_act(2000,9000,move_act_time_out,0,atoi(cmd_msg)); // move actuator to home position 
....................          act_full_stroke_tick[atoi(cmd_msg)]= actuator_pulse; 
....................          current_act_position[atoi(cmd_msg)] =0; 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................         flag2.en_operate =1;  
....................        } 
....................  
....................          break; 
....................       } 
....................         
....................       case 'j': { 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................          break; 
....................       } 
....................  
....................      case 'o': { 
....................        flag2.en_operate = !flag2.en_operate; 
....................        if (flag2.en_operate) printf("\r\n Normal operation"); else printf("\r\n Halt operation"); 
....................        break; 
....................      } 
....................  
....................       case 'y': { //adc conversion 
....................          set_adc_channel(0); 
....................          delay_us(20); 
....................        wall_pwr_read =read_adc(); 
....................          printf("\r\nADC= %lu",wall_pwr_read); 
....................          break; 
....................       } 
....................       case 'k': { 
....................        disable_interrupts(GLOBAL); 
....................          while(1); 
....................          break; 
....................       } 
....................  
....................  
....................  
....................       }// end case       
.................... } 
....................  
.................... */ 
.................... ////////////////////////////////////// 
.................... void button_menu() { 
....................    int8 k; 
....................    int8 target_act=0; 
2636:  CLRF   xBC
....................     flag2.en_operate = 0; // enter halt operation 
2638:  BCF    20.0
....................    LED_status.power = 0; // always red 
263A:  BCF    21.0
....................    LED_status.operation =0; 
263C:  BCF    21.1
....................    LED_status.aux =3; // both turned off 
263E:  MOVLW  F3
2640:  ANDWF  21,W
2642:  IORLW  0C
2644:  MOVWF  21
....................    display_LED(); 
2646:  CALL   0144
....................     flag2.abort_current_activity =0; 
264A:  BCF    20.2
....................    while(flag2.button_pressed ==1)   button_scan(); 
264C:  BTFSS  20.1
264E:  BRA    2662
2650:  CLRF   18
2652:  BTFSC  FF2.7
2654:  BSF    18.7
2656:  BCF    FF2.7
2658:  CALL   01A0
265C:  BTFSC  18.7
265E:  BSF    FF2.7
2660:  BRA    264C
2662:  CLRF   18
2664:  BTFSC  FF2.7
2666:  BSF    18.7
2668:  BCF    FF2.7
....................    delay_ms(10); 
266A:  MOVLW  0A
266C:  MOVWF  xE2
266E:  CALL   0178
2672:  BTFSC  18.7
2674:  BSF    FF2.7
....................    // button release 
....................  
....................     while(1) { 
....................       nButton =-1; 
2676:  MOVLW  FF
2678:  MOVWF  4B
267A:  CLRF   18
267C:  BTFSC  FF2.7
267E:  BSF    18.7
2680:  BCF    FF2.7
....................       button_scan(); 
2682:  CALL   01A0
2686:  BTFSC  18.7
2688:  BSF    FF2.7
....................       restart_wdt(); 
268A:  CLRWDT
....................       if (nButton != -1){ 
268C:  MOVF   4B,W
268E:  SUBLW  FF
2690:  BTFSC  FD8.2
2692:  BRA    295E
....................       switch (nButton) { 
2694:  MOVF   4B,W
2696:  ADDLW  FA
2698:  BTFSC  FD8.0
269A:  BRA    295E
269C:  ADDLW  06
269E:  GOTO   2964
....................          case 0: { // operate/halt button  
....................                while (flag2.button_pressed ==1) button_scan(); 
26A2:  BTFSS  20.1
26A4:  BRA    26B8
26A6:  CLRF   18
26A8:  BTFSC  FF2.7
26AA:  BSF    18.7
26AC:  BCF    FF2.7
26AE:  CALL   01A0
26B2:  BTFSC  18.7
26B4:  BSF    FF2.7
26B6:  BRA    26A2
26B8:  CLRF   18
26BA:  BTFSC  FF2.7
26BC:  BSF    18.7
26BE:  BCF    FF2.7
....................                delay_ms(10); 
26C0:  MOVLW  0A
26C2:  MOVWF  xE2
26C4:  CALL   0178
26C8:  BTFSC  18.7
26CA:  BSF    FF2.7
....................                nButton=-1; 
26CC:  MOVLW  FF
26CE:  MOVWF  4B
....................                flag2.en_operate =1; 
26D0:  BSF    20.0
....................                flag2.abort_current_activity =0; 
26D2:  BCF    20.2
....................                init_rs232(); 
26D4:  CALL   0124
....................                return;} 
26D8:  BRA    2960
....................          case 1: { // actuator select button 
....................                while (flag2.button_pressed ==1) button_scan(); 
26DA:  BTFSS  20.1
26DC:  BRA    26F0
26DE:  CLRF   18
26E0:  BTFSC  FF2.7
26E2:  BSF    18.7
26E4:  BCF    FF2.7
26E6:  CALL   01A0
26EA:  BTFSC  18.7
26EC:  BSF    FF2.7
26EE:  BRA    26DA
26F0:  CLRF   18
26F2:  BTFSC  FF2.7
26F4:  BSF    18.7
26F6:  BCF    FF2.7
....................                delay_ms(10); 
26F8:  MOVLW  0A
26FA:  MOVWF  xE2
26FC:  CALL   0178
2700:  BTFSC  18.7
2702:  BSF    FF2.7
....................                target_act++; 
2704:  INCF   xBC,F
....................                target_act = target_act%4; 
2706:  MOVLW  03
2708:  ANDWF  xBC,F
....................                LED_status.aux=target_act ^ 0xFF ; 
270A:  MOVF   xBC,W
270C:  XORLW  FF
270E:  ANDLW  03
2710:  MOVWF  00
2712:  BCF    FD8.0
2714:  RLCF   00,F
2716:  RLCF   00,F
2718:  MOVLW  F3
271A:  ANDWF  21,W
271C:  IORWF  00,W
271E:  MOVWF  21
....................                display_LED(); 
2720:  CALL   0144
....................                break;} 
2724:  BRA    295E
....................             case 2: { //return home 
....................                   move_act(2000,9000,move_act_time_out,1,target_act); // move actuator to west 
2726:  MOVLW  07
2728:  MOVWF  xC3
272A:  MOVLW  D0
272C:  MOVWF  xC2
272E:  MOVLW  23
2730:  MOVWF  xC5
2732:  MOVLW  28
2734:  MOVWF  xC4
2736:  MOVFF  81,C7
273A:  MOVFF  80,C6
273E:  MOVLW  01
2740:  MOVWF  xC8
2742:  MOVFF  BC,C9
2746:  CALL   1160
....................                   move_act(2000,9000,move_act_time_out,0,target_act); // move actuator to home position 
274A:  MOVLW  07
274C:  MOVWF  xC3
274E:  MOVLW  D0
2750:  MOVWF  xC2
2752:  MOVLW  23
2754:  MOVWF  xC5
2756:  MOVLW  28
2758:  MOVWF  xC4
275A:  MOVFF  81,C7
275E:  MOVFF  80,C6
2762:  CLRF   xC8
2764:  MOVFF  BC,C9
2768:  CALL   1160
....................                   act_full_stroke_tick[target_act]= actuator_pulse; 
276C:  BCF    FD8.0
276E:  RLCF   xBC,W
2770:  CLRF   03
2772:  ADDLW  94
2774:  MOVWF  FE9
2776:  MOVLW  00
2778:  ADDWFC 03,W
277A:  MOVWF  FEA
277C:  MOVFF  83,FEC
2780:  MOVF   FED,F
2782:  MOVFF  82,FEF
....................                   current_act_position[target_act] =0; 
2786:  BCF    FD8.0
2788:  RLCF   xBC,W
278A:  CLRF   03
278C:  ADDLW  8A
278E:  MOVWF  FE9
2790:  MOVLW  00
2792:  ADDWFC 03,W
2794:  MOVWF  FEA
2796:  CLRF   FEC
2798:  MOVF   FED,F
279A:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
279C:  MOVLW  01
279E:  MOVWF  xBF
27A0:  CALL   0A40
....................                   break; 
27A4:  BRA    295E
....................                   } 
....................          case 3: { // move east 
....................                flag2.allow_manual_move_act=1; 
27A6:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,0,target_act); 
27A8:  CLRF   xC3
27AA:  MOVLW  0A
27AC:  MOVWF  xC2
27AE:  MOVLW  11
27B0:  MOVWF  xC5
27B2:  MOVLW  94
27B4:  MOVWF  xC4
27B6:  MOVFF  81,C7
27BA:  MOVFF  80,C6
27BE:  CLRF   xC8
27C0:  MOVFF  BC,C9
27C4:  CALL   1160
....................                flag2.allow_manual_move_act=0; 
27C8:  BCF    20.3
....................                break; } 
27CA:  BRA    295E
....................          case 4: { // move safty 
....................                 while (flag2.button_pressed ==1) button_scan(); 
27CC:  BTFSS  20.1
27CE:  BRA    27E2
27D0:  CLRF   18
27D2:  BTFSC  FF2.7
27D4:  BSF    18.7
27D6:  BCF    FF2.7
27D8:  CALL   01A0
27DC:  BTFSC  18.7
27DE:  BSF    FF2.7
27E0:  BRA    27CC
27E2:  CLRF   18
27E4:  BTFSC  FF2.7
27E6:  BSF    18.7
27E8:  BCF    FF2.7
....................                delay_ms(10); 
27EA:  MOVLW  0A
27EC:  MOVWF  xE2
27EE:  CALL   0178
27F2:  BTFSC  18.7
27F4:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[target_act]*(int32)(act_safety_stroke-act_min_stroke[target_act]); 
27F6:  BCF    FD8.0
27F8:  RLCF   xBC,W
27FA:  CLRF   03
27FC:  ADDLW  94
27FE:  MOVWF  FE9
2800:  MOVLW  00
2802:  ADDWFC 03,W
2804:  MOVWF  FEA
2806:  MOVFF  FEC,03
280A:  MOVF   FED,F
280C:  MOVFF  FEF,BD
2810:  MOVFF  03,BE
2814:  CLRF   xBF
2816:  CLRF   xC0
2818:  BCF    FD8.0
281A:  RLCF   xBC,W
281C:  CLRF   03
281E:  ADDLW  A4
2820:  MOVWF  FE9
2822:  MOVLW  00
2824:  ADDWFC 03,W
2826:  MOVWF  FEA
2828:  MOVFF  FEC,03
282C:  MOVF   FED,F
282E:  MOVF   FEF,W
2830:  SUBWF  xAC,W
2832:  MOVWF  00
2834:  MOVF   03,W
2836:  SUBWFB xAD,W
2838:  MOVWF  03
283A:  MOVF   00,W
283C:  MOVFF  03,01
2840:  CLRF   02
2842:  CLRF   03
2844:  MOVFF  03,C4
2848:  MOVFF  02,C3
284C:  MOVFF  01,C2
2850:  MOVFF  00,C1
2854:  MOVFF  FEA,C6
2858:  MOVFF  FE9,C5
285C:  MOVFF  C0,D7
2860:  MOVFF  BF,D6
2864:  MOVFF  BE,D5
2868:  MOVFF  BD,D4
286C:  MOVFF  03,DB
2870:  MOVFF  02,DA
2874:  MOVFF  01,D9
2878:  MOVFF  00,D8
287C:  CALL   1506
2880:  MOVFF  C6,FEA
2884:  MOVFF  C5,FE9
2888:  MOVFF  03,29
288C:  MOVFF  02,28
2890:  MOVFF  01,27
2894:  MOVFF  00,26
....................                tick = tick/(act_max_stroke[target_act]-act_min_stroke[target_act]); 
2898:  BCF    FD8.0
289A:  RLCF   xBC,W
289C:  CLRF   03
289E:  ADDLW  9C
28A0:  MOVWF  FE9
28A2:  MOVLW  00
28A4:  ADDWFC 03,W
28A6:  MOVWF  FEA
28A8:  MOVFF  FEC,BE
28AC:  MOVF   FED,F
28AE:  MOVFF  FEF,BD
28B2:  BCF    FD8.0
28B4:  RLCF   xBC,W
28B6:  CLRF   03
28B8:  ADDLW  A4
28BA:  MOVWF  FE9
28BC:  MOVLW  00
28BE:  ADDWFC 03,W
28C0:  MOVWF  FEA
28C2:  MOVFF  FEC,03
28C6:  MOVF   FED,F
28C8:  MOVF   FEF,W
28CA:  SUBWF  xBD,W
28CC:  MOVWF  00
28CE:  MOVF   03,W
28D0:  SUBWFB xBE,W
28D2:  MOVWF  03
28D4:  MOVFF  00,BD
28D8:  MOVWF  xBE
28DA:  MOVFF  FEA,C0
28DE:  MOVFF  FE9,BF
28E2:  CLRF   18
28E4:  BTFSC  FF2.7
28E6:  BSF    18.7
28E8:  BCF    FF2.7
28EA:  MOVFF  29,E5
28EE:  MOVFF  28,E4
28F2:  MOVFF  27,E3
28F6:  MOVFF  26,E2
28FA:  CLRF   xE9
28FC:  CLRF   xE8
28FE:  MOVWF  xE7
2900:  MOVFF  00,E6
2904:  CALL   00AA
2908:  BTFSC  18.7
290A:  BSF    FF2.7
290C:  MOVFF  C0,FEA
2910:  MOVFF  BF,FE9
2914:  MOVFF  03,29
2918:  MOVFF  02,28
291C:  MOVFF  01,27
2920:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
2924:  MOVFF  27,93
2928:  MOVFF  26,92
....................                actuator_move_execute(target_act); 
292C:  MOVFF  BC,BF
2930:  CALL   155A
....................                break; } 
2934:  BRA    295E
....................          case 5: { // move west 
....................                flag2.allow_manual_move_act=1; 
2936:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,1,target_act); 
2938:  CLRF   xC3
293A:  MOVLW  0A
293C:  MOVWF  xC2
293E:  MOVLW  11
2940:  MOVWF  xC5
2942:  MOVLW  94
2944:  MOVWF  xC4
2946:  MOVFF  81,C7
294A:  MOVFF  80,C6
294E:  MOVLW  01
2950:  MOVWF  xC8
2952:  MOVFF  BC,C9
2956:  CALL   1160
....................                flag2.allow_manual_move_act=0; 
295A:  BCF    20.3
....................                break; } 
295C:  BRA    295E
....................  
....................          } 
....................           
....................       } 
....................       } 
295E:  BRA    2676
....................        
.................... } 
2960:  GOTO   2C86 (RETURN)
....................  
.................... ////////////////////////////////////// 
.................... void main() { 
*
2994:  CLRF   FF8
2996:  BCF    FD0.7
2998:  BSF    08.7
299A:  CLRF   FEA
299C:  CLRF   FE9
299E:  MOVLW  03
29A0:  MOVWF  FAF
29A2:  MOVLW  A2
29A4:  MOVWF  FAC
29A6:  MOVLW  90
29A8:  MOVWF  FAB
29AA:  BSF    F94.4
29AC:  BCF    F94.5
29AE:  BCF    F94.3
29B0:  BCF    F8B.3
29B2:  BSF    FC1.0
29B4:  BSF    FC1.1
29B6:  BSF    FC1.2
29B8:  BCF    FC1.3
29BA:  MOVLW  07
29BC:  MOVWF  FB4
29BE:  CLRF   19
29C0:  CLRF   1A
29C2:  CLRF   22
29C4:  CLRF   23
29C6:  CLRF   24
29C8:  CLRF   25
29CA:  CLRF   26
29CC:  CLRF   27
29CE:  CLRF   28
29D0:  CLRF   29
29D2:  CLRF   2A
29D4:  CLRF   2B
29D6:  CLRF   2C
29D8:  CLRF   2D
29DA:  MOVLW  01
29DC:  MOVWF  2E
29DE:  CLRF   2F
29E0:  CLRF   30
29E2:  CLRF   31
29E4:  CLRF   32
29E6:  CLRF   33
29E8:  MOVLW  75
29EA:  MOVWF  34
29EC:  CLRF   35
29EE:  CLRF   4A
29F0:  MOVLW  FF
29F2:  MOVWF  4B
29F4:  CLRF   4C
29F6:  CLRF   4D
29F8:  CLRF   4E
29FA:  CLRF   4F
29FC:  CLRF   50
29FE:  CLRF   51
2A00:  CLRF   x7D
2A02:  CLRF   x7E
2A04:  CLRF   x7F
2A06:  MOVLW  02
2A08:  MOVWF  x80
2A0A:  CLRF   x81
2A0C:  CLRF   x82
2A0E:  CLRF   x83
2A10:  CLRF   x8A
2A12:  CLRF   x8B
2A14:  CLRF   x8C
2A16:  CLRF   x8D
2A18:  CLRF   x8E
2A1A:  CLRF   x8F
2A1C:  CLRF   x90
2A1E:  CLRF   x91
2A20:  CLRF   x92
2A22:  CLRF   x93
2A24:  CLRF   x94
2A26:  CLRF   x95
2A28:  CLRF   x96
2A2A:  CLRF   x97
2A2C:  CLRF   x98
2A2E:  CLRF   x99
2A30:  CLRF   x9A
2A32:  CLRF   x9B
2A34:  CLRF   x9C
2A36:  CLRF   x9D
2A38:  CLRF   x9E
2A3A:  CLRF   x9F
2A3C:  CLRF   xA0
2A3E:  CLRF   xA1
2A40:  CLRF   xA2
2A42:  CLRF   xA3
2A44:  CLRF   xA4
2A46:  CLRF   xA5
2A48:  CLRF   xA6
2A4A:  CLRF   xA7
2A4C:  CLRF   xA8
2A4E:  CLRF   xA9
2A50:  CLRF   xAA
2A52:  CLRF   xAB
2A54:  CLRF   xAC
2A56:  CLRF   xAD
2A58:  CLRF   xAE
2A5A:  CLRF   xAF
2A5C:  CLRF   xB0
2A5E:  CLRF   xB1
2A60:  CLRF   xB2
2A62:  CLRF   xB3
2A64:  CLRF   xB4
....................    int16 relay_time,kk; 
....................    int8 act_loop,i; 
....................    init_spi(); 
2A66:  GOTO   059A
....................     setup_adc_ports(AN0); 
2A6A:  BCF    FC1.0
2A6C:  BSF    FC1.1
2A6E:  BSF    FC1.2
2A70:  BSF    FC1.3
....................     setup_adc(ADC_CLOCK_INTERNAL); 
2A72:  BCF    FC1.6
2A74:  BSF    FC2.6
2A76:  BSF    FC2.7
2A78:  BSF    FC1.7
2A7A:  BSF    FC2.0
....................     set_adc_channel(0); 
2A7C:  MOVLW  00
2A7E:  MOVWF  01
2A80:  MOVF   FC2,W
2A82:  ANDLW  C7
2A84:  IORWF  01,W
2A86:  MOVWF  FC2
....................    set_tris_a(0xFF); 
2A88:  MOVLW  FF
2A8A:  MOVWF  F92
....................    set_tris_b(0xFF); 
2A8C:  MOVWF  F93
....................    set_tris_d(0x00); 
2A8E:  MOVLW  00
2A90:  MOVWF  F95
....................     led_status =0xF0; 
2A92:  MOVLW  F0
2A94:  MOVWF  21
....................    display_LED(); 
2A96:  CALL   0144
....................    delay_ms(5000); 
2A9A:  MOVLW  14
2A9C:  MOVWF  xBB
2A9E:  CLRF   18
2AA0:  BTFSC  FF2.7
2AA2:  BSF    18.7
2AA4:  BCF    FF2.7
2AA6:  MOVLW  FA
2AA8:  MOVWF  xE2
2AAA:  CALL   0178
2AAE:  BTFSC  18.7
2AB0:  BSF    FF2.7
2AB2:  DECFSZ xBB,F
2AB4:  BRA    2A9E
....................    flag2.is_moving =0; 
2AB6:  BCF    20.6
....................    while((read_adc()+read_adc()+read_adc()+read_adc())/4 < 650) { 
2AB8:  BSF    FC2.2
2ABA:  BTFSC  FC2.2
2ABC:  BRA    2ABA
2ABE:  MOVFF  FC4,03
2AC2:  MOVFF  FC3,BB
2AC6:  MOVFF  FC4,BC
2ACA:  BSF    FC2.2
2ACC:  BTFSC  FC2.2
2ACE:  BRA    2ACC
2AD0:  MOVFF  FC4,03
2AD4:  MOVF   FC3,W
2AD6:  ADDWF  xBB,F
2AD8:  MOVF   FC4,W
2ADA:  ADDWFC xBC,F
2ADC:  BSF    FC2.2
2ADE:  BTFSC  FC2.2
2AE0:  BRA    2ADE
2AE2:  MOVFF  FC4,03
2AE6:  MOVF   FC3,W
2AE8:  ADDWF  xBB,F
2AEA:  MOVF   FC4,W
2AEC:  ADDWFC xBC,F
2AEE:  BSF    FC2.2
2AF0:  BTFSC  FC2.2
2AF2:  BRA    2AF0
2AF4:  MOVFF  FC4,03
2AF8:  MOVF   FC3,W
2AFA:  ADDWF  xBB,F
2AFC:  MOVF   FC4,W
2AFE:  ADDWFC xBC,F
2B00:  RRCF   xBC,F
2B02:  RRCF   xBB,F
2B04:  RRCF   xBC,F
2B06:  RRCF   xBB,F
2B08:  MOVLW  3F
2B0A:  ANDWF  xBC,F
2B0C:  MOVF   xBC,W
2B0E:  SUBLW  02
2B10:  BNC   2B54
2B12:  BNZ   2B1A
2B14:  MOVF   xBB,W
2B16:  SUBLW  89
2B18:  BNC   2B54
....................        led_status =0xFE; 
2B1A:  MOVLW  FE
2B1C:  MOVWF  21
....................        display_LED(); 
2B1E:  CALL   0144
2B22:  CLRF   18
2B24:  BTFSC  FF2.7
2B26:  BSF    18.7
2B28:  BCF    FF2.7
....................        delay_ms(2); 
2B2A:  MOVLW  02
2B2C:  MOVWF  xE2
2B2E:  CALL   0178
2B32:  BTFSC  18.7
2B34:  BSF    FF2.7
....................        led_status =0xFF; 
2B36:  MOVLW  FF
2B38:  MOVWF  21
....................        display_LED();          
2B3A:  CALL   0144
2B3E:  CLRF   18
2B40:  BTFSC  FF2.7
2B42:  BSF    18.7
2B44:  BCF    FF2.7
....................        delay_ms(50); 
2B46:  MOVLW  32
2B48:  MOVWF  xE2
2B4A:  CALL   0178
2B4E:  BTFSC  18.7
2B50:  BSF    FF2.7
....................    } // trap here  until voltage level is good 
2B52:  BRA    2AB8
2B54:  CLRF   18
2B56:  BTFSC  FF2.7
2B58:  BSF    18.7
2B5A:  BCF    FF2.7
....................    delay_ms(200); 
2B5C:  MOVLW  C8
2B5E:  MOVWF  xE2
2B60:  CALL   0178
2B64:  BTFSC  18.7
2B66:  BSF    FF2.7
....................    flag2.power=1; 
2B68:  BSF    20.5
....................  
....................  
....................    output_low(TX_EN); 
2B6A:  BCF    F96.1
2B6C:  BCF    F8D.1
....................  
....................  
....................    flash_wait_until_ready(); 
2B6E:  CALL   05E6
....................    flash_read_mfg_id(); 
2B72:  GOTO   060A
....................    flash_read_stat(); // stat & 0xBF == 0x9C means device ready 
2B76:  CALL   05B2
....................     // check flash readiness here // 
....................     //if (flash_mfg_id[1]==0x24) //4MBit 
....................     //if (flash_mfg_id[1]==0x26) //16MBit 
....................  
....................    read_eeprom_data(); 
2B7A:  GOTO   067E
....................    read_device_id(); 
2B7E:  CALL   09DA
....................    //print_fw_info(); 
....................     T1CON = 0b00001111;  // 0b10011011 
2B82:  MOVLW  0F
2B84:  MOVWF  FCD
....................     enable_interrupts(INT_RDA); 
2B86:  BSF    F9D.5
....................     enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
2B88:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
2B8A:  MOVLW  C0
2B8C:  IORWF  FF2,F
....................    init_rs232(); 
2B8E:  CALL   0124
....................    relay_time =0; 
2B92:  CLRF   xB6
2B94:  CLRF   xB5
....................    flag2.en_operate =1; 
2B96:  BSF    20.0
....................    flag2.button_pressed=0; 
2B98:  BCF    20.1
....................    flag2.allow_manual_move_act=0; 
2B9A:  BCF    20.3
....................    LED_status =0x00; 
2B9C:  CLRF   21
2B9E:  CLRF   18
2BA0:  BTFSC  FF2.7
2BA2:  BSF    18.7
2BA4:  BCF    FF2.7
....................  
....................    delay_ms(200); 
2BA6:  MOVLW  C8
2BA8:  MOVWF  xE2
2BAA:  CALL   0178
2BAE:  BTFSC  18.7
2BB0:  BSF    FF2.7
....................    while(read_eeprom((int8)0xf00040)!=0x34); 
2BB2:  MOVFF  FF2,BB
2BB6:  BCF    FF2.7
2BB8:  MOVLW  40
2BBA:  MOVWF  FA9
2BBC:  BCF    FA6.6
2BBE:  BCF    FA6.7
2BC0:  BSF    FA6.0
2BC2:  MOVF   FA8,W
2BC4:  BTFSC  xBB.7
2BC6:  BSF    FF2.7
2BC8:  SUBLW  34
2BCA:  BNZ   2BB2
....................    while(read_eeprom((int8)0xf00041)!=0x12); 
2BCC:  MOVFF  FF2,BB
2BD0:  BCF    FF2.7
2BD2:  MOVLW  41
2BD4:  MOVWF  FA9
2BD6:  BCF    FA6.6
2BD8:  BCF    FA6.7
2BDA:  BSF    FA6.0
2BDC:  MOVF   FA8,W
2BDE:  BTFSC  xBB.7
2BE0:  BSF    FF2.7
2BE2:  SUBLW  12
2BE4:  BNZ   2BCC
....................    display_LED(); 
2BE6:  CALL   0144
....................    startup_counter++; 
2BEA:  INCF   32,F
2BEC:  BTFSC  FD8.2
2BEE:  INCF   33,F
....................    write_eeprom_data(0); 
2BF0:  CLRF   xBF
2BF2:  CALL   0A40
....................    solar_load_parameter_from_flash(); 
2BF6:  GOTO   0DFA
....................    setup_wdt(WDT_ON); 
2BFA:  BSF    FD1.0
....................  
....................    while(1) { 
....................       if (flag.cmd_posted==1) process_cmd_msg(); 
2BFC:  BTFSS  1F.3
2BFE:  BRA    2C04
2C00:  GOTO   1D62
....................       if (bit_test(RCSTA,1)==1) init_rs232(); 
2C04:  BTFSS  FAB.1
2C06:  BRA    2C0C
2C08:  CALL   0124
....................       for(act_loop=0;act_loop<4;act_loop++) 
2C0C:  CLRF   xB9
2C0E:  MOVF   xB9,W
2C10:  SUBLW  03
2C12:  BNC   2C80
....................       { 
....................          if (bit_test(actuator_move_mask,act_loop)==1){ 
2C14:  MOVFF  B4,00
2C18:  MOVF   xB9,W
2C1A:  MOVWF  01
2C1C:  BZ    2C26
2C1E:  BCF    FD8.0
2C20:  RRCF   00,F
2C22:  DECFSZ 01,F
2C24:  BRA    2C1E
2C26:  BTFSS  00.0
2C28:  BRA    2C7C
....................             if (act_full_stroke_tick[act_loop]>0x0010) { 
2C2A:  BCF    FD8.0
2C2C:  RLCF   xB9,W
2C2E:  CLRF   03
2C30:  ADDLW  94
2C32:  MOVWF  FE9
2C34:  MOVLW  00
2C36:  ADDWFC 03,W
2C38:  MOVWF  FEA
2C3A:  MOVFF  FEC,BC
2C3E:  MOVF   FED,F
2C40:  MOVFF  FEF,BB
2C44:  MOVF   xBC,F
2C46:  BNZ   2C4E
2C48:  MOVF   xBB,W
2C4A:  SUBLW  10
2C4C:  BC    2C7C
....................                solar_get_act_length(act_loop); 
2C4E:  MOVFF  B9,BF
2C52:  CALL   16EA
....................              actuator_move_execute(act_loop); 
2C56:  MOVFF  B9,BF
2C5A:  CALL   155A
....................                bit_clear(actuator_move_mask,act_loop); 
2C5E:  MOVLW  01
2C60:  MOVWF  00
2C62:  MOVF   xB9,W
2C64:  MOVWF  01
2C66:  BZ    2C70
2C68:  BCF    FD8.0
2C6A:  RLCF   00,F
2C6C:  DECFSZ 01,F
2C6E:  BRA    2C68
2C70:  MOVF   00,W
2C72:  XORLW  FF
2C74:  ANDWF  xB4,F
....................             write_eeprom_data(0); 
2C76:  CLRF   xBF
2C78:  CALL   0A40
....................             //print_date_time(); 
....................          }  
....................          } 
....................       } 
2C7C:  INCF   xB9,F
2C7E:  BRA    2C0E
....................  
....................       if (nButton==0) { 
2C80:  MOVF   4B,F
2C82:  BNZ   2C86
....................           button_menu(); 
2C84:  BRA    2636
....................       } 
....................       restart_wdt(); 
2C86:  CLRWDT
....................         kk = read_adc(); 
2C88:  BSF    FC2.2
2C8A:  BTFSC  FC2.2
2C8C:  BRA    2C8A
2C8E:  MOVFF  FC3,B7
2C92:  MOVFF  FC4,B8
....................        if ((read_adc()+read_adc()+read_adc()+read_adc())/4 < 600) sleep(); 
2C96:  BSF    FC2.2
2C98:  BTFSC  FC2.2
2C9A:  BRA    2C98
2C9C:  MOVFF  FC4,03
2CA0:  MOVFF  FC3,BB
2CA4:  MOVFF  FC4,BC
2CA8:  BSF    FC2.2
2CAA:  BTFSC  FC2.2
2CAC:  BRA    2CAA
2CAE:  MOVFF  FC4,03
2CB2:  MOVF   FC3,W
2CB4:  ADDWF  xBB,F
2CB6:  MOVF   FC4,W
2CB8:  ADDWFC xBC,F
2CBA:  BSF    FC2.2
2CBC:  BTFSC  FC2.2
2CBE:  BRA    2CBC
2CC0:  MOVFF  FC4,03
2CC4:  MOVF   FC3,W
2CC6:  ADDWF  xBB,F
2CC8:  MOVF   FC4,W
2CCA:  ADDWFC xBC,F
2CCC:  BSF    FC2.2
2CCE:  BTFSC  FC2.2
2CD0:  BRA    2CCE
2CD2:  MOVFF  FC4,03
2CD6:  MOVF   FC3,W
2CD8:  ADDWF  xBB,F
2CDA:  MOVF   FC4,W
2CDC:  ADDWFC xBC,F
2CDE:  RRCF   xBC,F
2CE0:  RRCF   xBB,F
2CE2:  RRCF   xBC,F
2CE4:  RRCF   xBB,F
2CE6:  MOVLW  3F
2CE8:  ANDWF  xBC,F
2CEA:  MOVF   xBC,W
2CEC:  SUBLW  02
2CEE:  BNC   2CFA
2CF0:  BNZ   2CF8
2CF2:  MOVF   xBB,W
2CF4:  SUBLW  57
2CF6:  BTFSC  FD8.0
2CF8:  SLEEP 
....................    } 
2CFA:  BRA    2BFC
....................  
.................... DEAD_TRAP: while(1); 
2CFC:  BRA    2CFC
.................... } 
2CFE:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E000   WRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 7E 04 7F 03 80 02 81 01 

F00010: 00 00 01 00 02 00 03 00 

F00020: 00 00 00 00 01 00 00 00 

F00030: 00 00 

F00040: 34 12 

F00050: FE FF 

F00060: 80 4C 81 4C 82 4C 83 4C 

F00070: 80 7B 81 7B 82 7B 83 7B 
