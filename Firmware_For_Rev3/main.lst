CCS PCH C Compiler, Version 4.093, 5967               26-Aug-12 22:54

               Filename: main.lst

               ROM used: 10418 bytes (32%)
                         Largest free fragment is 22346
               RAM used: 173 (11%) at main() level
                         223 (15%) worst case
               Stack:    9 worst case (5 in main + 4 for interrupts)

*
0000:  GOTO   2562
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   01E4
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   04DC
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  MOVFF  0D,FE9
007C:  MOVFF  08,FEA
0080:  BSF    08.7
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #define NETWORK_COMM 1 
.................... #include <solar_lib.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <math.h> 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,BROWNOUT,BORV20,NOLVP,WRT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
0178:  CLRF   FEA
017A:  MOVLW  D2
017C:  MOVWF  FE9
017E:  MOVF   FEF,W
0180:  BZ    019E
0182:  MOVLW  03
0184:  MOVWF  01
0186:  CLRF   00
0188:  DECFSZ 00,F
018A:  BRA    0188
018C:  DECFSZ 01,F
018E:  BRA    0186
0190:  MOVLW  3C
0192:  MOVWF  00
0194:  DECFSZ 00,F
0196:  BRA    0194
0198:  BRA    019A
019A:  DECFSZ FEF,F
019C:  BRA    0182
019E:  RETLW  00
*
1A7E:  MOVLW  07
1A80:  SUBWF  xB0,F
1A82:  BNC   1A9A
1A84:  CLRF   FEA
1A86:  MOVLW  B0
1A88:  MOVWF  FE9
1A8A:  BCF    FD8.0
1A8C:  RRCF   FEF,F
1A8E:  MOVF   FEF,W
1A90:  BZ    1A9A
1A92:  BRA    1A96
1A94:  BRA    1A96
1A96:  DECFSZ FEF,F
1A98:  BRA    1A94
1A9A:  GOTO   21CC (RETURN)
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N,BITS=8) 
*
0440:  BTFSS  F9E.4
0442:  BRA    0440
0444:  MOVWF  FAD
0446:  RETLW  00
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, BITS=8, MSB_FIRST, IDLE=0) 
....................  
....................  
....................  
....................  
....................  
.................... struct port_d_map{ 
....................    int8 data_bus:4; //0:3 
....................    boolean rs;     //4 
....................    boolean LED_latch;  //5 
....................    boolean MUX_en;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte SSPCON2 = 0xFC5 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1  = 0xFCE 
.................... #byte T1CON = 0xFCD 
....................  
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1 PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3 PIN_B3 
.................... #define CCW PIN_B4 
.................... #define SENSE_0     PIN_A2 
.................... #define SENSE_1     PIN_A3 
.................... #define SENSE_2     PIN_A4 
.................... #define SENSE_3     PIN_A5 
.................... #define WALL_PWR    PIN_A0 //input 
.................... #define FLASH_CS PIN_C2 
.................... #define TX_EN PIN_E1 
....................  
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00010 
.................... #define ADDR_TIME           0xf00020 
.................... #define ADDR_START_COUNTER  0xf00030 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x047E,0x037F,0x0280,0x0181} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000,0x0001,0x0002,0x0003} 
.................... #rom ADDR_TIME={0x0000,0x0000,0x0001,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... #rom 0xf00040 ={0x1234} // to check if eeprom can be read properly 
.................... #rom 0xf00050 ={0xFFFE} // device ID 
.................... ////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////// flag 
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measured_current; 
.................... } flag; 
....................  
.................... struct flag2 { 
....................    boolean en_operate; 
....................    boolean button_pressed; 
....................    boolean abort_current_activity; 
....................    boolean allow_manual_move_act; 
....................    boolean current_pulse_state; 
....................    boolean power; 
....................    boolean is_moving; 
....................    boolean unused3; 
.................... } flag2; 
....................  
.................... struct LED_status { 
....................   boolean power; 
....................   boolean operation; 
....................   int8 aux:2; 
....................   int8 unused:4; 
.................... } LED_status; 
....................  
.................... /////////////////////////// timer_related 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... unsigned int32 nDay=1; 
.................... unsigned int16 startup_counter=0; 
.................... /////////////////////////// command processing 
.................... int16 dev_id = 0x0075; 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... int8 nButton=-1; 
.................... unsigned int32 last_command =0; 
.................... int8 de_stuffing_mask = 0x00; 
.................... int8 command_byte=0x00; 
.................... int16 aux_command; 
.................... int8 output_buffer[32]; 
.................... int8 output_checksum; 
.................... /////////////////////////// flash_related_variable 
.................... int8 flash_mfg_id[4]; 
.................... int8 flash_stat=0; 
.................... int8 flash_page_data=0; 
.................... int8 flash_page_data2=0; 
.................... /////////////////////////// actuator related 
.................... int16 move_act_time_out=2; 
.................... int16 actuator_pulse=0; 
.................... int16 last_actuator_pulse; 
.................... float act_len; 
.................... unsigned int16 current_act_position[4]={0,0,0,0}; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int16 act_full_stroke_tick[4]={0,0,0,0}; 
.................... unsigned int16 act_max_stroke=0; 
.................... unsigned int16 act_min_stroke=0; 
.................... unsigned int16 act_safety_stroke=0; 
.................... unsigned int16 latitude=0; 
.................... unsigned int16 longitude=0; 
.................... unsigned int16 altitude=0; 
.................... int8 actuator_move_mask=0x00; 
.................... ///////////////////PROTOTYPE/////////////////////////////////// 
.................... void button_scan(); 
.................... void stuff_data(int8 data_to_stuff); 
.................... void send_data(int8 packet_type,int8 size); 
.................... void process_cmd_msg(); 
.................... ///////////////////////////////////////////////////// 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
0124:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
0126:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
0128:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
012A:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
012C:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
012E:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
0130:  BCF    FAC.5
....................    delay_cycles(10); 
0132:  MOVLW  03
0134:  MOVWF  00
0136:  DECFSZ 00,F
0138:  BRA    0136
....................    bit_set(RCSTA,4); //CREN=1 
013A:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
013C:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
013E:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
0140:  BSF    F9D.5
....................  
.................... } 
0142:  RETLW  00
....................  
....................  
.................... void flash_read_mfg_id() { 
.................... 		output_low(FLASH_CS); 
*
0606:  BCF    F94.2
0608:  BCF    F8B.2
.................... 		delay_cycles(20); 
060A:  MOVLW  06
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  NOP   
.................... 		spi_write(0x9F); 
0614:  MOVF   FC9,W
0616:  MOVLW  9F
0618:  MOVWF  FC9
061A:  RRCF   FC7,W
061C:  BNC   061A
.................... 		flash_mfg_id[0] = spi_read(0); 
061E:  MOVF   FC9,W
0620:  CLRF   FC9
0622:  RRCF   FC7,W
0624:  BNC   0622
0626:  MOVFF  FC9,75
.................... 		flash_mfg_id[1] = spi_read(0); 
062A:  MOVF   FC9,W
062C:  CLRF   FC9
062E:  RRCF   FC7,W
0630:  BNC   062E
0632:  MOVFF  FC9,76
.................... 		flash_mfg_id[2] = spi_read(0); 
0636:  MOVF   FC9,W
0638:  CLRF   FC9
063A:  RRCF   FC7,W
063C:  BNC   063A
063E:  MOVFF  FC9,77
.................... 		flash_mfg_id[3] = spi_read(0); 
0642:  MOVF   FC9,W
0644:  CLRF   FC9
0646:  RRCF   FC7,W
0648:  BNC   0646
064A:  MOVFF  FC9,78
.................... 		delay_cycles(20); 
064E:  MOVLW  06
0650:  MOVWF  00
0652:  DECFSZ 00,F
0654:  BRA    0652
0656:  NOP   
.................... 		output_high(FLASH_CS); 
0658:  BCF    F94.2
065A:  BSF    F8B.2
.................... } 
065C:  GOTO   272C (RETURN)
....................  
.................... void flash_read_stat() { 
.................... 		output_low(FLASH_CS); 
*
05AE:  BCF    F94.2
05B0:  BCF    F8B.2
.................... 		delay_cycles(20); 
05B2:  MOVLW  06
05B4:  MOVWF  00
05B6:  DECFSZ 00,F
05B8:  BRA    05B6
05BA:  NOP   
.................... 		spi_write(0xD7); 
05BC:  MOVF   FC9,W
05BE:  MOVLW  D7
05C0:  MOVWF  FC9
05C2:  RRCF   FC7,W
05C4:  BNC   05C2
.................... 		flash_stat = spi_read(0); 
05C6:  MOVF   FC9,W
05C8:  CLRF   FC9
05CA:  RRCF   FC7,W
05CC:  BNC   05CA
05CE:  MOVFF  FC9,79
.................... 		delay_cycles(20); 
05D2:  MOVLW  06
05D4:  MOVWF  00
05D6:  DECFSZ 00,F
05D8:  BRA    05D6
05DA:  NOP   
.................... 		output_high(FLASH_CS); 
05DC:  BCF    F94.2
05DE:  BSF    F8B.2
.................... } 
05E0:  RETLW  00
....................  
.................... void flash_wait_until_ready() { 
....................    int8 wait_loop=0; 
05E2:  CLRF   xC0
....................    for ( wait_loop=0; wait_loop<0xFF; wait_loop++) { 
05E4:  CLRF   xC0
05E6:  INCFSZ xC0,W
05E8:  BRA    05EC
05EA:  BRA    0604
.................... 	 flash_read_stat(); 
05EC:  RCALL  05AE
....................      if ((flash_stat & 0xBF)==0x9C) break; 
05EE:  MOVF   x79,W
05F0:  ANDLW  BF
05F2:  SUBLW  9C
05F4:  BNZ   05F8
05F6:  BRA    0604
.................... 	 delay_cycles(100); 
05F8:  MOVLW  21
05FA:  MOVWF  00
05FC:  DECFSZ 00,F
05FE:  BRA    05FC
....................    } 
0600:  INCF   xC0,F
0602:  BRA    05E6
.................... } 
0604:  RETLW  00
....................  
.................... void flash_read_page(int16 pageAddress, int8 pageIndex) { 
....................  
.................... 	//pageAddress <<= 1; 
.................... 	//pageAddress &= 0xFE; 
....................     if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0BA0:  MOVF   x76,W
0BA2:  SUBLW  26
0BA4:  BNZ   0BAC
0BA6:  BCF    FD8.0
0BA8:  RLCF   xBD,F
0BAA:  RLCF   xBE,F
.................... 	flash_wait_until_ready(); 
0BAC:  RCALL  05E2
....................    	output_low(FLASH_CS); 
0BAE:  BCF    F94.2
0BB0:  BCF    F8B.2
.................... 	delay_cycles(20); 
0BB2:  MOVLW  06
0BB4:  MOVWF  00
0BB6:  DECFSZ 00,F
0BB8:  BRA    0BB6
0BBA:  NOP   
....................    	spi_write(0xD2); 
0BBC:  MOVF   FC9,W
0BBE:  MOVLW  D2
0BC0:  MOVWF  FC9
0BC2:  RRCF   FC7,W
0BC4:  BNC   0BC2
....................     spi_write(make8(pageAddress,1)); 
0BC6:  MOVFF  BE,C0
0BCA:  MOVF   FC9,W
0BCC:  MOVFF  BE,FC9
0BD0:  RRCF   FC7,W
0BD2:  BNC   0BD0
....................     spi_write(make8(pageAddress,0)); 
0BD4:  MOVFF  BD,C0
0BD8:  MOVF   FC9,W
0BDA:  MOVFF  BD,FC9
0BDE:  RRCF   FC7,W
0BE0:  BNC   0BDE
....................     spi_write(pageIndex); 
0BE2:  MOVF   FC9,W
0BE4:  MOVFF  BF,FC9
0BE8:  RRCF   FC7,W
0BEA:  BNC   0BE8
....................     spi_write(0); 
0BEC:  MOVF   FC9,W
0BEE:  CLRF   FC9
0BF0:  RRCF   FC7,W
0BF2:  BNC   0BF0
....................     spi_write(0); 
0BF4:  MOVF   FC9,W
0BF6:  CLRF   FC9
0BF8:  RRCF   FC7,W
0BFA:  BNC   0BF8
....................     spi_write(0); 
0BFC:  MOVF   FC9,W
0BFE:  CLRF   FC9
0C00:  RRCF   FC7,W
0C02:  BNC   0C00
....................     spi_write(0); 
0C04:  MOVF   FC9,W
0C06:  CLRF   FC9
0C08:  RRCF   FC7,W
0C0A:  BNC   0C08
.................... 	flash_page_data = spi_read(0); 
0C0C:  MOVF   FC9,W
0C0E:  CLRF   FC9
0C10:  RRCF   FC7,W
0C12:  BNC   0C10
0C14:  MOVFF  FC9,7A
.................... 	flash_page_data2 = spi_read(0); 
0C18:  MOVF   FC9,W
0C1A:  CLRF   FC9
0C1C:  RRCF   FC7,W
0C1E:  BNC   0C1C
0C20:  MOVFF  FC9,7B
....................    	output_high(FLASH_CS); 
0C24:  BCF    F94.2
0C26:  BSF    F8B.2
.................... } 
0C28:  RETLW  00
....................  
.................... void flash_block_erase() { 
....................    int8 i,j; 
....................    i=0xFF; 
*
0C9A:  MOVLW  FF
0C9C:  MOVWF  xAF
....................    do 
....................    { 
....................    i++; 
0C9E:  INCF   xAF,F
....................    flash_wait_until_ready(); 
0CA0:  RCALL  05E2
....................    output_low(FLASH_CS); 
0CA2:  BCF    F94.2
0CA4:  BCF    F8B.2
....................    spi_write(0x50); 
0CA6:  MOVF   FC9,W
0CA8:  MOVLW  50
0CAA:  MOVWF  FC9
0CAC:  RRCF   FC7,W
0CAE:  BNC   0CAC
....................    j = i>>5; 
0CB0:  SWAPF  xAF,W
0CB2:  MOVWF  xB0
0CB4:  RRCF   xB0,F
0CB6:  MOVLW  07
0CB8:  ANDWF  xB0,F
....................    spi_write(j); 
0CBA:  MOVF   FC9,W
0CBC:  MOVFF  B0,FC9
0CC0:  RRCF   FC7,W
0CC2:  BNC   0CC0
....................    j = i<<3; 
0CC4:  RLCF   xAF,W
0CC6:  MOVWF  xB0
0CC8:  RLCF   xB0,F
0CCA:  RLCF   xB0,F
0CCC:  MOVLW  F8
0CCE:  ANDWF  xB0,F
....................    spi_write(j); 
0CD0:  MOVF   FC9,W
0CD2:  MOVFF  B0,FC9
0CD6:  RRCF   FC7,W
0CD8:  BNC   0CD6
....................    spi_write(0); 
0CDA:  MOVF   FC9,W
0CDC:  CLRF   FC9
0CDE:  RRCF   FC7,W
0CE0:  BNC   0CDE
....................    output_high(FLASH_CS); 
0CE2:  BCF    F94.2
0CE4:  BSF    F8B.2
....................    } while(i!=0xFF); 
0CE6:  INCFSZ xAF,W
0CE8:  BRA    0C9E
....................    flash_wait_until_ready(); 
0CEA:  RCALL  05E2
.................... } 
0CEC:  GOTO   1B34 (RETURN)
....................  
.................... void flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
0E66:  CALL   05E2
....................    output_low(FLASH_CS); 
0E6A:  BCF    F94.2
0E6C:  BCF    F8B.2
....................    delay_cycles(20); 
0E6E:  MOVLW  06
0E70:  MOVWF  00
0E72:  DECFSZ 00,F
0E74:  BRA    0E72
0E76:  NOP   
....................    spi_write(0x84); 
0E78:  MOVF   FC9,W
0E7A:  MOVLW  84
0E7C:  MOVWF  FC9
0E7E:  RRCF   FC7,W
0E80:  BNC   0E7E
....................    spi_write(0); 
0E82:  MOVF   FC9,W
0E84:  CLRF   FC9
0E86:  RRCF   FC7,W
0E88:  BNC   0E86
....................    spi_write(0); 
0E8A:  MOVF   FC9,W
0E8C:  CLRF   FC9
0E8E:  RRCF   FC7,W
0E90:  BNC   0E8E
....................    spi_write(PageIndex); 
0E92:  MOVF   FC9,W
0E94:  MOVFF  B0,FC9
0E98:  RRCF   FC7,W
0E9A:  BNC   0E98
....................    if (nData>1) { 
0E9C:  MOVF   xB1,W
0E9E:  SUBLW  01
0EA0:  BC    0EBA
....................    i=255; 
0EA2:  MOVLW  FF
0EA4:  MOVWF  xB2
....................    do { 
....................       spi_write(data); 
0EA6:  MOVF   FC9,W
0EA8:  MOVFF  AF,FC9
0EAC:  RRCF   FC7,W
0EAE:  BNC   0EAC
....................       i++; 
0EB0:  INCF   xB2,F
....................    } while(i<nData); 
0EB2:  MOVF   xB1,W
0EB4:  SUBWF  xB2,W
0EB6:  BNC   0EA6
....................    } else 
0EB8:  BRA    0EC4
....................          spi_write(data); 
0EBA:  MOVF   FC9,W
0EBC:  MOVFF  AF,FC9
0EC0:  RRCF   FC7,W
0EC2:  BNC   0EC0
....................    output_high(FLASH_CS); 
0EC4:  BCF    F94.2
0EC6:  BSF    F8B.2
.................... } 
0EC8:  RETLW  00
....................  
.................... void flash_buffer1_read(int8 PageIndex) { 
....................    int i; 
....................    flash_wait_until_ready(); 
....................    output_low(FLASH_CS); 
....................    delay_cycles(20); 
....................    spi_write(0xD4); // use 0xD4 must have 1 dummy byte after address bytes 
....................    spi_write(0); 
....................    spi_write(0); 
....................    spi_write(PageIndex); 
....................    spi_write(0); // dummy byte required 
....................    flash_page_data = spi_read(0); 
....................    flash_page_data2 = spi_read(0); 
....................    output_high(FLASH_CS);    
.................... } 
....................  
.................... void flash_set_256_page_size() { 
....................    flash_wait_until_ready(); 
0ECA:  CALL   05E2
....................    output_low(FLASH_CS); 
0ECE:  BCF    F94.2
0ED0:  BCF    F8B.2
....................    delay_cycles(20); 
0ED2:  MOVLW  06
0ED4:  MOVWF  00
0ED6:  DECFSZ 00,F
0ED8:  BRA    0ED6
0EDA:  NOP   
....................    spi_write(0x3D); 
0EDC:  MOVF   FC9,W
0EDE:  MOVLW  3D
0EE0:  MOVWF  FC9
0EE2:  RRCF   FC7,W
0EE4:  BNC   0EE2
....................    spi_write(0x2A); 
0EE6:  MOVF   FC9,W
0EE8:  MOVLW  2A
0EEA:  MOVWF  FC9
0EEC:  RRCF   FC7,W
0EEE:  BNC   0EEC
....................    spi_write(0x80); 
0EF0:  MOVF   FC9,W
0EF2:  MOVLW  80
0EF4:  MOVWF  FC9
0EF6:  RRCF   FC7,W
0EF8:  BNC   0EF6
....................    spi_write(0xA6); 
0EFA:  MOVF   FC9,W
0EFC:  MOVLW  A6
0EFE:  MOVWF  FC9
0F00:  RRCF   FC7,W
0F02:  BNC   0F00
....................    output_high(FLASH_CS);  
0F04:  BCF    F94.2
0F06:  BSF    F8B.2
.................... } 
0F08:  GOTO   1BE6 (RETURN)
....................  
.................... void flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
*
0CF0:  MOVF   x76,W
0CF2:  SUBLW  26
0CF4:  BNZ   0CFC
0CF6:  BCF    FD8.0
0CF8:  RLCF   xAF,F
0CFA:  RLCF   xB0,F
....................    flash_wait_until_ready(); 
0CFC:  RCALL  05E2
....................    output_low(FLASH_CS); 
0CFE:  BCF    F94.2
0D00:  BCF    F8B.2
....................    delay_cycles(20);	 
0D02:  MOVLW  06
0D04:  MOVWF  00
0D06:  DECFSZ 00,F
0D08:  BRA    0D06
0D0A:  NOP   
....................    spi_write(0x83); 
0D0C:  MOVF   FC9,W
0D0E:  MOVLW  83
0D10:  MOVWF  FC9
0D12:  RRCF   FC7,W
0D14:  BNC   0D12
....................    spi_write(make8(pageAddress,1)); 
0D16:  MOVFF  B0,B1
0D1A:  MOVF   FC9,W
0D1C:  MOVFF  B0,FC9
0D20:  RRCF   FC7,W
0D22:  BNC   0D20
....................    spi_write(make8(pageAddress,0)); 
0D24:  MOVFF  AF,B1
0D28:  MOVF   FC9,W
0D2A:  MOVFF  AF,FC9
0D2E:  RRCF   FC7,W
0D30:  BNC   0D2E
....................    spi_write(0); 
0D32:  MOVF   FC9,W
0D34:  CLRF   FC9
0D36:  RRCF   FC7,W
0D38:  BNC   0D36
....................    output_high(FLASH_CS); 
0D3A:  BCF    F94.2
0D3C:  BSF    F8B.2
.................... } 
0D3E:  GOTO   1B5E (RETURN)
....................  
.................... void flash_write_page(int16 pageAddress) { 
....................    int8 i,check_sum; 
....................    char input_data; 
....................    disable_interrupts(GLOBAL); 
*
0F0C:  BCF    FF2.6
0F0E:  BCF    FF2.7
0F10:  BTFSC  FF2.7
0F12:  BRA    0F0E
....................    //output_high(FLASH_CS); 
....................    flash_wait_until_ready(); 
0F14:  CALL   05E2
....................    delay_cycles(50); 
0F18:  MOVLW  10
0F1A:  MOVWF  00
0F1C:  DECFSZ 00,F
0F1E:  BRA    0F1C
0F20:  NOP   
....................    output_low(FLASH_CS); 
0F22:  BCF    F94.2
0F24:  BCF    F8B.2
....................    if (pageAddress%2) spi_write(0x82); else spi_write(0x85); 
0F26:  MOVF   xAF,W
0F28:  ANDLW  01
0F2A:  MOVWF  00
0F2C:  CLRF   03
0F2E:  MOVF   00,W
0F30:  IORWF  03,W
0F32:  BZ    0F40
0F34:  MOVF   FC9,W
0F36:  MOVLW  82
0F38:  MOVWF  FC9
0F3A:  RRCF   FC7,W
0F3C:  BNC   0F3A
0F3E:  BRA    0F4A
0F40:  MOVF   FC9,W
0F42:  MOVLW  85
0F44:  MOVWF  FC9
0F46:  RRCF   FC7,W
0F48:  BNC   0F46
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
0F4A:  MOVF   x76,W
0F4C:  SUBLW  26
0F4E:  BNZ   0F56
0F50:  BCF    FD8.0
0F52:  RLCF   xAF,F
0F54:  RLCF   xB0,F
....................    spi_write(make8(pageAddress,1)); 
0F56:  MOVFF  B0,B4
0F5A:  MOVF   FC9,W
0F5C:  MOVFF  B0,FC9
0F60:  RRCF   FC7,W
0F62:  BNC   0F60
....................    spi_write(make8(pageAddress,0)); 
0F64:  MOVFF  AF,B4
0F68:  MOVF   FC9,W
0F6A:  MOVFF  AF,FC9
0F6E:  RRCF   FC7,W
0F70:  BNC   0F6E
....................    spi_write(0); 
0F72:  MOVF   FC9,W
0F74:  CLRF   FC9
0F76:  RRCF   FC7,W
0F78:  BNC   0F76
....................    check_sum=0; 
0F7A:  CLRF   xB2
....................    i=0xFF; 
0F7C:  MOVLW  FF
0F7E:  MOVWF  xB1
....................    check_sum=0xCC; 
0F80:  MOVLW  CC
0F82:  MOVWF  xB2
....................    do { 
....................       input_data = getc(); 
0F84:  BTFSS  F9E.5
0F86:  BRA    0F84
0F88:  MOVFF  FAE,B3
....................       check_sum ^= input_data; 
0F8C:  MOVF   xB3,W
0F8E:  XORWF  xB2,F
....................       spi_write(input_data); 
0F90:  MOVF   FC9,W
0F92:  MOVFF  B3,FC9
0F96:  RRCF   FC7,W
0F98:  BNC   0F96
....................       i++; 
0F9A:  INCF   xB1,F
....................    } while(i!=0xFF); 
0F9C:  INCFSZ xB1,W
0F9E:  BRA    0F84
....................    output_high(FLASH_CS); 
0FA0:  BCF    F94.2
0FA2:  BSF    F8B.2
....................    enable_interrupts(GLOBAL); 
0FA4:  MOVLW  C0
0FA6:  IORWF  FF2,F
.................... } 
0FA8:  GOTO   1C14 (RETURN)
....................  
.................... void flash_read_main_memory_to_buffer1(int16 pageAddress) { 
....................    flash_wait_until_ready(); 
*
0D42:  RCALL  05E2
....................    if (flash_mfg_id[1]==0x26) pageAddress <<=1; 
0D44:  MOVF   x76,W
0D46:  SUBLW  26
0D48:  BNZ   0D50
0D4A:  BCF    FD8.0
0D4C:  RLCF   xAF,F
0D4E:  RLCF   xB0,F
....................    output_low(FLASH_CS); 
0D50:  BCF    F94.2
0D52:  BCF    F8B.2
....................    spi_write(0x53); 
0D54:  MOVF   FC9,W
0D56:  MOVLW  53
0D58:  MOVWF  FC9
0D5A:  RRCF   FC7,W
0D5C:  BNC   0D5A
....................    spi_write(make8(pageAddress,1)); 
0D5E:  MOVFF  B0,B1
0D62:  MOVF   FC9,W
0D64:  MOVFF  B0,FC9
0D68:  RRCF   FC7,W
0D6A:  BNC   0D68
....................    spi_write(make8(pageAddress,0)); 
0D6C:  MOVFF  AF,B1
0D70:  MOVF   FC9,W
0D72:  MOVFF  AF,FC9
0D76:  RRCF   FC7,W
0D78:  BNC   0D76
....................    spi_write(0); 
0D7A:  MOVF   FC9,W
0D7C:  CLRF   FC9
0D7E:  RRCF   FC7,W
0D80:  BNC   0D7E
....................    output_high(FLASH_CS); 
0D82:  BCF    F94.2
0D84:  BSF    F8B.2
.................... } 
0D86:  GOTO   1B8C (RETURN)
....................  
.................... /* 
.................... void print_date_time() { 
....................  
.................... 	  printf("\r\n Day#%lu, ",nDay); 
....................       strcpy(tmp_str,"00:00:00"); 
....................       itoa((int8) (timer_sec/3600),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) ((timer_sec%3600)/60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................       itoa((int8) (timer_sec%60),10,tmp_str2); 
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
....................    	  printf("%s",tmp_str); 
.................... } 
....................  
.................... void print_page_data(int16 nPage) { 
.................... // filled output buffer with memory content in flash page memory 
....................     int8 i; 
....................     int8 j; 
....................     for(i=0;i<16;i++) { 
....................       //printf("\r\n%02X : ",i); 
....................       for (j=0;j<8;j++) { 
....................         flash_read_page(nPage,i*16+j*2); 
.................... 		output_buffer[i*16+j*2] = flash_page_data; 
.................... 		output_buffer[i*16+j*2+1] = flash_page_data2; 
.................... 		//printf("%02X %02X ",flash_page_data,flash_page_data2); 
.................... 	  } 
....................    } 
.................... } 
.................... */ 
.................... void solar_load_parameter_from_flash() { 
....................     flash_read_page(0,0x4E);  
*
0C2A:  CLRF   xBE
0C2C:  CLRF   xBD
0C2E:  MOVLW  4E
0C30:  MOVWF  xBF
0C32:  RCALL  0BA0
.................... 	act_min_stroke = make16(flash_page_data2,flash_page_data); 
0C34:  MOVFF  7B,9B
0C38:  MOVFF  7A,9A
....................     flash_read_page(0,0x50);  
0C3C:  CLRF   xBE
0C3E:  CLRF   xBD
0C40:  MOVLW  50
0C42:  MOVWF  xBF
0C44:  RCALL  0BA0
.................... 	act_max_stroke = make16(flash_page_data2,flash_page_data); 
0C46:  MOVFF  7B,99
0C4A:  MOVFF  7A,98
....................     flash_read_page(0,0x56);  
0C4E:  CLRF   xBE
0C50:  CLRF   xBD
0C52:  MOVLW  56
0C54:  MOVWF  xBF
0C56:  RCALL  0BA0
.................... 	latitude = make16(flash_page_data2,flash_page_data); 
0C58:  MOVFF  7B,9F
0C5C:  MOVFF  7A,9E
....................     flash_read_page(0,0x58);  
0C60:  CLRF   xBE
0C62:  CLRF   xBD
0C64:  MOVLW  58
0C66:  MOVWF  xBF
0C68:  RCALL  0BA0
.................... 	longitude = make16(flash_page_data2,flash_page_data); 
0C6A:  MOVFF  7B,A1
0C6E:  MOVFF  7A,A0
....................     flash_read_page(0,0x5A);  
0C72:  CLRF   xBE
0C74:  CLRF   xBD
0C76:  MOVLW  5A
0C78:  MOVWF  xBF
0C7A:  RCALL  0BA0
.................... 	altitude = make16(flash_page_data2,flash_page_data);	 
0C7C:  MOVFF  7B,A3
0C80:  MOVFF  7A,A2
....................     flash_read_page(0,0x5C);  
0C84:  CLRF   xBE
0C86:  CLRF   xBD
0C88:  MOVLW  5C
0C8A:  MOVWF  xBF
0C8C:  RCALL  0BA0
.................... 	act_safety_stroke = make16(flash_page_data2,flash_page_data); 
0C8E:  MOVFF  7B,9D
0C92:  MOVFF  7A,9C
.................... } 
0C96:  GOTO   27B0 (RETURN)
.................... /* 
.................... void print_fw_info() { 
....................     int8 i,j; 
.................... 	disable_interrupts(GLOBAL); 
....................     for (i=0;i<4;i++) { 
....................         printf("\r\n"); 
.................... 		for (j=0;j<8;j++) { 
....................     		flash_read_page(0,i*16+j*2); 
.................... 			printf("%c%c",flash_page_data,flash_page_data2); 
.................... 		} 
.................... 	} 
.................... 	flash_read_page(0,0x40); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................   	flash_read_page(0,0x42); 
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
....................     solar_load_parameter_from_flash(); 
.................... 	printf("\r\n Min Stroke=%lu/256 cm",act_min_stroke); 
.................... 	printf("\r\n Max Stroke=%lu/256 cm",act_max_stroke); 
.................... 	printf("\r\n Safty Stroke=%lu/256 cm",act_safety_stroke); 
.................... 	printf("\r\n Latitude=%lu/100",latitude); 
.................... 	printf("\r\n Longitude=%lu/100",longitude); 
.................... 	printf("\r\n Altitude =%lu/100",altitude); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... } 
.................... */ 
.................... void display_LED() { 
.................... 	portd.data_bus=LED_status; 
*
0144:  MOVF   21,W
0146:  ANDLW  0F
0148:  MOVWF  00
014A:  MOVLW  F0
014C:  ANDWF  F83,W
014E:  IORWF  00,W
0150:  MOVWF  F83
.................... 	delay_cycles(20); 
0152:  MOVLW  06
0154:  MOVWF  00
0156:  DECFSZ 00,F
0158:  BRA    0156
015A:  NOP   
.................... 	portd.LED_latch=1; 
015C:  BSF    F83.5
.................... 	delay_cycles(20); 
015E:  MOVLW  06
0160:  MOVWF  00
0162:  DECFSZ 00,F
0164:  BRA    0162
0166:  NOP   
.................... 	portd.LED_latch=0; 
0168:  BCF    F83.5
.................... 	delay_cycles(20); 
016A:  MOVLW  06
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
0172:  NOP   
.................... 	portd.LED_latch=1; 
0174:  BSF    F83.5
.................... } 
0176:  RETLW  00
....................  
.................... ///////////////////////////// 
.................... void stuff_data(int8 data_to_stuff) { 
.................... 	int8 stuffing_mask =0xFF; 
*
0448:  MOVLW  FF
044A:  MOVWF  xDC
.................... 	if ((data_to_stuff==0xA8) || (data_to_stuff==0xA9)) { 
044C:  MOVF   xDB,W
044E:  SUBLW  A8
0450:  BZ    0458
0452:  MOVF   xDB,W
0454:  SUBLW  A9
0456:  BNZ   0460
.................... 		printf("%c",0xA9); 
0458:  MOVLW  A9
045A:  RCALL  0440
.................... 		stuffing_mask = 0xDF; 
045C:  MOVLW  DF
045E:  MOVWF  xDC
.................... 	} 
.................... 	printf("%c",stuffing_mask&data_to_stuff); 
0460:  MOVF   xDC,W
0462:  ANDWF  xDB,W
0464:  MOVWF  xDD
0466:  RCALL  0440
.................... } 
0468:  RETLW  00
.................... // send whatever in sent buffer 
.................... // packet_type:  
.................... //0= ACK,  
.................... //1=NACK,  
.................... //2=DATA, GENERIC,  
.................... //3 = BUFFER1 
.................... //4 = Acutator stat 
.................... //5 = Last acutator move pulse 
.................... //6 = SET 256 PAGE SIZE COMPLETE 
.................... //7 = BUSY 
.................... //8 = FLASH WRITE COMPLETE 
.................... //9 = DATE TIME 
.................... //10 = STATUS FLAGS 
.................... //11 = DEVICE ID 
.................... void send_data(int8 packet_type,int8 size) { 
.................... 	int8 i; 
.................... 	output_checksum=0; 
046A:  CLRF   x74
.................... 	printf("%c",0xA8); 
046C:  MOVLW  A8
046E:  RCALL  0440
.................... 	stuff_data(make8(dev_id,1)); 
0470:  MOVFF  35,DA
0474:  MOVFF  35,DB
0478:  RCALL  0448
.................... 	output_checksum ^= make8(dev_id,1); 
047A:  MOVF   35,W
047C:  XORWF  x74,F
.................... 	stuff_data(make8(dev_id,0)); 
047E:  MOVFF  34,DA
0482:  MOVFF  34,DB
0486:  RCALL  0448
.................... 	output_checksum ^= make8(dev_id,0); 
0488:  MOVF   34,W
048A:  XORWF  x74,F
.................... 	stuff_data(packet_type); 
048C:  MOVFF  D7,DB
0490:  RCALL  0448
.................... 	output_checksum ^= packet_type; 
0492:  MOVF   xD7,W
0494:  XORWF  x74,F
.................... 	if (size >0) { 
0496:  MOVF   xD8,F
0498:  BZ    04D0
....................     	i = 0xFF; 
049A:  MOVLW  FF
049C:  MOVWF  xD9
....................     	do { 
.................... 			i++; 
049E:  INCF   xD9,F
.................... 			output_checksum ^=output_buffer[i]; 
04A0:  CLRF   03
04A2:  MOVF   xD9,W
04A4:  ADDLW  54
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVF   FEF,W
04B0:  XORWF  x74,F
.................... 			stuff_data(output_buffer[i]); 
04B2:  CLRF   03
04B4:  MOVF   xD9,W
04B6:  ADDLW  54
04B8:  MOVWF  FE9
04BA:  MOVLW  00
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVFF  FEF,DA
04C4:  MOVFF  DA,DB
04C8:  RCALL  0448
.................... 		} while(i<size); 
04CA:  MOVF   xD8,W
04CC:  SUBWF  xD9,W
04CE:  BNC   049E
.................... 	} 
.................... 	stuff_data(output_checksum); 
04D0:  MOVFF  74,DB
04D4:  RCALL  0448
.................... 	printf("%c",0xA8); 
04D6:  MOVLW  A8
04D8:  RCALL  0440
.................... } 
04DA:  RETLW  00
.................... /////////////////////// send buffer 1 content 
.................... void send_buffer1_content() { 
....................  
....................    int8 i; 
....................    int8 buffer1_content; 
....................    output_checksum=0; 
*
0D8A:  CLRF   x74
....................    printf("%c",0xA8); 
0D8C:  MOVLW  A8
0D8E:  CALL   0440
....................    stuff_data(make8(dev_id,1)); 
0D92:  MOVFF  35,B1
0D96:  CLRF   18
0D98:  BTFSC  FF2.7
0D9A:  BSF    18.7
0D9C:  BCF    FF2.7
0D9E:  MOVFF  35,DB
0DA2:  CALL   0448
0DA6:  BTFSC  18.7
0DA8:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,1); 
0DAA:  MOVF   35,W
0DAC:  XORWF  x74,F
....................    stuff_data(make8(dev_id,0)); 
0DAE:  MOVFF  34,B1
0DB2:  CLRF   18
0DB4:  BTFSC  FF2.7
0DB6:  BSF    18.7
0DB8:  BCF    FF2.7
0DBA:  MOVFF  34,DB
0DBE:  CALL   0448
0DC2:  BTFSC  18.7
0DC4:  BSF    FF2.7
....................    output_checksum ^= make8(dev_id,0); 
0DC6:  MOVF   34,W
0DC8:  XORWF  x74,F
0DCA:  CLRF   18
0DCC:  BTFSC  FF2.7
0DCE:  BSF    18.7
0DD0:  BCF    FF2.7
....................    stuff_data(0x03); 
0DD2:  MOVLW  03
0DD4:  MOVWF  xDB
0DD6:  CALL   0448
0DDA:  BTFSC  18.7
0DDC:  BSF    FF2.7
....................    output_checksum ^= 0x03; 
0DDE:  MOVLW  03
0DE0:  XORWF  x74,F
....................  
....................    flash_wait_until_ready(); 
0DE2:  CALL   05E2
....................    output_low(FLASH_CS); 
0DE6:  BCF    F94.2
0DE8:  BCF    F8B.2
....................    delay_cycles(20); 
0DEA:  MOVLW  06
0DEC:  MOVWF  00
0DEE:  DECFSZ 00,F
0DF0:  BRA    0DEE
0DF2:  NOP   
....................    spi_write(0xD1); 
0DF4:  MOVF   FC9,W
0DF6:  MOVLW  D1
0DF8:  MOVWF  FC9
0DFA:  RRCF   FC7,W
0DFC:  BNC   0DFA
....................    spi_write(0); 
0DFE:  MOVF   FC9,W
0E00:  CLRF   FC9
0E02:  RRCF   FC7,W
0E04:  BNC   0E02
....................    spi_write(0); 
0E06:  MOVF   FC9,W
0E08:  CLRF   FC9
0E0A:  RRCF   FC7,W
0E0C:  BNC   0E0A
....................    spi_write(0); 
0E0E:  MOVF   FC9,W
0E10:  CLRF   FC9
0E12:  RRCF   FC7,W
0E14:  BNC   0E12
....................     
....................    	i = 0xFF; 
0E16:  MOVLW  FF
0E18:  MOVWF  xAF
....................    	do { 
.................... 		i++; 
0E1A:  INCF   xAF,F
.................... 		buffer1_content = spi_read(0); 
0E1C:  MOVF   FC9,W
0E1E:  CLRF   FC9
0E20:  RRCF   FC7,W
0E22:  BNC   0E20
0E24:  MOVFF  FC9,B0
.................... 		output_checksum ^=buffer1_content; 
0E28:  MOVF   xB0,W
0E2A:  XORWF  x74,F
0E2C:  CLRF   18
0E2E:  BTFSC  FF2.7
0E30:  BSF    18.7
0E32:  BCF    FF2.7
.................... 		stuff_data(buffer1_content); 
0E34:  MOVFF  B0,DB
0E38:  CALL   0448
0E3C:  BTFSC  18.7
0E3E:  BSF    FF2.7
.................... 		} while(i<255); 
0E40:  INCFSZ xAF,W
0E42:  BRA    0E1A
....................    output_high(FLASH_CS);   
0E44:  BCF    F94.2
0E46:  BSF    F8B.2
0E48:  CLRF   18
0E4A:  BTFSC  FF2.7
0E4C:  BSF    18.7
0E4E:  BCF    FF2.7
....................  
....................    stuff_data(output_checksum); 
0E50:  MOVFF  74,DB
0E54:  CALL   0448
0E58:  BTFSC  18.7
0E5A:  BSF    FF2.7
....................    printf("%c",0xA8); 
0E5C:  MOVLW  A8
0E5E:  CALL   0440
....................  
....................  
....................  
....................   
.................... } 
0E62:  GOTO   1BB2 (RETURN)
.................... //////////////////////////////////////////////////////////////////// 
.................... void solar_get_act_length(unsigned int8 nActuator) { 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 current_period_fraction; 
....................  
.................... 	unsigned int16 current_act_len; 
.................... 	unsigned int16 next_act_len; 
.................... 	 
....................     target_act_position =0; 
*
1536:  CLRF   x8F
1538:  CLRF   x8E
....................  
.................... 	flash_read_page(nDay,0x00);  // verify page number 
153A:  MOVFF  2F,BB
153E:  MOVFF  2E,BA
1542:  MOVFF  2F,BE
1546:  MOVFF  2E,BD
154A:  CLRF   xBF
154C:  CALL   0BA0
....................     if (nDay != make16(flash_page_data2,flash_page_data))  { 
1550:  MOVFF  7B,03
1554:  MOVF   x7A,W
1556:  SUBWF  2E,W
1558:  BNZ   1568
155A:  MOVF   03,W
155C:  SUBWF  2F,W
155E:  BNZ   1568
1560:  MOVF   30,F
1562:  BNZ   1568
1564:  MOVF   31,F
1566:  BZ    156A
.................... 		//printf("Error:Flash data corrupt"); 
.................... 		return; 
1568:  BRA    1A08
.................... 	} 
....................     current_period = (timer_sec+225)/450; 
156A:  MOVLW  E1
156C:  ADDWF  22,W
156E:  MOVWF  xBA
1570:  MOVLW  00
1572:  ADDWFC 23,W
1574:  MOVWF  xBB
1576:  MOVLW  00
1578:  ADDWFC 24,W
157A:  MOVWF  xBC
157C:  MOVLW  00
157E:  ADDWFC 25,W
1580:  MOVWF  xBD
1582:  CLRF   18
1584:  BTFSC  FF2.7
1586:  BSF    18.7
1588:  BCF    FF2.7
158A:  MOVWF  xD5
158C:  MOVFF  BC,D4
1590:  MOVFF  BB,D3
1594:  MOVFF  BA,D2
1598:  CLRF   xD9
159A:  CLRF   xD8
159C:  MOVLW  01
159E:  MOVWF  xD7
15A0:  MOVLW  C2
15A2:  MOVWF  xD6
15A4:  CALL   00AA
15A8:  BTFSC  18.7
15AA:  BSF    FF2.7
15AC:  MOVFF  01,B3
15B0:  MOVFF  00,B2
....................     current_period_fraction = (timer_sec+225)%450; 
15B4:  MOVLW  E1
15B6:  ADDWF  22,W
15B8:  MOVWF  xBA
15BA:  MOVLW  00
15BC:  ADDWFC 23,W
15BE:  MOVWF  xBB
15C0:  MOVLW  00
15C2:  ADDWFC 24,W
15C4:  MOVWF  xBC
15C6:  MOVLW  00
15C8:  ADDWFC 25,W
15CA:  MOVWF  xBD
15CC:  CLRF   18
15CE:  BTFSC  FF2.7
15D0:  BSF    18.7
15D2:  BCF    FF2.7
15D4:  MOVWF  xD5
15D6:  MOVFF  BC,D4
15DA:  MOVFF  BB,D3
15DE:  MOVFF  BA,D2
15E2:  CLRF   xD9
15E4:  CLRF   xD8
15E6:  MOVLW  01
15E8:  MOVWF  xD7
15EA:  MOVLW  C2
15EC:  MOVWF  xD6
15EE:  CALL   00AA
15F2:  BTFSC  18.7
15F4:  BSF    FF2.7
15F6:  MOVFF  FEF,B4
15FA:  MOVFF  FEC,B5
....................     flash_read_page(nDay,0x02); // get sun rise time 
15FE:  MOVFF  2F,BB
1602:  MOVFF  2E,BA
1606:  MOVFF  2F,BE
160A:  MOVFF  2E,BD
160E:  MOVLW  02
1610:  MOVWF  xBF
1612:  CALL   0BA0
....................     sun_rise_period=make16(flash_page_data2,flash_page_data); 
1616:  MOVFF  7B,B1
161A:  MOVFF  7A,B0
.................... 	if ((current_period < sun_rise_period) || (current_period > sun_rise_period+124)) // still dark 
161E:  MOVF   xB3,W
1620:  SUBWF  xB1,W
1622:  BNC   162C
1624:  BNZ   1646
1626:  MOVF   xB0,W
1628:  SUBWF  xB2,W
162A:  BNC   1646
162C:  MOVLW  7C
162E:  ADDWF  xB0,W
1630:  MOVWF  01
1632:  MOVLW  00
1634:  ADDWFC xB1,W
1636:  MOVWF  03
1638:  MOVF   03,W
163A:  SUBWF  xB3,W
163C:  BNC   1726
163E:  BNZ   1646
1640:  MOVF   xB2,W
1642:  SUBWF  01,W
1644:  BC    1726
.................... 	{ 
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]*(int32)(act_safety_stroke-act_min_stroke); 
1646:  BCF    FD8.0
1648:  RLCF   xAF,W
164A:  CLRF   03
164C:  ADDLW  90
164E:  MOVWF  FE9
1650:  MOVLW  00
1652:  ADDWFC 03,W
1654:  MOVWF  FEA
1656:  MOVFF  FEC,03
165A:  MOVF   FED,F
165C:  MOVFF  FEF,BA
1660:  MOVFF  03,BB
1664:  CLRF   xBC
1666:  CLRF   xBD
1668:  MOVF   x9A,W
166A:  SUBWF  x9C,W
166C:  MOVWF  00
166E:  MOVF   x9B,W
1670:  SUBWFB x9D,W
1672:  MOVWF  03
1674:  MOVF   00,W
1676:  MOVFF  03,01
167A:  CLRF   02
167C:  CLRF   03
167E:  MOVFF  03,C1
1682:  MOVFF  02,C0
1686:  MOVFF  01,BF
168A:  MOVFF  00,BE
168E:  MOVFF  FEA,C3
1692:  MOVFF  FE9,C2
1696:  MOVFF  BD,C7
169A:  MOVFF  BC,C6
169E:  MOVFF  BB,C5
16A2:  MOVFF  BA,C4
16A6:  MOVFF  03,CB
16AA:  MOVFF  02,CA
16AE:  MOVFF  01,C9
16B2:  MOVFF  00,C8
16B6:  RCALL  1352
16B8:  MOVFF  C3,FEA
16BC:  MOVFF  C2,FE9
16C0:  MOVFF  03,29
16C4:  MOVFF  02,28
16C8:  MOVFF  01,27
16CC:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
16D0:  MOVF   x9A,W
16D2:  SUBWF  x98,W
16D4:  MOVWF  00
16D6:  MOVF   x9B,W
16D8:  SUBWFB x99,W
16DA:  MOVWF  03
16DC:  MOVFF  00,BA
16E0:  MOVWF  xBB
16E2:  CLRF   18
16E4:  BTFSC  FF2.7
16E6:  BSF    18.7
16E8:  BCF    FF2.7
16EA:  MOVFF  29,D5
16EE:  MOVFF  28,D4
16F2:  MOVFF  27,D3
16F6:  MOVFF  26,D2
16FA:  CLRF   xD9
16FC:  CLRF   xD8
16FE:  MOVWF  xD7
1700:  MOVFF  00,D6
1704:  CALL   00AA
1708:  BTFSC  18.7
170A:  BSF    FF2.7
170C:  MOVFF  03,29
1710:  MOVFF  02,28
1714:  MOVFF  01,27
1718:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
171C:  MOVFF  27,8F
1720:  MOVFF  26,8E
.................... 	} else { 
1724:  BRA    1A08
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+4); 
1726:  MOVFF  2F,BB
172A:  MOVFF  2E,BA
172E:  MOVF   xB0,W
1730:  SUBWF  xB2,W
1732:  MOVWF  00
1734:  MOVF   xB1,W
1736:  SUBWFB xB3,W
1738:  MOVWF  03
173A:  MOVF   00,W
173C:  BCF    FD8.0
173E:  RLCF   00,F
1740:  MOVF   00,W
1742:  ADDLW  04
1744:  MOVWF  xBC
1746:  MOVFF  2F,BE
174A:  MOVFF  2E,BD
174E:  MOVWF  xBF
1750:  CALL   0BA0
.................... 		current_act_len = make16(flash_page_data2,flash_page_data); 
1754:  MOVFF  7B,B7
1758:  MOVFF  7A,B6
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+6); 
175C:  MOVFF  2F,BB
1760:  MOVFF  2E,BA
1764:  MOVF   xB0,W
1766:  SUBWF  xB2,W
1768:  MOVWF  00
176A:  MOVF   xB1,W
176C:  SUBWFB xB3,W
176E:  MOVWF  03
1770:  MOVF   00,W
1772:  BCF    FD8.0
1774:  RLCF   00,F
1776:  MOVF   00,W
1778:  ADDLW  06
177A:  MOVWF  xBC
177C:  MOVFF  2F,BE
1780:  MOVFF  2E,BD
1784:  MOVWF  xBF
1786:  CALL   0BA0
.................... 		next_act_len = make16(flash_page_data2,flash_page_data); 
178A:  MOVFF  7B,B9
178E:  MOVFF  7A,B8
.................... 		// do linear interpolation of the act len 
.................... 		if (next_act_len>current_act_len) { 
1792:  MOVF   xB7,W
1794:  SUBWF  xB9,W
1796:  BNC   1850
1798:  BNZ   17A0
179A:  MOVF   xB8,W
179C:  SUBWF  xB6,W
179E:  BC    1850
.................... 			tick = (int32)(next_act_len-current_act_len)*(int32)(current_period_fraction); 
17A0:  MOVF   xB6,W
17A2:  SUBWF  xB8,W
17A4:  MOVWF  00
17A6:  MOVF   xB7,W
17A8:  SUBWFB xB9,W
17AA:  MOVWF  03
17AC:  MOVFF  00,BA
17B0:  MOVWF  xBB
17B2:  CLRF   xBC
17B4:  CLRF   xBD
17B6:  MOVFF  B4,00
17BA:  MOVFF  B5,01
17BE:  CLRF   02
17C0:  CLRF   03
17C2:  MOVFF  03,C1
17C6:  MOVFF  02,C0
17CA:  MOVFF  B5,BF
17CE:  MOVFF  B4,BE
17D2:  MOVFF  BD,C7
17D6:  MOVFF  BC,C6
17DA:  MOVWF  xC5
17DC:  MOVFF  BA,C4
17E0:  MOVFF  03,CB
17E4:  MOVFF  02,CA
17E8:  MOVFF  B5,C9
17EC:  MOVFF  B4,C8
17F0:  RCALL  1352
17F2:  MOVFF  03,29
17F6:  MOVFF  02,28
17FA:  MOVFF  01,27
17FE:  MOVFF  00,26
1802:  CLRF   18
1804:  BTFSC  FF2.7
1806:  BSF    18.7
1808:  BCF    FF2.7
.................... 			tick = tick/450; 
180A:  MOVFF  29,D5
180E:  MOVFF  28,D4
1812:  MOVFF  27,D3
1816:  MOVFF  26,D2
181A:  CLRF   xD9
181C:  CLRF   xD8
181E:  MOVLW  01
1820:  MOVWF  xD7
1822:  MOVLW  C2
1824:  MOVWF  xD6
1826:  CALL   00AA
182A:  BTFSC  18.7
182C:  BSF    FF2.7
182E:  MOVFF  03,29
1832:  MOVFF  02,28
1836:  MOVFF  01,27
183A:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
183E:  MOVFF  27,B9
1842:  MOVFF  26,B8
.................... 			current_act_len = current_act_len + next_act_len; 
1846:  MOVF   xB8,W
1848:  ADDWF  xB6,F
184A:  MOVF   xB9,W
184C:  ADDWFC xB7,F
.................... 		} else  { 
184E:  BRA    18FE
.................... 			tick = (int32)(current_act_len-next_act_len)*(int32)(current_period_fraction); 
1850:  MOVF   xB8,W
1852:  SUBWF  xB6,W
1854:  MOVWF  00
1856:  MOVF   xB9,W
1858:  SUBWFB xB7,W
185A:  MOVWF  03
185C:  MOVFF  00,BA
1860:  MOVWF  xBB
1862:  CLRF   xBC
1864:  CLRF   xBD
1866:  MOVFF  B4,00
186A:  MOVFF  B5,01
186E:  CLRF   02
1870:  CLRF   03
1872:  MOVFF  03,C1
1876:  MOVFF  02,C0
187A:  MOVFF  B5,BF
187E:  MOVFF  B4,BE
1882:  MOVFF  BD,C7
1886:  MOVFF  BC,C6
188A:  MOVWF  xC5
188C:  MOVFF  BA,C4
1890:  MOVFF  03,CB
1894:  MOVFF  02,CA
1898:  MOVFF  B5,C9
189C:  MOVFF  B4,C8
18A0:  RCALL  1352
18A2:  MOVFF  03,29
18A6:  MOVFF  02,28
18AA:  MOVFF  01,27
18AE:  MOVFF  00,26
18B2:  CLRF   18
18B4:  BTFSC  FF2.7
18B6:  BSF    18.7
18B8:  BCF    FF2.7
.................... 			tick = tick/450; 
18BA:  MOVFF  29,D5
18BE:  MOVFF  28,D4
18C2:  MOVFF  27,D3
18C6:  MOVFF  26,D2
18CA:  CLRF   xD9
18CC:  CLRF   xD8
18CE:  MOVLW  01
18D0:  MOVWF  xD7
18D2:  MOVLW  C2
18D4:  MOVWF  xD6
18D6:  CALL   00AA
18DA:  BTFSC  18.7
18DC:  BSF    FF2.7
18DE:  MOVFF  03,29
18E2:  MOVFF  02,28
18E6:  MOVFF  01,27
18EA:  MOVFF  00,26
....................         	next_act_len = (unsigned int16) tick; 
18EE:  MOVFF  27,B9
18F2:  MOVFF  26,B8
.................... 			current_act_len = current_act_len - next_act_len; 
18F6:  MOVF   xB8,W
18F8:  SUBWF  xB6,F
18FA:  MOVF   xB9,W
18FC:  SUBWFB xB7,F
.................... 		} 
.................... 		if (current_act_len >= act_max_stroke) current_act_len = act_max_stroke; 
18FE:  MOVF   x99,W
1900:  SUBWF  xB7,W
1902:  BNC   1914
1904:  BNZ   190C
1906:  MOVF   x98,W
1908:  SUBWF  xB6,W
190A:  BNC   1914
190C:  MOVFF  99,B7
1910:  MOVFF  98,B6
.................... 		if (current_act_len <= act_min_stroke) current_act_len = act_min_stroke; 
1914:  MOVF   xB7,W
1916:  SUBWF  x9B,W
1918:  BNC   192A
191A:  BNZ   1922
191C:  MOVF   xB6,W
191E:  SUBWF  x9A,W
1920:  BNC   192A
1922:  MOVFF  9B,B7
1926:  MOVFF  9A,B6
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]* (int32)(current_act_len-act_min_stroke); 
192A:  BCF    FD8.0
192C:  RLCF   xAF,W
192E:  CLRF   03
1930:  ADDLW  90
1932:  MOVWF  FE9
1934:  MOVLW  00
1936:  ADDWFC 03,W
1938:  MOVWF  FEA
193A:  MOVFF  FEC,03
193E:  MOVF   FED,F
1940:  MOVFF  FEF,BA
1944:  MOVFF  03,BB
1948:  CLRF   xBC
194A:  CLRF   xBD
194C:  MOVF   x9A,W
194E:  SUBWF  xB6,W
1950:  MOVWF  00
1952:  MOVF   x9B,W
1954:  SUBWFB xB7,W
1956:  MOVWF  03
1958:  MOVF   00,W
195A:  MOVFF  03,01
195E:  CLRF   02
1960:  CLRF   03
1962:  MOVFF  03,C1
1966:  MOVFF  02,C0
196A:  MOVFF  01,BF
196E:  MOVFF  00,BE
1972:  MOVFF  FEA,C3
1976:  MOVFF  FE9,C2
197A:  MOVFF  BD,C7
197E:  MOVFF  BC,C6
1982:  MOVFF  BB,C5
1986:  MOVFF  BA,C4
198A:  MOVFF  03,CB
198E:  MOVFF  02,CA
1992:  MOVFF  01,C9
1996:  MOVFF  00,C8
199A:  RCALL  1352
199C:  MOVFF  C3,FEA
19A0:  MOVFF  C2,FE9
19A4:  MOVFF  03,29
19A8:  MOVFF  02,28
19AC:  MOVFF  01,27
19B0:  MOVFF  00,26
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
19B4:  MOVF   x9A,W
19B6:  SUBWF  x98,W
19B8:  MOVWF  00
19BA:  MOVF   x9B,W
19BC:  SUBWFB x99,W
19BE:  MOVWF  03
19C0:  MOVFF  00,BA
19C4:  MOVWF  xBB
19C6:  CLRF   18
19C8:  BTFSC  FF2.7
19CA:  BSF    18.7
19CC:  BCF    FF2.7
19CE:  MOVFF  29,D5
19D2:  MOVFF  28,D4
19D6:  MOVFF  27,D3
19DA:  MOVFF  26,D2
19DE:  CLRF   xD9
19E0:  CLRF   xD8
19E2:  MOVWF  xD7
19E4:  MOVFF  00,D6
19E8:  CALL   00AA
19EC:  BTFSC  18.7
19EE:  BSF    FF2.7
19F0:  MOVFF  03,29
19F4:  MOVFF  02,28
19F8:  MOVFF  01,27
19FC:  MOVFF  00,26
.................... 		target_act_position = (unsigned int16) tick; 
1A00:  MOVFF  27,8F
1A04:  MOVFF  26,8E
.................... 	} 
....................  
.................... } 
1A08:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,int8 direction,unsigned int8 nActuator) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
0FAC:  CLRF   xBA
0FAE:  CLRF   xBB
....................    unsigned int16 yyy=0;    
0FB0:  CLRF   xBC
0FB2:  CLRF   xBD
....................    output_low(CCW); 
0FB4:  BCF    F93.4
0FB6:  BCF    F8A.4
....................    output_low(EN0); 
0FB8:  BCF    F93.0
0FBA:  BCF    F8A.0
....................    output_low(EN1); 
0FBC:  BCF    F93.1
0FBE:  BCF    F8A.1
....................    output_low(EN2); 
0FC0:  BCF    F93.2
0FC2:  BCF    F8A.2
....................    output_low(EN3); 
0FC4:  BCF    F93.3
0FC6:  BCF    F8A.3
0FC8:  CLRF   18
0FCA:  BTFSC  FF2.7
0FCC:  BSF    18.7
0FCE:  BCF    FF2.7
....................    delay_ms(20); 
0FD0:  MOVLW  14
0FD2:  MOVWF  xD2
0FD4:  CALL   0178
0FD8:  BTFSC  18.7
0FDA:  BSF    FF2.7
....................    if (nActuator > 3) return; // actuator exceed max number allowable 
0FDC:  MOVF   xB9,W
0FDE:  SUBLW  03
0FE0:  BC    0FE4
0FE2:  BRA    12A0
....................    flag2.is_moving =1; 
0FE4:  BSF    20.6
....................    switch (nActuator) { 
0FE6:  MOVF   xB9,W
0FE8:  ADDLW  FC
0FEA:  BC    101A
0FEC:  ADDLW  04
0FEE:  GOTO   12A2
.................... 		case 0: { flag.prev_pulse_state = input(SENSE_0); break;} 
0FF2:  BSF    F92.2
0FF4:  BCF    1F.2
0FF6:  BTFSC  F80.2
0FF8:  BSF    1F.2
0FFA:  BRA    101A
.................... 		case 1: { flag.prev_pulse_state = input(SENSE_1); break;} 
0FFC:  BSF    F92.3
0FFE:  BCF    1F.2
1000:  BTFSC  F80.3
1002:  BSF    1F.2
1004:  BRA    101A
.................... 		case 2: { flag.prev_pulse_state = input(SENSE_2); break;} 
1006:  BSF    F92.4
1008:  BCF    1F.2
100A:  BTFSC  F80.4
100C:  BSF    1F.2
100E:  BRA    101A
.................... 		case 3: { flag.prev_pulse_state = input(SENSE_3); break;} 
1010:  BSF    F92.5
1012:  BCF    1F.2
1014:  BTFSC  F80.5
1016:  BSF    1F.2
1018:  BRA    101A
....................    } 
....................  
....................    if (!direction)   { 
101A:  MOVF   xB8,F
101C:  BNZ   1022
....................       output_high(CCW); 
101E:  BCF    F93.4
1020:  BSF    F8A.4
1022:  CLRF   18
1024:  BTFSC  FF2.7
1026:  BSF    18.7
1028:  BCF    FF2.7
....................    } 
....................  
....................    delay_ms(200); 
102A:  MOVLW  C8
102C:  MOVWF  xD2
102E:  CALL   0178
1032:  BTFSC  18.7
1034:  BSF    FF2.7
....................    switch (nActuator) { 
1036:  MOVF   xB9,W
1038:  ADDLW  FC
103A:  BC    105A
103C:  ADDLW  04
103E:  GOTO   12CE
.................... 		case 0: {output_high(EN0); break;} 
1042:  BCF    F93.0
1044:  BSF    F8A.0
1046:  BRA    105A
.................... 		case 1: {output_high(EN1); break;} 
1048:  BCF    F93.1
104A:  BSF    F8A.1
104C:  BRA    105A
.................... 		case 2: {output_high(EN2); break;} 
104E:  BCF    F93.2
1050:  BSF    F8A.2
1052:  BRA    105A
.................... 		case 3: {output_high(EN3); break;} 
1054:  BCF    F93.3
1056:  BSF    F8A.3
1058:  BRA    105A
....................    } 
....................    delay_ms(10); 
105A:  CLRF   18
105C:  BTFSC  FF2.7
105E:  BSF    18.7
1060:  BCF    FF2.7
1062:  MOVLW  0A
1064:  MOVWF  xD2
1066:  CALL   0178
106A:  BTFSC  18.7
106C:  BSF    FF2.7
....................  
....................    tick = timer_sec; 
106E:  MOVFF  25,29
1072:  MOVFF  24,28
1076:  MOVFF  23,27
107A:  MOVFF  22,26
....................    tick2 = timer_sec; 
107E:  MOVFF  25,2D
1082:  MOVFF  24,2C
1086:  MOVFF  23,2B
108A:  MOVFF  22,2A
....................    actuator_pulse =0; 
108E:  CLRF   x7F
1090:  CLRF   x7E
....................    while(1) { 
....................       restart_wdt(); 
1092:  CLRWDT
....................       xxx = (int16) (timer_sec-tick); 
1094:  MOVF   26,W
1096:  SUBWF  22,W
1098:  MOVWF  00
109A:  MOVF   27,W
109C:  SUBWFB 23,W
109E:  MOVWF  01
10A0:  MOVF   28,W
10A2:  SUBWFB 24,W
10A4:  MOVF   29,W
10A6:  SUBWFB 25,W
10A8:  MOVFF  01,BB
10AC:  MOVFF  00,BA
....................       yyy = (int16) (timer_sec-tick2); 
10B0:  MOVF   2A,W
10B2:  SUBWF  22,W
10B4:  MOVWF  00
10B6:  MOVF   2B,W
10B8:  SUBWFB 23,W
10BA:  MOVWF  01
10BC:  MOVF   2C,W
10BE:  SUBWFB 24,W
10C0:  MOVF   2D,W
10C2:  SUBWFB 25,W
10C4:  MOVFF  01,BD
10C8:  MOVFF  00,BC
....................    	  switch (nActuator) { 
10CC:  MOVF   xB9,W
10CE:  ADDLW  FC
10D0:  BC    1100
10D2:  ADDLW  04
10D4:  GOTO   12FA
.................... 		case 0: { flag2.current_pulse_state = input(SENSE_0); break;} 
10D8:  BSF    F92.2
10DA:  BCF    20.4
10DC:  BTFSC  F80.2
10DE:  BSF    20.4
10E0:  BRA    1100
.................... 		case 1: { flag2.current_pulse_state = input(SENSE_1); break;} 
10E2:  BSF    F92.3
10E4:  BCF    20.4
10E6:  BTFSC  F80.3
10E8:  BSF    20.4
10EA:  BRA    1100
.................... 		case 2: { flag2.current_pulse_state = input(SENSE_2); break;} 
10EC:  BSF    F92.4
10EE:  BCF    20.4
10F0:  BTFSC  F80.4
10F2:  BSF    20.4
10F4:  BRA    1100
.................... 		case 3: { flag2.current_pulse_state = input(SENSE_3); break;} 
10F6:  BSF    F92.5
10F8:  BCF    20.4
10FA:  BTFSC  F80.5
10FC:  BSF    20.4
10FE:  BRA    1100
....................       } 
....................  
.................... 	  if (flag2.allow_manual_move_act) { 
1100:  BTFSS  20.3
1102:  BRA    1122
.................... 		  if (((!direction && (nButton==3)) || (direction && (nButton==5))) && flag2.button_pressed)  
1104:  MOVF   xB8,F
1106:  BNZ   110E
1108:  MOVF   4B,W
110A:  SUBLW  03
110C:  BZ    1118
110E:  MOVF   xB8,F
1110:  BZ    1120
1112:  MOVF   4B,W
1114:  SUBLW  05
1116:  BNZ   1120
1118:  BTFSS  20.1
111A:  BRA    1120
.................... 			flag2.allow_manual_move_act=1; 
111C:  BSF    20.3
.................... 		  else 
111E:  BRA    1122
.................... 			flag2.allow_manual_move_act=0;	 
1120:  BCF    20.3
.................... 	  } 
.................... 	  if (!flag2.allow_manual_move_act) {  
1122:  BTFSC  20.3
1124:  BRA    1180
....................       if (flag2.abort_current_activity ==1) { 
1126:  BTFSS  20.2
1128:  BRA    112E
.................... 		 flag2.abort_current_activity=0; 
112A:  BCF    20.2
.................... 		 break; 
112C:  BRA    1252
....................       } 
....................       if ( xxx>= time_out_sec)  
112E:  MOVF   xB5,W
1130:  SUBWF  xBB,W
1132:  BNC   113E
1134:  BNZ   113C
1136:  MOVF   xB4,W
1138:  SUBWF  xBA,W
113A:  BNC   113E
....................          break; 
113C:  BRA    1252
....................        if (actuator_pulse >= nPulse) 
113E:  MOVF   xB3,W
1140:  SUBWF  x7F,W
1142:  BNC   1170
1144:  BNZ   114C
1146:  MOVF   xB2,W
1148:  SUBWF  x7E,W
114A:  BNC   1170
.................... 	    switch (nActuator) { 
114C:  MOVF   xB9,W
114E:  ADDLW  FC
1150:  BC    1170
1152:  ADDLW  04
1154:  GOTO   1326
.................... 			case 0: {output_low(EN0); break;} 
1158:  BCF    F93.0
115A:  BCF    F8A.0
115C:  BRA    1170
.................... 			case 1: {output_low(EN1); break;} 
115E:  BCF    F93.1
1160:  BCF    F8A.1
1162:  BRA    1170
.................... 			case 2: {output_low(EN2); break;} 
1164:  BCF    F93.2
1166:  BCF    F8A.2
1168:  BRA    1170
.................... 			case 3: {output_low(EN3); break;} 
116A:  BCF    F93.3
116C:  BCF    F8A.3
116E:  BRA    1170
....................    		} 
....................       if ( yyy >=stuck_sec) 
1170:  MOVF   xB7,W
1172:  SUBWF  xBD,W
1174:  BNC   1180
1176:  BNZ   117E
1178:  MOVF   xB6,W
117A:  SUBWF  xBC,W
117C:  BNC   1180
....................          break; 
117E:  BRA    1252
....................       }    
....................       if (flag.prev_pulse_state != flag2.current_pulse_state) { 
1180:  CLRF   00
1182:  BTFSC  20.4
1184:  BSF    00.2
1186:  MOVF   1F,W
1188:  XORWF  00,W
118A:  ANDLW  04
118C:  BZ    1250
....................          tick2 = timer_sec; 
118E:  MOVFF  25,2D
1192:  MOVFF  24,2C
1196:  MOVFF  23,2B
119A:  MOVFF  22,2A
....................          flag.prev_pulse_state = flag2.current_pulse_state; 
119E:  BCF    1F.2
11A0:  BTFSC  20.4
11A2:  BSF    1F.2
....................          if (!direction && (current_act_position[nActuator] >0)) current_act_position[nActuator]--; 
11A4:  MOVF   xB8,F
11A6:  BNZ   11E4
11A8:  BCF    FD8.0
11AA:  RLCF   xB9,W
11AC:  CLRF   03
11AE:  ADDLW  86
11B0:  MOVWF  FE9
11B2:  MOVLW  00
11B4:  ADDWFC 03,W
11B6:  MOVWF  FEA
11B8:  MOVFF  FEC,BF
11BC:  MOVF   FED,F
11BE:  MOVFF  FEF,BE
11C2:  MOVF   xBE,F
11C4:  BNZ   11CA
11C6:  MOVF   xBF,F
11C8:  BZ    11E4
11CA:  BCF    FD8.0
11CC:  RLCF   xB9,W
11CE:  CLRF   03
11D0:  ADDLW  86
11D2:  MOVWF  FE9
11D4:  MOVLW  00
11D6:  ADDWFC 03,W
11D8:  MOVWF  FEA
11DA:  MOVLW  FF
11DC:  ADDWF  FEF,F
11DE:  BC    11E4
11E0:  MOVF   FEE,F
11E2:  DECF   FED,F
....................          if (direction && (current_act_position[nActuator] < act_full_stroke_tick[nActuator])) current_act_position[nActuator]++; 
11E4:  MOVF   xB8,F
11E6:  BZ    1242
11E8:  BCF    FD8.0
11EA:  RLCF   xB9,W
11EC:  CLRF   03
11EE:  ADDLW  86
11F0:  MOVWF  FE9
11F2:  MOVLW  00
11F4:  ADDWFC 03,W
11F6:  MOVWF  FEA
11F8:  MOVFF  FEC,BF
11FC:  MOVF   FED,F
11FE:  MOVFF  FEF,BE
1202:  BCF    FD8.0
1204:  RLCF   xB9,W
1206:  CLRF   03
1208:  ADDLW  90
120A:  MOVWF  FE9
120C:  MOVLW  00
120E:  ADDWFC 03,W
1210:  MOVWF  FEA
1212:  MOVFF  FEC,03
1216:  MOVF   FED,F
1218:  MOVFF  FEF,01
121C:  MOVF   xBF,W
121E:  SUBWF  03,W
1220:  BNC   1242
1222:  BNZ   122A
1224:  MOVF   01,W
1226:  SUBWF  xBE,W
1228:  BC    1242
122A:  BCF    FD8.0
122C:  RLCF   xB9,W
122E:  CLRF   03
1230:  ADDLW  86
1232:  MOVWF  FE9
1234:  MOVLW  00
1236:  ADDWFC 03,W
1238:  MOVWF  FEA
123A:  MOVLW  01
123C:  ADDWF  FEE,F
123E:  BNC   1242
1240:  INCF   FEF,F
....................          actuator_pulse=actuator_pulse+1; 
1242:  MOVLW  01
1244:  ADDWF  x7E,F
1246:  MOVLW  00
1248:  ADDWFC x7F,F
.................... 		 led_status.operation = !led_status.operation; 
124A:  BTG    21.1
.................... 		 display_LED(); 
124C:  CALL   0144
....................       } 
....................    } 
1250:  BRA    1092
....................    flag2.abort_current_activity=0; 
1252:  BCF    20.2
....................    output_low(EN0); 
1254:  BCF    F93.0
1256:  BCF    F8A.0
....................    output_low(EN1); 
1258:  BCF    F93.1
125A:  BCF    F8A.1
....................    output_low(EN2); 
125C:  BCF    F93.2
125E:  BCF    F8A.2
....................    output_low(EN3); 
1260:  BCF    F93.3
1262:  BCF    F8A.3
....................    delay_ms(500); 
1264:  MOVLW  02
1266:  MOVWF  xBE
1268:  CLRF   18
126A:  BTFSC  FF2.7
126C:  BSF    18.7
126E:  BCF    FF2.7
1270:  MOVLW  FA
1272:  MOVWF  xD2
1274:  CALL   0178
1278:  BTFSC  18.7
127A:  BSF    FF2.7
127C:  DECFSZ xBE,F
127E:  BRA    1268
....................    output_low(CCW); 
1280:  BCF    F93.4
1282:  BCF    F8A.4
1284:  CLRF   18
1286:  BTFSC  FF2.7
1288:  BSF    18.7
128A:  BCF    FF2.7
....................    delay_ms(20); 
128C:  MOVLW  14
128E:  MOVWF  xD2
1290:  CALL   0178
1294:  BTFSC  18.7
1296:  BSF    FF2.7
....................    led_status.operation = 1; 
1298:  BSF    21.1
....................    display_LED(); 
129A:  CALL   0144
....................    flag2.is_moving =0; 
129E:  BCF    20.6
....................  
....................  
.................... } 
12A0:  RETLW  00
....................  
.................... void actuator_move_execute(nActuator) { 
....................     if(current_act_position[nActuator] > (target_act_position+5))// move east 
*
13A6:  BCF    FD8.0
13A8:  RLCF   xAF,W
13AA:  CLRF   03
13AC:  ADDLW  86
13AE:  MOVWF  FE9
13B0:  MOVLW  00
13B2:  ADDWFC 03,W
13B4:  MOVWF  FEA
13B6:  MOVFF  FEC,B1
13BA:  MOVF   FED,F
13BC:  MOVFF  FEF,B0
13C0:  MOVLW  05
13C2:  ADDWF  x8E,W
13C4:  MOVWF  01
13C6:  MOVLW  00
13C8:  ADDWFC x8F,W
13CA:  MOVWF  03
13CC:  MOVF   03,W
13CE:  SUBWF  xB1,W
13D0:  BNC   141E
13D2:  BNZ   13DA
13D4:  MOVF   xB0,W
13D6:  SUBWF  01,W
13D8:  BC    141E
....................             move_act(current_act_position[nActuator]-target_act_position,4500,move_act_time_out,0,nActuator); 
13DA:  BCF    FD8.0
13DC:  RLCF   xAF,W
13DE:  CLRF   03
13E0:  ADDLW  86
13E2:  MOVWF  FE9
13E4:  MOVLW  00
13E6:  ADDWFC 03,W
13E8:  MOVWF  FEA
13EA:  MOVFF  FEC,B1
13EE:  MOVF   FED,F
13F0:  MOVFF  FEF,B0
13F4:  MOVF   x8E,W
13F6:  SUBWF  xB0,F
13F8:  MOVF   x8F,W
13FA:  SUBWFB xB1,F
13FC:  MOVFF  B1,B3
1400:  MOVFF  B0,B2
1404:  MOVLW  11
1406:  MOVWF  xB5
1408:  MOVLW  94
140A:  MOVWF  xB4
140C:  MOVFF  7D,B7
1410:  MOVFF  7C,B6
1414:  CLRF   xB8
1416:  MOVFF  AF,B9
141A:  RCALL  0FAC
....................     else if((current_act_position[nActuator]+5) < target_act_position)// move west 
141C:  BRA    1534
141E:  BCF    FD8.0
1420:  RLCF   xAF,W
1422:  CLRF   03
1424:  ADDLW  86
1426:  MOVWF  FE9
1428:  MOVLW  00
142A:  ADDWFC 03,W
142C:  MOVWF  FEA
142E:  MOVFF  FEC,B1
1432:  MOVF   FED,F
1434:  MOVFF  FEF,B0
1438:  MOVLW  05
143A:  ADDWF  xB0,F
143C:  MOVLW  00
143E:  ADDWFC xB1,F
1440:  MOVF   xB1,W
1442:  SUBWF  x8F,W
1444:  BNC   1492
1446:  BNZ   144E
1448:  MOVF   x8E,W
144A:  SUBWF  xB0,W
144C:  BC    1492
....................             move_act(target_act_position-current_act_position[nActuator],4500,move_act_time_out,1,nActuator); 
144E:  BCF    FD8.0
1450:  RLCF   xAF,W
1452:  CLRF   03
1454:  ADDLW  86
1456:  MOVWF  FE9
1458:  MOVLW  00
145A:  ADDWFC 03,W
145C:  MOVWF  FEA
145E:  MOVFF  FEC,03
1462:  MOVF   FED,F
1464:  MOVF   FEF,W
1466:  SUBWF  x8E,W
1468:  MOVWF  xB0
146A:  MOVF   03,W
146C:  SUBWFB x8F,W
146E:  MOVWF  xB1
1470:  MOVWF  xB3
1472:  MOVFF  B0,B2
1476:  MOVLW  11
1478:  MOVWF  xB5
147A:  MOVLW  94
147C:  MOVWF  xB4
147E:  MOVFF  7D,B7
1482:  MOVFF  7C,B6
1486:  MOVLW  01
1488:  MOVWF  xB8
148A:  MOVFF  AF,B9
148E:  RCALL  0FAC
....................     else if (target_act_position == 0x00)  // move east all the way 
1490:  BRA    1534
1492:  MOVF   x8E,F
1494:  BNZ   14D6
1496:  MOVF   x8F,F
1498:  BNZ   14D6
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,0,nActuator); 
149A:  BCF    FD8.0
149C:  RLCF   xAF,W
149E:  CLRF   03
14A0:  ADDLW  90
14A2:  MOVWF  FE9
14A4:  MOVLW  00
14A6:  ADDWFC 03,W
14A8:  MOVWF  FEA
14AA:  MOVFF  FEC,B1
14AE:  MOVF   FED,F
14B0:  MOVFF  FEF,B0
14B4:  MOVFF  B1,B3
14B8:  MOVFF  B0,B2
14BC:  MOVLW  11
14BE:  MOVWF  xB5
14C0:  MOVLW  94
14C2:  MOVWF  xB4
14C4:  MOVFF  7D,B7
14C8:  MOVFF  7C,B6
14CC:  CLRF   xB8
14CE:  MOVFF  AF,B9
14D2:  RCALL  0FAC
....................     else if (target_act_position == act_full_stroke_tick[nActuator]) // move west all the way 
14D4:  BRA    1534
14D6:  BCF    FD8.0
14D8:  RLCF   xAF,W
14DA:  CLRF   03
14DC:  ADDLW  90
14DE:  MOVWF  FE9
14E0:  MOVLW  00
14E2:  ADDWFC 03,W
14E4:  MOVWF  FEA
14E6:  MOVFF  FEC,03
14EA:  MOVF   FED,F
14EC:  MOVF   FEF,W
14EE:  SUBWF  x8E,W
14F0:  BNZ   1534
14F2:  MOVF   03,W
14F4:  SUBWF  x8F,W
14F6:  BNZ   1534
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,1,nActuator); 
14F8:  BCF    FD8.0
14FA:  RLCF   xAF,W
14FC:  CLRF   03
14FE:  ADDLW  90
1500:  MOVWF  FE9
1502:  MOVLW  00
1504:  ADDWFC 03,W
1506:  MOVWF  FEA
1508:  MOVFF  FEC,B1
150C:  MOVF   FED,F
150E:  MOVFF  FEF,B0
1512:  MOVFF  B1,B3
1516:  MOVFF  B0,B2
151A:  MOVLW  11
151C:  MOVWF  xB5
151E:  MOVLW  94
1520:  MOVWF  xB4
1522:  MOVFF  7D,B7
1526:  MOVFF  7C,B6
152A:  MOVLW  01
152C:  MOVWF  xB8
152E:  MOVFF  AF,B9
1532:  RCALL  0FAC
.................... } 
1534:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... void read_device_id() { 
....................    int16 temp_mem; 
....................    int8 i; 
....................    temp_mem= &dev_id; 
*
090A:  CLRF   xB0
090C:  MOVLW  34
090E:  MOVWF  xAF
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom(0xf00050+i),1); 
0910:  CLRF   xB1
0912:  MOVF   xB1,W
0914:  SUBLW  01
0916:  BNC   096E
0918:  MOVF   xB1,W
091A:  ADDWF  xAF,W
091C:  MOVWF  xB2
091E:  MOVLW  00
0920:  ADDWFC xB0,W
0922:  MOVWF  xB3
0924:  MOVLW  50
0926:  ADDWF  xB1,W
0928:  MOVWF  xB4
092A:  CLRF   xB5
092C:  BTFSC  FD8.0
092E:  INCF   xB5,F
0930:  MOVLW  F0
0932:  MOVWF  xB6
0934:  BTFSC  FD8.0
0936:  INCF   xB6,F
0938:  CLRF   xB7
093A:  BTFSC  FD8.0
093C:  INCF   xB7,F
093E:  MOVFF  FF2,B8
0942:  BCF    FF2.7
0944:  MOVFF  B4,FA9
0948:  BCF    FA6.6
094A:  BCF    FA6.7
094C:  BSF    FA6.0
094E:  MOVF   FA8,W
0950:  BTFSC  xB8.7
0952:  BSF    FF2.7
0954:  MOVWF  xB4
0956:  MOVFF  B3,FEA
095A:  MOVFF  B2,FE9
095E:  MOVFF  B4,B9
0962:  CLRF   xBB
0964:  MOVLW  01
0966:  MOVWF  xBA
0968:  RCALL  0660
096A:  INCF   xB1,F
096C:  BRA    0912
.................... } 
096E:  RETLW  00
....................  
.................... void write_device_id() { 
.................... 	int8 i; 
.................... 	for (i=0;i<2;i++) write_eeprom(0xf00050+i,dev_id>>(i*8)); 
*
1A0A:  CLRF   xAF
1A0C:  MOVF   xAF,W
1A0E:  SUBLW  01
1A10:  BNC   1A7A
1A12:  MOVLW  50
1A14:  ADDWF  xAF,W
1A16:  MOVWF  xB0
1A18:  CLRF   xB1
1A1A:  BTFSC  FD8.0
1A1C:  INCF   xB1,F
1A1E:  MOVLW  F0
1A20:  MOVWF  xB2
1A22:  BTFSC  FD8.0
1A24:  INCF   xB2,F
1A26:  CLRF   xB3
1A28:  BTFSC  FD8.0
1A2A:  INCF   xB3,F
1A2C:  MOVF   xAF,W
1A2E:  MULLW  08
1A30:  MOVFF  FF3,00
1A34:  MOVFF  35,B5
1A38:  MOVFF  34,B4
1A3C:  MOVF   00,F
1A3E:  BZ    1A4A
1A40:  BCF    FD8.0
1A42:  RRCF   xB5,F
1A44:  RRCF   xB4,F
1A46:  DECFSZ 00,F
1A48:  BRA    1A40
1A4A:  MOVFF  B0,FA9
1A4E:  MOVFF  B4,FA8
1A52:  BCF    FA6.6
1A54:  BCF    FA6.7
1A56:  BSF    FA6.2
1A58:  MOVFF  FF2,00
1A5C:  BCF    FF2.7
1A5E:  MOVLB  F
1A60:  MOVLW  55
1A62:  MOVWF  FA7
1A64:  MOVLW  AA
1A66:  MOVWF  FA7
1A68:  BSF    FA6.1
1A6A:  BTFSC  FA6.1
1A6C:  BRA    1A6A
1A6E:  BCF    FA6.2
1A70:  MOVF   00,W
1A72:  IORWF  FF2,F
1A74:  MOVLB  0
1A76:  INCF   xAF,F
1A78:  BRA    1A0C
.................... } 
1A7A:  GOTO   215C (RETURN)
....................  
.................... void read_eeprom_data() 
.................... { 
....................    int8 i,j; 
....................    int16 temp_mem;    
....................  
....................    temp_mem= &timer_sec; 
*
067A:  CLRF   xAE
067C:  MOVLW  22
067E:  MOVWF  xAD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
0680:  CLRF   xAB
0682:  MOVF   xAB,W
0684:  SUBLW  03
0686:  BNC   06CA
0688:  MOVF   xAB,W
068A:  ADDWF  xAD,W
068C:  MOVWF  xAF
068E:  MOVLW  00
0690:  ADDWFC xAE,W
0692:  MOVWF  xB0
0694:  MOVLW  20
0696:  ADDWF  xAB,W
0698:  MOVWF  xB1
069A:  MOVFF  FF2,B2
069E:  BCF    FF2.7
06A0:  MOVFF  B1,FA9
06A4:  BCF    FA6.6
06A6:  BCF    FA6.7
06A8:  BSF    FA6.0
06AA:  MOVF   FA8,W
06AC:  BTFSC  xB2.7
06AE:  BSF    FF2.7
06B0:  MOVWF  xB1
06B2:  MOVFF  B0,FEA
06B6:  MOVFF  AF,FE9
06BA:  MOVFF  B1,B9
06BE:  CLRF   xBB
06C0:  MOVLW  01
06C2:  MOVWF  xBA
06C4:  RCALL  0660
06C6:  INCF   xAB,F
06C8:  BRA    0682
....................  
....................    temp_mem= &nDay; 
06CA:  CLRF   xAE
06CC:  MOVLW  2E
06CE:  MOVWF  xAD
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i+4),1); 
06D0:  CLRF   xAB
06D2:  MOVF   xAB,W
06D4:  SUBLW  03
06D6:  BNC   071C
06D8:  MOVF   xAB,W
06DA:  ADDWF  xAD,W
06DC:  MOVWF  xAF
06DE:  MOVLW  00
06E0:  ADDWFC xAE,W
06E2:  MOVWF  xB0
06E4:  MOVLW  20
06E6:  ADDWF  xAB,W
06E8:  ADDLW  04
06EA:  MOVWF  xB1
06EC:  MOVFF  FF2,B2
06F0:  BCF    FF2.7
06F2:  MOVFF  B1,FA9
06F6:  BCF    FA6.6
06F8:  BCF    FA6.7
06FA:  BSF    FA6.0
06FC:  MOVF   FA8,W
06FE:  BTFSC  xB2.7
0700:  BSF    FF2.7
0702:  MOVWF  xB1
0704:  MOVFF  B0,FEA
0708:  MOVFF  AF,FE9
070C:  MOVFF  B1,B9
0710:  CLRF   xBB
0712:  MOVLW  01
0714:  MOVWF  xBA
0716:  RCALL  0660
0718:  INCF   xAB,F
071A:  BRA    06D2
....................  
....................  
....................    temp_mem= &startup_counter; 
071C:  CLRF   xAE
071E:  MOVLW  32
0720:  MOVWF  xAD
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
0722:  CLRF   xAB
0724:  MOVF   xAB,W
0726:  SUBLW  01
0728:  BNC   076C
072A:  MOVF   xAB,W
072C:  ADDWF  xAD,W
072E:  MOVWF  xAF
0730:  MOVLW  00
0732:  ADDWFC xAE,W
0734:  MOVWF  xB0
0736:  MOVLW  30
0738:  ADDWF  xAB,W
073A:  MOVWF  xB1
073C:  MOVFF  FF2,B2
0740:  BCF    FF2.7
0742:  MOVFF  B1,FA9
0746:  BCF    FA6.6
0748:  BCF    FA6.7
074A:  BSF    FA6.0
074C:  MOVF   FA8,W
074E:  BTFSC  xB2.7
0750:  BSF    FF2.7
0752:  MOVWF  xB1
0754:  MOVFF  B0,FEA
0758:  MOVFF  AF,FE9
075C:  MOVFF  B1,B9
0760:  CLRF   xBB
0762:  MOVLW  01
0764:  MOVWF  xBA
0766:  RCALL  0660
0768:  INCF   xAB,F
076A:  BRA    0724
....................  
....................    for (j=0;j<4;j++) { 
076C:  CLRF   xAC
076E:  MOVF   xAC,W
0770:  SUBLW  03
0772:  BTFSS  FD8.0
0774:  BRA    0906
....................    		temp_mem= &act_full_stroke_tick[j]; 
0776:  BCF    FD8.0
0778:  RLCF   xAC,W
077A:  CLRF   03
077C:  ADDLW  90
077E:  MOVWF  01
0780:  MOVLW  00
0782:  ADDWFC 03,F
0784:  MOVFF  01,AD
0788:  MOVFF  03,AE
.................... 	   	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i+j*2),1); 
078C:  CLRF   xAB
078E:  MOVF   xAB,W
0790:  SUBLW  01
0792:  BNC   07D8
0794:  MOVF   xAB,W
0796:  ADDWF  xAD,W
0798:  MOVWF  xAF
079A:  MOVLW  00
079C:  ADDWFC xAE,W
079E:  MOVWF  xB0
07A0:  BCF    FD8.0
07A2:  RLCF   xAC,W
07A4:  ADDWF  xAB,W
07A6:  MOVWF  xB1
07A8:  MOVFF  FF2,B2
07AC:  BCF    FF2.7
07AE:  MOVFF  B1,FA9
07B2:  BCF    FA6.6
07B4:  BCF    FA6.7
07B6:  BSF    FA6.0
07B8:  MOVF   FA8,W
07BA:  BTFSC  xB2.7
07BC:  BSF    FF2.7
07BE:  MOVWF  xB1
07C0:  MOVFF  B0,FEA
07C4:  MOVFF  AF,FE9
07C8:  MOVFF  B1,B9
07CC:  CLRF   xBB
07CE:  MOVLW  01
07D0:  MOVWF  xBA
07D2:  RCALL  0660
07D4:  INCF   xAB,F
07D6:  BRA    078E
....................    		if (act_full_stroke_tick[j] > MAX_FULL_STROKE) act_full_stroke_tick[j] = MAX_FULL_STROKE; 
07D8:  BCF    FD8.0
07DA:  RLCF   xAC,W
07DC:  CLRF   03
07DE:  ADDLW  90
07E0:  MOVWF  FE9
07E2:  MOVLW  00
07E4:  ADDWFC 03,W
07E6:  MOVWF  FEA
07E8:  MOVFF  FEC,B0
07EC:  MOVF   FED,F
07EE:  MOVFF  FEF,AF
07F2:  MOVF   xB0,W
07F4:  SUBLW  06
07F6:  BC    081C
07F8:  XORLW  FF
07FA:  BNZ   0802
07FC:  MOVF   xAF,W
07FE:  SUBLW  D0
0800:  BC    081C
0802:  BCF    FD8.0
0804:  RLCF   xAC,W
0806:  CLRF   03
0808:  ADDLW  90
080A:  MOVWF  FE9
080C:  MOVLW  00
080E:  ADDWFC 03,W
0810:  MOVWF  FEA
0812:  MOVLW  07
0814:  MOVWF  FEC
0816:  MOVF   FED,F
0818:  MOVLW  D0
081A:  MOVWF  FEF
....................    		temp_mem= &current_act_position[j]; 
081C:  BCF    FD8.0
081E:  RLCF   xAC,W
0820:  CLRF   03
0822:  ADDLW  86
0824:  MOVWF  01
0826:  MOVLW  00
0828:  ADDWFC 03,F
082A:  MOVFF  01,AD
082E:  MOVFF  03,AE
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2),1); 
0832:  CLRF   xAB
0834:  MOVF   xAB,W
0836:  SUBLW  01
0838:  BNC   0882
083A:  MOVF   xAB,W
083C:  ADDWF  xAD,W
083E:  MOVWF  xAF
0840:  MOVLW  00
0842:  ADDWFC xAE,W
0844:  MOVWF  xB0
0846:  MOVLW  10
0848:  ADDWF  xAB,W
084A:  MOVWF  xB1
084C:  BCF    FD8.0
084E:  RLCF   xAC,W
0850:  ADDWF  xB1,F
0852:  MOVFF  FF2,B2
0856:  BCF    FF2.7
0858:  MOVFF  B1,FA9
085C:  BCF    FA6.6
085E:  BCF    FA6.7
0860:  BSF    FA6.0
0862:  MOVF   FA8,W
0864:  BTFSC  xB2.7
0866:  BSF    FF2.7
0868:  MOVWF  xB1
086A:  MOVFF  B0,FEA
086E:  MOVFF  AF,FE9
0872:  MOVFF  B1,B9
0876:  CLRF   xBB
0878:  MOVLW  01
087A:  MOVWF  xBA
087C:  RCALL  0660
087E:  INCF   xAB,F
0880:  BRA    0834
....................    		if (current_act_position[j] > act_full_stroke_tick[j]) current_act_position[j] = act_full_stroke_tick[j]; 
0882:  BCF    FD8.0
0884:  RLCF   xAC,W
0886:  CLRF   03
0888:  ADDLW  86
088A:  MOVWF  FE9
088C:  MOVLW  00
088E:  ADDWFC 03,W
0890:  MOVWF  FEA
0892:  MOVFF  FEC,B0
0896:  MOVF   FED,F
0898:  MOVFF  FEF,AF
089C:  BCF    FD8.0
089E:  RLCF   xAC,W
08A0:  CLRF   03
08A2:  ADDLW  90
08A4:  MOVWF  FE9
08A6:  MOVLW  00
08A8:  ADDWFC 03,W
08AA:  MOVWF  FEA
08AC:  MOVFF  FEC,03
08B0:  MOVF   FED,F
08B2:  MOVFF  FEF,01
08B6:  MOVF   03,W
08B8:  SUBWF  xB0,W
08BA:  BNC   0902
08BC:  BNZ   08C4
08BE:  MOVF   xAF,W
08C0:  SUBWF  01,W
08C2:  BC    0902
08C4:  BCF    FD8.0
08C6:  RLCF   xAC,W
08C8:  CLRF   03
08CA:  ADDLW  86
08CC:  MOVWF  01
08CE:  MOVLW  00
08D0:  ADDWFC 03,F
08D2:  MOVFF  03,B0
08D6:  BCF    FD8.0
08D8:  RLCF   xAC,W
08DA:  CLRF   03
08DC:  ADDLW  90
08DE:  MOVWF  FE9
08E0:  MOVLW  00
08E2:  ADDWFC 03,W
08E4:  MOVWF  FEA
08E6:  MOVFF  FEC,03
08EA:  MOVF   FED,F
08EC:  MOVFF  FEF,B1
08F0:  MOVFF  B0,FEA
08F4:  MOVFF  01,FE9
08F8:  MOVFF  03,FEC
08FC:  MOVF   FED,F
08FE:  MOVFF  B1,FEF
....................    } 
0902:  INCF   xAC,F
0904:  BRA    076E
....................  
....................  
.................... } 
0906:  GOTO   2734 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i,j; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
0970:  CLRF   xB0
0972:  MOVF   xB0,W
0974:  SUBLW  03
0976:  BNC   09D8
0978:  MOVLW  20
097A:  ADDWF  xB0,W
097C:  MOVWF  xB2
097E:  MOVF   xB0,W
0980:  MULLW  08
0982:  MOVFF  FF3,B3
0986:  MOVFF  25,B7
098A:  MOVFF  24,B6
098E:  MOVFF  23,B5
0992:  MOVFF  22,B4
0996:  MOVF   xB3,F
0998:  BZ    09A8
099A:  BCF    FD8.0
099C:  RRCF   xB7,F
099E:  RRCF   xB6,F
09A0:  RRCF   xB5,F
09A2:  RRCF   xB4,F
09A4:  DECFSZ xB3,F
09A6:  BRA    099A
09A8:  MOVFF  B2,FA9
09AC:  MOVFF  B4,FA8
09B0:  BCF    FA6.6
09B2:  BCF    FA6.7
09B4:  BSF    FA6.2
09B6:  MOVFF  FF2,00
09BA:  BCF    FF2.7
09BC:  MOVLB  F
09BE:  MOVLW  55
09C0:  MOVWF  FA7
09C2:  MOVLW  AA
09C4:  MOVWF  FA7
09C6:  BSF    FA6.1
09C8:  BTFSC  FA6.1
09CA:  BRA    09C8
09CC:  BCF    FA6.2
09CE:  MOVF   00,W
09D0:  IORWF  FF2,F
09D2:  MOVLB  0
09D4:  INCF   xB0,F
09D6:  BRA    0972
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i+4,nDay>>(i*8)); 
09D8:  CLRF   xB0
09DA:  MOVF   xB0,W
09DC:  SUBLW  03
09DE:  BNC   0A42
09E0:  MOVLW  20
09E2:  ADDWF  xB0,W
09E4:  ADDLW  04
09E6:  MOVWF  xB2
09E8:  MOVF   xB0,W
09EA:  MULLW  08
09EC:  MOVFF  FF3,B3
09F0:  MOVFF  31,B7
09F4:  MOVFF  30,B6
09F8:  MOVFF  2F,B5
09FC:  MOVFF  2E,B4
0A00:  MOVF   xB3,F
0A02:  BZ    0A12
0A04:  BCF    FD8.0
0A06:  RRCF   xB7,F
0A08:  RRCF   xB6,F
0A0A:  RRCF   xB5,F
0A0C:  RRCF   xB4,F
0A0E:  DECFSZ xB3,F
0A10:  BRA    0A04
0A12:  MOVFF  B2,FA9
0A16:  MOVFF  B4,FA8
0A1A:  BCF    FA6.6
0A1C:  BCF    FA6.7
0A1E:  BSF    FA6.2
0A20:  MOVFF  FF2,00
0A24:  BCF    FF2.7
0A26:  MOVLB  F
0A28:  MOVLW  55
0A2A:  MOVWF  FA7
0A2C:  MOVLW  AA
0A2E:  MOVWF  FA7
0A30:  BSF    FA6.1
0A32:  BTFSC  FA6.1
0A34:  BRA    0A32
0A36:  BCF    FA6.2
0A38:  MOVF   00,W
0A3A:  IORWF  FF2,F
0A3C:  MOVLB  0
0A3E:  INCF   xB0,F
0A40:  BRA    09DA
....................  
....................    for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2,current_act_position[j]>>(i*8)); 
0A42:  CLRF   xB1
0A44:  MOVF   xB1,W
0A46:  SUBLW  03
0A48:  BNC   0AC2
0A4A:  CLRF   xB0
0A4C:  MOVF   xB0,W
0A4E:  SUBLW  01
0A50:  BNC   0ABE
0A52:  MOVLW  10
0A54:  ADDWF  xB0,W
0A56:  MOVWF  xB2
0A58:  BCF    FD8.0
0A5A:  RLCF   xB1,W
0A5C:  ADDWF  xB2,F
0A5E:  BCF    FD8.0
0A60:  RLCF   xB1,W
0A62:  CLRF   03
0A64:  ADDLW  86
0A66:  MOVWF  FE9
0A68:  MOVLW  00
0A6A:  ADDWFC 03,W
0A6C:  MOVWF  FEA
0A6E:  MOVFF  FEC,B4
0A72:  MOVF   FED,F
0A74:  MOVFF  FEF,B3
0A78:  MOVF   xB0,W
0A7A:  MULLW  08
0A7C:  MOVFF  FF3,00
0A80:  MOVF   00,F
0A82:  BZ    0A8E
0A84:  BCF    FD8.0
0A86:  RRCF   xB4,F
0A88:  RRCF   xB3,F
0A8A:  DECFSZ 00,F
0A8C:  BRA    0A84
0A8E:  MOVFF  B2,FA9
0A92:  MOVFF  B3,FA8
0A96:  BCF    FA6.6
0A98:  BCF    FA6.7
0A9A:  BSF    FA6.2
0A9C:  MOVFF  FF2,00
0AA0:  BCF    FF2.7
0AA2:  MOVLB  F
0AA4:  MOVLW  55
0AA6:  MOVWF  FA7
0AA8:  MOVLW  AA
0AAA:  MOVWF  FA7
0AAC:  BSF    FA6.1
0AAE:  BTFSC  FA6.1
0AB0:  BRA    0AAE
0AB2:  BCF    FA6.2
0AB4:  MOVF   00,W
0AB6:  IORWF  FF2,F
0AB8:  MOVLB  0
0ABA:  INCF   xB0,F
0ABC:  BRA    0A4C
0ABE:  INCF   xB1,F
0AC0:  BRA    0A44
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
0AC2:  CLRF   xB0
0AC4:  MOVF   xB0,W
0AC6:  SUBLW  01
0AC8:  BNC   0B1E
0ACA:  MOVLW  30
0ACC:  ADDWF  xB0,W
0ACE:  MOVWF  xB2
0AD0:  MOVF   xB0,W
0AD2:  MULLW  08
0AD4:  MOVFF  FF3,00
0AD8:  MOVFF  33,B4
0ADC:  MOVFF  32,B3
0AE0:  MOVF   00,F
0AE2:  BZ    0AEE
0AE4:  BCF    FD8.0
0AE6:  RRCF   xB4,F
0AE8:  RRCF   xB3,F
0AEA:  DECFSZ 00,F
0AEC:  BRA    0AE4
0AEE:  MOVFF  B2,FA9
0AF2:  MOVFF  B3,FA8
0AF6:  BCF    FA6.6
0AF8:  BCF    FA6.7
0AFA:  BSF    FA6.2
0AFC:  MOVFF  FF2,00
0B00:  BCF    FF2.7
0B02:  MOVLB  F
0B04:  MOVLW  55
0B06:  MOVWF  FA7
0B08:  MOVLW  AA
0B0A:  MOVWF  FA7
0B0C:  BSF    FA6.1
0B0E:  BTFSC  FA6.1
0B10:  BRA    0B0E
0B12:  BCF    FA6.2
0B14:  MOVF   00,W
0B16:  IORWF  FF2,F
0B18:  MOVLB  0
0B1A:  INCF   xB0,F
0B1C:  BRA    0AC4
....................    if (write_cal ==1) 
0B1E:  DECFSZ xAF,W
0B20:  BRA    0B9E
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i+j*2,act_full_stroke_tick[j]>>(i*8)); 
0B22:  CLRF   xB1
0B24:  MOVF   xB1,W
0B26:  SUBLW  03
0B28:  BNC   0B9E
0B2A:  CLRF   xB0
0B2C:  MOVF   xB0,W
0B2E:  SUBLW  01
0B30:  BNC   0B9A
0B32:  BCF    FD8.0
0B34:  RLCF   xB1,W
0B36:  ADDWF  xB0,W
0B38:  MOVWF  xB2
0B3A:  BCF    FD8.0
0B3C:  RLCF   xB1,W
0B3E:  CLRF   03
0B40:  ADDLW  90
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,B4
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,B3
0B54:  MOVF   xB0,W
0B56:  MULLW  08
0B58:  MOVFF  FF3,00
0B5C:  MOVF   00,F
0B5E:  BZ    0B6A
0B60:  BCF    FD8.0
0B62:  RRCF   xB4,F
0B64:  RRCF   xB3,F
0B66:  DECFSZ 00,F
0B68:  BRA    0B60
0B6A:  MOVFF  B2,FA9
0B6E:  MOVFF  B3,FA8
0B72:  BCF    FA6.6
0B74:  BCF    FA6.7
0B76:  BSF    FA6.2
0B78:  MOVFF  FF2,00
0B7C:  BCF    FF2.7
0B7E:  MOVLB  F
0B80:  MOVLW  55
0B82:  MOVWF  FA7
0B84:  MOVLW  AA
0B86:  MOVWF  FA7
0B88:  BSF    FA6.1
0B8A:  BTFSC  FA6.1
0B8C:  BRA    0B8A
0B8E:  BCF    FA6.2
0B90:  MOVF   00,W
0B92:  IORWF  FF2,F
0B94:  MOVLB  0
0B96:  INCF   xB0,F
0B98:  BRA    0B2C
0B9A:  INCF   xB1,F
0B9C:  BRA    0B24
.................... } 
0B9E:  RETLW  00
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////// 
.................... void button_scan() { 
....................    int8 i; 
....................     flag2.button_pressed=0; 
*
01A0:  BCF    20.1
....................    for(i=0;i<6;i++) { 
01A2:  CLRF   xD2
01A4:  MOVF   xD2,W
01A6:  SUBLW  05
01A8:  BNC   01E0
....................       portd.data_bus=i; 
01AA:  MOVF   xD2,W
01AC:  ANDLW  0F
01AE:  MOVWF  00
01B0:  MOVLW  F0
01B2:  ANDWF  F83,W
01B4:  IORWF  00,W
01B6:  MOVWF  F83
....................       portd.MUX_en =0; 
01B8:  BCF    F83.6
....................       delay_cycles(20); 
01BA:  MOVLW  06
01BC:  MOVWF  00
01BE:  DECFSZ 00,F
01C0:  BRA    01BE
01C2:  NOP   
....................       if (!input(PIN_E0)) { 
01C4:  BSF    F96.0
01C6:  BTFSC  F84.0
01C8:  BRA    01D0
....................          flag2.button_pressed=1; 
01CA:  BSF    20.1
....................          nButton=i; 
01CC:  MOVFF  D2,4B
....................       }  
....................       delay_cycles(20); 
01D0:  MOVLW  06
01D2:  MOVWF  00
01D4:  DECFSZ 00,F
01D6:  BRA    01D4
01D8:  NOP   
....................       portd.MUX_en =1; 
01DA:  BSF    F83.6
....................    } 
01DC:  INCF   xD2,F
01DE:  BRA    01A4
....................    restart_wdt(); 
01E0:  CLRWDT
.................... } 
01E2:  RETLW  00
....................  
....................  
.................... ////////////////////////////////// 
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       //set_timer1(get_timer1()+0x7FB8); 
....................      #asm 
....................       MOVLW 0x00; 
01E4:  MOVLW  00
....................       MOVWF TMR1; 
01E6:  MOVWF  FCE
....................       MOVLW 0x80; 
01E8:  MOVLW  80
....................       MOVWF TMR1H; 
01EA:  MOVWF  FCF
....................      #endasm 
....................       timer_sec+=1;  
01EC:  MOVLW  01
01EE:  ADDWF  22,F
01F0:  MOVLW  00
01F2:  ADDWFC 23,F
01F4:  ADDWFC 24,F
01F6:  ADDWFC 25,F
....................      last_command +=1; 
01F8:  MOVLW  01
01FA:  ADDWF  4C,F
01FC:  MOVLW  00
01FE:  ADDWFC 4D,F
0200:  ADDWFC 4E,F
0202:  ADDWFC 4F,F
....................       if (timer_sec>=86400) { 
0204:  MOVF   25,F
0206:  BNZ   0222
0208:  MOVF   24,W
020A:  SUBLW  00
020C:  BC    0268
020E:  XORLW  FF
0210:  BNZ   0222
0212:  MOVF   23,W
0214:  SUBLW  50
0216:  BC    0268
0218:  XORLW  FF
021A:  BNZ   0222
021C:  MOVF   22,W
021E:  SUBLW  7F
0220:  BC    0268
....................       nDay = (nDay%1461)+1; 
0222:  MOVFF  31,D5
0226:  MOVFF  30,D4
022A:  MOVFF  2F,D3
022E:  MOVFF  2E,D2
0232:  CLRF   xD9
0234:  CLRF   xD8
0236:  MOVLW  05
0238:  MOVWF  xD7
023A:  MOVLW  B5
023C:  MOVWF  xD6
023E:  RCALL  00AA
0240:  MOVFF  FEF,D2
0244:  MOVFF  FEC,D3
0248:  MOVFF  FEC,D4
024C:  MOVFF  FEC,D5
0250:  MOVLW  01
0252:  ADDWF  xD2,W
0254:  MOVWF  2E
0256:  MOVLW  00
0258:  ADDWFC xD3,W
025A:  MOVWF  2F
025C:  MOVLW  00
025E:  ADDWFC xD4,W
0260:  MOVWF  30
0262:  MOVLW  00
0264:  ADDWFC xD5,W
0266:  MOVWF  31
....................      } 
....................      timer_sec = timer_sec % 86400; 
0268:  MOVFF  25,D5
026C:  MOVFF  24,D4
0270:  MOVFF  23,D3
0274:  MOVFF  22,D2
0278:  CLRF   xD9
027A:  MOVLW  01
027C:  MOVWF  xD8
027E:  MOVLW  51
0280:  MOVWF  xD7
0282:  MOVLW  80
0284:  MOVWF  xD6
0286:  RCALL  00AA
0288:  MOVFF  FEF,22
028C:  MOVFF  FEC,23
0290:  MOVFF  FEC,24
0294:  MOVFF  FEC,25
....................      if (last_command > 180)// if no command recv in 3 minutes, reset the RS232 
0298:  MOVF   4F,F
029A:  BNZ   02AA
029C:  MOVF   4E,F
029E:  BNZ   02AA
02A0:  MOVF   4D,F
02A2:  BNZ   02AA
02A4:  MOVF   4C,W
02A6:  SUBLW  B4
02A8:  BC    02B6
....................      {    init_rs232(); 
02AA:  RCALL  0124
....................        last_command =0; 
02AC:  CLRF   4F
02AE:  CLRF   4E
02B0:  CLRF   4D
02B2:  CLRF   4C
....................        cmd_len =0; 
02B4:  CLRF   4A
....................       }    
....................  
....................      if ((read_adc()+read_adc()+read_adc()+read_adc())/4<600) { 
02B6:  BSF    FC2.2
02B8:  BTFSC  FC2.2
02BA:  BRA    02B8
02BC:  MOVFF  FC4,03
02C0:  MOVFF  FC3,D2
02C4:  MOVFF  FC4,D3
02C8:  BSF    FC2.2
02CA:  BTFSC  FC2.2
02CC:  BRA    02CA
02CE:  MOVFF  FC4,03
02D2:  MOVF   FC3,W
02D4:  ADDWF  xD2,F
02D6:  MOVF   FC4,W
02D8:  ADDWFC xD3,F
02DA:  BSF    FC2.2
02DC:  BTFSC  FC2.2
02DE:  BRA    02DC
02E0:  MOVFF  FC4,03
02E4:  MOVF   FC3,W
02E6:  ADDWF  xD2,F
02E8:  MOVF   FC4,W
02EA:  ADDWFC xD3,F
02EC:  BSF    FC2.2
02EE:  BTFSC  FC2.2
02F0:  BRA    02EE
02F2:  MOVFF  FC4,03
02F6:  MOVF   FC3,W
02F8:  ADDWF  xD2,F
02FA:  MOVF   FC4,W
02FC:  ADDWFC xD3,F
02FE:  RRCF   xD3,F
0300:  RRCF   xD2,F
0302:  RRCF   xD3,F
0304:  RRCF   xD2,F
0306:  MOVLW  3F
0308:  ANDWF  xD3,F
030A:  MOVF   xD3,W
030C:  SUBLW  02
030E:  BNC   0336
0310:  BNZ   0318
0312:  MOVF   xD2,W
0314:  SUBLW  57
0316:  BNC   0336
....................        if (flag2.is_moving) flag2.abort_current_activity=1; 
0318:  BTFSC  20.6
031A:  BSF    20.2
....................        flag2.power = 0; 
031C:  BCF    20.5
....................        disable_interrupts(INT_RDA); 
031E:  BCF    F9D.5
....................        led_status =0xFE; 
0320:  MOVLW  FE
0322:  MOVWF  21
....................        display_LED(); 
0324:  RCALL  0144
....................        delay_ms(10); 
0326:  MOVLW  0A
0328:  MOVWF  xD2
032A:  RCALL  0178
....................        led_status =0xFF; 
032C:  MOVLW  FF
032E:  MOVWF  21
....................        display_LED(); 
0330:  RCALL  0144
....................          return; 
0332:  BRA    043A
....................      } else { 
0334:  BRA    0340
....................        if (flag2.power==0) { 
0336:  BTFSC  20.5
0338:  BRA    033E
....................          enable_interrupts(INT_RDA); 
033A:  BSF    F9D.5
....................          init_rs232(); 
033C:  RCALL  0124
....................        } 
....................        flag2.power=1; 
033E:  BSF    20.5
....................      } 
....................  
....................       flag.update_time = true; 
0340:  BSF    1F.1
....................       if (flag2.en_operate == 1) { 
0342:  BTFSS  20.0
0344:  BRA    0432
....................         led_status.power = !led_status.power; // blink power led 
0346:  BTG    21.0
....................       // display morning, noon, evening 
....................        if(timer_sec >64800 || timer_sec <21600) { 
0348:  MOVF   25,F
034A:  BNZ   0376
034C:  MOVF   24,F
034E:  BNZ   0376
0350:  MOVF   23,W
0352:  SUBLW  FC
0354:  BC    0360
0356:  XORLW  FF
0358:  BNZ   0376
035A:  MOVF   22,W
035C:  SUBLW  20
035E:  BNC   0376
0360:  MOVF   25,F
0362:  BNZ   0380
0364:  MOVF   24,F
0366:  BNZ   0380
0368:  MOVF   23,W
036A:  SUBLW  54
036C:  BNC   0380
036E:  BNZ   0376
0370:  MOVF   22,W
0372:  SUBLW  5F
0374:  BNC   0380
....................          led_status.aux=3; 
0376:  MOVLW  F3
0378:  ANDWF  21,W
037A:  IORLW  0C
037C:  MOVWF  21
....................       } else if ( timer_sec < 36000 ) { 
037E:  BRA    03C6
0380:  MOVF   25,F
0382:  BNZ   03A0
0384:  MOVF   24,F
0386:  BNZ   03A0
0388:  MOVF   23,W
038A:  SUBLW  8C
038C:  BNC   03A0
038E:  BNZ   0396
0390:  MOVF   22,W
0392:  SUBLW  9F
0394:  BNC   03A0
....................          led_status.aux=2; 
0396:  MOVLW  F3
0398:  ANDWF  21,W
039A:  IORLW  08
039C:  MOVWF  21
....................       } else if ( timer_sec < 50400) { 
039E:  BRA    03C6
03A0:  MOVF   25,F
03A2:  BNZ   03BE
03A4:  MOVF   24,F
03A6:  BNZ   03BE
03A8:  MOVF   23,W
03AA:  SUBLW  C4
03AC:  BNC   03BE
03AE:  BNZ   03B6
03B0:  MOVF   22,W
03B2:  SUBLW  DF
03B4:  BNC   03BE
....................          led_status.aux=0; 
03B6:  MOVLW  F3
03B8:  ANDWF  21,W
03BA:  MOVWF  21
....................       } else { 
03BC:  BRA    03C6
....................          led_status.aux=1; 
03BE:  MOVLW  F3
03C0:  ANDWF  21,W
03C2:  IORLW  04
03C4:  MOVWF  21
....................       } 
....................  
....................         display_LED(); 
03C6:  RCALL  0144
....................         switch ((unsigned int16) (timer_sec % 450)) { 
03C8:  MOVFF  25,D5
03CC:  MOVFF  24,D4
03D0:  MOVFF  23,D3
03D4:  MOVFF  22,D2
03D8:  CLRF   xD9
03DA:  CLRF   xD8
03DC:  MOVLW  01
03DE:  MOVWF  xD7
03E0:  MOVLW  C2
03E2:  MOVWF  xD6
03E4:  RCALL  00AA
03E6:  MOVFF  FEF,00
03EA:  MOVFF  FEC,01
03EE:  MOVFF  FEC,02
03F2:  MOVFF  FEC,03
03F6:  MOVF   01,W
03F8:  MOVWF  03
03FA:  BNZ   0400
03FC:  MOVF   00,F
03FE:  BZ    0422
0400:  MOVF   03,W
0402:  BNZ   040A
0404:  MOVLW  6E
0406:  SUBWF  00,W
0408:  BZ    0426
040A:  MOVF   03,W
040C:  BNZ   0414
040E:  MOVLW  DC
0410:  SUBWF  00,W
0412:  BZ    042A
0414:  MOVLW  01
0416:  SUBWF  03,W
0418:  BNZ   0420
041A:  MOVLW  4A
041C:  SUBWF  00,W
041E:  BZ    042E
0420:  BRA    0432
....................          case 0: {   bit_set(actuator_move_mask,0); break;} 
0422:  BSF    xA4.0
0424:  BRA    0432
....................          case 110: {   bit_set(actuator_move_mask,1); break;} 
0426:  BSF    xA4.1
0428:  BRA    0432
....................          case 220: {   bit_set(actuator_move_mask,2); break;} 
042A:  BSF    xA4.2
042C:  BRA    0432
....................          case 330: {   bit_set(actuator_move_mask,3); break;} 
042E:  BSF    xA4.3
0430:  BRA    0432
....................         } 
....................      } 
....................      button_scan(); 
0432:  RCALL  01A0
....................      if (nButton == 0) flag2.abort_current_activity=1; 
0434:  MOVF   4B,F
0436:  BTFSC  FD8.2
0438:  BSF    20.2
....................  
.................... } 
....................  
043A:  BCF    F9E.0
043C:  GOTO   0064
.................... void init_spi() { 
....................    setup_spi(spi_master |spi_h_to_l | spi_clk_div_16 ); 
*
0596:  BCF    FC6.5
0598:  BCF    F94.5
059A:  BSF    F94.4
059C:  BCF    F94.3
059E:  MOVLW  31
05A0:  MOVWF  FC6
05A2:  MOVLW  40
05A4:  MOVWF  FC7
....................     SSPSTAT = 0xC0; 
05A6:  MOVLW  C0
05A8:  MOVWF  FC7
.................... } 
05AA:  GOTO   2620 (RETURN)
....................  
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................    int8 i; 
....................    int8 checksum =0x00; 
*
04DC:  CLRF   xD4
....................    int16 msg_addr; 
....................  
....................    c=getc(); 
04DE:  BTFSS  F9E.5
04E0:  BRA    04DE
04E2:  MOVFF  FAE,D2
....................    switch (c) {    
04E6:  MOVF   xD2,W
04E8:  XORLW  A8
04EA:  BZ    04F2
04EC:  XORLW  01
04EE:  BZ    0562
04F0:  BRA    0568
....................     case(0xA8):{ if(cmd_len>=4) { 
04F2:  MOVF   4A,W
04F4:  SUBLW  03
04F6:  BC    055E
....................                   for(i=0;i<cmd_len;i++) 
04F8:  CLRF   xD3
04FA:  MOVF   4A,W
04FC:  SUBWF  xD3,W
04FE:  BC    0516
....................                   { 
....................                   checksum ^= cmd_msg[i]; 
0500:  CLRF   03
0502:  MOVF   xD3,W
0504:  ADDLW  36
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVF   FEF,W
0510:  XORWF  xD4,F
....................                   } 
0512:  INCF   xD3,F
0514:  BRA    04FA
....................                if (checksum != 0x00) {cmd_len=0; return;} 
0516:  MOVF   xD4,F
0518:  BZ    051E
051A:  CLRF   4A
051C:  BRA    0590
....................                msg_addr = make16(cmd_msg[0],cmd_msg[1]); // address 
051E:  MOVFF  36,D6
0522:  MOVFF  37,D5
....................                if (msg_addr != 0xFFFE && msg_addr != dev_id) {cmd_len=0; return;} // address not correct, just ignore this command 
0526:  MOVF   xD5,W
0528:  SUBLW  FE
052A:  BNZ   0532
052C:  INCFSZ xD6,W
052E:  BRA    0532
0530:  BRA    0542
0532:  MOVF   34,W
0534:  SUBWF  xD5,W
0536:  BNZ   053E
0538:  MOVF   35,W
053A:  SUBWF  xD6,W
053C:  BZ    0542
053E:  CLRF   4A
0540:  BRA    0590
....................                command_byte = cmd_msg[2]; 
0542:  MOVFF  38,51
....................                aux_command = make16(cmd_msg[3],cmd_msg[4]); 
0546:  MOVFF  39,53
054A:  MOVFF  3A,52
....................                if (flag2.is_moving) send_data(7,0); // send BUSY 
054E:  BTFSS  20.6
0550:  BRA    055C
0552:  MOVLW  07
0554:  MOVWF  xD7
0556:  CLRF   xD8
0558:  RCALL  046A
....................                else flag.cmd_posted=true; 
055A:  BRA    055E
055C:  BSF    1F.3
....................                  
....................              }        
....................                 cmd_len =0; 
055E:  CLRF   4A
....................              break;} 
0560:  BRA    0590
....................     case(0xA9): {de_stuffing_mask = 0x20; break;} 
0562:  MOVLW  20
0564:  MOVWF  50
0566:  BRA    0590
....................      default:     {if(cmd_len<=MAX_CMD_LEN) { 
0568:  MOVF   4A,W
056A:  SUBLW  12
056C:  BNC   058C
....................                cmd_msg[cmd_len++]=c|de_stuffing_mask; 
056E:  MOVF   4A,W
0570:  INCF   4A,F
0572:  CLRF   03
0574:  ADDLW  36
0576:  MOVWF  FE9
0578:  MOVLW  00
057A:  ADDWFC 03,W
057C:  MOVWF  FEA
057E:  MOVF   xD2,W
0580:  IORWF  50,W
0582:  MOVWF  FEF
....................                last_command =0;  
0584:  CLRF   4F
0586:  CLRF   4E
0588:  CLRF   4D
058A:  CLRF   4C
....................             } 
....................             de_stuffing_mask = 0x00; 
058C:  CLRF   50
....................             break; } 
058E:  BRA    0590
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
0590:  BCF    F9E.5
0592:  GOTO   0064
.................... void process_cmd_msg() { 
....................    int8 i,j; 
....................     int16 temp_mem; 
....................     flag.cmd_posted =false; 
*
1A9E:  BCF    1F.3
....................     last_command =0;     
1AA0:  CLRF   4F
1AA2:  CLRF   4E
1AA4:  CLRF   4D
1AA6:  CLRF   4C
....................     switch(command_byte) { 
1AA8:  MOVF   51,W
1AAA:  XORLW  80
1AAC:  BZ    1B30
1AAE:  XORLW  02
1AB0:  BZ    1B4A
1AB2:  XORLW  01
1AB4:  BZ    1B78
1AB6:  XORLW  07
1AB8:  BTFSC  FD8.2
1ABA:  BRA    1BA6
1ABC:  XORLW  01
1ABE:  BTFSC  FD8.2
1AC0:  BRA    1BB8
1AC2:  XORLW  0B
1AC4:  BTFSC  FD8.2
1AC6:  BRA    1BE2
1AC8:  XORLW  01
1ACA:  BTFSC  FD8.2
1ACC:  BRA    1BFE
1ACE:  XORLW  BF
1AD0:  BTFSC  FD8.2
1AD2:  BRA    1C4C
1AD4:  XORLW  01
1AD6:  BTFSC  FD8.2
1AD8:  BRA    1C6E
1ADA:  XORLW  03
1ADC:  BTFSC  FD8.2
1ADE:  BRA    1C90
1AE0:  XORLW  12
1AE2:  BTFSC  FD8.2
1AE4:  BRA    1CD0
1AE6:  XORLW  01
1AE8:  BTFSC  FD8.2
1AEA:  BRA    1D4A
1AEC:  XORLW  03
1AEE:  BTFSC  FD8.2
1AF0:  BRA    1DC2
1AF2:  XORLW  01
1AF4:  BTFSC  FD8.2
1AF6:  BRA    1EE4
1AF8:  XORLW  07
1AFA:  BTFSC  FD8.2
1AFC:  BRA    1F9C
1AFE:  XORLW  01
1B00:  BTFSC  FD8.2
1B02:  BRA    202E
1B04:  XORLW  03
1B06:  BTFSC  FD8.2
1B08:  BRA    209C
1B0A:  XORLW  36
1B0C:  BTFSC  FD8.2
1B0E:  BRA    20CE
1B10:  XORLW  01
1B12:  BTFSC  FD8.2
1B14:  BRA    2118
1B16:  XORLW  03
1B18:  BTFSC  FD8.2
1B1A:  BRA    2152
1B1C:  XORLW  01
1B1E:  BTFSC  FD8.2
1B20:  BRA    2172
1B22:  XORLW  12
1B24:  BTFSC  FD8.2
1B26:  BRA    21A8
1B28:  XORLW  03
1B2A:  BTFSC  FD8.2
1B2C:  BRA    21FE
1B2E:  BRA    2256
.................... // level 8 is for flash related 
....................       // 0x80 = block erase 
....................       case 0x80: { flash_block_erase();  send_data(0,0); break; } 
1B30:  GOTO   0C9A
1B34:  CLRF   18
1B36:  BTFSC  FF2.7
1B38:  BSF    18.7
1B3A:  BCF    FF2.7
1B3C:  CLRF   xD7
1B3E:  CLRF   xD8
1B40:  CALL   046A
1B44:  BTFSC  18.7
1B46:  BSF    FF2.7
1B48:  BRA    2256
....................       // 0x82  = write buffer 1 to flash page 
....................      case 0x82: { disable_interrupts(GLOBAL); 
1B4A:  BCF    FF2.6
1B4C:  BCF    FF2.7
1B4E:  BTFSC  FF2.7
1B50:  BRA    1B4C
....................                   flash_write_buffer1_to_main_memory(aux_command); 
1B52:  MOVFF  53,B0
1B56:  MOVFF  52,AF
1B5A:  GOTO   0CF0
1B5E:  CLRF   18
1B60:  BTFSC  FF2.7
1B62:  BSF    18.7
1B64:  BCF    FF2.7
....................                send_data(0,0); 
1B66:  CLRF   xD7
1B68:  CLRF   xD8
1B6A:  CALL   046A
1B6E:  BTFSC  18.7
1B70:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL); 
1B72:  MOVLW  C0
1B74:  IORWF  FF2,F
....................                   break;  
1B76:  BRA    2256
....................              } 
....................      // 0x83 = read page to buffer 1 
....................      case 0x83: { 
....................                   disable_interrupts(GLOBAL); 
1B78:  BCF    FF2.6
1B7A:  BCF    FF2.7
1B7C:  BTFSC  FF2.7
1B7E:  BRA    1B7A
....................                   flash_read_main_memory_to_buffer1(aux_command); 
1B80:  MOVFF  53,B0
1B84:  MOVFF  52,AF
1B88:  GOTO   0D42
1B8C:  CLRF   18
1B8E:  BTFSC  FF2.7
1B90:  BSF    18.7
1B92:  BCF    FF2.7
....................                  send_data(0,0); 
1B94:  CLRF   xD7
1B96:  CLRF   xD8
1B98:  CALL   046A
1B9C:  BTFSC  18.7
1B9E:  BSF    FF2.7
....................                   enable_interrupts(GLOBAL);    
1BA0:  MOVLW  C0
1BA2:  IORWF  FF2,F
....................                 break; 
1BA4:  BRA    2256
....................               }    
....................      // 0x84 = Buffer1 read 
....................      case 0x84: { //buffer1 read 
....................                   disable_interrupts(GLOBAL); 
1BA6:  BCF    FF2.6
1BA8:  BCF    FF2.7
1BAA:  BTFSC  FF2.7
1BAC:  BRA    1BA8
....................                 send_buffer1_content(); 
1BAE:  GOTO   0D8A
....................                   enable_interrupts(GLOBAL);          
1BB2:  MOVLW  C0
1BB4:  IORWF  FF2,F
....................                   break;   } 
1BB6:  BRA    2256
....................  
....................      case 0x85: { //test code 
....................                   disable_interrupts(GLOBAL); 
1BB8:  BCF    FF2.6
1BBA:  BCF    FF2.7
1BBC:  BTFSC  FF2.7
1BBE:  BRA    1BBA
....................                flash_buffer1_write(0,0,255); 
1BC0:  CLRF   xAF
1BC2:  CLRF   xB0
1BC4:  MOVLW  FF
1BC6:  MOVWF  xB1
1BC8:  CALL   0E66
....................                flash_buffer1_write(0x55,0x10,0x08); 
1BCC:  MOVLW  55
1BCE:  MOVWF  xAF
1BD0:  MOVLW  10
1BD2:  MOVWF  xB0
1BD4:  MOVLW  08
1BD6:  MOVWF  xB1
1BD8:  CALL   0E66
....................                   enable_interrupts(GLOBAL);          
1BDC:  MOVLW  C0
1BDE:  IORWF  FF2,F
....................                   break;   } 
1BE0:  BRA    2256
....................  
....................  
....................      // 0x8E = set flash page size = 256 
....................       case 0x8E: {  flash_set_256_page_size(); send_data(6,0); break; } 
1BE2:  GOTO   0ECA
1BE6:  CLRF   18
1BE8:  BTFSC  FF2.7
1BEA:  BSF    18.7
1BEC:  BCF    FF2.7
1BEE:  MOVLW  06
1BF0:  MOVWF  xD7
1BF2:  CLRF   xD8
1BF4:  CALL   046A
1BF8:  BTFSC  18.7
1BFA:  BSF    FF2.7
1BFC:  BRA    2256
....................      // 0x8F = flash write page 
....................      case 0x8F: { 
....................                   disable_interrupts(GLOBAL); 
1BFE:  BCF    FF2.6
1C00:  BCF    FF2.7
1C02:  BTFSC  FF2.7
1C04:  BRA    1C00
....................                 setup_WDT(WDT_OFF); 
1C06:  BCF    FD1.0
....................                   flash_write_page(aux_command); 
1C08:  MOVFF  53,B0
1C0C:  MOVFF  52,AF
1C10:  GOTO   0F0C
....................                memcpy(output_buffer,&aux_command,2); 
1C14:  CLRF   FEA
1C16:  MOVLW  54
1C18:  MOVWF  FE9
1C1A:  CLRF   FE2
1C1C:  MOVLW  52
1C1E:  MOVWF  FE1
1C20:  MOVLW  02
1C22:  MOVWF  01
1C24:  MOVFF  FE6,FEE
1C28:  DECFSZ 01,F
1C2A:  BRA    1C24
1C2C:  CLRF   18
1C2E:  BTFSC  FF2.7
1C30:  BSF    18.7
1C32:  BCF    FF2.7
....................                 send_data(8,1); 
1C34:  MOVLW  08
1C36:  MOVWF  xD7
1C38:  MOVLW  01
1C3A:  MOVWF  xD8
1C3C:  CALL   046A
1C40:  BTFSC  18.7
1C42:  BSF    FF2.7
....................                 setup_WDT(WDT_ON); 
1C44:  BSF    FD1.0
....................                   enable_interrupts(GLOBAL); 
1C46:  MOVLW  C0
1C48:  IORWF  FF2,F
....................                   break;}      
1C4A:  BRA    2256
.................... // level 3 = date and time setup 
....................      case 0x30: { // set date 
....................          nDay= aux_command;  send_data(0,0);break;    } 
1C4C:  CLRF   31
1C4E:  CLRF   30
1C50:  MOVFF  53,2F
1C54:  MOVFF  52,2E
1C58:  CLRF   18
1C5A:  BTFSC  FF2.7
1C5C:  BSF    18.7
1C5E:  BCF    FF2.7
1C60:  CLRF   xD7
1C62:  CLRF   xD8
1C64:  CALL   046A
1C68:  BTFSC  18.7
1C6A:  BSF    FF2.7
1C6C:  BRA    2256
....................      case 0x31: { // set low byte of time 
....................        timer_sec = aux_command; // rouding to 60 sec 
1C6E:  CLRF   25
1C70:  CLRF   24
1C72:  MOVFF  53,23
1C76:  MOVFF  52,22
1C7A:  CLRF   18
1C7C:  BTFSC  FF2.7
1C7E:  BSF    18.7
1C80:  BCF    FF2.7
....................        send_data(0,0); 
1C82:  CLRF   xD7
1C84:  CLRF   xD8
1C86:  CALL   046A
1C8A:  BTFSC  18.7
1C8C:  BSF    FF2.7
....................          break;    } 
1C8E:  BRA    2256
....................      case 0x32: { // set high byte of time 
....................          temp_mem = &timer_sec; 
1C90:  CLRF   xAE
1C92:  MOVLW  22
1C94:  MOVWF  xAD
....................        memcpy(temp_mem+2,&aux_command,2); 
1C96:  MOVLW  02
1C98:  ADDWF  xAD,W
1C9A:  MOVWF  xAF
1C9C:  MOVLW  00
1C9E:  ADDWFC xAE,W
1CA0:  MOVWF  xB0
1CA2:  MOVWF  FEA
1CA4:  MOVFF  AF,FE9
1CA8:  CLRF   FE2
1CAA:  MOVLW  52
1CAC:  MOVWF  FE1
1CAE:  MOVLW  02
1CB0:  MOVWF  01
1CB2:  MOVFF  FE6,FEE
1CB6:  DECFSZ 01,F
1CB8:  BRA    1CB2
1CBA:  CLRF   18
1CBC:  BTFSC  FF2.7
1CBE:  BSF    18.7
1CC0:  BCF    FF2.7
....................        send_data(0,0); 
1CC2:  CLRF   xD7
1CC4:  CLRF   xD8
1CC6:  CALL   046A
1CCA:  BTFSC  18.7
1CCC:  BSF    FF2.7
....................          break;    } 
1CCE:  BRA    2256
.................... // level 2 = actuator control 
....................       // 0x20 = move east 
....................      case 0x20: { if (flag2.is_moving) {send_data(1,0); break;} 
1CD0:  BTFSS  20.6
1CD2:  BRA    1CEC
1CD4:  CLRF   18
1CD6:  BTFSC  FF2.7
1CD8:  BSF    18.7
1CDA:  BCF    FF2.7
1CDC:  MOVLW  01
1CDE:  MOVWF  xD7
1CE0:  CLRF   xD8
1CE2:  CALL   046A
1CE6:  BTFSC  18.7
1CE8:  BSF    FF2.7
1CEA:  BRA    2256
1CEC:  CLRF   18
1CEE:  BTFSC  FF2.7
1CF0:  BSF    18.7
1CF2:  BCF    FF2.7
....................         send_data(0,0);  
1CF4:  CLRF   xD7
1CF6:  CLRF   xD8
1CF8:  CALL   046A
1CFC:  BTFSC  18.7
1CFE:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,1,(int8)(aux_command>>14));  
1D00:  MOVFF  52,AF
1D04:  MOVF   53,W
1D06:  ANDLW  3F
1D08:  MOVWF  xB0
1D0A:  SWAPF  53,W
1D0C:  MOVWF  02
1D0E:  CLRF   03
1D10:  RRCF   02,F
1D12:  RRCF   02,F
1D14:  MOVLW  03
1D16:  ANDWF  02,F
1D18:  MOVFF  02,B1
1D1C:  MOVFF  B0,B3
1D20:  MOVFF  52,B2
1D24:  MOVLW  23
1D26:  MOVWF  xB5
1D28:  MOVLW  28
1D2A:  MOVWF  xB4
1D2C:  MOVFF  7D,B7
1D30:  MOVFF  7C,B6
1D34:  MOVLW  01
1D36:  MOVWF  xB8
1D38:  MOVFF  02,B9
1D3C:  CALL   0FAC
....................        last_actuator_pulse = actuator_pulse; 
1D40:  MOVFF  7F,81
1D44:  MOVFF  7E,80
....................       break;    } 
1D48:  BRA    2256
....................      // 0x21 = move west 
....................      case 0x21: {  if (flag2.is_moving) {send_data(1,0); break;} 
1D4A:  BTFSS  20.6
1D4C:  BRA    1D66
1D4E:  CLRF   18
1D50:  BTFSC  FF2.7
1D52:  BSF    18.7
1D54:  BCF    FF2.7
1D56:  MOVLW  01
1D58:  MOVWF  xD7
1D5A:  CLRF   xD8
1D5C:  CALL   046A
1D60:  BTFSC  18.7
1D62:  BSF    FF2.7
1D64:  BRA    2256
1D66:  CLRF   18
1D68:  BTFSC  FF2.7
1D6A:  BSF    18.7
1D6C:  BCF    FF2.7
....................       send_data(0,0); 
1D6E:  CLRF   xD7
1D70:  CLRF   xD8
1D72:  CALL   046A
1D76:  BTFSC  18.7
1D78:  BSF    FF2.7
....................       move_act(aux_command&(0x3FFF),9000,move_act_time_out,0,(int8)(aux_command>>14));  
1D7A:  MOVFF  52,AF
1D7E:  MOVF   53,W
1D80:  ANDLW  3F
1D82:  MOVWF  xB0
1D84:  SWAPF  53,W
1D86:  MOVWF  02
1D88:  CLRF   03
1D8A:  RRCF   02,F
1D8C:  RRCF   02,F
1D8E:  MOVLW  03
1D90:  ANDWF  02,F
1D92:  MOVFF  02,B1
1D96:  MOVFF  B0,B3
1D9A:  MOVFF  52,B2
1D9E:  MOVLW  23
1DA0:  MOVWF  xB5
1DA2:  MOVLW  28
1DA4:  MOVWF  xB4
1DA6:  MOVFF  7D,B7
1DAA:  MOVFF  7C,B6
1DAE:  CLRF   xB8
1DB0:  MOVFF  02,B9
1DB4:  CALL   0FAC
....................        last_actuator_pulse = actuator_pulse; 
1DB8:  MOVFF  7F,81
1DBC:  MOVFF  7E,80
....................       break;    } 
1DC0:  BRA    2256
....................      // 0x22 = go home 
....................       case 0x22: {  if (flag2.is_moving) {send_data(1,0); break;} 
1DC2:  BTFSS  20.6
1DC4:  BRA    1DDE
1DC6:  CLRF   18
1DC8:  BTFSC  FF2.7
1DCA:  BSF    18.7
1DCC:  BCF    FF2.7
1DCE:  MOVLW  01
1DD0:  MOVWF  xD7
1DD2:  CLRF   xD8
1DD4:  CALL   046A
1DD8:  BTFSC  18.7
1DDA:  BSF    FF2.7
1DDC:  BRA    2256
1DDE:  CLRF   18
1DE0:  BTFSC  FF2.7
1DE2:  BSF    18.7
1DE4:  BCF    FF2.7
....................                send_data(0,0); 
1DE6:  CLRF   xD7
1DE8:  CLRF   xD8
1DEA:  CALL   046A
1DEE:  BTFSC  18.7
1DF0:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[(int8) aux_command]*(int32)(act_safety_stroke-act_min_stroke); 
1DF2:  BCF    FD8.0
1DF4:  RLCF   52,W
1DF6:  CLRF   03
1DF8:  ADDLW  90
1DFA:  MOVWF  FE9
1DFC:  MOVLW  00
1DFE:  ADDWFC 03,W
1E00:  MOVWF  FEA
1E02:  MOVFF  FEC,03
1E06:  MOVF   FED,F
1E08:  MOVFF  FEF,AF
1E0C:  MOVFF  03,B0
1E10:  CLRF   xB1
1E12:  CLRF   xB2
1E14:  MOVF   x9A,W
1E16:  SUBWF  x9C,W
1E18:  MOVWF  00
1E1A:  MOVF   x9B,W
1E1C:  SUBWFB x9D,W
1E1E:  MOVWF  03
1E20:  MOVF   00,W
1E22:  MOVFF  03,01
1E26:  CLRF   02
1E28:  CLRF   03
1E2A:  MOVFF  03,B6
1E2E:  MOVFF  02,B5
1E32:  MOVFF  01,B4
1E36:  MOVFF  00,B3
1E3A:  MOVFF  FEA,B8
1E3E:  MOVFF  FE9,B7
1E42:  MOVFF  B2,C7
1E46:  MOVFF  B1,C6
1E4A:  MOVFF  B0,C5
1E4E:  MOVFF  AF,C4
1E52:  MOVFF  03,CB
1E56:  MOVFF  02,CA
1E5A:  MOVFF  01,C9
1E5E:  MOVFF  00,C8
1E62:  CALL   1352
1E66:  MOVFF  B8,FEA
1E6A:  MOVFF  B7,FE9
1E6E:  MOVFF  03,29
1E72:  MOVFF  02,28
1E76:  MOVFF  01,27
1E7A:  MOVFF  00,26
....................                tick = tick/(act_max_stroke-act_min_stroke); 
1E7E:  MOVF   x9A,W
1E80:  SUBWF  x98,W
1E82:  MOVWF  00
1E84:  MOVF   x9B,W
1E86:  SUBWFB x99,W
1E88:  MOVWF  03
1E8A:  MOVFF  00,AF
1E8E:  MOVWF  xB0
1E90:  CLRF   18
1E92:  BTFSC  FF2.7
1E94:  BSF    18.7
1E96:  BCF    FF2.7
1E98:  MOVFF  29,D5
1E9C:  MOVFF  28,D4
1EA0:  MOVFF  27,D3
1EA4:  MOVFF  26,D2
1EA8:  CLRF   xD9
1EAA:  CLRF   xD8
1EAC:  MOVWF  xD7
1EAE:  MOVFF  00,D6
1EB2:  CALL   00AA
1EB6:  BTFSC  18.7
1EB8:  BSF    FF2.7
1EBA:  MOVFF  03,29
1EBE:  MOVFF  02,28
1EC2:  MOVFF  01,27
1EC6:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
1ECA:  MOVFF  27,8F
1ECE:  MOVFF  26,8E
....................                actuator_move_execute((int8) aux_command); 
1ED2:  MOVFF  52,AF
1ED6:  CALL   13A6
....................                    last_actuator_pulse = actuator_pulse; 
1EDA:  MOVFF  7F,81
1EDE:  MOVFF  7E,80
....................                break; } 
1EE2:  BRA    2256
....................      // 0x23 = cal act 
....................      case 0x23: {  if (flag2.is_moving) {send_data(1,0); break;} 
1EE4:  BTFSS  20.6
1EE6:  BRA    1F00
1EE8:  CLRF   18
1EEA:  BTFSC  FF2.7
1EEC:  BSF    18.7
1EEE:  BCF    FF2.7
1EF0:  MOVLW  01
1EF2:  MOVWF  xD7
1EF4:  CLRF   xD8
1EF6:  CALL   046A
1EFA:  BTFSC  18.7
1EFC:  BSF    FF2.7
1EFE:  BRA    2256
1F00:  CLRF   18
1F02:  BTFSC  FF2.7
1F04:  BSF    18.7
1F06:  BCF    FF2.7
....................                send_data(0,0); 
1F08:  CLRF   xD7
1F0A:  CLRF   xD8
1F0C:  CALL   046A
1F10:  BTFSC  18.7
1F12:  BSF    FF2.7
....................                   move_act(2000,9000,move_act_time_out,1,(int8) aux_command); // move actuator to west 
1F14:  MOVLW  07
1F16:  MOVWF  xB3
1F18:  MOVLW  D0
1F1A:  MOVWF  xB2
1F1C:  MOVLW  23
1F1E:  MOVWF  xB5
1F20:  MOVLW  28
1F22:  MOVWF  xB4
1F24:  MOVFF  7D,B7
1F28:  MOVFF  7C,B6
1F2C:  MOVLW  01
1F2E:  MOVWF  xB8
1F30:  MOVFF  52,B9
1F34:  CALL   0FAC
....................                   move_act(2000,9000,move_act_time_out,0,(int8) aux_command); // move actuator to home position 
1F38:  MOVLW  07
1F3A:  MOVWF  xB3
1F3C:  MOVLW  D0
1F3E:  MOVWF  xB2
1F40:  MOVLW  23
1F42:  MOVWF  xB5
1F44:  MOVLW  28
1F46:  MOVWF  xB4
1F48:  MOVFF  7D,B7
1F4C:  MOVFF  7C,B6
1F50:  CLRF   xB8
1F52:  MOVFF  52,B9
1F56:  CALL   0FAC
....................                   act_full_stroke_tick[(int8) aux_command]= actuator_pulse; 
1F5A:  BCF    FD8.0
1F5C:  RLCF   52,W
1F5E:  CLRF   03
1F60:  ADDLW  90
1F62:  MOVWF  FE9
1F64:  MOVLW  00
1F66:  ADDWFC 03,W
1F68:  MOVWF  FEA
1F6A:  MOVFF  7F,FEC
1F6E:  MOVF   FED,F
1F70:  MOVFF  7E,FEF
....................                   current_act_position[(int8) aux_command] =0; 
1F74:  BCF    FD8.0
1F76:  RLCF   52,W
1F78:  CLRF   03
1F7A:  ADDLW  86
1F7C:  MOVWF  FE9
1F7E:  MOVLW  00
1F80:  ADDWFC 03,W
1F82:  MOVWF  FEA
1F84:  CLRF   FEC
1F86:  MOVF   FED,F
1F88:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
1F8A:  MOVLW  01
1F8C:  MOVWF  xAF
1F8E:  CALL   0970
....................                 last_actuator_pulse = actuator_pulse; 
1F92:  MOVFF  7F,81
1F96:  MOVFF  7E,80
....................                   break; } 
1F9A:  BRA    2256
....................      // 0x24 = report actuator stat 
....................      case 0x24: {   
....................                memcpy(output_buffer,&act_min_stroke,2); 
1F9C:  CLRF   FEA
1F9E:  MOVLW  54
1FA0:  MOVWF  FE9
1FA2:  CLRF   FE2
1FA4:  MOVLW  9A
1FA6:  MOVWF  FE1
1FA8:  MOVLW  02
1FAA:  MOVWF  01
1FAC:  MOVFF  FE6,FEE
1FB0:  DECFSZ 01,F
1FB2:  BRA    1FAC
....................                memcpy(output_buffer+2,&act_max_stroke,2); 
1FB4:  CLRF   FEA
1FB6:  MOVLW  56
1FB8:  MOVWF  FE9
1FBA:  CLRF   FE2
1FBC:  MOVLW  98
1FBE:  MOVWF  FE1
1FC0:  MOVLW  02
1FC2:  MOVWF  01
1FC4:  MOVFF  FE6,FEE
1FC8:  DECFSZ 01,F
1FCA:  BRA    1FC4
....................                memcpy(output_buffer+4,&act_safety_stroke,2); 
1FCC:  CLRF   FEA
1FCE:  MOVLW  58
1FD0:  MOVWF  FE9
1FD2:  CLRF   FE2
1FD4:  MOVLW  9C
1FD6:  MOVWF  FE1
1FD8:  MOVLW  02
1FDA:  MOVWF  01
1FDC:  MOVFF  FE6,FEE
1FE0:  DECFSZ 01,F
1FE2:  BRA    1FDC
....................                memcpy(output_buffer+6,act_full_stroke_tick,8); 
1FE4:  CLRF   FEA
1FE6:  MOVLW  5A
1FE8:  MOVWF  FE9
1FEA:  CLRF   FE2
1FEC:  MOVLW  90
1FEE:  MOVWF  FE1
1FF0:  MOVLW  08
1FF2:  MOVWF  01
1FF4:  MOVFF  FE6,FEE
1FF8:  DECFSZ 01,F
1FFA:  BRA    1FF4
....................                memcpy(output_buffer+14,current_act_position,8); 
1FFC:  CLRF   FEA
1FFE:  MOVLW  62
2000:  MOVWF  FE9
2002:  CLRF   FE2
2004:  MOVLW  86
2006:  MOVWF  FE1
2008:  MOVLW  08
200A:  MOVWF  01
200C:  MOVFF  FE6,FEE
2010:  DECFSZ 01,F
2012:  BRA    200C
2014:  CLRF   18
2016:  BTFSC  FF2.7
2018:  BSF    18.7
201A:  BCF    FF2.7
....................                send_data(4,21); 
201C:  MOVLW  04
201E:  MOVWF  xD7
2020:  MOVLW  15
2022:  MOVWF  xD8
2024:  CALL   046A
2028:  BTFSC  18.7
202A:  BSF    FF2.7
....................                break; 
202C:  BRA    2256
....................               }    
....................       // 0x25 = execute move on actuator to target position 
....................      case 0x25: {   if (flag2.is_moving) {send_data(1,0); break;} 
202E:  BTFSS  20.6
2030:  BRA    204A
2032:  CLRF   18
2034:  BTFSC  FF2.7
2036:  BSF    18.7
2038:  BCF    FF2.7
203A:  MOVLW  01
203C:  MOVWF  xD7
203E:  CLRF   xD8
2040:  CALL   046A
2044:  BTFSC  18.7
2046:  BSF    FF2.7
2048:  BRA    2256
204A:  CLRF   18
204C:  BTFSC  FF2.7
204E:  BSF    18.7
2050:  BCF    FF2.7
....................                send_data(0,0); 
2052:  CLRF   xD7
2054:  CLRF   xD8
2056:  CALL   046A
205A:  BTFSC  18.7
205C:  BSF    FF2.7
....................                   if (act_full_stroke_tick[(int8) aux_command] > 0x10) { 
205E:  BCF    FD8.0
2060:  RLCF   52,W
2062:  CLRF   03
2064:  ADDLW  90
2066:  MOVWF  FE9
2068:  MOVLW  00
206A:  ADDWFC 03,W
206C:  MOVWF  FEA
206E:  MOVFF  FEC,B0
2072:  MOVF   FED,F
2074:  MOVFF  FEF,AF
2078:  MOVF   xB0,F
207A:  BNZ   2082
207C:  MOVF   xAF,W
207E:  SUBLW  10
2080:  BC    2092
....................                   solar_get_act_length((int8) aux_command); 
2082:  MOVFF  52,AF
2086:  CALL   1536
....................                 actuator_move_execute((int8) aux_command); 
208A:  MOVFF  52,AF
208E:  CALL   13A6
....................                } 
....................                 last_actuator_pulse = actuator_pulse; 
2092:  MOVFF  7F,81
2096:  MOVFF  7E,80
....................                   break;    } 
209A:  BRA    2256
....................  
....................      case 0x26: { // report last_actuator_move  
....................                memcpy(output_buffer,&last_actuator_pulse,2); 
209C:  CLRF   FEA
209E:  MOVLW  54
20A0:  MOVWF  FE9
20A2:  CLRF   FE2
20A4:  MOVLW  80
20A6:  MOVWF  FE1
20A8:  MOVLW  02
20AA:  MOVWF  01
20AC:  MOVFF  FE6,FEE
20B0:  DECFSZ 01,F
20B2:  BRA    20AC
20B4:  CLRF   18
20B6:  BTFSC  FF2.7
20B8:  BSF    18.7
20BA:  BCF    FF2.7
....................                send_data(5,1); 
20BC:  MOVLW  05
20BE:  MOVWF  xD7
20C0:  MOVLW  01
20C2:  MOVWF  xD8
20C4:  CALL   046A
20C8:  BTFSC  18.7
20CA:  BSF    FF2.7
....................                 break; 
20CC:  BRA    2256
....................             }    
....................   
.................... // level 1 command is for generic status 
....................      case 0x10: { memcpy(output_buffer,&nDay,4); 
20CE:  CLRF   FEA
20D0:  MOVLW  54
20D2:  MOVWF  FE9
20D4:  CLRF   FE2
20D6:  MOVLW  2E
20D8:  MOVWF  FE1
20DA:  MOVLW  04
20DC:  MOVWF  01
20DE:  MOVFF  FE6,FEE
20E2:  DECFSZ 01,F
20E4:  BRA    20DE
....................                    memcpy(output_buffer+4,&timer_sec,4); 
20E6:  CLRF   FEA
20E8:  MOVLW  58
20EA:  MOVWF  FE9
20EC:  CLRF   FE2
20EE:  MOVLW  22
20F0:  MOVWF  FE1
20F2:  MOVLW  04
20F4:  MOVWF  01
20F6:  MOVFF  FE6,FEE
20FA:  DECFSZ 01,F
20FC:  BRA    20F6
20FE:  CLRF   18
2100:  BTFSC  FF2.7
2102:  BSF    18.7
2104:  BCF    FF2.7
....................                send_data(9,7); 
2106:  MOVLW  09
2108:  MOVWF  xD7
210A:  MOVLW  07
210C:  MOVWF  xD8
210E:  CALL   046A
2112:  BTFSC  18.7
2114:  BSF    FF2.7
....................                break; } 
2116:  BRA    2256
....................       // report status flag 
....................      case 0x11: { memcpy(output_buffer,&flag,1); 
2118:  CLRF   FEA
211A:  MOVLW  54
211C:  MOVWF  FE9
211E:  CLRF   FE2
2120:  MOVLW  1F
2122:  MOVWF  FE1
2124:  MOVFF  FE6,FEE
....................                    memcpy(output_buffer+1,&flag2,1); 
2128:  CLRF   FEA
212A:  MOVLW  55
212C:  MOVWF  FE9
212E:  CLRF   FE2
2130:  MOVLW  20
2132:  MOVWF  FE1
2134:  MOVFF  FE6,FEE
2138:  CLRF   18
213A:  BTFSC  FF2.7
213C:  BSF    18.7
213E:  BCF    FF2.7
....................                send_data(10,1); 
2140:  MOVLW  0A
2142:  MOVWF  xD7
2144:  MOVLW  01
2146:  MOVWF  xD8
2148:  CALL   046A
214C:  BTFSC  18.7
214E:  BSF    FF2.7
....................                break; } 
2150:  BRA    2256
....................      case 0x12: { //write device id 
....................                dev_id = aux_command; 
2152:  MOVFF  53,35
2156:  MOVFF  52,34
....................                write_device_id(); 
215A:  BRA    1A0A
215C:  CLRF   18
215E:  BTFSC  FF2.7
2160:  BSF    18.7
2162:  BCF    FF2.7
....................                send_data(0,0); 
2164:  CLRF   xD7
2166:  CLRF   xD8
2168:  CALL   046A
216C:  BTFSC  18.7
216E:  BSF    FF2.7
....................                break; 
2170:  BRA    2256
....................                } 
....................       case 0x13: { // read device_id 
....................                read_device_id(); 
2172:  CALL   090A
....................                memcpy(output_buffer,&dev_id,2); 
2176:  CLRF   FEA
2178:  MOVLW  54
217A:  MOVWF  FE9
217C:  CLRF   FE2
217E:  MOVLW  34
2180:  MOVWF  FE1
2182:  MOVLW  02
2184:  MOVWF  01
2186:  MOVFF  FE6,FEE
218A:  DECFSZ 01,F
218C:  BRA    2186
218E:  CLRF   18
2190:  BTFSC  FF2.7
2192:  BSF    18.7
2194:  BCF    FF2.7
....................                send_data(11,1); 
2196:  MOVLW  0B
2198:  MOVWF  xD7
219A:  MOVLW  01
219C:  MOVWF  xD8
219E:  CALL   046A
21A2:  BTFSC  18.7
21A4:  BSF    FF2.7
....................                break;  
21A6:  BRA    2256
....................              } 
....................  
....................  
.................... // level 0 communication control 
....................      case 0x01: {  // close/open communication port 
....................                 if (aux_command ==0x0000) {  
21A8:  MOVF   52,F
21AA:  BNZ   21B6
21AC:  MOVF   53,F
21AE:  BNZ   21B6
....................                   output_low(TX_EN); 
21B0:  BCF    F96.1
21B2:  BCF    F8D.1
....................                } else if (aux_command ==0x0001) { 
21B4:  BRA    21FC
21B6:  DECFSZ 52,W
21B8:  BRA    21E6
21BA:  MOVF   53,F
21BC:  BNZ   21E6
....................                   output_high(TX_EN); 
21BE:  BCF    F96.1
21C0:  BSF    F8D.1
....................                   delay_us(500); 
21C2:  MOVLW  02
21C4:  MOVWF  xAF
21C6:  MOVLW  F9
21C8:  MOVWF  xB0
21CA:  BRA    1A7E
21CC:  DECFSZ xAF,F
21CE:  BRA    21C6
21D0:  CLRF   18
21D2:  BTFSC  FF2.7
21D4:  BSF    18.7
21D6:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
21D8:  CLRF   xD7
21DA:  CLRF   xD8
21DC:  CALL   046A
21E0:  BTFSC  18.7
21E2:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
21E4:  BRA    21FC
21E6:  CLRF   18
21E8:  BTFSC  FF2.7
21EA:  BSF    18.7
21EC:  BCF    FF2.7
21EE:  MOVLW  01
21F0:  MOVWF  xD7
21F2:  CLRF   xD8
21F4:  CALL   046A
21F8:  BTFSC  18.7
21FA:  BSF    FF2.7
....................                break; 
21FC:  BRA    2256
....................              }    
....................  
....................      case 0x02: {  // close/open communication port 
....................                 if (aux_command ==0x0000) {  
21FE:  MOVF   52,F
2200:  BNZ   221E
2202:  MOVF   53,F
2204:  BNZ   221E
....................                   flag2.en_operate=0; 
2206:  BCF    20.0
2208:  CLRF   18
220A:  BTFSC  FF2.7
220C:  BSF    18.7
220E:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
2210:  CLRF   xD7
2212:  CLRF   xD8
2214:  CALL   046A
2218:  BTFSC  18.7
221A:  BSF    FF2.7
....................                } else if (aux_command ==0x0001) { 
221C:  BRA    2254
221E:  DECFSZ 52,W
2220:  BRA    223E
2222:  MOVF   53,F
2224:  BNZ   223E
....................                   flag2.en_operate=1; 
2226:  BSF    20.0
2228:  CLRF   18
222A:  BTFSC  FF2.7
222C:  BSF    18.7
222E:  BCF    FF2.7
....................                   send_data(0,0); // send ack          
2230:  CLRF   xD7
2232:  CLRF   xD8
2234:  CALL   046A
2238:  BTFSC  18.7
223A:  BSF    FF2.7
....................                } else send_data(1,0); // send NACK 
223C:  BRA    2254
223E:  CLRF   18
2240:  BTFSC  FF2.7
2242:  BSF    18.7
2244:  BCF    FF2.7
2246:  MOVLW  01
2248:  MOVWF  xD7
224A:  CLRF   xD8
224C:  CALL   046A
2250:  BTFSC  18.7
2252:  BSF    FF2.7
....................                break; 
2254:  BRA    2256
....................              }    
....................  
....................  
....................  
....................    } 
....................  
.................... } 
2256:  GOTO   27BA (RETURN)
....................  
.................... /* 
.................... void process_cmd_msg(){ 
....................    int8 i,j; 
....................    flag.cmd_posted =false; 
....................    last_command =0; 
....................    printf("\r\n>%s\r\n",cmd_msg); 
....................    switch (cmd_msg[0]) { 
....................       case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Block erase\r\n"); 
....................          flash_block_erase(); 
....................          break; } 
....................  
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
....................         setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
....................          print_page_data(atol(cmd_msg)); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'b': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Write buffer1 -> PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_buffer1_to_main_memory(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'c': { 
....................          disable_interrupts(GLOBAL); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n Read PAGE %ld -> buffer1",atol(cmd_msg)); 
....................          flash_read_main_memory_to_buffer1(atol(cmd_msg)); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................  
....................       case 'f': { 
....................          disable_interrupts(GLOBAL); 
....................        setup_WDT(WDT_OFF); 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          printf("\r\n WRITE PAGE %ld:",atol(cmd_msg)); 
....................          flash_write_page(atol(cmd_msg)); 
....................        printf("\r\n."); 
....................        setup_WDT(WDT_ON); 
....................          enable_interrupts(GLOBAL); 
....................          break; 
....................       } 
....................       case 'g': { 
....................          print_date_time(); 
....................          break; 
....................       } 
....................  
....................       case 'w': { //buffer1 read 
....................          disable_interrupts(GLOBAL); 
....................        printf("\r\n Buffer1:"); 
....................        for(i=0;i<16;i++) { 
....................             printf("\r\n%02X : ",i*16); 
....................             for (j=0;j<8;j++) { 
....................               flash_buffer1_read(i*16+j*2); 
....................             printf("%02X %02X ",flash_page_data,flash_page_data2); 
....................             restart_wdt(); 
....................             } 
....................        } 
....................          enable_interrupts(GLOBAL);          
....................          break;    
....................      } 
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
....................          break;    } 
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
....................          break;    } 
....................       case 'p': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)!=22) break; 
....................        printf("\r\n Set 256 page size\r\n"); 
....................          flash_set_256_page_size(); 
....................          break; } 
....................  
....................      case 'z': { 
....................        print_fw_info(); 
....................        printf("\r\n startup = %ld",startup_counter); 
....................        break; 
....................      } 
....................      case 'd': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          if (atol(cmd_msg)==0) break; 
....................          nDay= atol(cmd_msg); 
....................          break;    } 
....................      case 't': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          timer_sec = atoi32(cmd_msg); 
....................        timer_sec = timer_sec; // rouding to 60 sec 
....................          break;    } 
....................      case 'l': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
....................          solar_get_act_length(atoi(cmd_msg)); 
....................        disable_interrupts(GLOBAL); 
....................        printf("\r\n Act#%d Len=%lu Now=%lu\r\n",atoi(cmd_msg), target_act_position, current_act_position[atoi(cmd_msg)]); 
....................        enable_interrupts(GLOBAL); 
....................        actuator_move_execute(atoi(cmd_msg)); 
....................          break;    } 
....................       case 'h' : { //return home 
....................         memcpy(cmd_msg,cmd_msg+1,18); 
....................          if(strlen(cmd_msg)>0) { 
....................         flag2.en_operate =0; 
....................          move_act(2000,9000,move_act_time_out,1,atoi(cmd_msg)); // move actuator to west 
....................          move_act(2000,9000,move_act_time_out,0,atoi(cmd_msg)); // move actuator to home position 
....................          act_full_stroke_tick[atoi(cmd_msg)]= actuator_pulse; 
....................          current_act_position[atoi(cmd_msg)] =0; 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................         flag2.en_operate =1;  
....................        } 
....................  
....................          break; 
....................       } 
....................         
....................       case 'j': { 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
....................          break; 
....................       } 
....................  
....................      case 'o': { 
....................        flag2.en_operate = !flag2.en_operate; 
....................        if (flag2.en_operate) printf("\r\n Normal operation"); else printf("\r\n Halt operation"); 
....................        break; 
....................      } 
....................  
....................       case 'y': { //adc conversion 
....................          set_adc_channel(0); 
....................          delay_us(20); 
....................        wall_pwr_read =read_adc(); 
....................          printf("\r\nADC= %lu",wall_pwr_read); 
....................          break; 
....................       } 
....................       case 'k': { 
....................        disable_interrupts(GLOBAL); 
....................          while(1); 
....................          break; 
....................       } 
....................  
....................  
....................  
....................       }// end case       
.................... } 
....................  
.................... */ 
.................... ////////////////////////////////////// 
.................... void button_menu() { 
....................    int8 k; 
....................    int8 target_act=0; 
225A:  CLRF   xAC
....................     flag2.en_operate = 0; // enter halt operation 
225C:  BCF    20.0
....................    LED_status.power = 0; // always red 
225E:  BCF    21.0
....................    LED_status.operation =0; 
2260:  BCF    21.1
....................    LED_status.aux =3; // both turned off 
2262:  MOVLW  F3
2264:  ANDWF  21,W
2266:  IORLW  0C
2268:  MOVWF  21
....................    display_LED(); 
226A:  CALL   0144
....................     flag2.abort_current_activity =0; 
226E:  BCF    20.2
....................    while(flag2.button_pressed ==1)   button_scan(); 
2270:  BTFSS  20.1
2272:  BRA    2286
2274:  CLRF   18
2276:  BTFSC  FF2.7
2278:  BSF    18.7
227A:  BCF    FF2.7
227C:  CALL   01A0
2280:  BTFSC  18.7
2282:  BSF    FF2.7
2284:  BRA    2270
2286:  CLRF   18
2288:  BTFSC  FF2.7
228A:  BSF    18.7
228C:  BCF    FF2.7
....................    delay_ms(10); 
228E:  MOVLW  0A
2290:  MOVWF  xD2
2292:  CALL   0178
2296:  BTFSC  18.7
2298:  BSF    FF2.7
....................    // button release 
....................  
....................     while(1) { 
....................       nButton =-1; 
229A:  MOVLW  FF
229C:  MOVWF  4B
229E:  CLRF   18
22A0:  BTFSC  FF2.7
22A2:  BSF    18.7
22A4:  BCF    FF2.7
....................       button_scan(); 
22A6:  CALL   01A0
22AA:  BTFSC  18.7
22AC:  BSF    FF2.7
....................       restart_wdt(); 
22AE:  CLRWDT
....................       if (nButton != -1){ 
22B0:  MOVF   4B,W
22B2:  SUBLW  FF
22B4:  BTFSC  FD8.2
22B6:  BRA    252C
....................       switch (nButton) { 
22B8:  MOVF   4B,W
22BA:  ADDLW  FA
22BC:  BTFSC  FD8.0
22BE:  BRA    252C
22C0:  ADDLW  06
22C2:  GOTO   2532
....................          case 0: { // operate/halt button  
....................                while (flag2.button_pressed ==1) button_scan(); 
22C6:  BTFSS  20.1
22C8:  BRA    22DC
22CA:  CLRF   18
22CC:  BTFSC  FF2.7
22CE:  BSF    18.7
22D0:  BCF    FF2.7
22D2:  CALL   01A0
22D6:  BTFSC  18.7
22D8:  BSF    FF2.7
22DA:  BRA    22C6
22DC:  CLRF   18
22DE:  BTFSC  FF2.7
22E0:  BSF    18.7
22E2:  BCF    FF2.7
....................                delay_ms(10); 
22E4:  MOVLW  0A
22E6:  MOVWF  xD2
22E8:  CALL   0178
22EC:  BTFSC  18.7
22EE:  BSF    FF2.7
....................                nButton=-1; 
22F0:  MOVLW  FF
22F2:  MOVWF  4B
....................                flag2.en_operate =1; 
22F4:  BSF    20.0
....................                flag2.abort_current_activity =0; 
22F6:  BCF    20.2
....................                init_rs232(); 
22F8:  CALL   0124
....................                return;} 
22FC:  BRA    252E
....................          case 1: { // actuator select button 
....................                while (flag2.button_pressed ==1) button_scan(); 
22FE:  BTFSS  20.1
2300:  BRA    2314
2302:  CLRF   18
2304:  BTFSC  FF2.7
2306:  BSF    18.7
2308:  BCF    FF2.7
230A:  CALL   01A0
230E:  BTFSC  18.7
2310:  BSF    FF2.7
2312:  BRA    22FE
2314:  CLRF   18
2316:  BTFSC  FF2.7
2318:  BSF    18.7
231A:  BCF    FF2.7
....................                delay_ms(10); 
231C:  MOVLW  0A
231E:  MOVWF  xD2
2320:  CALL   0178
2324:  BTFSC  18.7
2326:  BSF    FF2.7
....................                target_act++; 
2328:  INCF   xAC,F
....................                target_act = target_act%4; 
232A:  MOVLW  03
232C:  ANDWF  xAC,F
....................                LED_status.aux=target_act ^ 0xFF ; 
232E:  MOVF   xAC,W
2330:  XORLW  FF
2332:  ANDLW  03
2334:  MOVWF  00
2336:  BCF    FD8.0
2338:  RLCF   00,F
233A:  RLCF   00,F
233C:  MOVLW  F3
233E:  ANDWF  21,W
2340:  IORWF  00,W
2342:  MOVWF  21
....................                display_LED(); 
2344:  CALL   0144
....................                break;} 
2348:  BRA    252C
....................             case 2: { //return home 
....................                   move_act(2000,9000,move_act_time_out,1,target_act); // move actuator to west 
234A:  MOVLW  07
234C:  MOVWF  xB3
234E:  MOVLW  D0
2350:  MOVWF  xB2
2352:  MOVLW  23
2354:  MOVWF  xB5
2356:  MOVLW  28
2358:  MOVWF  xB4
235A:  MOVFF  7D,B7
235E:  MOVFF  7C,B6
2362:  MOVLW  01
2364:  MOVWF  xB8
2366:  MOVFF  AC,B9
236A:  CALL   0FAC
....................                   move_act(2000,9000,move_act_time_out,0,target_act); // move actuator to home position 
236E:  MOVLW  07
2370:  MOVWF  xB3
2372:  MOVLW  D0
2374:  MOVWF  xB2
2376:  MOVLW  23
2378:  MOVWF  xB5
237A:  MOVLW  28
237C:  MOVWF  xB4
237E:  MOVFF  7D,B7
2382:  MOVFF  7C,B6
2386:  CLRF   xB8
2388:  MOVFF  AC,B9
238C:  CALL   0FAC
....................                   act_full_stroke_tick[target_act]= actuator_pulse; 
2390:  BCF    FD8.0
2392:  RLCF   xAC,W
2394:  CLRF   03
2396:  ADDLW  90
2398:  MOVWF  FE9
239A:  MOVLW  00
239C:  ADDWFC 03,W
239E:  MOVWF  FEA
23A0:  MOVFF  7F,FEC
23A4:  MOVF   FED,F
23A6:  MOVFF  7E,FEF
....................                   current_act_position[target_act] =0; 
23AA:  BCF    FD8.0
23AC:  RLCF   xAC,W
23AE:  CLRF   03
23B0:  ADDLW  86
23B2:  MOVWF  FE9
23B4:  MOVLW  00
23B6:  ADDWFC 03,W
23B8:  MOVWF  FEA
23BA:  CLRF   FEC
23BC:  MOVF   FED,F
23BE:  CLRF   FEF
....................                   write_eeprom_data(1); // save full_stroke_tick and current_position 
23C0:  MOVLW  01
23C2:  MOVWF  xAF
23C4:  CALL   0970
....................                   break; 
23C8:  BRA    252C
....................                   } 
....................          case 3: { // move east 
....................                flag2.allow_manual_move_act=1; 
23CA:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,0,target_act); 
23CC:  CLRF   xB3
23CE:  MOVLW  0A
23D0:  MOVWF  xB2
23D2:  MOVLW  11
23D4:  MOVWF  xB5
23D6:  MOVLW  94
23D8:  MOVWF  xB4
23DA:  MOVFF  7D,B7
23DE:  MOVFF  7C,B6
23E2:  CLRF   xB8
23E4:  MOVFF  AC,B9
23E8:  CALL   0FAC
....................                flag2.allow_manual_move_act=0; 
23EC:  BCF    20.3
....................                break; } 
23EE:  BRA    252C
....................          case 4: { // move safty 
....................                 while (flag2.button_pressed ==1) button_scan(); 
23F0:  BTFSS  20.1
23F2:  BRA    2406
23F4:  CLRF   18
23F6:  BTFSC  FF2.7
23F8:  BSF    18.7
23FA:  BCF    FF2.7
23FC:  CALL   01A0
2400:  BTFSC  18.7
2402:  BSF    FF2.7
2404:  BRA    23F0
2406:  CLRF   18
2408:  BTFSC  FF2.7
240A:  BSF    18.7
240C:  BCF    FF2.7
....................                delay_ms(10); 
240E:  MOVLW  0A
2410:  MOVWF  xD2
2412:  CALL   0178
2416:  BTFSC  18.7
2418:  BSF    FF2.7
....................                tick = (int32)act_full_stroke_tick[target_act]*(int32)(act_safety_stroke-act_min_stroke); 
241A:  BCF    FD8.0
241C:  RLCF   xAC,W
241E:  CLRF   03
2420:  ADDLW  90
2422:  MOVWF  FE9
2424:  MOVLW  00
2426:  ADDWFC 03,W
2428:  MOVWF  FEA
242A:  MOVFF  FEC,03
242E:  MOVF   FED,F
2430:  MOVFF  FEF,AD
2434:  MOVFF  03,AE
2438:  CLRF   xAF
243A:  CLRF   xB0
243C:  MOVF   x9A,W
243E:  SUBWF  x9C,W
2440:  MOVWF  00
2442:  MOVF   x9B,W
2444:  SUBWFB x9D,W
2446:  MOVWF  03
2448:  MOVF   00,W
244A:  MOVFF  03,01
244E:  CLRF   02
2450:  CLRF   03
2452:  MOVFF  03,B4
2456:  MOVFF  02,B3
245A:  MOVFF  01,B2
245E:  MOVFF  00,B1
2462:  MOVFF  FEA,B6
2466:  MOVFF  FE9,B5
246A:  MOVFF  B0,C7
246E:  MOVFF  AF,C6
2472:  MOVFF  AE,C5
2476:  MOVFF  AD,C4
247A:  MOVFF  03,CB
247E:  MOVFF  02,CA
2482:  MOVFF  01,C9
2486:  MOVFF  00,C8
248A:  CALL   1352
248E:  MOVFF  B6,FEA
2492:  MOVFF  B5,FE9
2496:  MOVFF  03,29
249A:  MOVFF  02,28
249E:  MOVFF  01,27
24A2:  MOVFF  00,26
....................                tick = tick/(act_max_stroke-act_min_stroke); 
24A6:  MOVF   x9A,W
24A8:  SUBWF  x98,W
24AA:  MOVWF  00
24AC:  MOVF   x9B,W
24AE:  SUBWFB x99,W
24B0:  MOVWF  03
24B2:  MOVFF  00,AD
24B6:  MOVWF  xAE
24B8:  CLRF   18
24BA:  BTFSC  FF2.7
24BC:  BSF    18.7
24BE:  BCF    FF2.7
24C0:  MOVFF  29,D5
24C4:  MOVFF  28,D4
24C8:  MOVFF  27,D3
24CC:  MOVFF  26,D2
24D0:  CLRF   xD9
24D2:  CLRF   xD8
24D4:  MOVWF  xD7
24D6:  MOVFF  00,D6
24DA:  CALL   00AA
24DE:  BTFSC  18.7
24E0:  BSF    FF2.7
24E2:  MOVFF  03,29
24E6:  MOVFF  02,28
24EA:  MOVFF  01,27
24EE:  MOVFF  00,26
....................                target_act_position = (unsigned int16) tick; 
24F2:  MOVFF  27,8F
24F6:  MOVFF  26,8E
....................                actuator_move_execute(target_act); 
24FA:  MOVFF  AC,AF
24FE:  CALL   13A6
....................                break; } 
2502:  BRA    252C
....................          case 5: { // move west 
....................                flag2.allow_manual_move_act=1; 
2504:  BSF    20.3
....................                move_act(10,4500,move_act_time_out,1,target_act); 
2506:  CLRF   xB3
2508:  MOVLW  0A
250A:  MOVWF  xB2
250C:  MOVLW  11
250E:  MOVWF  xB5
2510:  MOVLW  94
2512:  MOVWF  xB4
2514:  MOVFF  7D,B7
2518:  MOVFF  7C,B6
251C:  MOVLW  01
251E:  MOVWF  xB8
2520:  MOVFF  AC,B9
2524:  CALL   0FAC
....................                flag2.allow_manual_move_act=0; 
2528:  BCF    20.3
....................                break; } 
252A:  BRA    252C
....................  
....................          } 
....................           
....................       } 
....................       } 
252C:  BRA    229A
....................        
.................... } 
252E:  GOTO   283C (RETURN)
....................  
.................... ////////////////////////////////////// 
.................... void main() { 
*
2562:  CLRF   FF8
2564:  BCF    FD0.7
2566:  BSF    08.7
2568:  CLRF   FEA
256A:  CLRF   FE9
256C:  MOVLW  03
256E:  MOVWF  FAF
2570:  MOVLW  A2
2572:  MOVWF  FAC
2574:  MOVLW  90
2576:  MOVWF  FAB
2578:  BSF    F94.4
257A:  BCF    F94.5
257C:  BCF    F94.3
257E:  BCF    F8B.3
2580:  BSF    FC1.0
2582:  BSF    FC1.1
2584:  BSF    FC1.2
2586:  BCF    FC1.3
2588:  MOVLW  07
258A:  MOVWF  FB4
258C:  CLRF   19
258E:  CLRF   1A
2590:  CLRF   22
2592:  CLRF   23
2594:  CLRF   24
2596:  CLRF   25
2598:  CLRF   26
259A:  CLRF   27
259C:  CLRF   28
259E:  CLRF   29
25A0:  CLRF   2A
25A2:  CLRF   2B
25A4:  CLRF   2C
25A6:  CLRF   2D
25A8:  MOVLW  01
25AA:  MOVWF  2E
25AC:  CLRF   2F
25AE:  CLRF   30
25B0:  CLRF   31
25B2:  CLRF   32
25B4:  CLRF   33
25B6:  MOVLW  75
25B8:  MOVWF  34
25BA:  CLRF   35
25BC:  CLRF   4A
25BE:  MOVLW  FF
25C0:  MOVWF  4B
25C2:  CLRF   4C
25C4:  CLRF   4D
25C6:  CLRF   4E
25C8:  CLRF   4F
25CA:  CLRF   50
25CC:  CLRF   51
25CE:  CLRF   x79
25D0:  CLRF   x7A
25D2:  CLRF   x7B
25D4:  MOVLW  02
25D6:  MOVWF  x7C
25D8:  CLRF   x7D
25DA:  CLRF   x7E
25DC:  CLRF   x7F
25DE:  CLRF   x86
25E0:  CLRF   x87
25E2:  CLRF   x88
25E4:  CLRF   x89
25E6:  CLRF   x8A
25E8:  CLRF   x8B
25EA:  CLRF   x8C
25EC:  CLRF   x8D
25EE:  CLRF   x8E
25F0:  CLRF   x8F
25F2:  CLRF   x90
25F4:  CLRF   x91
25F6:  CLRF   x92
25F8:  CLRF   x93
25FA:  CLRF   x94
25FC:  CLRF   x95
25FE:  CLRF   x96
2600:  CLRF   x97
2602:  CLRF   x98
2604:  CLRF   x99
2606:  CLRF   x9A
2608:  CLRF   x9B
260A:  CLRF   x9C
260C:  CLRF   x9D
260E:  CLRF   x9E
2610:  CLRF   x9F
2612:  CLRF   xA0
2614:  CLRF   xA1
2616:  CLRF   xA2
2618:  CLRF   xA3
261A:  CLRF   xA4
....................    int16 relay_time,kk; 
....................    int8 act_loop,i; 
....................    init_spi(); 
261C:  GOTO   0596
....................     setup_adc_ports(AN0); 
2620:  BCF    FC1.0
2622:  BSF    FC1.1
2624:  BSF    FC1.2
2626:  BSF    FC1.3
....................     setup_adc(ADC_CLOCK_INTERNAL); 
2628:  BCF    FC1.6
262A:  BSF    FC2.6
262C:  BSF    FC2.7
262E:  BSF    FC1.7
2630:  BSF    FC2.0
....................     set_adc_channel(0); 
2632:  MOVLW  00
2634:  MOVWF  01
2636:  MOVF   FC2,W
2638:  ANDLW  C7
263A:  IORWF  01,W
263C:  MOVWF  FC2
....................    set_tris_a(0xFF); 
263E:  MOVLW  FF
2640:  MOVWF  F92
....................    set_tris_b(0xFF); 
2642:  MOVWF  F93
....................    set_tris_d(0x00); 
2644:  MOVLW  00
2646:  MOVWF  F95
....................     led_status =0xF0; 
2648:  MOVLW  F0
264A:  MOVWF  21
....................    display_LED(); 
264C:  CALL   0144
....................    delay_ms(5000); 
2650:  MOVLW  14
2652:  MOVWF  xAB
2654:  CLRF   18
2656:  BTFSC  FF2.7
2658:  BSF    18.7
265A:  BCF    FF2.7
265C:  MOVLW  FA
265E:  MOVWF  xD2
2660:  CALL   0178
2664:  BTFSC  18.7
2666:  BSF    FF2.7
2668:  DECFSZ xAB,F
266A:  BRA    2654
....................    flag2.is_moving =0; 
266C:  BCF    20.6
....................    while((read_adc()+read_adc()+read_adc()+read_adc())/4 < 650) { 
266E:  BSF    FC2.2
2670:  BTFSC  FC2.2
2672:  BRA    2670
2674:  MOVFF  FC4,03
2678:  MOVFF  FC3,AB
267C:  MOVFF  FC4,AC
2680:  BSF    FC2.2
2682:  BTFSC  FC2.2
2684:  BRA    2682
2686:  MOVFF  FC4,03
268A:  MOVF   FC3,W
268C:  ADDWF  xAB,F
268E:  MOVF   FC4,W
2690:  ADDWFC xAC,F
2692:  BSF    FC2.2
2694:  BTFSC  FC2.2
2696:  BRA    2694
2698:  MOVFF  FC4,03
269C:  MOVF   FC3,W
269E:  ADDWF  xAB,F
26A0:  MOVF   FC4,W
26A2:  ADDWFC xAC,F
26A4:  BSF    FC2.2
26A6:  BTFSC  FC2.2
26A8:  BRA    26A6
26AA:  MOVFF  FC4,03
26AE:  MOVF   FC3,W
26B0:  ADDWF  xAB,F
26B2:  MOVF   FC4,W
26B4:  ADDWFC xAC,F
26B6:  RRCF   xAC,F
26B8:  RRCF   xAB,F
26BA:  RRCF   xAC,F
26BC:  RRCF   xAB,F
26BE:  MOVLW  3F
26C0:  ANDWF  xAC,F
26C2:  MOVF   xAC,W
26C4:  SUBLW  02
26C6:  BNC   270A
26C8:  BNZ   26D0
26CA:  MOVF   xAB,W
26CC:  SUBLW  89
26CE:  BNC   270A
....................        led_status =0xFE; 
26D0:  MOVLW  FE
26D2:  MOVWF  21
....................        display_LED(); 
26D4:  CALL   0144
26D8:  CLRF   18
26DA:  BTFSC  FF2.7
26DC:  BSF    18.7
26DE:  BCF    FF2.7
....................        delay_ms(2); 
26E0:  MOVLW  02
26E2:  MOVWF  xD2
26E4:  CALL   0178
26E8:  BTFSC  18.7
26EA:  BSF    FF2.7
....................        led_status =0xFF; 
26EC:  MOVLW  FF
26EE:  MOVWF  21
....................        display_LED();          
26F0:  CALL   0144
26F4:  CLRF   18
26F6:  BTFSC  FF2.7
26F8:  BSF    18.7
26FA:  BCF    FF2.7
....................        delay_ms(50); 
26FC:  MOVLW  32
26FE:  MOVWF  xD2
2700:  CALL   0178
2704:  BTFSC  18.7
2706:  BSF    FF2.7
....................    } // trap here  until voltage level is good 
2708:  BRA    266E
270A:  CLRF   18
270C:  BTFSC  FF2.7
270E:  BSF    18.7
2710:  BCF    FF2.7
....................    delay_ms(200); 
2712:  MOVLW  C8
2714:  MOVWF  xD2
2716:  CALL   0178
271A:  BTFSC  18.7
271C:  BSF    FF2.7
....................    flag2.power=1; 
271E:  BSF    20.5
....................  
....................  
....................    output_low(TX_EN); 
2720:  BCF    F96.1
2722:  BCF    F8D.1
....................  
....................  
....................    flash_wait_until_ready(); 
2724:  CALL   05E2
....................    flash_read_mfg_id(); 
2728:  GOTO   0606
....................    flash_read_stat(); // stat & 0xBF == 0x9C means device ready 
272C:  CALL   05AE
....................     // check flash readiness here // 
....................     //if (flash_mfg_id[1]==0x24) //4MBit 
....................     //if (flash_mfg_id[1]==0x26) //16MBit 
....................  
....................    read_eeprom_data(); 
2730:  GOTO   067A
....................    read_device_id(); 
2734:  CALL   090A
....................    //print_fw_info(); 
....................     T1CON = 0b00001111;  // 0b10011011 
2738:  MOVLW  0F
273A:  MOVWF  FCD
....................     enable_interrupts(INT_RDA); 
273C:  BSF    F9D.5
....................     enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
273E:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
2740:  MOVLW  C0
2742:  IORWF  FF2,F
....................    init_rs232(); 
2744:  CALL   0124
....................    relay_time =0; 
2748:  CLRF   xA6
274A:  CLRF   xA5
....................    flag2.en_operate =1; 
274C:  BSF    20.0
....................    flag2.button_pressed=0; 
274E:  BCF    20.1
....................    flag2.allow_manual_move_act=0; 
2750:  BCF    20.3
....................    LED_status =0x00; 
2752:  CLRF   21
2754:  CLRF   18
2756:  BTFSC  FF2.7
2758:  BSF    18.7
275A:  BCF    FF2.7
....................  
....................    delay_ms(200); 
275C:  MOVLW  C8
275E:  MOVWF  xD2
2760:  CALL   0178
2764:  BTFSC  18.7
2766:  BSF    FF2.7
....................    while(read_eeprom((int8)0xf00040)!=0x34); 
2768:  MOVFF  FF2,AB
276C:  BCF    FF2.7
276E:  MOVLW  40
2770:  MOVWF  FA9
2772:  BCF    FA6.6
2774:  BCF    FA6.7
2776:  BSF    FA6.0
2778:  MOVF   FA8,W
277A:  BTFSC  xAB.7
277C:  BSF    FF2.7
277E:  SUBLW  34
2780:  BNZ   2768
....................    while(read_eeprom((int8)0xf00041)!=0x12); 
2782:  MOVFF  FF2,AB
2786:  BCF    FF2.7
2788:  MOVLW  41
278A:  MOVWF  FA9
278C:  BCF    FA6.6
278E:  BCF    FA6.7
2790:  BSF    FA6.0
2792:  MOVF   FA8,W
2794:  BTFSC  xAB.7
2796:  BSF    FF2.7
2798:  SUBLW  12
279A:  BNZ   2782
....................    display_LED(); 
279C:  CALL   0144
....................    startup_counter++; 
27A0:  INCF   32,F
27A2:  BTFSC  FD8.2
27A4:  INCF   33,F
....................    write_eeprom_data(0); 
27A6:  CLRF   xAF
27A8:  CALL   0970
....................    solar_load_parameter_from_flash(); 
27AC:  GOTO   0C2A
....................    setup_wdt(WDT_ON); 
27B0:  BSF    FD1.0
....................  
....................    while(1) { 
....................       if (flag.cmd_posted==1) process_cmd_msg(); 
27B2:  BTFSS  1F.3
27B4:  BRA    27BA
27B6:  GOTO   1A9E
....................       if (bit_test(RCSTA,1)==1) init_rs232(); 
27BA:  BTFSS  FAB.1
27BC:  BRA    27C2
27BE:  CALL   0124
....................       for(act_loop=0;act_loop<4;act_loop++) 
27C2:  CLRF   xA9
27C4:  MOVF   xA9,W
27C6:  SUBLW  03
27C8:  BNC   2836
....................       { 
....................          if (bit_test(actuator_move_mask,act_loop)==1){ 
27CA:  MOVFF  A4,00
27CE:  MOVF   xA9,W
27D0:  MOVWF  01
27D2:  BZ    27DC
27D4:  BCF    FD8.0
27D6:  RRCF   00,F
27D8:  DECFSZ 01,F
27DA:  BRA    27D4
27DC:  BTFSS  00.0
27DE:  BRA    2832
....................             if (act_full_stroke_tick[act_loop]>0x0010) { 
27E0:  BCF    FD8.0
27E2:  RLCF   xA9,W
27E4:  CLRF   03
27E6:  ADDLW  90
27E8:  MOVWF  FE9
27EA:  MOVLW  00
27EC:  ADDWFC 03,W
27EE:  MOVWF  FEA
27F0:  MOVFF  FEC,AC
27F4:  MOVF   FED,F
27F6:  MOVFF  FEF,AB
27FA:  MOVF   xAC,F
27FC:  BNZ   2804
27FE:  MOVF   xAB,W
2800:  SUBLW  10
2802:  BC    2832
....................                solar_get_act_length(act_loop); 
2804:  MOVFF  A9,AF
2808:  CALL   1536
....................              actuator_move_execute(act_loop); 
280C:  MOVFF  A9,AF
2810:  CALL   13A6
....................                bit_clear(actuator_move_mask,act_loop); 
2814:  MOVLW  01
2816:  MOVWF  00
2818:  MOVF   xA9,W
281A:  MOVWF  01
281C:  BZ    2826
281E:  BCF    FD8.0
2820:  RLCF   00,F
2822:  DECFSZ 01,F
2824:  BRA    281E
2826:  MOVF   00,W
2828:  XORLW  FF
282A:  ANDWF  xA4,F
....................             write_eeprom_data(0); 
282C:  CLRF   xAF
282E:  CALL   0970
....................             //print_date_time(); 
....................          }  
....................          } 
....................       } 
2832:  INCF   xA9,F
2834:  BRA    27C4
....................  
....................       if (nButton==0) { 
2836:  MOVF   4B,F
2838:  BNZ   283C
....................           button_menu(); 
283A:  BRA    225A
....................       } 
....................       restart_wdt(); 
283C:  CLRWDT
....................         kk = read_adc(); 
283E:  BSF    FC2.2
2840:  BTFSC  FC2.2
2842:  BRA    2840
2844:  MOVFF  FC3,A7
2848:  MOVFF  FC4,A8
....................        if ((read_adc()+read_adc()+read_adc()+read_adc())/4 < 600) sleep(); 
284C:  BSF    FC2.2
284E:  BTFSC  FC2.2
2850:  BRA    284E
2852:  MOVFF  FC4,03
2856:  MOVFF  FC3,AB
285A:  MOVFF  FC4,AC
285E:  BSF    FC2.2
2860:  BTFSC  FC2.2
2862:  BRA    2860
2864:  MOVFF  FC4,03
2868:  MOVF   FC3,W
286A:  ADDWF  xAB,F
286C:  MOVF   FC4,W
286E:  ADDWFC xAC,F
2870:  BSF    FC2.2
2872:  BTFSC  FC2.2
2874:  BRA    2872
2876:  MOVFF  FC4,03
287A:  MOVF   FC3,W
287C:  ADDWF  xAB,F
287E:  MOVF   FC4,W
2880:  ADDWFC xAC,F
2882:  BSF    FC2.2
2884:  BTFSC  FC2.2
2886:  BRA    2884
2888:  MOVFF  FC4,03
288C:  MOVF   FC3,W
288E:  ADDWF  xAB,F
2890:  MOVF   FC4,W
2892:  ADDWFC xAC,F
2894:  RRCF   xAC,F
2896:  RRCF   xAB,F
2898:  RRCF   xAC,F
289A:  RRCF   xAB,F
289C:  MOVLW  3F
289E:  ANDWF  xAC,F
28A0:  MOVF   xAC,W
28A2:  SUBLW  02
28A4:  BNC   28B0
28A6:  BNZ   28AE
28A8:  MOVF   xAB,W
28AA:  SUBLW  57
28AC:  BTFSC  FD8.0
28AE:  SLEEP 
....................    } 
28B0:  BRA    27B2
....................  
.................... DEAD_TRAP: while(1); 
28B2:  BRA    28B2
.................... } 
28B4:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E000   WRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 7E 04 7F 03 80 02 81 01 

F00010: 00 00 01 00 02 00 03 00 

F00020: 00 00 00 00 01 00 00 00 

F00030: 00 00 

F00040: 34 12 

F00050: FE FF 
