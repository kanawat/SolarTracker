CCS PCH C Compiler, Version 4.078, 38112               23-Jun-10 23:38

               Filename: classicmain.lst

               ROM used: 16860 bytes (51%)
                         Largest free fragment is 15904
               RAM used: 177 (12%) at main() level
                         218 (14%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
0000:  GOTO   3E10
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   06F2
0058:  BTFSS  F9D.5
005A:  GOTO   0064
005E:  BTFSC  F9E.5
0060:  GOTO   0876
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  BSF    0E.7
007A:  MOVFF  0D,FE9
007E:  MOVFF  08,FEA
0082:  MOVFF  09,FE1
0086:  MOVFF  0A,FE2
008A:  MOVFF  0B,FD9
008E:  MOVFF  0C,FDA
0092:  MOVFF  14,FF3
0096:  MOVFF  15,FF4
009A:  MOVFF  16,FFA
009E:  MOVF   05,W
00A0:  MOVFF  07,FE0
00A4:  MOVFF  06,FD8
00A8:  RETFIE 0
.................... #include <classic_solar_lib.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1D98:  MOVFF  B2,B4
1D9C:  MOVFF  B1,B3
1DA0:  MOVFF  B4,03
1DA4:  MOVFF  B3,FE9
1DA8:  MOVFF  B4,FEA
1DAC:  MOVF   FEF,F
1DAE:  BZ    1DB8
1DB0:  INCF   xB3,F
1DB2:  BTFSC  FD8.2
1DB4:  INCF   xB4,F
1DB6:  BRA    1DA0
....................    return(sc - s); 
1DB8:  MOVF   xB1,W
1DBA:  SUBWF  xB3,W
1DBC:  MOVWF  00
1DBE:  MOVF   xB2,W
1DC0:  SUBWFB xB4,W
1DC2:  MOVWF  03
1DC4:  MOVFF  00,01
.................... } 
1DC8:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
28CE:  CLRF   xB4
....................    sign = 0; 
28D0:  CLRF   xB2
....................    base = 10; 
28D2:  MOVLW  0A
28D4:  MOVWF  xB3
....................    result = 0; 
28D6:  CLRF   xB1
....................  
....................    if (!s) 
28D8:  MOVF   xAF,W
28DA:  IORWF  xB0,W
28DC:  BNZ   28E4
....................       return 0; 
28DE:  MOVLW  00
28E0:  MOVWF  01
28E2:  BRA    2A66
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
28E4:  MOVF   xB4,W
28E6:  INCF   xB4,F
28E8:  CLRF   03
28EA:  ADDWF  xAF,W
28EC:  MOVWF  FE9
28EE:  MOVF   xB0,W
28F0:  ADDWFC 03,W
28F2:  MOVWF  FEA
28F4:  MOVFF  FEF,B5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
28F8:  MOVF   xB5,W
28FA:  SUBLW  2D
28FC:  BNZ   2918
....................    { 
....................       sign = 1;         // Set the sign to negative 
28FE:  MOVLW  01
2900:  MOVWF  xB2
....................       c = s[index++]; 
2902:  MOVF   xB4,W
2904:  INCF   xB4,F
2906:  CLRF   03
2908:  ADDWF  xAF,W
290A:  MOVWF  FE9
290C:  MOVF   xB0,W
290E:  ADDWFC 03,W
2910:  MOVWF  FEA
2912:  MOVFF  FEF,B5
....................    } 
....................    else if (c == '+') 
2916:  BRA    2932
2918:  MOVF   xB5,W
291A:  SUBLW  2B
291C:  BNZ   2932
....................    { 
....................       c = s[index++]; 
291E:  MOVF   xB4,W
2920:  INCF   xB4,F
2922:  CLRF   03
2924:  ADDWF  xAF,W
2926:  MOVWF  FE9
2928:  MOVF   xB0,W
292A:  ADDWFC 03,W
292C:  MOVWF  FEA
292E:  MOVFF  FEF,B5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2932:  MOVF   xB5,W
2934:  SUBLW  2F
2936:  BTFSC  FD8.0
2938:  BRA    2A56
293A:  MOVF   xB5,W
293C:  SUBLW  39
293E:  BTFSS  FD8.0
2940:  BRA    2A56
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2942:  MOVF   xB5,W
2944:  SUBLW  30
2946:  BNZ   298A
2948:  CLRF   03
294A:  MOVF   xB4,W
294C:  ADDWF  xAF,W
294E:  MOVWF  FE9
2950:  MOVF   xB0,W
2952:  ADDWFC 03,W
2954:  MOVWF  FEA
2956:  MOVF   FEF,W
2958:  SUBLW  78
295A:  BZ    2970
295C:  CLRF   03
295E:  MOVF   xB4,W
2960:  ADDWF  xAF,W
2962:  MOVWF  FE9
2964:  MOVF   xB0,W
2966:  ADDWFC 03,W
2968:  MOVWF  FEA
296A:  MOVF   FEF,W
296C:  SUBLW  58
296E:  BNZ   298A
....................       { 
....................          base = 16; 
2970:  MOVLW  10
2972:  MOVWF  xB3
....................          index++; 
2974:  INCF   xB4,F
....................          c = s[index++]; 
2976:  MOVF   xB4,W
2978:  INCF   xB4,F
297A:  CLRF   03
297C:  ADDWF  xAF,W
297E:  MOVWF  FE9
2980:  MOVF   xB0,W
2982:  ADDWFC 03,W
2984:  MOVWF  FEA
2986:  MOVFF  FEF,B5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
298A:  MOVF   xB3,W
298C:  SUBLW  0A
298E:  BNZ   29C6
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
2990:  MOVF   xB5,W
2992:  SUBLW  2F
2994:  BC    29C4
2996:  MOVF   xB5,W
2998:  SUBLW  39
299A:  BNC   29C4
....................             result = 10*result + (c - '0'); 
299C:  MOVLW  0A
299E:  MOVWF  xB6
29A0:  MOVFF  B1,B7
29A4:  RCALL  2884
29A6:  MOVLW  30
29A8:  SUBWF  xB5,W
29AA:  ADDWF  01,W
29AC:  MOVWF  xB1
....................             c = s[index++]; 
29AE:  MOVF   xB4,W
29B0:  INCF   xB4,F
29B2:  CLRF   03
29B4:  ADDWF  xAF,W
29B6:  MOVWF  FE9
29B8:  MOVF   xB0,W
29BA:  ADDWFC 03,W
29BC:  MOVWF  FEA
29BE:  MOVFF  FEF,B5
....................          } 
29C2:  BRA    2990
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
29C4:  BRA    2A56
29C6:  MOVF   xB3,W
29C8:  SUBLW  10
29CA:  BNZ   2A56
....................       { 
....................          c = toupper(c); 
29CC:  MOVF   xB5,W
29CE:  SUBLW  60
29D0:  BC    29DE
29D2:  MOVF   xB5,W
29D4:  SUBLW  7A
29D6:  BNC   29DE
29D8:  MOVF   xB5,W
29DA:  ANDLW  DF
29DC:  BRA    29E0
29DE:  MOVF   xB5,W
29E0:  MOVWF  xB5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
29E2:  MOVF   xB5,W
29E4:  SUBLW  2F
29E6:  BC    29EE
29E8:  MOVF   xB5,W
29EA:  SUBLW  39
29EC:  BC    29FA
29EE:  MOVF   xB5,W
29F0:  SUBLW  40
29F2:  BC    2A56
29F4:  MOVF   xB5,W
29F6:  SUBLW  46
29F8:  BNC   2A56
....................             if (c >= '0' && c <= '9') 
29FA:  MOVF   xB5,W
29FC:  SUBLW  2F
29FE:  BC    2A18
2A00:  MOVF   xB5,W
2A02:  SUBLW  39
2A04:  BNC   2A18
....................                result = (result << 4) + (c - '0'); 
2A06:  SWAPF  xB1,W
2A08:  MOVWF  xB6
2A0A:  MOVLW  F0
2A0C:  ANDWF  xB6,F
2A0E:  MOVLW  30
2A10:  SUBWF  xB5,W
2A12:  ADDWF  xB6,W
2A14:  MOVWF  xB1
....................             else 
2A16:  BRA    2A2A
....................                result = (result << 4) + (c - 'A' + 10); 
2A18:  SWAPF  xB1,W
2A1A:  MOVWF  xB6
2A1C:  MOVLW  F0
2A1E:  ANDWF  xB6,F
2A20:  MOVLW  41
2A22:  SUBWF  xB5,W
2A24:  ADDLW  0A
2A26:  ADDWF  xB6,W
2A28:  MOVWF  xB1
....................  
....................             c = s[index++]; 
2A2A:  MOVF   xB4,W
2A2C:  INCF   xB4,F
2A2E:  CLRF   03
2A30:  ADDWF  xAF,W
2A32:  MOVWF  FE9
2A34:  MOVF   xB0,W
2A36:  ADDWFC 03,W
2A38:  MOVWF  FEA
2A3A:  MOVFF  FEF,B5
....................             c = toupper(c); 
2A3E:  MOVF   xB5,W
2A40:  SUBLW  60
2A42:  BC    2A50
2A44:  MOVF   xB5,W
2A46:  SUBLW  7A
2A48:  BNC   2A50
2A4A:  MOVF   xB5,W
2A4C:  ANDLW  DF
2A4E:  BRA    2A52
2A50:  MOVF   xB5,W
2A52:  MOVWF  xB5
....................          } 
2A54:  BRA    29E2
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
2A56:  DECFSZ xB2,W
2A58:  BRA    2A62
2A5A:  MOVF   xB3,W
2A5C:  SUBLW  0A
2A5E:  BNZ   2A62
....................        result = -result; 
2A60:  NEGF   xB1
....................  
....................    return(result); 
2A62:  MOVFF  B1,01
.................... } 
2A66:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
13D4:  CLRF   xB4
....................    sign = 0; 
13D6:  CLRF   xB2
....................    base = 10; 
13D8:  MOVLW  0A
13DA:  MOVWF  xB3
....................    result = 0; 
13DC:  CLRF   xB1
13DE:  CLRF   xB0
....................  
....................    if (!s) 
13E0:  MOVF   xAE,W
13E2:  IORWF  xAF,W
13E4:  BNZ   13EE
....................       return 0; 
13E6:  MOVLW  00
13E8:  MOVWF  01
13EA:  MOVWF  02
13EC:  BRA    15BA
....................    c = s[index++]; 
13EE:  MOVF   xB4,W
13F0:  INCF   xB4,F
13F2:  CLRF   03
13F4:  ADDWF  xAE,W
13F6:  MOVWF  FE9
13F8:  MOVF   xAF,W
13FA:  ADDWFC 03,W
13FC:  MOVWF  FEA
13FE:  MOVFF  FEF,B5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1402:  MOVF   xB5,W
1404:  SUBLW  2D
1406:  BNZ   1422
....................    { 
....................       sign = 1;         // Set the sign to negative 
1408:  MOVLW  01
140A:  MOVWF  xB2
....................       c = s[index++]; 
140C:  MOVF   xB4,W
140E:  INCF   xB4,F
1410:  CLRF   03
1412:  ADDWF  xAE,W
1414:  MOVWF  FE9
1416:  MOVF   xAF,W
1418:  ADDWFC 03,W
141A:  MOVWF  FEA
141C:  MOVFF  FEF,B5
....................    } 
....................    else if (c == '+') 
1420:  BRA    143C
1422:  MOVF   xB5,W
1424:  SUBLW  2B
1426:  BNZ   143C
....................    { 
....................       c = s[index++]; 
1428:  MOVF   xB4,W
142A:  INCF   xB4,F
142C:  CLRF   03
142E:  ADDWF  xAE,W
1430:  MOVWF  FE9
1432:  MOVF   xAF,W
1434:  ADDWFC 03,W
1436:  MOVWF  FEA
1438:  MOVFF  FEF,B5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
143C:  MOVF   xB5,W
143E:  SUBLW  2F
1440:  BTFSC  FD8.0
1442:  BRA    159E
1444:  MOVF   xB5,W
1446:  SUBLW  39
1448:  BTFSS  FD8.0
144A:  BRA    159E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
144C:  MOVF   xB5,W
144E:  SUBLW  30
1450:  BNZ   1494
1452:  CLRF   03
1454:  MOVF   xB4,W
1456:  ADDWF  xAE,W
1458:  MOVWF  FE9
145A:  MOVF   xAF,W
145C:  ADDWFC 03,W
145E:  MOVWF  FEA
1460:  MOVF   FEF,W
1462:  SUBLW  78
1464:  BZ    147A
1466:  CLRF   03
1468:  MOVF   xB4,W
146A:  ADDWF  xAE,W
146C:  MOVWF  FE9
146E:  MOVF   xAF,W
1470:  ADDWFC 03,W
1472:  MOVWF  FEA
1474:  MOVF   FEF,W
1476:  SUBLW  58
1478:  BNZ   1494
....................       { 
....................          base = 16; 
147A:  MOVLW  10
147C:  MOVWF  xB3
....................          index++; 
147E:  INCF   xB4,F
....................          c = s[index++]; 
1480:  MOVF   xB4,W
1482:  INCF   xB4,F
1484:  CLRF   03
1486:  ADDWF  xAE,W
1488:  MOVWF  FE9
148A:  MOVF   xAF,W
148C:  ADDWFC 03,W
148E:  MOVWF  FEA
1490:  MOVFF  FEF,B5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1494:  MOVF   xB3,W
1496:  SUBLW  0A
1498:  BNZ   14DC
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
149A:  MOVF   xB5,W
149C:  SUBLW  2F
149E:  BC    14DA
14A0:  MOVF   xB5,W
14A2:  SUBLW  39
14A4:  BNC   14DA
....................             result = 10*result + (c - '0'); 
14A6:  CLRF   xB7
14A8:  MOVLW  0A
14AA:  MOVWF  xB6
14AC:  MOVFF  B1,B9
14B0:  MOVFF  B0,B8
14B4:  BRA    13B4
14B6:  MOVLW  30
14B8:  SUBWF  xB5,W
14BA:  ADDWF  01,W
14BC:  MOVWF  xB0
14BE:  MOVLW  00
14C0:  ADDWFC 02,W
14C2:  MOVWF  xB1
....................             c = s[index++]; 
14C4:  MOVF   xB4,W
14C6:  INCF   xB4,F
14C8:  CLRF   03
14CA:  ADDWF  xAE,W
14CC:  MOVWF  FE9
14CE:  MOVF   xAF,W
14D0:  ADDWFC 03,W
14D2:  MOVWF  FEA
14D4:  MOVFF  FEF,B5
....................          } 
14D8:  BRA    149A
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
14DA:  BRA    159E
14DC:  MOVF   xB3,W
14DE:  SUBLW  10
14E0:  BNZ   159E
....................       { 
....................          c = toupper(c); 
14E2:  MOVF   xB5,W
14E4:  SUBLW  60
14E6:  BC    14F4
14E8:  MOVF   xB5,W
14EA:  SUBLW  7A
14EC:  BNC   14F4
14EE:  MOVF   xB5,W
14F0:  ANDLW  DF
14F2:  BRA    14F6
14F4:  MOVF   xB5,W
14F6:  MOVWF  xB5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
14F8:  MOVF   xB5,W
14FA:  SUBLW  2F
14FC:  BC    1504
14FE:  MOVF   xB5,W
1500:  SUBLW  39
1502:  BC    1510
1504:  MOVF   xB5,W
1506:  SUBLW  40
1508:  BC    159E
150A:  MOVF   xB5,W
150C:  SUBLW  46
150E:  BNC   159E
....................             if (c >= '0' && c <= '9') 
1510:  MOVF   xB5,W
1512:  SUBLW  2F
1514:  BC    1548
1516:  MOVF   xB5,W
1518:  SUBLW  39
151A:  BNC   1548
....................                result = (result << 4) + (c - '0'); 
151C:  RLCF   xB0,W
151E:  MOVWF  xB6
1520:  RLCF   xB1,W
1522:  MOVWF  xB7
1524:  RLCF   xB6,F
1526:  RLCF   xB7,F
1528:  RLCF   xB6,F
152A:  RLCF   xB7,F
152C:  RLCF   xB6,F
152E:  RLCF   xB7,F
1530:  MOVLW  F0
1532:  ANDWF  xB6,F
1534:  MOVLW  30
1536:  SUBWF  xB5,W
1538:  ADDWF  xB6,W
153A:  MOVWF  01
153C:  MOVLW  00
153E:  ADDWFC xB7,W
1540:  MOVFF  01,B0
1544:  MOVWF  xB1
....................             else 
1546:  BRA    1574
....................                result = (result << 4) + (c - 'A' + 10); 
1548:  RLCF   xB0,W
154A:  MOVWF  xB6
154C:  RLCF   xB1,W
154E:  MOVWF  xB7
1550:  RLCF   xB6,F
1552:  RLCF   xB7,F
1554:  RLCF   xB6,F
1556:  RLCF   xB7,F
1558:  RLCF   xB6,F
155A:  RLCF   xB7,F
155C:  MOVLW  F0
155E:  ANDWF  xB6,F
1560:  MOVLW  41
1562:  SUBWF  xB5,W
1564:  ADDLW  0A
1566:  ADDWF  xB6,W
1568:  MOVWF  01
156A:  MOVLW  00
156C:  ADDWFC xB7,W
156E:  MOVFF  01,B0
1572:  MOVWF  xB1
....................  
....................             c = s[index++];c = toupper(c); 
1574:  MOVF   xB4,W
1576:  INCF   xB4,F
1578:  CLRF   03
157A:  ADDWF  xAE,W
157C:  MOVWF  FE9
157E:  MOVF   xAF,W
1580:  ADDWFC 03,W
1582:  MOVWF  FEA
1584:  MOVF   FEF,W
1586:  MOVWF  xB5
1588:  SUBLW  60
158A:  BC    1598
158C:  MOVF   xB5,W
158E:  SUBLW  7A
1590:  BNC   1598
1592:  MOVF   xB5,W
1594:  ANDLW  DF
1596:  BRA    159A
1598:  MOVF   xB5,W
159A:  MOVWF  xB5
....................          } 
159C:  BRA    14F8
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
159E:  MOVF   xB3,W
15A0:  SUBLW  0A
15A2:  BNZ   15B2
15A4:  DECFSZ xB2,W
15A6:  BRA    15B2
....................       result = -result; 
15A8:  COMF   xB0,F
15AA:  COMF   xB1,F
15AC:  INCF   xB0,F
15AE:  BTFSC  FD8.2
15B0:  INCF   xB1,F
....................  
....................    return(result); 
15B2:  MOVFF  B0,01
15B6:  MOVFF  B1,02
.................... } 
15BA:  RETLW  00
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
25E6:  CLRF   xB6
....................    sign = 0; 
25E8:  CLRF   xB4
....................    base = 10; 
25EA:  MOVLW  0A
25EC:  MOVWF  xB5
....................    result = 0; 
25EE:  CLRF   xB3
25F0:  CLRF   xB2
25F2:  CLRF   xB1
25F4:  CLRF   xB0
....................  
....................    if (!s) 
25F6:  MOVF   xAE,W
25F8:  IORWF  xAF,W
25FA:  BNZ   2606
....................       return 0; 
25FC:  CLRF   00
25FE:  CLRF   01
2600:  CLRF   02
2602:  CLRF   03
2604:  BRA    2880
....................    c = s[index++]; 
2606:  MOVF   xB6,W
2608:  INCF   xB6,F
260A:  CLRF   03
260C:  ADDWF  xAE,W
260E:  MOVWF  FE9
2610:  MOVF   xAF,W
2612:  ADDWFC 03,W
2614:  MOVWF  FEA
2616:  MOVFF  FEF,B7
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
261A:  MOVF   xB7,W
261C:  SUBLW  2D
261E:  BNZ   263A
....................    { 
....................       sign = 1;         // Set the sign to negative 
2620:  MOVLW  01
2622:  MOVWF  xB4
....................       c = s[index++]; 
2624:  MOVF   xB6,W
2626:  INCF   xB6,F
2628:  CLRF   03
262A:  ADDWF  xAE,W
262C:  MOVWF  FE9
262E:  MOVF   xAF,W
2630:  ADDWFC 03,W
2632:  MOVWF  FEA
2634:  MOVFF  FEF,B7
....................    } 
....................    else if (c == '+') 
2638:  BRA    2654
263A:  MOVF   xB7,W
263C:  SUBLW  2B
263E:  BNZ   2654
....................    { 
....................       c = s[index++]; 
2640:  MOVF   xB6,W
2642:  INCF   xB6,F
2644:  CLRF   03
2646:  ADDWF  xAE,W
2648:  MOVWF  FE9
264A:  MOVF   xAF,W
264C:  ADDWFC 03,W
264E:  MOVWF  FEA
2650:  MOVFF  FEF,B7
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2654:  MOVF   xB7,W
2656:  SUBLW  2F
2658:  BTFSC  FD8.0
265A:  BRA    2850
265C:  MOVF   xB7,W
265E:  SUBLW  39
2660:  BTFSS  FD8.0
2662:  BRA    2850
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2664:  MOVF   xB7,W
2666:  SUBLW  30
2668:  BNZ   26AC
266A:  CLRF   03
266C:  MOVF   xB6,W
266E:  ADDWF  xAE,W
2670:  MOVWF  FE9
2672:  MOVF   xAF,W
2674:  ADDWFC 03,W
2676:  MOVWF  FEA
2678:  MOVF   FEF,W
267A:  SUBLW  78
267C:  BZ    2692
267E:  CLRF   03
2680:  MOVF   xB6,W
2682:  ADDWF  xAE,W
2684:  MOVWF  FE9
2686:  MOVF   xAF,W
2688:  ADDWFC 03,W
268A:  MOVWF  FEA
268C:  MOVF   FEF,W
268E:  SUBLW  58
2690:  BNZ   26AC
....................       { 
....................          base = 16; 
2692:  MOVLW  10
2694:  MOVWF  xB5
....................          index++; 
2696:  INCF   xB6,F
....................          c = s[index++]; 
2698:  MOVF   xB6,W
269A:  INCF   xB6,F
269C:  CLRF   03
269E:  ADDWF  xAE,W
26A0:  MOVWF  FE9
26A2:  MOVF   xAF,W
26A4:  ADDWFC 03,W
26A6:  MOVWF  FEA
26A8:  MOVFF  FEF,B7
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
26AC:  MOVF   xB5,W
26AE:  SUBLW  0A
26B0:  BNZ   273A
....................       { 
....................          while (c >= '0' && c <= '9') { 
26B2:  MOVF   xB7,W
26B4:  SUBLW  2F
26B6:  BC    2738
26B8:  MOVF   xB7,W
26BA:  SUBLW  39
26BC:  BNC   2738
....................             result = (result << 1) + (result << 3);  // result *= 10; 
26BE:  BCF    FD8.0
26C0:  RLCF   xB0,W
26C2:  MOVWF  xB9
26C4:  RLCF   xB1,W
26C6:  MOVWF  xBA
26C8:  RLCF   xB2,W
26CA:  MOVWF  xBB
26CC:  RLCF   xB3,W
26CE:  MOVWF  xBC
26D0:  RLCF   xB0,W
26D2:  MOVWF  00
26D4:  RLCF   xB1,W
26D6:  MOVWF  01
26D8:  RLCF   xB2,W
26DA:  MOVWF  02
26DC:  RLCF   xB3,W
26DE:  MOVWF  03
26E0:  RLCF   00,F
26E2:  RLCF   01,F
26E4:  RLCF   02,F
26E6:  RLCF   03,F
26E8:  RLCF   00,F
26EA:  RLCF   01,F
26EC:  RLCF   02,F
26EE:  RLCF   03,F
26F0:  MOVLW  F8
26F2:  ANDWF  00,F
26F4:  MOVF   xB9,W
26F6:  ADDWF  00,F
26F8:  MOVF   xBA,W
26FA:  ADDWFC 01,F
26FC:  MOVF   xBB,W
26FE:  ADDWFC 02,F
2700:  MOVF   xBC,W
2702:  ADDWFC 03,F
2704:  MOVFF  03,B3
2708:  MOVFF  02,B2
270C:  MOVFF  01,B1
2710:  MOVFF  00,B0
....................             result += (c - '0'); 
2714:  MOVLW  30
2716:  SUBWF  xB7,W
2718:  ADDWF  xB0,F
271A:  MOVLW  00
271C:  ADDWFC xB1,F
271E:  ADDWFC xB2,F
2720:  ADDWFC xB3,F
....................             c = s[index++]; 
2722:  MOVF   xB6,W
2724:  INCF   xB6,F
2726:  CLRF   03
2728:  ADDWF  xAE,W
272A:  MOVWF  FE9
272C:  MOVF   xAF,W
272E:  ADDWFC 03,W
2730:  MOVWF  FEA
2732:  MOVFF  FEF,B7
....................          } 
2736:  BRA    26B2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2738:  BRA    2850
273A:  MOVF   xB5,W
273C:  SUBLW  10
273E:  BTFSS  FD8.2
2740:  BRA    2850
....................       { 
....................          c = toupper(c); 
2742:  MOVF   xB7,W
2744:  SUBLW  60
2746:  BC    2754
2748:  MOVF   xB7,W
274A:  SUBLW  7A
274C:  BNC   2754
274E:  MOVF   xB7,W
2750:  ANDLW  DF
2752:  BRA    2756
2754:  MOVF   xB7,W
2756:  MOVWF  xB7
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
2758:  MOVF   xB7,W
275A:  SUBLW  2F
275C:  BC    2764
275E:  MOVF   xB7,W
2760:  SUBLW  39
2762:  BC    2772
2764:  MOVF   xB7,W
2766:  SUBLW  40
2768:  BTFSC  FD8.0
276A:  BRA    2850
276C:  MOVF   xB7,W
276E:  SUBLW  46
2770:  BNC   2850
....................             if (c >= '0' && c <= '9') 
2772:  MOVF   xB7,W
2774:  SUBLW  2F
2776:  BC    27D2
2778:  MOVF   xB7,W
277A:  SUBLW  39
277C:  BNC   27D2
....................                result = (result << 4) + (c - '0'); 
277E:  RLCF   xB0,W
2780:  MOVWF  xB9
2782:  RLCF   xB1,W
2784:  MOVWF  xBA
2786:  RLCF   xB2,W
2788:  MOVWF  xBB
278A:  RLCF   xB3,W
278C:  MOVWF  xBC
278E:  RLCF   xB9,F
2790:  RLCF   xBA,F
2792:  RLCF   xBB,F
2794:  RLCF   xBC,F
2796:  RLCF   xB9,F
2798:  RLCF   xBA,F
279A:  RLCF   xBB,F
279C:  RLCF   xBC,F
279E:  RLCF   xB9,F
27A0:  RLCF   xBA,F
27A2:  RLCF   xBB,F
27A4:  RLCF   xBC,F
27A6:  MOVLW  F0
27A8:  ANDWF  xB9,F
27AA:  MOVLW  30
27AC:  SUBWF  xB7,W
27AE:  ADDWF  xB9,W
27B0:  MOVWF  00
27B2:  MOVLW  00
27B4:  ADDWFC xBA,W
27B6:  MOVWF  01
27B8:  MOVLW  00
27BA:  ADDWFC xBB,W
27BC:  MOVWF  02
27BE:  MOVLW  00
27C0:  ADDWFC xBC,W
27C2:  MOVWF  xB3
27C4:  MOVFF  02,B2
27C8:  MOVFF  01,B1
27CC:  MOVFF  00,B0
....................             else 
27D0:  BRA    2826
....................                result = (result << 4) + (c - 'A' + 10); 
27D2:  RLCF   xB0,W
27D4:  MOVWF  xB9
27D6:  RLCF   xB1,W
27D8:  MOVWF  xBA
27DA:  RLCF   xB2,W
27DC:  MOVWF  xBB
27DE:  RLCF   xB3,W
27E0:  MOVWF  xBC
27E2:  RLCF   xB9,F
27E4:  RLCF   xBA,F
27E6:  RLCF   xBB,F
27E8:  RLCF   xBC,F
27EA:  RLCF   xB9,F
27EC:  RLCF   xBA,F
27EE:  RLCF   xBB,F
27F0:  RLCF   xBC,F
27F2:  RLCF   xB9,F
27F4:  RLCF   xBA,F
27F6:  RLCF   xBB,F
27F8:  RLCF   xBC,F
27FA:  MOVLW  F0
27FC:  ANDWF  xB9,F
27FE:  MOVLW  41
2800:  SUBWF  xB7,W
2802:  ADDLW  0A
2804:  ADDWF  xB9,W
2806:  MOVWF  00
2808:  MOVLW  00
280A:  ADDWFC xBA,W
280C:  MOVWF  01
280E:  MOVLW  00
2810:  ADDWFC xBB,W
2812:  MOVWF  02
2814:  MOVLW  00
2816:  ADDWFC xBC,W
2818:  MOVWF  xB3
281A:  MOVFF  02,B2
281E:  MOVFF  01,B1
2822:  MOVFF  00,B0
....................  
....................             c = s[index++];c = toupper(c); 
2826:  MOVF   xB6,W
2828:  INCF   xB6,F
282A:  CLRF   03
282C:  ADDWF  xAE,W
282E:  MOVWF  FE9
2830:  MOVF   xAF,W
2832:  ADDWFC 03,W
2834:  MOVWF  FEA
2836:  MOVF   FEF,W
2838:  MOVWF  xB7
283A:  SUBLW  60
283C:  BC    284A
283E:  MOVF   xB7,W
2840:  SUBLW  7A
2842:  BNC   284A
2844:  MOVF   xB7,W
2846:  ANDLW  DF
2848:  BRA    284C
284A:  MOVF   xB7,W
284C:  MOVWF  xB7
....................          } 
284E:  BRA    2758
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
2850:  MOVF   xB5,W
2852:  SUBLW  0A
2854:  BNZ   2870
2856:  DECFSZ xB4,W
2858:  BRA    2870
....................       result = -result; 
285A:  COMF   xB0,F
285C:  COMF   xB1,F
285E:  COMF   xB2,F
2860:  COMF   xB3,F
2862:  INCF   xB0,F
2864:  BTFSC  FD8.2
2866:  INCF   xB1,F
2868:  BTFSC  FD8.2
286A:  INCF   xB2,F
286C:  BTFSC  FD8.2
286E:  INCF   xB3,F
....................  
....................    return(result); 
2870:  MOVFF  B0,00
2874:  MOVFF  B1,01
2878:  MOVFF  B2,02
287C:  MOVFF  B3,03
.................... } 
2880:  GOTO   3794 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
*
1BC4:  MOVLW  01
1BC6:  MOVWF  xBC
1BC8:  CLRF   xBD
1BCA:  CLRF   xBE
1BCC:  CLRF   xBF
....................      unsigned int8 i,sign=0,cnt=0; 
1BCE:  CLRF   xC1
1BD0:  CLRF   xC2
....................      char c; 
....................  
....................      if(num<0) { 
1BD2:  BTFSC  xB8.7
1BD4:  BRA    1BD8
1BD6:  BRA    1C08
....................          sign=1;        // Check for negative number 
1BD8:  MOVLW  01
1BDA:  MOVWF  xC1
....................          num*=-1; 
1BDC:  MOVFF  B8,C7
1BE0:  MOVFF  B7,C6
1BE4:  MOVFF  B6,C5
1BE8:  MOVFF  B5,C4
1BEC:  MOVLW  FF
1BEE:  MOVWF  xCB
1BF0:  MOVWF  xCA
1BF2:  MOVWF  xC9
1BF4:  MOVWF  xC8
1BF6:  RCALL  1AA0
1BF8:  MOVFF  03,B8
1BFC:  MOVFF  02,B7
1C00:  MOVFF  01,B6
1C04:  MOVFF  00,B5
....................      } 
....................  
....................      while(temp>0) { 
1C08:  MOVF   xBC,F
1C0A:  BNZ   1C18
1C0C:  MOVF   xBD,F
1C0E:  BNZ   1C18
1C10:  MOVF   xBE,F
1C12:  BNZ   1C18
1C14:  MOVF   xBF,F
1C16:  BZ    1CFE
....................          temp=(num/base); 
1C18:  MOVFF  B8,CB
1C1C:  MOVFF  B7,CA
1C20:  MOVFF  B6,C9
1C24:  MOVFF  B5,C8
1C28:  CLRF   xCF
1C2A:  CLRF   xCE
1C2C:  CLRF   xCD
1C2E:  MOVFF  B9,CC
1C32:  RCALL  1AF4
1C34:  MOVFF  03,BF
1C38:  MOVFF  02,BE
1C3C:  MOVFF  01,BD
1C40:  MOVFF  00,BC
....................          s[cnt]=(num%base)+'0';    // Conversion 
1C44:  CLRF   03
1C46:  MOVF   xC2,W
1C48:  ADDWF  xBA,W
1C4A:  MOVWF  01
1C4C:  MOVF   xBB,W
1C4E:  ADDWFC 03,F
1C50:  MOVFF  01,C4
1C54:  MOVFF  03,C5
1C58:  MOVFF  FEA,C7
1C5C:  MOVFF  FE9,C6
1C60:  MOVFF  B8,CB
1C64:  MOVFF  B7,CA
1C68:  MOVFF  B6,C9
1C6C:  MOVFF  B5,C8
1C70:  CLRF   xCF
1C72:  CLRF   xCE
1C74:  CLRF   xCD
1C76:  MOVFF  B9,CC
1C7A:  RCALL  1AF4
1C7C:  MOVFF  FEF,00
1C80:  MOVFF  FEC,01
1C84:  MOVFF  FEC,02
1C88:  MOVFF  FEC,03
1C8C:  MOVFF  C7,FEA
1C90:  MOVFF  C6,FE9
1C94:  MOVFF  03,CB
1C98:  MOVFF  02,CA
1C9C:  MOVFF  01,C9
1CA0:  MOVFF  00,C8
1CA4:  MOVLW  30
1CA6:  ADDWF  00,W
1CA8:  MOVWF  00
1CAA:  MOVLW  00
1CAC:  ADDWFC 01,W
1CAE:  MOVLW  00
1CB0:  ADDWFC 02,W
1CB2:  MOVLW  00
1CB4:  ADDWFC 03,W
1CB6:  MOVFF  C5,FEA
1CBA:  MOVFF  C4,FE9
1CBE:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
1CC2:  CLRF   03
1CC4:  MOVF   xC2,W
1CC6:  ADDWF  xBA,W
1CC8:  MOVWF  FE9
1CCA:  MOVF   xBB,W
1CCC:  ADDWFC 03,W
1CCE:  MOVWF  FEA
1CD0:  MOVF   FEF,W
1CD2:  SUBLW  39
1CD4:  BC    1CEA
....................             s[cnt]+=0x7; 
1CD6:  CLRF   03
1CD8:  MOVF   xC2,W
1CDA:  ADDWF  xBA,W
1CDC:  MOVWF  FE9
1CDE:  MOVF   xBB,W
1CE0:  ADDWFC 03,W
1CE2:  MOVWF  FEA
1CE4:  MOVLW  07
1CE6:  ADDWF  FEF,W
1CE8:  MOVWF  FEF
....................  
....................          cnt++; 
1CEA:  INCF   xC2,F
....................          num=temp; 
1CEC:  MOVFF  BF,B8
1CF0:  MOVFF  BE,B7
1CF4:  MOVFF  BD,B6
1CF8:  MOVFF  BC,B5
....................      } 
1CFC:  BRA    1C08
....................  
....................      if(sign==1) { 
1CFE:  DECFSZ xC1,W
1D00:  BRA    1D16
....................          s[cnt]=0x2D;      // Negative sign 
1D02:  CLRF   03
1D04:  MOVF   xC2,W
1D06:  ADDWF  xBA,W
1D08:  MOVWF  FE9
1D0A:  MOVF   xBB,W
1D0C:  ADDWFC 03,W
1D0E:  MOVWF  FEA
1D10:  MOVLW  2D
1D12:  MOVWF  FEF
....................          cnt++; 
1D14:  INCF   xC2,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
1D16:  CLRF   xC0
1D18:  BCF    FD8.0
1D1A:  RRCF   xC2,W
1D1C:  SUBWF  xC0,W
1D1E:  BC    1D7E
....................  
....................          c=s[i]; 
1D20:  CLRF   03
1D22:  MOVF   xC0,W
1D24:  ADDWF  xBA,W
1D26:  MOVWF  FE9
1D28:  MOVF   xBB,W
1D2A:  ADDWFC 03,W
1D2C:  MOVWF  FEA
1D2E:  MOVFF  FEF,C3
....................          s[i]=s[cnt-i-1];        // Reverse the number 
1D32:  CLRF   03
1D34:  MOVF   xC0,W
1D36:  ADDWF  xBA,W
1D38:  MOVWF  01
1D3A:  MOVF   xBB,W
1D3C:  ADDWFC 03,F
1D3E:  MOVFF  03,C5
1D42:  MOVF   xC0,W
1D44:  SUBWF  xC2,W
1D46:  ADDLW  FF
1D48:  CLRF   03
1D4A:  ADDWF  xBA,W
1D4C:  MOVWF  FE9
1D4E:  MOVF   xBB,W
1D50:  ADDWFC 03,W
1D52:  MOVWF  FEA
1D54:  MOVFF  FEF,C8
1D58:  MOVFF  C5,FEA
1D5C:  MOVFF  01,FE9
1D60:  MOVFF  C8,FEF
....................          s[cnt-i-1]=c; 
1D64:  MOVF   xC0,W
1D66:  SUBWF  xC2,W
1D68:  ADDLW  FF
1D6A:  CLRF   03
1D6C:  ADDWF  xBA,W
1D6E:  MOVWF  FE9
1D70:  MOVF   xBB,W
1D72:  ADDWFC 03,W
1D74:  MOVWF  FEA
1D76:  MOVFF  C3,FEF
....................      } 
1D7A:  INCF   xC0,F
1D7C:  BRA    1D18
....................      s[cnt]='\0';     // End the string 
1D7E:  CLRF   03
1D80:  MOVF   xC2,W
1D82:  ADDWF  xBA,W
1D84:  MOVWF  FE9
1D86:  MOVF   xBB,W
1D88:  ADDWFC 03,W
1D8A:  MOVWF  FEA
1D8C:  CLRF   FEF
....................      return s; 
1D8E:  MOVFF  BA,01
1D92:  MOVFF  BB,02
.................... } 
1D96:  RETLW  00
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <math.h> 
....................  
.................... #fuses HS,NOWDT,WDT128,NOPROTECT,NOLVP,PUT,NOBROWNOUT 
.................... #use fixed_io(d_outputs=PIN_D0, PIN_D1, PIN_D2, PIN_D3, PIN_D4, PIN_D5, PIN_D6, PIN_D7) 
.................... #use delay(clock=10000000) 
*
08FE:  CLRF   FEA
0900:  MOVLW  C1
0902:  MOVWF  FE9
0904:  MOVF   FEF,W
0906:  BZ    0924
0908:  MOVLW  03
090A:  MOVWF  01
090C:  CLRF   00
090E:  DECFSZ 00,F
0910:  BRA    090E
0912:  DECFSZ 01,F
0914:  BRA    090C
0916:  MOVLW  3C
0918:  MOVWF  00
091A:  DECFSZ 00,F
091C:  BRA    091A
091E:  BRA    0920
0920:  DECFSZ FEF,F
0922:  BRA    0908
0924:  RETLW  00
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7, BRGH1OK, parity =N,BITS=8) 
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, BITS=8, MSB_FIRST, IDLE=0) 
....................  
....................  
....................  
....................  
.................... /* 
.................... struct port_d_map{ 
....................    int8 data_bus:4; //0:3 
....................    boolean rs;     //4 
....................    boolean LED_latch;  //5 
....................    boolean MUX_en;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
.................... */ 
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte SSPCON2 = 0xFC5 
.................... #byte PIE1 = 0xF9D 
.................... #byte RCSTA= 0xFAB 
.................... #byte TXSTA= 0xFAC 
.................... #byte PIR1 = 0xF9E 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1  = 0xFCE 
.................... #byte T1CON = 0xFCD 
....................  
.................... ////////////// various constant ///////// 
.................... #define Y2010_UNIX_TIME 1262304000 
.................... #define Y2010_JDN 2455197.5 
.................... #define UTC 7 
.................... #define SEC_IN_4_YEARS 126230400 
.................... #define MAX_CMD_LEN 18 
.................... #define TX_DLY_TIME 1 
.................... /////////////////  I/O //////////// 
.................... #define EN0 PIN_B0 
.................... #define EN1 PIN_B1 
.................... #define EN2 PIN_B2 
.................... #define EN3 PIN_B3 
.................... #define CCW PIN_B4 
.................... #define FLASH_CS PIN_C2 
.................... //#define TX_EN PIN_E2 
.................... #define SENSE_0     PIN_A1 
.................... #define SENSE_1     PIN_A2 
.................... #define SENSE_2     PIN_A3 
.................... #define SENSE_3     PIN_A4 
.................... #define WALL_PWR    PIN_A5 //input 
.................... ///////////// DATA STORAGE //////// 
.................... #define ADDR_FULL_STROKE    0xf00000 
.................... #define ADDR_CURRENT_STROKE 0xf00010 
.................... #define ADDR_TIME           0xf00020 
.................... #define ADDR_START_COUNTER  0xf00030 
.................... #define MAX_FULL_STROKE 2000 
.................... #rom ADDR_FULL_STROKE={0x047E,0x037F,0x0280,0x0181} // default value = 0x2D8 = 728 tick 
.................... #rom ADDR_CURRENT_STROKE={0x0000,0x0001,0x0002,0x0003} 
.................... #rom ADDR_TIME={0x0000,0x0000,0x0001,0x0000} 
.................... #rom ADDR_START_COUNTER={0x0000} 
.................... #rom 0xf00040 ={0x1234} // to check if eeprom can be read properly 
.................... #define LOGGER_START_PAGE 1500 
.................... ////////////////////////////////////// 
....................  
....................  
.................... /////////////////////////// flag 
.................... struct flag { 
....................    boolean task1_armed; 
....................    boolean update_time; 
....................    boolean prev_pulse_state; 
....................    boolean cmd_posted; 
....................    boolean setup_required; 
....................    boolean reset_rs232; 
....................    boolean pwr_state; 
....................    boolean measure_current; 
.................... } flag; 
....................  
.................... struct flag2 { 
....................    boolean en_operate; 
....................    boolean button_pressed; 
....................    boolean abort_current_activity; 
....................    boolean allow_manual_move_act; 
....................    boolean current_pulse_state; 
....................    boolean power; 
....................    boolean is_moving; 
....................    boolean unused3; 
.................... } flag2; 
.................... /* 
.................... struct LED_status { 
....................   boolean power; 
....................   boolean operation; 
....................   int8 aux:2; 
....................   int8 unused:4; 
.................... } LED_status; 
.................... */ 
.................... struct port_d_map{ 
....................    int8 lcd_nibble:4; //0:3 
....................    boolean ps_en;     //4 
....................    boolean meas_rly;  //5 
....................    boolean pwr_ctrl;  //6 
....................    boolean disp_en;   //7 
.................... } PORTD; 
.................... #byte PORTD =0xF83 
....................  
.................... struct port_e_map{ 
....................    boolean rs; //0 
....................    boolean emgcy; //1 
....................    boolean tx_en; //2 
....................    int8 unused:5; 
.................... } PORTE; 
.................... #byte PORTE =0xF84 
....................  
.................... /////////////////////////// timer_related 
.................... unsigned int32 timer_sec =0; 
.................... unsigned int32 last_command =0; 
.................... unsigned int32 tick =0; 
.................... unsigned int32 tick2 =0; 
.................... unsigned int32 nDay=1; 
.................... unsigned int16 startup_counter=0; 
.................... /////////////////////////// command processing 
.................... char cmd_msg[20]; 
.................... int8 cmd_len=0; 
.................... int8 nButton=-1; 
....................  
.................... /////////////////////////// string format 
.................... char tmp_str[20]; 
.................... char tmp_str2[20]; 
.................... const int8 line[4] = {0,0x40,0x10,0x50}; 
.................... //////////////////////////// ADC 
.................... int16 wall_pwr_read; 
.................... int16 accumulate_current=0; 
.................... int8  n_avg=0; 
.................... /////////////////////////// flash_related_variable 
.................... int8 flash_mfg_id[4]; 
.................... int8 flash_stat=0; 
.................... int8 flash_page_data=0; 
.................... int8 flash_page_data2=0; 
.................... /////////////////////////// actuator related 
.................... int16 move_act_time_out=3; 
.................... int16 actuator_pulse=0; 
.................... float act_len; 
.................... unsigned int16 current_act_position[4]={0,0,0,0}; 
.................... unsigned int16 target_act_position=0; 
.................... unsigned int16 act_full_stroke_tick[4]={0,0,0,0}; 
.................... unsigned int16 act_max_stroke=0; 
.................... unsigned int16 act_min_stroke=0; 
.................... unsigned int16 act_safety_stroke=0; 
.................... unsigned int16 latitude=0; 
.................... unsigned int16 longitude=0; 
.................... unsigned int16 altitude=0; 
.................... int8 actuator_move_mask=0x00; 
.................... /////////////////// LCD FUNCTION 
.................... void lcd_send_nibble( BYTE n ) { 
....................       PORTD.lcd_nibble=n>>4; 
0926:  SWAPF  xC5,W
0928:  MOVWF  00
092A:  MOVLW  0F
092C:  ANDWF  00,F
092E:  MOVF   00,W
0930:  ANDLW  0F
0932:  MOVWF  00
0934:  MOVLW  F0
0936:  ANDWF  F83,W
0938:  IORWF  00,W
093A:  MOVWF  F83
....................       delay_us(50); 
093C:  MOVLW  29
093E:  MOVWF  00
0940:  DECFSZ 00,F
0942:  BRA    0940
0944:  NOP   
....................       PORTD.disp_en=1; 
0946:  BSF    F83.7
....................       delay_us(50); 
0948:  MOVLW  29
094A:  MOVWF  00
094C:  DECFSZ 00,F
094E:  BRA    094C
0950:  NOP   
....................       PORTD.disp_en=0; 
0952:  BCF    F83.7
....................      delay_us(50); 
0954:  MOVLW  29
0956:  MOVWF  00
0958:  DECFSZ 00,F
095A:  BRA    0958
095C:  NOP   
.................... } 
095E:  RETLW  00
....................  
.................... void lcd_send_cmd(boolean rs, int8 dat) { 
....................    PORTE.rs=rs; 
0960:  BTFSS  xC1.0
0962:  BCF    F84.0
0964:  BTFSC  xC1.0
0966:  BSF    F84.0
....................    lcd_send_nibble(dat&0xF0); 
0968:  MOVF   xC2,W
096A:  ANDLW  F0
096C:  MOVWF  xC3
096E:  MOVWF  xC5
0970:  RCALL  0926
....................    lcd_send_nibble((dat<<4)&0xF0); 
0972:  SWAPF  xC2,W
0974:  MOVWF  00
0976:  MOVLW  F0
0978:  ANDWF  00,F
097A:  MOVF   00,W
097C:  ANDLW  F0
097E:  MOVWF  xC4
0980:  MOVWF  xC5
0982:  RCALL  0926
....................    PORTE.rs=1; 
0984:  BSF    F84.0
.................... } 
0986:  RETLW  00
....................  
.................... void lcd_init() { 
....................    int8 i; 
....................     PORTE.rs = 0; 
0988:  BCF    F84.0
....................     PORTD.disp_en=0; 
098A:  BCF    F83.7
....................    delay_ms(15); 
098C:  MOVLW  0F
098E:  MOVWF  xC1
0990:  RCALL  08FE
....................     for(i=1;i<=3;++i) { 
0992:  MOVLW  01
0994:  MOVWF  xAC
0996:  MOVF   xAC,W
0998:  SUBLW  03
099A:  BNC   09AC
....................        lcd_send_nibble(0x30);  
099C:  MOVLW  30
099E:  MOVWF  xC5
09A0:  RCALL  0926
....................        delay_ms(15); 
09A2:  MOVLW  0F
09A4:  MOVWF  xC1
09A6:  RCALL  08FE
....................     } 
09A8:  INCF   xAC,F
09AA:  BRA    0996
....................     lcd_send_nibble(0x20);  
09AC:  MOVLW  20
09AE:  MOVWF  xC5
09B0:  RCALL  0926
....................     delay_ms(15); 
09B2:  MOVLW  0F
09B4:  MOVWF  xC1
09B6:  RCALL  08FE
....................     lcd_send_cmd(0,0x06); 
09B8:  CLRF   xC1
09BA:  MOVLW  06
09BC:  MOVWF  xC2
09BE:  RCALL  0960
....................     delay_us(50); 
09C0:  MOVLW  29
09C2:  MOVWF  00
09C4:  DECFSZ 00,F
09C6:  BRA    09C4
09C8:  NOP   
....................     lcd_send_cmd(0,0x0c); 
09CA:  CLRF   xC1
09CC:  MOVLW  0C
09CE:  MOVWF  xC2
09D0:  RCALL  0960
....................     delay_us(50); 
09D2:  MOVLW  29
09D4:  MOVWF  00
09D6:  DECFSZ 00,F
09D8:  BRA    09D6
09DA:  NOP   
....................     lcd_send_cmd(0,0x10); 
09DC:  CLRF   xC1
09DE:  MOVLW  10
09E0:  MOVWF  xC2
09E2:  RCALL  0960
....................     delay_us(50); 
09E4:  MOVLW  29
09E6:  MOVWF  00
09E8:  DECFSZ 00,F
09EA:  BRA    09E8
09EC:  NOP   
....................     lcd_send_cmd(0,0x2c); // 8bit data, 2lines, 5x8 font 
09EE:  CLRF   xC1
09F0:  MOVLW  2C
09F2:  MOVWF  xC2
09F4:  RCALL  0960
....................     delay_us(50); 
09F6:  MOVLW  29
09F8:  MOVWF  00
09FA:  DECFSZ 00,F
09FC:  BRA    09FA
09FE:  NOP   
....................     lcd_send_cmd(0,0x01); 
0A00:  CLRF   xC1
0A02:  MOVLW  01
0A04:  MOVWF  xC2
0A06:  RCALL  0960
....................     delay_us(50); 
0A08:  MOVLW  29
0A0A:  MOVWF  00
0A0C:  DECFSZ 00,F
0A0E:  BRA    0A0C
0A10:  NOP   
....................  
.................... } 
0A12:  RETLW  00
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................    address=line[y%4]; 
*
1962:  MOVF   xBE,W
1964:  ANDLW  03
1966:  CLRF   03
1968:  MOVFF  FF2,C1
196C:  BCF    FF2.7
196E:  CALL   00AA
1972:  BTFSC  xC1.7
1974:  BSF    FF2.7
1976:  MOVWF  xBF
....................    address+=x; 
1978:  MOVF   xBD,W
197A:  ADDWF  xBF,F
....................    lcd_send_cmd(0,0x80|address); 
197C:  MOVF   xBF,W
197E:  IORLW  80
1980:  MOVWF  xC0
1982:  CLRF   xC1
1984:  MOVWF  xC2
1986:  CALL   0960
.................... } 
198A:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
198C:  MOVF   xBC,W
198E:  XORLW  0C
1990:  BZ    199C
1992:  XORLW  06
1994:  BZ    19B0
1996:  XORLW  02
1998:  BZ    19BC
199A:  BRA    19C8
....................      case '\f'   : lcd_send_cmd(0,1); 
199C:  CLRF   xC1
199E:  MOVLW  01
19A0:  MOVWF  xC2
19A2:  CALL   0960
....................                    delay_ms(2); 
19A6:  MOVLW  02
19A8:  MOVWF  xC1
19AA:  CALL   08FE
....................                                            break; 
19AE:  BRA    19D6
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
19B0:  MOVLW  01
19B2:  MOVWF  xBD
19B4:  MOVLW  02
19B6:  MOVWF  xBE
19B8:  RCALL  1962
19BA:  BRA    19D6
....................      case '\b'   : lcd_send_cmd(0,0x10);  break; 
19BC:  CLRF   xC1
19BE:  MOVLW  10
19C0:  MOVWF  xC2
19C2:  CALL   0960
19C6:  BRA    19D6
....................      default     : lcd_send_cmd(1,c);     break; 
19C8:  MOVLW  01
19CA:  MOVWF  xC1
19CC:  MOVFF  BC,C2
19D0:  CALL   0960
19D4:  BRA    19D6
....................    } 
.................... } 
19D6:  RETLW  00
....................  
.................... void lcd_put_str(char* c, int8 size) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<size;i++)   lcd_putc(c[i]); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////// 
.................... void button_scan(); 
....................  
.................... ///////////////////////////////////////////////////// 
....................  
.................... void init_rs232() { 
....................    bit_clear(PIR1,4);  //TXIF=0 
*
06D2:  BCF    F9E.4
....................    bit_clear(PIR1,5);  //RCIF=0 
06D4:  BCF    F9E.5
....................    bit_clear(PIE1,5);  //RCIE=0 
06D6:  BCF    F9D.5
....................    bit_clear(RCSTA,7); //SPEN=0 
06D8:  BCF    FAB.7
....................    bit_clear(RCSTA,4); //CREN=0 
06DA:  BCF    FAB.4
....................     bit_clear(TXSTA,4); //SYNC=0 
06DC:  BCF    FAC.4
....................     bit_clear(TXSTA,5); //TXEN=0 
06DE:  BCF    FAC.5
....................    delay_cycles(10); 
06E0:  MOVLW  03
06E2:  MOVWF  00
06E4:  DECFSZ 00,F
06E6:  BRA    06E4
....................    bit_set(RCSTA,4); //CREN=1 
06E8:  BSF    FAB.4
....................    bit_set(RCSTA,7); //SPEN=1 
06EA:  BSF    FAB.7
....................     bit_set(TXSTA,5); //TXEN=1 
06EC:  BSF    FAC.5
....................    bit_set(PIE1,5); //RCIE=1 
06EE:  BSF    F9D.5
....................  
.................... } 
06F0:  RETLW  00
....................  
....................  
.................... void flash_read_mfg_id() { 
.................... 		output_low(FLASH_CS); 
*
0A6C:  BCF    F94.2
0A6E:  BCF    F8B.2
.................... 		delay_cycles(20); 
0A70:  MOVLW  06
0A72:  MOVWF  00
0A74:  DECFSZ 00,F
0A76:  BRA    0A74
0A78:  NOP   
.................... 		spi_write(0x9F); 
0A7A:  MOVF   FC9,W
0A7C:  MOVLW  9F
0A7E:  MOVWF  FC9
0A80:  RRCF   FC7,W
0A82:  BNC   0A80
.................... 		flash_mfg_id[0] = spi_read(0); 
0A84:  MOVF   FC9,W
0A86:  CLRF   FC9
0A88:  RRCF   FC7,W
0A8A:  BNC   0A88
0A8C:  MOVFF  FC9,7A
.................... 		flash_mfg_id[1] = spi_read(0); 
0A90:  MOVF   FC9,W
0A92:  CLRF   FC9
0A94:  RRCF   FC7,W
0A96:  BNC   0A94
0A98:  MOVFF  FC9,7B
.................... 		flash_mfg_id[2] = spi_read(0); 
0A9C:  MOVF   FC9,W
0A9E:  CLRF   FC9
0AA0:  RRCF   FC7,W
0AA2:  BNC   0AA0
0AA4:  MOVFF  FC9,7C
.................... 		flash_mfg_id[3] = spi_read(0); 
0AA8:  MOVF   FC9,W
0AAA:  CLRF   FC9
0AAC:  RRCF   FC7,W
0AAE:  BNC   0AAC
0AB0:  MOVFF  FC9,7D
.................... 		delay_cycles(20); 
0AB4:  MOVLW  06
0AB6:  MOVWF  00
0AB8:  DECFSZ 00,F
0ABA:  BRA    0AB8
0ABC:  NOP   
.................... 		output_high(FLASH_CS); 
0ABE:  BCF    F94.2
0AC0:  BSF    F8B.2
.................... } 
0AC2:  GOTO   3F60 (RETURN)
....................  
.................... void flash_read_stat() { 
.................... 		output_low(FLASH_CS); 
*
0A14:  BCF    F94.2
0A16:  BCF    F8B.2
.................... 		delay_cycles(20); 
0A18:  MOVLW  06
0A1A:  MOVWF  00
0A1C:  DECFSZ 00,F
0A1E:  BRA    0A1C
0A20:  NOP   
.................... 		spi_write(0xD7); 
0A22:  MOVF   FC9,W
0A24:  MOVLW  D7
0A26:  MOVWF  FC9
0A28:  RRCF   FC7,W
0A2A:  BNC   0A28
.................... 		flash_stat = spi_read(0); 
0A2C:  MOVF   FC9,W
0A2E:  CLRF   FC9
0A30:  RRCF   FC7,W
0A32:  BNC   0A30
0A34:  MOVFF  FC9,7E
.................... 		delay_cycles(20); 
0A38:  MOVLW  06
0A3A:  MOVWF  00
0A3C:  DECFSZ 00,F
0A3E:  BRA    0A3C
0A40:  NOP   
.................... 		output_high(FLASH_CS); 
0A42:  BCF    F94.2
0A44:  BSF    F8B.2
.................... } 
0A46:  RETLW  00
....................  
.................... void flash_wait_until_ready() { 
....................    int8 wait_loop=0; 
0A48:  CLRF   xC2
....................    for ( wait_loop=0; wait_loop<0xFF; wait_loop++) { 
0A4A:  CLRF   xC2
0A4C:  INCFSZ xC2,W
0A4E:  BRA    0A52
0A50:  BRA    0A6A
.................... 	 flash_read_stat(); 
0A52:  RCALL  0A14
....................      if ((flash_stat & 0xBF)==0x9C) break; 
0A54:  MOVF   x7E,W
0A56:  ANDLW  BF
0A58:  SUBLW  9C
0A5A:  BNZ   0A5E
0A5C:  BRA    0A6A
.................... 	 delay_cycles(100); 
0A5E:  MOVLW  21
0A60:  MOVWF  00
0A62:  DECFSZ 00,F
0A64:  BRA    0A62
....................    } 
0A66:  INCF   xC2,F
0A68:  BRA    0A4C
.................... } 
0A6A:  RETLW  00
....................  
.................... void flash_read_page(int16 pageAddress, int8 pageIndex) { 
....................  
.................... 	//pageAddress <<= 1; 
.................... 	//pageAddress &= 0xFE; 
.................... 	flash_wait_until_ready(); 
*
0DB4:  RCALL  0A48
....................    	output_low(FLASH_CS); 
0DB6:  BCF    F94.2
0DB8:  BCF    F8B.2
.................... 	delay_cycles(20); 
0DBA:  MOVLW  06
0DBC:  MOVWF  00
0DBE:  DECFSZ 00,F
0DC0:  BRA    0DBE
0DC2:  NOP   
....................    	spi_write(0xD2); 
0DC4:  MOVF   FC9,W
0DC6:  MOVLW  D2
0DC8:  MOVWF  FC9
0DCA:  RRCF   FC7,W
0DCC:  BNC   0DCA
....................     spi_write(make8(pageAddress,1)); 
0DCE:  MOVFF  C0,C2
0DD2:  MOVF   FC9,W
0DD4:  MOVFF  C0,FC9
0DD8:  RRCF   FC7,W
0DDA:  BNC   0DD8
....................     spi_write(make8(pageAddress,0)); 
0DDC:  MOVFF  BF,C2
0DE0:  MOVF   FC9,W
0DE2:  MOVFF  BF,FC9
0DE6:  RRCF   FC7,W
0DE8:  BNC   0DE6
....................     spi_write(pageIndex); 
0DEA:  MOVF   FC9,W
0DEC:  MOVFF  C1,FC9
0DF0:  RRCF   FC7,W
0DF2:  BNC   0DF0
....................     spi_write(0); 
0DF4:  MOVF   FC9,W
0DF6:  CLRF   FC9
0DF8:  RRCF   FC7,W
0DFA:  BNC   0DF8
....................     spi_write(0); 
0DFC:  MOVF   FC9,W
0DFE:  CLRF   FC9
0E00:  RRCF   FC7,W
0E02:  BNC   0E00
....................     spi_write(0); 
0E04:  MOVF   FC9,W
0E06:  CLRF   FC9
0E08:  RRCF   FC7,W
0E0A:  BNC   0E08
....................     spi_write(0); 
0E0C:  MOVF   FC9,W
0E0E:  CLRF   FC9
0E10:  RRCF   FC7,W
0E12:  BNC   0E10
.................... 	flash_page_data = spi_read(0); 
0E14:  MOVF   FC9,W
0E16:  CLRF   FC9
0E18:  RRCF   FC7,W
0E1A:  BNC   0E18
0E1C:  MOVFF  FC9,7F
.................... 	flash_page_data2 = spi_read(0); 
0E20:  MOVF   FC9,W
0E22:  CLRF   FC9
0E24:  RRCF   FC7,W
0E26:  BNC   0E24
0E28:  MOVFF  FC9,80
....................    	output_high(FLASH_CS); 
0E2C:  BCF    F94.2
0E2E:  BSF    F8B.2
.................... } 
0E30:  RETLW  00
....................  
.................... void flash_block_erase() { 
....................    int8 i,j; 
....................    i=0xFF; 
*
15BC:  MOVLW  FF
15BE:  MOVWF  xAE
....................    do 
....................    { 
....................    i++; 
15C0:  INCF   xAE,F
....................    flash_wait_until_ready(); 
15C2:  CALL   0A48
....................    output_low(FLASH_CS); 
15C6:  BCF    F94.2
15C8:  BCF    F8B.2
....................    spi_write(0x50); 
15CA:  MOVF   FC9,W
15CC:  MOVLW  50
15CE:  MOVWF  FC9
15D0:  RRCF   FC7,W
15D2:  BNC   15D0
....................    j = i>>5; 
15D4:  SWAPF  xAE,W
15D6:  MOVWF  xAF
15D8:  RRCF   xAF,F
15DA:  MOVLW  07
15DC:  ANDWF  xAF,F
....................    spi_write(j); 
15DE:  MOVF   FC9,W
15E0:  MOVFF  AF,FC9
15E4:  RRCF   FC7,W
15E6:  BNC   15E4
....................    j = i<<3; 
15E8:  RLCF   xAE,W
15EA:  MOVWF  xAF
15EC:  RLCF   xAF,F
15EE:  RLCF   xAF,F
15F0:  MOVLW  F8
15F2:  ANDWF  xAF,F
....................    spi_write(j); 
15F4:  MOVF   FC9,W
15F6:  MOVFF  AF,FC9
15FA:  RRCF   FC7,W
15FC:  BNC   15FA
....................    spi_write(0); 
15FE:  MOVF   FC9,W
1600:  CLRF   FC9
1602:  RRCF   FC7,W
1604:  BNC   1602
....................    output_high(FLASH_CS); 
1606:  BCF    F94.2
1608:  BSF    F8B.2
....................    } while(i!=0xFF); 
160A:  INCFSZ xAE,W
160C:  BRA    15C0
....................    flash_wait_until_ready(); 
160E:  CALL   0A48
.................... } 
1612:  GOTO   3A5A (RETURN)
....................  
.................... void flash_buffer1_write(int8 data, int8 PageIndex, int8 nData) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
3AB4:  CALL   0A48
....................    output_low(FLASH_CS); 
3AB8:  BCF    F94.2
3ABA:  BCF    F8B.2
....................    delay_cycles(20); 
3ABC:  MOVLW  06
3ABE:  MOVWF  00
3AC0:  DECFSZ 00,F
3AC2:  BRA    3AC0
3AC4:  NOP   
....................    spi_write(0x84); 
3AC6:  MOVF   FC9,W
3AC8:  MOVLW  84
3ACA:  MOVWF  FC9
3ACC:  RRCF   FC7,W
3ACE:  BNC   3ACC
....................    spi_write(0); 
3AD0:  MOVF   FC9,W
3AD2:  CLRF   FC9
3AD4:  RRCF   FC7,W
3AD6:  BNC   3AD4
....................    spi_write(0); 
3AD8:  MOVF   FC9,W
3ADA:  CLRF   FC9
3ADC:  RRCF   FC7,W
3ADE:  BNC   3ADC
....................    spi_write(PageIndex); 
3AE0:  MOVF   FC9,W
3AE2:  MOVFF  B6,FC9
3AE6:  RRCF   FC7,W
3AE8:  BNC   3AE6
....................    if (nData>1) { 
3AEA:  MOVF   xB7,W
3AEC:  SUBLW  01
3AEE:  BC    3B08
....................    i=255; 
3AF0:  MOVLW  FF
3AF2:  MOVWF  xB8
....................    do { 
....................       spi_write(data); 
3AF4:  MOVF   FC9,W
3AF6:  MOVFF  B5,FC9
3AFA:  RRCF   FC7,W
3AFC:  BNC   3AFA
....................       i++; 
3AFE:  INCF   xB8,F
....................    } while(i<nData); 
3B00:  MOVF   xB7,W
3B02:  SUBWF  xB8,W
3B04:  BNC   3AF4
....................    } else 
3B06:  BRA    3B12
....................          spi_write(data); 
3B08:  MOVF   FC9,W
3B0A:  MOVFF  B5,FC9
3B0E:  RRCF   FC7,W
3B10:  BNC   3B0E
....................    output_high(FLASH_CS); 
3B12:  BCF    F94.2
3B14:  BSF    F8B.2
.................... } 
3B16:  RETLW  00
....................  
.................... void flash_buffer1_read(int8 PageIndex) { 
....................    int i; 
....................    flash_wait_until_ready(); 
*
21D8:  CALL   0A48
....................    output_low(FLASH_CS); 
21DC:  BCF    F94.2
21DE:  BCF    F8B.2
....................    delay_cycles(20); 
21E0:  MOVLW  06
21E2:  MOVWF  00
21E4:  DECFSZ 00,F
21E6:  BRA    21E4
21E8:  NOP   
....................    spi_write(0xD1); 
21EA:  MOVF   FC9,W
21EC:  MOVLW  D1
21EE:  MOVWF  FC9
21F0:  RRCF   FC7,W
21F2:  BNC   21F0
....................    spi_write(0); 
21F4:  MOVF   FC9,W
21F6:  CLRF   FC9
21F8:  RRCF   FC7,W
21FA:  BNC   21F8
....................    spi_write(0); 
21FC:  MOVF   FC9,W
21FE:  CLRF   FC9
2200:  RRCF   FC7,W
2202:  BNC   2200
....................    spi_write(PageIndex); 
2204:  MOVF   FC9,W
2206:  MOVFF  B0,FC9
220A:  RRCF   FC7,W
220C:  BNC   220A
....................    flash_page_data = spi_read(0); 
220E:  MOVF   FC9,W
2210:  CLRF   FC9
2212:  RRCF   FC7,W
2214:  BNC   2212
2216:  MOVFF  FC9,7F
....................    flash_page_data2 = spi_read(0); 
221A:  MOVF   FC9,W
221C:  CLRF   FC9
221E:  RRCF   FC7,W
2220:  BNC   221E
2222:  MOVFF  FC9,80
....................    output_high(FLASH_CS);    
2226:  BCF    F94.2
2228:  BSF    F8B.2
.................... } 
222A:  GOTO   358A (RETURN)
....................  
.................... void flash_set_256_page_size() { 
....................    flash_wait_until_ready(); 
*
25A4:  CALL   0A48
....................    output_low(FLASH_CS); 
25A8:  BCF    F94.2
25AA:  BCF    F8B.2
....................    delay_cycles(20); 
25AC:  MOVLW  06
25AE:  MOVWF  00
25B0:  DECFSZ 00,F
25B2:  BRA    25B0
25B4:  NOP   
....................    spi_write(0x3D); 
25B6:  MOVF   FC9,W
25B8:  MOVLW  3D
25BA:  MOVWF  FC9
25BC:  RRCF   FC7,W
25BE:  BNC   25BC
....................    spi_write(0x2A); 
25C0:  MOVF   FC9,W
25C2:  MOVLW  2A
25C4:  MOVWF  FC9
25C6:  RRCF   FC7,W
25C8:  BNC   25C6
....................    spi_write(0x80); 
25CA:  MOVF   FC9,W
25CC:  MOVLW  80
25CE:  MOVWF  FC9
25D0:  RRCF   FC7,W
25D2:  BNC   25D0
....................    spi_write(0xA6); 
25D4:  MOVF   FC9,W
25D6:  MOVLW  A6
25D8:  MOVWF  FC9
25DA:  RRCF   FC7,W
25DC:  BNC   25DA
....................    output_high(FLASH_CS);  
25DE:  BCF    F94.2
25E0:  BSF    F8B.2
.................... } 
25E2:  GOTO   3A5A (RETURN)
....................  
.................... void flash_write_buffer1_to_main_memory(int16 pageAddress) { 
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    flash_wait_until_ready(); 
*
1788:  CALL   0A48
....................    output_low(FLASH_CS); 
178C:  BCF    F94.2
178E:  BCF    F8B.2
....................    delay_cycles(20);	 
1790:  MOVLW  06
1792:  MOVWF  00
1794:  DECFSZ 00,F
1796:  BRA    1794
1798:  NOP   
....................    spi_write(0x83); 
179A:  MOVF   FC9,W
179C:  MOVLW  83
179E:  MOVWF  FC9
17A0:  RRCF   FC7,W
17A2:  BNC   17A0
....................    spi_write(make8(pageAddress,1)); 
17A4:  MOVFF  BB,BC
17A8:  MOVF   FC9,W
17AA:  MOVFF  BB,FC9
17AE:  RRCF   FC7,W
17B0:  BNC   17AE
....................    spi_write(make8(pageAddress,0)); 
17B2:  MOVFF  BA,BC
17B6:  MOVF   FC9,W
17B8:  MOVFF  BA,FC9
17BC:  RRCF   FC7,W
17BE:  BNC   17BC
....................    spi_write(0); 
17C0:  MOVF   FC9,W
17C2:  CLRF   FC9
17C4:  RRCF   FC7,W
17C6:  BNC   17C4
....................    output_high(FLASH_CS); 
17C8:  BCF    F94.2
17CA:  BSF    F8B.2
.................... } 
17CC:  RETLW  00
....................  
.................... void flash_write_page(int16 pageAddress) { 
....................    int8 i,check_sum; 
....................    char input_data; 
....................    disable_interrupts(GLOBAL); 
*
180A:  BCF    FF2.6
180C:  BCF    FF2.7
180E:  BTFSC  FF2.7
1810:  BRA    180C
....................    output_high(FLASH_CS); 
1812:  BCF    F94.2
1814:  BSF    F8B.2
....................    flash_wait_until_ready(); 
1816:  CALL   0A48
....................    output_low(FLASH_CS); 
181A:  BCF    F94.2
181C:  BCF    F8B.2
....................    if (pageAddress%2) spi_write(0x82); else spi_write(0x85); 
181E:  MOVF   xB0,W
1820:  ANDLW  01
1822:  MOVWF  00
1824:  CLRF   03
1826:  MOVF   00,W
1828:  IORWF  03,W
182A:  BZ    1838
182C:  MOVF   FC9,W
182E:  MOVLW  82
1830:  MOVWF  FC9
1832:  RRCF   FC7,W
1834:  BNC   1832
1836:  BRA    1842
1838:  MOVF   FC9,W
183A:  MOVLW  85
183C:  MOVWF  FC9
183E:  RRCF   FC7,W
1840:  BNC   183E
....................    //pageAddress = pageAddress <<1; 
....................    //pageAddress &= 0xFE; 
....................    spi_write(make8(pageAddress,1)); 
1842:  MOVFF  B1,B5
1846:  MOVF   FC9,W
1848:  MOVFF  B1,FC9
184C:  RRCF   FC7,W
184E:  BNC   184C
....................    spi_write(make8(pageAddress,0)); 
1850:  MOVFF  B0,B5
1854:  MOVF   FC9,W
1856:  MOVFF  B0,FC9
185A:  RRCF   FC7,W
185C:  BNC   185A
....................    spi_write(0); 
185E:  MOVF   FC9,W
1860:  CLRF   FC9
1862:  RRCF   FC7,W
1864:  BNC   1862
....................    check_sum=0; 
1866:  CLRF   xB3
....................    i=0xFF; 
1868:  MOVLW  FF
186A:  MOVWF  xB2
....................    check_sum=0xCC; 
186C:  MOVLW  CC
186E:  MOVWF  xB3
....................    do { 
....................       input_data = getc(); 
1870:  BTFSS  F9E.5
1872:  BRA    1870
1874:  MOVFF  FAE,B4
....................       check_sum ^= input_data; 
1878:  MOVF   xB4,W
187A:  XORWF  xB3,F
....................       spi_write(input_data); 
187C:  MOVF   FC9,W
187E:  MOVFF  B4,FC9
1882:  RRCF   FC7,W
1884:  BNC   1882
....................       i++; 
1886:  INCF   xB2,F
....................    } while(i!=0xFF); 
1888:  INCFSZ xB2,W
188A:  BRA    1870
....................    output_high(FLASH_CS); 
188C:  BCF    F94.2
188E:  BSF    F8B.2
....................    enable_interrupts(GLOBAL); 
1890:  MOVLW  C0
1892:  IORWF  FF2,F
.................... } 
1894:  GOTO   34DC (RETURN)
....................  
.................... void flash_read_main_memory_to_buffer1(int16 pageAddress) { 
....................    flash_wait_until_ready(); 
*
17CE:  CALL   0A48
....................    output_low(FLASH_CS); 
17D2:  BCF    F94.2
17D4:  BCF    F8B.2
....................    spi_write(0x53); 
17D6:  MOVF   FC9,W
17D8:  MOVLW  53
17DA:  MOVWF  FC9
17DC:  RRCF   FC7,W
17DE:  BNC   17DC
....................    spi_write(make8(pageAddress,1)); 
17E0:  MOVFF  BB,BC
17E4:  MOVF   FC9,W
17E6:  MOVFF  BB,FC9
17EA:  RRCF   FC7,W
17EC:  BNC   17EA
....................    spi_write(make8(pageAddress,0)); 
17EE:  MOVFF  BA,BC
17F2:  MOVF   FC9,W
17F4:  MOVFF  BA,FC9
17F8:  RRCF   FC7,W
17FA:  BNC   17F8
....................    spi_write(0); 
17FC:  MOVF   FC9,W
17FE:  CLRF   FC9
1800:  RRCF   FC7,W
1802:  BNC   1800
....................    output_high(FLASH_CS); 
1804:  BCF    F94.2
1806:  BSF    F8B.2
.................... } 
1808:  RETLW  00
....................  
....................  
.................... void print_date_time(int8 output_stream) { 
....................  
.................... 	  if(bit_test(output_stream,0))printf("\r\n Day#%lu, ",nDay); 
*
1E7E:  BTFSS  xAE.0
1E80:  BRA    1EC2
1E82:  CLRF   xAF
1E84:  MOVF   xAF,W
1E86:  CALL   00C8
1E8A:  INCF   xAF,F
1E8C:  MOVWF  00
1E8E:  MOVF   00,W
1E90:  BTFSS  F9E.4
1E92:  BRA    1E90
1E94:  MOVWF  FAD
1E96:  MOVLW  07
1E98:  SUBWF  xAF,W
1E9A:  BNZ   1E84
1E9C:  MOVLW  41
1E9E:  MOVWF  FE9
1EA0:  MOVFF  34,B3
1EA4:  MOVFF  33,B2
1EA8:  MOVFF  32,B1
1EAC:  MOVFF  31,B0
1EB0:  BRA    1898
1EB2:  MOVLW  2C
1EB4:  BTFSS  F9E.4
1EB6:  BRA    1EB4
1EB8:  MOVWF  FAD
1EBA:  MOVLW  20
1EBC:  BTFSS  F9E.4
1EBE:  BRA    1EBC
1EC0:  MOVWF  FAD
.................... 	   
.................... 	  if(bit_test(output_stream,1)) { 
1EC2:  BTFSS  xAE.1
1EC4:  BRA    1F10
....................        lcd_gotoxy(0,0); 
1EC6:  CLRF   xBD
1EC8:  CLRF   xBE
1ECA:  RCALL  1962
.................... 	   lcd_putc(0); 
1ECC:  CLRF   xBC
1ECE:  RCALL  198C
....................        lcd_gotoxy(4,0); 
1ED0:  MOVLW  04
1ED2:  MOVWF  xBD
1ED4:  CLRF   xBE
1ED6:  RCALL  1962
.................... 	   printf(lcd_putc,"Day#%4lu, ",nDay ); 
1ED8:  CLRF   xAF
1EDA:  MOVF   xAF,W
1EDC:  CALL   00F0
1EE0:  INCF   xAF,F
1EE2:  MOVWF  00
1EE4:  MOVWF  xBC
1EE6:  RCALL  198C
1EE8:  MOVLW  04
1EEA:  SUBWF  xAF,W
1EEC:  BNZ   1EDA
1EEE:  MOVLW  04
1EF0:  MOVWF  FE9
1EF2:  MOVFF  34,B3
1EF6:  MOVFF  33,B2
1EFA:  MOVFF  32,B1
1EFE:  MOVFF  31,B0
1F02:  BRA    19D8
1F04:  MOVLW  2C
1F06:  MOVWF  xBC
1F08:  RCALL  198C
1F0A:  MOVLW  20
1F0C:  MOVWF  xBC
1F0E:  RCALL  198C
.................... 	  } 
....................       strcpy(tmp_str,"00:00:00"); 
1F10:  CLRF   FEA
1F12:  MOVLW  4D
1F14:  MOVWF  FE9
1F16:  MOVFF  FF2,AF
1F1A:  BCF    FF2.7
1F1C:  MOVLW  00
1F1E:  CALL   0116
1F22:  TBLRD*-
1F24:  TBLRD*+
1F26:  MOVF   FF5,W
1F28:  MOVWF  FEE
1F2A:  IORLW  00
1F2C:  BNZ   1F24
1F2E:  BTFSC  xAF.7
1F30:  BSF    FF2.7
1F32:  CLRF   18
1F34:  BTFSC  FF2.7
1F36:  BSF    18.7
1F38:  BCF    FF2.7
....................       itoa((int8) (timer_sec/3600),10,tmp_str2); 
1F3A:  MOVFF  24,C1
1F3E:  MOVFF  23,C0
1F42:  MOVFF  22,BF
1F46:  MOVFF  21,BE
1F4A:  CLRF   xC5
1F4C:  CLRF   xC4
1F4E:  MOVLW  0E
1F50:  MOVWF  xC3
1F52:  MOVLW  10
1F54:  MOVWF  xC2
1F56:  CALL   0658
1F5A:  BTFSC  18.7
1F5C:  BSF    FF2.7
1F5E:  MOVFF  00,AF
1F62:  CLRF   xB8
1F64:  CLRF   xB7
1F66:  CLRF   xB6
1F68:  MOVFF  00,B5
1F6C:  MOVLW  0A
1F6E:  MOVWF  xB9
1F70:  CLRF   xBB
1F72:  MOVLW  61
1F74:  MOVWF  xBA
1F76:  RCALL  1BC4
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+2-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
1F78:  CLRF   xB2
1F7A:  MOVLW  61
1F7C:  MOVWF  xB1
1F7E:  RCALL  1D98
1F80:  MOVF   01,W
1F82:  SUBLW  02
1F84:  BNC   1FC6
1F86:  CLRF   xB2
1F88:  MOVLW  61
1F8A:  MOVWF  xB1
1F8C:  RCALL  1D98
1F8E:  MOVLW  4F
1F90:  BSF    FD8.0
1F92:  SUBFWB 01,W
1F94:  MOVWF  xAF
1F96:  MOVLW  00
1F98:  BTFSS  FD8.0
1F9A:  DECF   FE8,F
1F9C:  MOVWF  xB0
1F9E:  CLRF   xB2
1FA0:  MOVLW  61
1FA2:  MOVWF  xB1
1FA4:  RCALL  1D98
1FA6:  MOVFF  01,B1
1FAA:  MOVFF  B0,FEA
1FAE:  MOVFF  AF,FE9
1FB2:  CLRF   FE2
1FB4:  MOVLW  61
1FB6:  MOVWF  FE1
1FB8:  MOVF   01,W
1FBA:  MOVWF  01
1FBC:  BZ    1FC6
1FBE:  MOVFF  FE6,FEE
1FC2:  DECFSZ 01,F
1FC4:  BRA    1FBE
1FC6:  CLRF   18
1FC8:  BTFSC  FF2.7
1FCA:  BSF    18.7
1FCC:  BCF    FF2.7
....................       itoa((int8) ((timer_sec%3600)/60),10,tmp_str2); 
1FCE:  MOVFF  24,C1
1FD2:  MOVFF  23,C0
1FD6:  MOVFF  22,BF
1FDA:  MOVFF  21,BE
1FDE:  CLRF   xC5
1FE0:  CLRF   xC4
1FE2:  MOVLW  0E
1FE4:  MOVWF  xC3
1FE6:  MOVLW  10
1FE8:  MOVWF  xC2
1FEA:  CALL   0658
1FEE:  BTFSC  18.7
1FF0:  BSF    FF2.7
1FF2:  MOVFF  FEF,AF
1FF6:  MOVFF  FEC,B0
1FFA:  MOVFF  FEC,B1
1FFE:  MOVFF  FEC,B2
2002:  MOVFF  FEA,B4
2006:  MOVFF  FE9,B3
200A:  CLRF   18
200C:  BTFSC  FF2.7
200E:  BSF    18.7
2010:  BCF    FF2.7
2012:  MOVFF  B2,C1
2016:  MOVFF  B1,C0
201A:  MOVFF  B0,BF
201E:  MOVFF  AF,BE
2022:  CLRF   xC5
2024:  CLRF   xC4
2026:  CLRF   xC3
2028:  MOVLW  3C
202A:  MOVWF  xC2
202C:  CALL   0658
2030:  BTFSC  18.7
2032:  BSF    FF2.7
2034:  MOVFF  B4,FEA
2038:  MOVFF  B3,FE9
203C:  MOVFF  00,B0
2040:  CLRF   xB8
2042:  CLRF   xB7
2044:  CLRF   xB6
2046:  MOVFF  00,B5
204A:  MOVLW  0A
204C:  MOVWF  xB9
204E:  CLRF   xBB
2050:  MOVLW  61
2052:  MOVWF  xBA
2054:  RCALL  1BC4
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+5-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
2056:  CLRF   xB2
2058:  MOVLW  61
205A:  MOVWF  xB1
205C:  RCALL  1D98
205E:  MOVF   01,W
2060:  SUBLW  02
2062:  BNC   20A4
2064:  CLRF   xB2
2066:  MOVLW  61
2068:  MOVWF  xB1
206A:  RCALL  1D98
206C:  MOVLW  52
206E:  BSF    FD8.0
2070:  SUBFWB 01,W
2072:  MOVWF  xAF
2074:  MOVLW  00
2076:  BTFSS  FD8.0
2078:  DECF   FE8,F
207A:  MOVWF  xB0
207C:  CLRF   xB2
207E:  MOVLW  61
2080:  MOVWF  xB1
2082:  RCALL  1D98
2084:  MOVFF  01,B1
2088:  MOVFF  B0,FEA
208C:  MOVFF  AF,FE9
2090:  CLRF   FE2
2092:  MOVLW  61
2094:  MOVWF  FE1
2096:  MOVF   01,W
2098:  MOVWF  01
209A:  BZ    20A4
209C:  MOVFF  FE6,FEE
20A0:  DECFSZ 01,F
20A2:  BRA    209C
20A4:  CLRF   18
20A6:  BTFSC  FF2.7
20A8:  BSF    18.7
20AA:  BCF    FF2.7
....................       itoa((int8) (timer_sec%60),10,tmp_str2); 
20AC:  MOVFF  24,C1
20B0:  MOVFF  23,C0
20B4:  MOVFF  22,BF
20B8:  MOVFF  21,BE
20BC:  CLRF   xC5
20BE:  CLRF   xC4
20C0:  CLRF   xC3
20C2:  MOVLW  3C
20C4:  MOVWF  xC2
20C6:  CALL   0658
20CA:  BTFSC  18.7
20CC:  BSF    FF2.7
20CE:  MOVFF  FEF,00
20D2:  MOVFF  FEC,01
20D6:  MOVFF  FEC,02
20DA:  MOVFF  FEC,03
20DE:  MOVFF  00,AF
20E2:  CLRF   xB8
20E4:  CLRF   xB7
20E6:  CLRF   xB6
20E8:  MOVFF  00,B5
20EC:  MOVLW  0A
20EE:  MOVWF  xB9
20F0:  CLRF   xBB
20F2:  MOVLW  61
20F4:  MOVWF  xBA
20F6:  RCALL  1BC4
....................       if (strlen(tmp_str2)<=2) memcpy(tmp_str+8-strlen(tmp_str2),tmp_str2,strlen(tmp_str2)); 
20F8:  CLRF   xB2
20FA:  MOVLW  61
20FC:  MOVWF  xB1
20FE:  RCALL  1D98
2100:  MOVF   01,W
2102:  SUBLW  02
2104:  BNC   2146
2106:  CLRF   xB2
2108:  MOVLW  61
210A:  MOVWF  xB1
210C:  RCALL  1D98
210E:  MOVLW  55
2110:  BSF    FD8.0
2112:  SUBFWB 01,W
2114:  MOVWF  xAF
2116:  MOVLW  00
2118:  BTFSS  FD8.0
211A:  DECF   FE8,F
211C:  MOVWF  xB0
211E:  CLRF   xB2
2120:  MOVLW  61
2122:  MOVWF  xB1
2124:  RCALL  1D98
2126:  MOVFF  01,B1
212A:  MOVFF  B0,FEA
212E:  MOVFF  AF,FE9
2132:  CLRF   FE2
2134:  MOVLW  61
2136:  MOVWF  FE1
2138:  MOVF   01,W
213A:  MOVWF  01
213C:  BZ    2146
213E:  MOVFF  FE6,FEE
2142:  DECFSZ 01,F
2144:  BRA    213E
.................... 	  lcd_gotoxy(4,1); 
2146:  MOVLW  04
2148:  MOVWF  xBD
214A:  MOVLW  01
214C:  MOVWF  xBE
214E:  RCALL  1962
.................... 	  if(bit_test(output_stream,0)) printf("%s",tmp_str); 
2150:  BTFSS  xAE.0
2152:  BRA    2170
2154:  CLRF   FEA
2156:  MOVLW  4D
2158:  MOVWF  FE9
215A:  MOVLW  00
215C:  IORWF  FEF,W
215E:  BZ    2170
2160:  MOVF   FEF,W
2162:  BTFSS  F9E.4
2164:  BRA    2162
2166:  MOVWF  FAD
2168:  INCF   FE9,F
216A:  BTFSC  FD8.2
216C:  INCF   FEA,F
216E:  BRA    215A
.................... 	  if(bit_test(output_stream,1)) printf(lcd_putc,"%s",tmp_str); 
2170:  BTFSS  xAE.1
2172:  BRA    21A0
2174:  CLRF   FEA
2176:  MOVLW  4D
2178:  MOVWF  FE9
217A:  MOVLW  00
217C:  IORWF  FEF,W
217E:  BZ    21A0
2180:  MOVFF  FEA,B0
2184:  MOVFF  FE9,AF
2188:  MOVFF  FEF,BC
218C:  CALL   198C
2190:  MOVFF  B0,FEA
2194:  MOVFF  AF,FE9
2198:  INCF   FE9,F
219A:  BTFSC  FD8.2
219C:  INCF   FEA,F
219E:  BRA    217A
.................... 	  lcd_gotoxy(4,2); 
21A0:  MOVLW  04
21A2:  MOVWF  xBD
21A4:  MOVLW  02
21A6:  MOVWF  xBE
21A8:  CALL   1962
.................... 	  if(bit_test(output_stream,1)) printf(lcd_putc,"Rst:%4lu",startup_counter); 
21AC:  BTFSS  xAE.1
21AE:  BRA    21D6
21B0:  CLRF   xAF
21B2:  MOVF   xAF,W
21B4:  CALL   013A
21B8:  INCF   xAF,F
21BA:  MOVWF  00
21BC:  MOVWF  xBC
21BE:  CALL   198C
21C2:  MOVLW  04
21C4:  SUBWF  xAF,W
21C6:  BNZ   21B2
21C8:  MOVLW  01
21CA:  MOVWF  FE9
21CC:  MOVFF  36,B1
21D0:  MOVFF  35,B0
21D4:  BRA    1DCA
....................  
.................... } 
21D6:  RETLW  00
....................  
.................... void print_page_data(int16 nPage) { 
....................     int8 i; 
....................     int8 j; 
....................     for(i=0;i<16;i++) { 
*
16F2:  CLRF   xB2
16F4:  MOVF   xB2,W
16F6:  SUBLW  0F
16F8:  BNC   1784
....................       printf("\r\n%02X : ",i); 
16FA:  MOVLW  0D
16FC:  BTFSS  F9E.4
16FE:  BRA    16FC
1700:  MOVWF  FAD
1702:  MOVLW  0A
1704:  BTFSS  F9E.4
1706:  BRA    1704
1708:  MOVWF  FAD
170A:  MOVFF  B2,B4
170E:  MOVLW  37
1710:  MOVWF  xB5
1712:  CALL   0AC6
1716:  MOVLW  20
1718:  BTFSS  F9E.4
171A:  BRA    1718
171C:  MOVWF  FAD
171E:  MOVLW  3A
1720:  BTFSS  F9E.4
1722:  BRA    1720
1724:  MOVWF  FAD
1726:  MOVLW  20
1728:  BTFSS  F9E.4
172A:  BRA    1728
172C:  MOVWF  FAD
....................       for (j=0;j<8;j++) { 
172E:  CLRF   xB3
1730:  MOVF   xB3,W
1732:  SUBLW  07
1734:  BNC   1780
....................         flash_read_page(nPage,i*16+j*2); 
1736:  MOVF   xB2,W
1738:  MULLW  10
173A:  MOVFF  FF3,B4
173E:  BCF    FD8.0
1740:  RLCF   xB3,W
1742:  ADDWF  xB4,W
1744:  MOVWF  xB5
1746:  MOVFF  B1,C0
174A:  MOVFF  B0,BF
174E:  MOVWF  xC1
1750:  CALL   0DB4
.................... 		printf("%02X %02X ",flash_page_data,flash_page_data2); 
1754:  MOVFF  7F,B4
1758:  MOVLW  37
175A:  MOVWF  xB5
175C:  CALL   0AC6
1760:  MOVLW  20
1762:  BTFSS  F9E.4
1764:  BRA    1762
1766:  MOVWF  FAD
1768:  MOVFF  80,B4
176C:  MOVLW  37
176E:  MOVWF  xB5
1770:  CALL   0AC6
1774:  MOVLW  20
1776:  BTFSS  F9E.4
1778:  BRA    1776
177A:  MOVWF  FAD
.................... 	  } 
177C:  INCF   xB3,F
177E:  BRA    1730
....................    } 
1780:  INCF   xB2,F
1782:  BRA    16F4
.................... } 
1784:  GOTO   332A (RETURN)
....................  
.................... void solar_load_parameter_from_flash() { 
....................     flash_read_page(0,0x4E);  
*
0E32:  CLRF   xC0
0E34:  CLRF   xBF
0E36:  MOVLW  4E
0E38:  MOVWF  xC1
0E3A:  RCALL  0DB4
.................... 	act_min_stroke = make16(flash_page_data2,flash_page_data); 
0E3C:  MOVFF  80,9E
0E40:  MOVFF  7F,9D
....................     flash_read_page(0,0x50);  
0E44:  CLRF   xC0
0E46:  CLRF   xBF
0E48:  MOVLW  50
0E4A:  MOVWF  xC1
0E4C:  RCALL  0DB4
.................... 	act_max_stroke = make16(flash_page_data2,flash_page_data); 
0E4E:  MOVFF  80,9C
0E52:  MOVFF  7F,9B
....................     flash_read_page(0,0x56);  
0E56:  CLRF   xC0
0E58:  CLRF   xBF
0E5A:  MOVLW  56
0E5C:  MOVWF  xC1
0E5E:  RCALL  0DB4
.................... 	latitude = make16(flash_page_data2,flash_page_data); 
0E60:  MOVFF  80,A2
0E64:  MOVFF  7F,A1
....................     flash_read_page(0,0x58);  
0E68:  CLRF   xC0
0E6A:  CLRF   xBF
0E6C:  MOVLW  58
0E6E:  MOVWF  xC1
0E70:  RCALL  0DB4
.................... 	longitude = make16(flash_page_data2,flash_page_data); 
0E72:  MOVFF  80,A4
0E76:  MOVFF  7F,A3
....................     flash_read_page(0,0x5A);  
0E7A:  CLRF   xC0
0E7C:  CLRF   xBF
0E7E:  MOVLW  5A
0E80:  MOVWF  xC1
0E82:  RCALL  0DB4
.................... 	altitude = make16(flash_page_data2,flash_page_data);	 
0E84:  MOVFF  80,A6
0E88:  MOVFF  7F,A5
....................     flash_read_page(0,0x5C);  
0E8C:  CLRF   xC0
0E8E:  CLRF   xBF
0E90:  MOVLW  5C
0E92:  MOVWF  xC1
0E94:  RCALL  0DB4
.................... 	act_safety_stroke = make16(flash_page_data2,flash_page_data); 
0E96:  MOVFF  80,A0
0E9A:  MOVFF  7F,9F
.................... } 
0E9E:  GOTO   0FD4 (RETURN)
....................  
.................... void print_fw_info() { 
....................     int8 i,j; 
.................... 	disable_interrupts(GLOBAL); 
*
0F46:  BCF    FF2.6
0F48:  BCF    FF2.7
0F4A:  BTFSC  FF2.7
0F4C:  BRA    0F48
....................     for (i=0;i<4;i++) { 
0F4E:  CLRF   xAE
0F50:  MOVF   xAE,W
0F52:  SUBLW  03
0F54:  BNC   0F9E
....................         printf("\r\n"); 
0F56:  MOVLW  0D
0F58:  BTFSS  F9E.4
0F5A:  BRA    0F58
0F5C:  MOVWF  FAD
0F5E:  MOVLW  0A
0F60:  BTFSS  F9E.4
0F62:  BRA    0F60
0F64:  MOVWF  FAD
.................... 		for (j=0;j<8;j++) { 
0F66:  CLRF   xAF
0F68:  MOVF   xAF,W
0F6A:  SUBLW  07
0F6C:  BNC   0F9A
....................     		flash_read_page(0,i*16+j*2); 
0F6E:  MOVF   xAE,W
0F70:  MULLW  10
0F72:  MOVFF  FF3,B0
0F76:  BCF    FD8.0
0F78:  RLCF   xAF,W
0F7A:  ADDWF  xB0,W
0F7C:  MOVWF  xB1
0F7E:  CLRF   xC0
0F80:  CLRF   xBF
0F82:  MOVWF  xC1
0F84:  RCALL  0DB4
.................... 			printf("%c%c",flash_page_data,flash_page_data2); 
0F86:  MOVF   x7F,W
0F88:  BTFSS  F9E.4
0F8A:  BRA    0F88
0F8C:  MOVWF  FAD
0F8E:  MOVF   x80,W
0F90:  BTFSS  F9E.4
0F92:  BRA    0F90
0F94:  MOVWF  FAD
.................... 		} 
0F96:  INCF   xAF,F
0F98:  BRA    0F68
.................... 	} 
0F9A:  INCF   xAE,F
0F9C:  BRA    0F50
.................... 	flash_read_page(0,0x40); 
0F9E:  CLRF   xC0
0FA0:  CLRF   xBF
0FA2:  MOVLW  40
0FA4:  MOVWF  xC1
0FA6:  RCALL  0DB4
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
0FA8:  MOVF   x7F,W
0FAA:  BTFSS  F9E.4
0FAC:  BRA    0FAA
0FAE:  MOVWF  FAD
0FB0:  MOVF   x80,W
0FB2:  BTFSS  F9E.4
0FB4:  BRA    0FB2
0FB6:  MOVWF  FAD
....................   	flash_read_page(0,0x42); 
0FB8:  CLRF   xC0
0FBA:  CLRF   xBF
0FBC:  MOVLW  42
0FBE:  MOVWF  xC1
0FC0:  RCALL  0DB4
.................... 	printf("%c%c",flash_page_data,flash_page_data2); 
0FC2:  MOVF   x7F,W
0FC4:  BTFSS  F9E.4
0FC6:  BRA    0FC4
0FC8:  MOVWF  FAD
0FCA:  MOVF   x80,W
0FCC:  BTFSS  F9E.4
0FCE:  BRA    0FCC
0FD0:  MOVWF  FAD
....................     solar_load_parameter_from_flash(); 
0FD2:  BRA    0E32
.................... 	printf("\r\n Min Stroke=%lu/256 cm",act_min_stroke); 
0FD4:  CLRF   xB0
0FD6:  MOVF   xB0,W
0FD8:  CALL   015E
0FDC:  INCF   xB0,F
0FDE:  MOVWF  00
0FE0:  MOVF   00,W
0FE2:  BTFSS  F9E.4
0FE4:  BRA    0FE2
0FE6:  MOVWF  FAD
0FE8:  MOVLW  0E
0FEA:  SUBWF  xB0,W
0FEC:  BNZ   0FD6
0FEE:  MOVLW  10
0FF0:  MOVWF  FE9
0FF2:  MOVFF  9E,B6
0FF6:  MOVFF  9D,B5
0FFA:  RCALL  0EA2
0FFC:  MOVLW  11
0FFE:  MOVWF  xB1
1000:  MOVF   xB1,W
1002:  CALL   015E
1006:  INCF   xB1,F
1008:  MOVWF  00
100A:  MOVF   00,W
100C:  BTFSS  F9E.4
100E:  BRA    100C
1010:  MOVWF  FAD
1012:  MOVLW  18
1014:  SUBWF  xB1,W
1016:  BNZ   1000
.................... 	printf("\r\n Max Stroke=%lu/256 cm",act_max_stroke); 
1018:  CLRF   xB0
101A:  MOVF   xB0,W
101C:  CALL   0192
1020:  INCF   xB0,F
1022:  MOVWF  00
1024:  MOVF   00,W
1026:  BTFSS  F9E.4
1028:  BRA    1026
102A:  MOVWF  FAD
102C:  MOVLW  0E
102E:  SUBWF  xB0,W
1030:  BNZ   101A
1032:  MOVLW  10
1034:  MOVWF  FE9
1036:  MOVFF  9C,B6
103A:  MOVFF  9B,B5
103E:  RCALL  0EA2
1040:  MOVLW  11
1042:  MOVWF  xB1
1044:  MOVF   xB1,W
1046:  CALL   0192
104A:  INCF   xB1,F
104C:  MOVWF  00
104E:  MOVF   00,W
1050:  BTFSS  F9E.4
1052:  BRA    1050
1054:  MOVWF  FAD
1056:  MOVLW  18
1058:  SUBWF  xB1,W
105A:  BNZ   1044
.................... 	printf("\r\n Safty Stroke=%lu/256 cm",act_safety_stroke); 
105C:  CLRF   xB0
105E:  MOVF   xB0,W
1060:  CALL   01C6
1064:  INCF   xB0,F
1066:  MOVWF  00
1068:  MOVF   00,W
106A:  BTFSS  F9E.4
106C:  BRA    106A
106E:  MOVWF  FAD
1070:  MOVLW  10
1072:  SUBWF  xB0,W
1074:  BNZ   105E
1076:  MOVLW  10
1078:  MOVWF  FE9
107A:  MOVFF  A0,B6
107E:  MOVFF  9F,B5
1082:  RCALL  0EA2
1084:  MOVLW  13
1086:  MOVWF  xB1
1088:  MOVF   xB1,W
108A:  CALL   01C6
108E:  INCF   xB1,F
1090:  MOVWF  00
1092:  MOVF   00,W
1094:  BTFSS  F9E.4
1096:  BRA    1094
1098:  MOVWF  FAD
109A:  MOVLW  1A
109C:  SUBWF  xB1,W
109E:  BNZ   1088
.................... 	printf("\r\n Latitude=%lu/100",latitude); 
10A0:  CLRF   xB0
10A2:  MOVF   xB0,W
10A4:  CALL   01FC
10A8:  INCF   xB0,F
10AA:  MOVWF  00
10AC:  MOVF   00,W
10AE:  BTFSS  F9E.4
10B0:  BRA    10AE
10B2:  MOVWF  FAD
10B4:  MOVLW  0C
10B6:  SUBWF  xB0,W
10B8:  BNZ   10A2
10BA:  MOVLW  10
10BC:  MOVWF  FE9
10BE:  MOVFF  A2,B6
10C2:  MOVFF  A1,B5
10C6:  RCALL  0EA2
10C8:  MOVLW  0F
10CA:  MOVWF  xB1
10CC:  MOVF   xB1,W
10CE:  CALL   01FC
10D2:  INCF   xB1,F
10D4:  MOVWF  00
10D6:  MOVF   00,W
10D8:  BTFSS  F9E.4
10DA:  BRA    10D8
10DC:  MOVWF  FAD
10DE:  MOVLW  13
10E0:  SUBWF  xB1,W
10E2:  BNZ   10CC
.................... 	printf("\r\n Longitude=%lu/100",longitude); 
10E4:  CLRF   xB0
10E6:  MOVF   xB0,W
10E8:  CALL   022A
10EC:  INCF   xB0,F
10EE:  MOVWF  00
10F0:  MOVF   00,W
10F2:  BTFSS  F9E.4
10F4:  BRA    10F2
10F6:  MOVWF  FAD
10F8:  MOVLW  0D
10FA:  SUBWF  xB0,W
10FC:  BNZ   10E6
10FE:  MOVLW  10
1100:  MOVWF  FE9
1102:  MOVFF  A4,B6
1106:  MOVFF  A3,B5
110A:  RCALL  0EA2
110C:  MOVLW  10
110E:  MOVWF  xB1
1110:  MOVF   xB1,W
1112:  CALL   022A
1116:  INCF   xB1,F
1118:  MOVWF  00
111A:  MOVF   00,W
111C:  BTFSS  F9E.4
111E:  BRA    111C
1120:  MOVWF  FAD
1122:  MOVLW  14
1124:  SUBWF  xB1,W
1126:  BNZ   1110
.................... 	printf("\r\n Altitude =%lu/100",altitude); 
1128:  CLRF   xB0
112A:  MOVF   xB0,W
112C:  CALL   025A
1130:  INCF   xB0,F
1132:  MOVWF  00
1134:  MOVF   00,W
1136:  BTFSS  F9E.4
1138:  BRA    1136
113A:  MOVWF  FAD
113C:  MOVLW  0D
113E:  SUBWF  xB0,W
1140:  BNZ   112A
1142:  MOVLW  10
1144:  MOVWF  FE9
1146:  MOVFF  A6,B6
114A:  MOVFF  A5,B5
114E:  RCALL  0EA2
1150:  MOVLW  10
1152:  MOVWF  xB1
1154:  MOVF   xB1,W
1156:  CALL   025A
115A:  INCF   xB1,F
115C:  MOVWF  00
115E:  MOVF   00,W
1160:  BTFSS  F9E.4
1162:  BRA    1160
1164:  MOVWF  FAD
1166:  MOVLW  14
1168:  SUBWF  xB1,W
116A:  BNZ   1154
.................... 	enable_interrupts(GLOBAL); 
116C:  MOVLW  C0
116E:  IORWF  FF2,F
....................  
.................... } 
1170:  RETLW  00
.................... /* 
.................... void display_LED() { 
.................... 	portd.data_bus=LED_status; 
.................... 	delay_cycles(20); 
.................... 	portd.LED_latch=1; 
.................... 	delay_cycles(20); 
.................... 	portd.LED_latch=0; 
.................... 	delay_cycles(20); 
.................... 	portd.LED_latch=1; 
.................... } 
.................... */ 
.................... //////////////////////////////////////////////////////////////////// 
.................... void solar_get_act_length(unsigned int8 nActuator) { 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 current_period_fraction; 
....................  
.................... 	unsigned int16 current_act_len; 
.................... 	unsigned int16 next_act_len; 
.................... 	 
....................     target_act_position =0; 
*
2A68:  CLRF   x92
2A6A:  CLRF   x91
....................  
.................... 	flash_read_page(nDay,0x00);  // verify page number 
2A6C:  MOVFF  32,BB
2A70:  MOVFF  31,BA
2A74:  MOVFF  32,C0
2A78:  MOVFF  31,BF
2A7C:  CLRF   xC1
2A7E:  CALL   0DB4
....................     if (nDay != make16(flash_page_data2,flash_page_data))  { 
2A82:  MOVFF  80,03
2A86:  MOVF   x7F,W
2A88:  SUBWF  31,W
2A8A:  BNZ   2A9A
2A8C:  MOVF   03,W
2A8E:  SUBWF  32,W
2A90:  BNZ   2A9A
2A92:  MOVF   33,F
2A94:  BNZ   2A9A
2A96:  MOVF   34,F
2A98:  BZ    2AB6
.................... 		printf("Error:Flash data corrupt"); 
2A9A:  CLRF   xBA
2A9C:  MOVF   xBA,W
2A9E:  CALL   028A
2AA2:  INCF   xBA,F
2AA4:  MOVWF  00
2AA6:  MOVF   00,W
2AA8:  BTFSS  F9E.4
2AAA:  BRA    2AA8
2AAC:  MOVWF  FAD
2AAE:  MOVLW  18
2AB0:  SUBWF  xBA,W
2AB2:  BNZ   2A9C
.................... 		return; 
2AB4:  BRA    2F5C
.................... 	} 
....................     current_period = (timer_sec+225)/450; 
2AB6:  MOVLW  E1
2AB8:  ADDWF  21,W
2ABA:  MOVWF  xBA
2ABC:  MOVLW  00
2ABE:  ADDWFC 22,W
2AC0:  MOVWF  xBB
2AC2:  MOVLW  00
2AC4:  ADDWFC 23,W
2AC6:  MOVWF  xBC
2AC8:  MOVLW  00
2ACA:  ADDWFC 24,W
2ACC:  MOVWF  xBD
2ACE:  CLRF   18
2AD0:  BTFSC  FF2.7
2AD2:  BSF    18.7
2AD4:  BCF    FF2.7
2AD6:  MOVWF  xC1
2AD8:  MOVFF  BC,C0
2ADC:  MOVFF  BB,BF
2AE0:  MOVFF  BA,BE
2AE4:  CLRF   xC5
2AE6:  CLRF   xC4
2AE8:  MOVLW  01
2AEA:  MOVWF  xC3
2AEC:  MOVLW  C2
2AEE:  MOVWF  xC2
2AF0:  CALL   0658
2AF4:  BTFSC  18.7
2AF6:  BSF    FF2.7
2AF8:  MOVFF  01,B3
2AFC:  MOVFF  00,B2
....................     current_period_fraction = (timer_sec+225)%450; 
2B00:  MOVLW  E1
2B02:  ADDWF  21,W
2B04:  MOVWF  xBA
2B06:  MOVLW  00
2B08:  ADDWFC 22,W
2B0A:  MOVWF  xBB
2B0C:  MOVLW  00
2B0E:  ADDWFC 23,W
2B10:  MOVWF  xBC
2B12:  MOVLW  00
2B14:  ADDWFC 24,W
2B16:  MOVWF  xBD
2B18:  CLRF   18
2B1A:  BTFSC  FF2.7
2B1C:  BSF    18.7
2B1E:  BCF    FF2.7
2B20:  MOVWF  xC1
2B22:  MOVFF  BC,C0
2B26:  MOVFF  BB,BF
2B2A:  MOVFF  BA,BE
2B2E:  CLRF   xC5
2B30:  CLRF   xC4
2B32:  MOVLW  01
2B34:  MOVWF  xC3
2B36:  MOVLW  C2
2B38:  MOVWF  xC2
2B3A:  CALL   0658
2B3E:  BTFSC  18.7
2B40:  BSF    FF2.7
2B42:  MOVFF  FEF,B4
2B46:  MOVFF  FEC,B5
....................     flash_read_page(nDay,0x02); // get sun rise time 
2B4A:  MOVFF  32,BB
2B4E:  MOVFF  31,BA
2B52:  MOVFF  32,C0
2B56:  MOVFF  31,BF
2B5A:  MOVLW  02
2B5C:  MOVWF  xC1
2B5E:  CALL   0DB4
....................     sun_rise_period=make16(flash_page_data2,flash_page_data); 
2B62:  MOVFF  80,B1
2B66:  MOVFF  7F,B0
.................... 	if ((current_period < sun_rise_period) || (current_period > sun_rise_period+124)) // still dark 
2B6A:  MOVF   xB3,W
2B6C:  SUBWF  xB1,W
2B6E:  BNC   2B78
2B70:  BNZ   2B92
2B72:  MOVF   xB0,W
2B74:  SUBWF  xB2,W
2B76:  BNC   2B92
2B78:  MOVLW  7C
2B7A:  ADDWF  xB0,W
2B7C:  MOVWF  01
2B7E:  MOVLW  00
2B80:  ADDWFC xB1,W
2B82:  MOVWF  03
2B84:  MOVF   03,W
2B86:  SUBWF  xB3,W
2B88:  BNC   2C74
2B8A:  BNZ   2B92
2B8C:  MOVF   xB2,W
2B8E:  SUBWF  01,W
2B90:  BC    2C74
.................... 	{ 
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]*(int32)(act_safety_stroke-act_min_stroke); 
2B92:  BCF    FD8.0
2B94:  RLCF   xAF,W
2B96:  CLRF   03
2B98:  ADDLW  93
2B9A:  MOVWF  FE9
2B9C:  MOVLW  00
2B9E:  ADDWFC 03,W
2BA0:  MOVWF  FEA
2BA2:  MOVFF  FEC,03
2BA6:  MOVF   FED,F
2BA8:  MOVFF  FEF,BA
2BAC:  MOVFF  03,BB
2BB0:  CLRF   xBC
2BB2:  CLRF   xBD
2BB4:  MOVF   x9D,W
2BB6:  SUBWF  x9F,W
2BB8:  MOVWF  00
2BBA:  MOVF   x9E,W
2BBC:  SUBWFB xA0,W
2BBE:  MOVWF  03
2BC0:  MOVF   00,W
2BC2:  MOVFF  03,01
2BC6:  CLRF   02
2BC8:  CLRF   03
2BCA:  MOVFF  03,C1
2BCE:  MOVFF  02,C0
2BD2:  MOVFF  01,BF
2BD6:  MOVFF  00,BE
2BDA:  MOVFF  FEA,C3
2BDE:  MOVFF  FE9,C2
2BE2:  MOVFF  BD,C7
2BE6:  MOVFF  BC,C6
2BEA:  MOVFF  BB,C5
2BEE:  MOVFF  BA,C4
2BF2:  MOVFF  03,CB
2BF6:  MOVFF  02,CA
2BFA:  MOVFF  01,C9
2BFE:  MOVFF  00,C8
2C02:  CALL   1AA0
2C06:  MOVFF  C3,FEA
2C0A:  MOVFF  C2,FE9
2C0E:  MOVFF  03,2C
2C12:  MOVFF  02,2B
2C16:  MOVFF  01,2A
2C1A:  MOVFF  00,29
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
2C1E:  MOVF   x9D,W
2C20:  SUBWF  x9B,W
2C22:  MOVWF  00
2C24:  MOVF   x9E,W
2C26:  SUBWFB x9C,W
2C28:  MOVWF  03
2C2A:  MOVFF  00,BA
2C2E:  MOVWF  xBB
2C30:  CLRF   18
2C32:  BTFSC  FF2.7
2C34:  BSF    18.7
2C36:  BCF    FF2.7
2C38:  MOVFF  2C,C1
2C3C:  MOVFF  2B,C0
2C40:  MOVFF  2A,BF
2C44:  MOVFF  29,BE
2C48:  CLRF   xC5
2C4A:  CLRF   xC4
2C4C:  MOVWF  xC3
2C4E:  MOVFF  00,C2
2C52:  CALL   0658
2C56:  BTFSC  18.7
2C58:  BSF    FF2.7
2C5A:  MOVFF  03,2C
2C5E:  MOVFF  02,2B
2C62:  MOVFF  01,2A
2C66:  MOVFF  00,29
.................... 		target_act_position = (unsigned int16) tick; 
2C6A:  MOVFF  2A,92
2C6E:  MOVFF  29,91
.................... 	} else { 
2C72:  BRA    2F5C
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+4); 
2C74:  MOVFF  32,BB
2C78:  MOVFF  31,BA
2C7C:  MOVF   xB0,W
2C7E:  SUBWF  xB2,W
2C80:  MOVWF  00
2C82:  MOVF   xB1,W
2C84:  SUBWFB xB3,W
2C86:  MOVWF  03
2C88:  MOVF   00,W
2C8A:  BCF    FD8.0
2C8C:  RLCF   00,F
2C8E:  MOVF   00,W
2C90:  ADDLW  04
2C92:  MOVWF  xBE
2C94:  MOVFF  32,C0
2C98:  MOVFF  31,BF
2C9C:  MOVWF  xC1
2C9E:  CALL   0DB4
.................... 		current_act_len = make16(flash_page_data2,flash_page_data); 
2CA2:  MOVFF  80,B7
2CA6:  MOVFF  7F,B6
.................... 		flash_read_page(nDay,(int8)(current_period-sun_rise_period)*2+6); 
2CAA:  MOVFF  32,BB
2CAE:  MOVFF  31,BA
2CB2:  MOVF   xB0,W
2CB4:  SUBWF  xB2,W
2CB6:  MOVWF  00
2CB8:  MOVF   xB1,W
2CBA:  SUBWFB xB3,W
2CBC:  MOVWF  03
2CBE:  MOVF   00,W
2CC0:  BCF    FD8.0
2CC2:  RLCF   00,F
2CC4:  MOVF   00,W
2CC6:  ADDLW  06
2CC8:  MOVWF  xBE
2CCA:  MOVFF  32,C0
2CCE:  MOVFF  31,BF
2CD2:  MOVWF  xC1
2CD4:  CALL   0DB4
.................... 		next_act_len = make16(flash_page_data2,flash_page_data); 
2CD8:  MOVFF  80,B9
2CDC:  MOVFF  7F,B8
.................... 		// do linear interpolation of the act len 
.................... 		if (next_act_len>current_act_len) { 
2CE0:  MOVF   xB7,W
2CE2:  SUBWF  xB9,W
2CE4:  BNC   2DA0
2CE6:  BNZ   2CEE
2CE8:  MOVF   xB8,W
2CEA:  SUBWF  xB6,W
2CEC:  BC    2DA0
.................... 			tick = (int32)(next_act_len-current_act_len)*(int32)(current_period_fraction); 
2CEE:  MOVF   xB6,W
2CF0:  SUBWF  xB8,W
2CF2:  MOVWF  00
2CF4:  MOVF   xB7,W
2CF6:  SUBWFB xB9,W
2CF8:  MOVWF  03
2CFA:  MOVFF  00,BA
2CFE:  MOVWF  xBB
2D00:  CLRF   xBC
2D02:  CLRF   xBD
2D04:  MOVFF  B4,00
2D08:  MOVFF  B5,01
2D0C:  CLRF   02
2D0E:  CLRF   03
2D10:  MOVFF  03,C1
2D14:  MOVFF  02,C0
2D18:  MOVFF  B5,BF
2D1C:  MOVFF  B4,BE
2D20:  MOVFF  BD,C7
2D24:  MOVFF  BC,C6
2D28:  MOVWF  xC5
2D2A:  MOVFF  BA,C4
2D2E:  MOVFF  03,CB
2D32:  MOVFF  02,CA
2D36:  MOVFF  B5,C9
2D3A:  MOVFF  B4,C8
2D3E:  CALL   1AA0
2D42:  MOVFF  03,2C
2D46:  MOVFF  02,2B
2D4A:  MOVFF  01,2A
2D4E:  MOVFF  00,29
2D52:  CLRF   18
2D54:  BTFSC  FF2.7
2D56:  BSF    18.7
2D58:  BCF    FF2.7
.................... 			tick = tick/450; 
2D5A:  MOVFF  2C,C1
2D5E:  MOVFF  2B,C0
2D62:  MOVFF  2A,BF
2D66:  MOVFF  29,BE
2D6A:  CLRF   xC5
2D6C:  CLRF   xC4
2D6E:  MOVLW  01
2D70:  MOVWF  xC3
2D72:  MOVLW  C2
2D74:  MOVWF  xC2
2D76:  CALL   0658
2D7A:  BTFSC  18.7
2D7C:  BSF    FF2.7
2D7E:  MOVFF  03,2C
2D82:  MOVFF  02,2B
2D86:  MOVFF  01,2A
2D8A:  MOVFF  00,29
....................         	next_act_len = (unsigned int16) tick; 
2D8E:  MOVFF  2A,B9
2D92:  MOVFF  29,B8
.................... 			current_act_len = current_act_len + next_act_len; 
2D96:  MOVF   xB8,W
2D98:  ADDWF  xB6,F
2D9A:  MOVF   xB9,W
2D9C:  ADDWFC xB7,F
.................... 		} else  { 
2D9E:  BRA    2E50
.................... 			tick = (int32)(current_act_len-next_act_len)*(int32)(current_period_fraction); 
2DA0:  MOVF   xB8,W
2DA2:  SUBWF  xB6,W
2DA4:  MOVWF  00
2DA6:  MOVF   xB9,W
2DA8:  SUBWFB xB7,W
2DAA:  MOVWF  03
2DAC:  MOVFF  00,BA
2DB0:  MOVWF  xBB
2DB2:  CLRF   xBC
2DB4:  CLRF   xBD
2DB6:  MOVFF  B4,00
2DBA:  MOVFF  B5,01
2DBE:  CLRF   02
2DC0:  CLRF   03
2DC2:  MOVFF  03,C1
2DC6:  MOVFF  02,C0
2DCA:  MOVFF  B5,BF
2DCE:  MOVFF  B4,BE
2DD2:  MOVFF  BD,C7
2DD6:  MOVFF  BC,C6
2DDA:  MOVWF  xC5
2DDC:  MOVFF  BA,C4
2DE0:  MOVFF  03,CB
2DE4:  MOVFF  02,CA
2DE8:  MOVFF  B5,C9
2DEC:  MOVFF  B4,C8
2DF0:  CALL   1AA0
2DF4:  MOVFF  03,2C
2DF8:  MOVFF  02,2B
2DFC:  MOVFF  01,2A
2E00:  MOVFF  00,29
2E04:  CLRF   18
2E06:  BTFSC  FF2.7
2E08:  BSF    18.7
2E0A:  BCF    FF2.7
.................... 			tick = tick/450; 
2E0C:  MOVFF  2C,C1
2E10:  MOVFF  2B,C0
2E14:  MOVFF  2A,BF
2E18:  MOVFF  29,BE
2E1C:  CLRF   xC5
2E1E:  CLRF   xC4
2E20:  MOVLW  01
2E22:  MOVWF  xC3
2E24:  MOVLW  C2
2E26:  MOVWF  xC2
2E28:  CALL   0658
2E2C:  BTFSC  18.7
2E2E:  BSF    FF2.7
2E30:  MOVFF  03,2C
2E34:  MOVFF  02,2B
2E38:  MOVFF  01,2A
2E3C:  MOVFF  00,29
....................         	next_act_len = (unsigned int16) tick; 
2E40:  MOVFF  2A,B9
2E44:  MOVFF  29,B8
.................... 			current_act_len = current_act_len - next_act_len; 
2E48:  MOVF   xB8,W
2E4A:  SUBWF  xB6,F
2E4C:  MOVF   xB9,W
2E4E:  SUBWFB xB7,F
.................... 		} 
.................... 		if (current_act_len >= act_max_stroke) current_act_len = act_max_stroke; 
2E50:  MOVF   x9C,W
2E52:  SUBWF  xB7,W
2E54:  BNC   2E66
2E56:  BNZ   2E5E
2E58:  MOVF   x9B,W
2E5A:  SUBWF  xB6,W
2E5C:  BNC   2E66
2E5E:  MOVFF  9C,B7
2E62:  MOVFF  9B,B6
.................... 		if (current_act_len <= act_min_stroke) current_act_len = act_min_stroke; 
2E66:  MOVF   xB7,W
2E68:  SUBWF  x9E,W
2E6A:  BNC   2E7C
2E6C:  BNZ   2E74
2E6E:  MOVF   xB6,W
2E70:  SUBWF  x9D,W
2E72:  BNC   2E7C
2E74:  MOVFF  9E,B7
2E78:  MOVFF  9D,B6
....................  
.................... 		tick = (int32)act_full_stroke_tick[nActuator]* (int32)(current_act_len-act_min_stroke); 
2E7C:  BCF    FD8.0
2E7E:  RLCF   xAF,W
2E80:  CLRF   03
2E82:  ADDLW  93
2E84:  MOVWF  FE9
2E86:  MOVLW  00
2E88:  ADDWFC 03,W
2E8A:  MOVWF  FEA
2E8C:  MOVFF  FEC,03
2E90:  MOVF   FED,F
2E92:  MOVFF  FEF,BA
2E96:  MOVFF  03,BB
2E9A:  CLRF   xBC
2E9C:  CLRF   xBD
2E9E:  MOVF   x9D,W
2EA0:  SUBWF  xB6,W
2EA2:  MOVWF  00
2EA4:  MOVF   x9E,W
2EA6:  SUBWFB xB7,W
2EA8:  MOVWF  03
2EAA:  MOVF   00,W
2EAC:  MOVFF  03,01
2EB0:  CLRF   02
2EB2:  CLRF   03
2EB4:  MOVFF  03,C1
2EB8:  MOVFF  02,C0
2EBC:  MOVFF  01,BF
2EC0:  MOVFF  00,BE
2EC4:  MOVFF  FEA,C3
2EC8:  MOVFF  FE9,C2
2ECC:  MOVFF  BD,C7
2ED0:  MOVFF  BC,C6
2ED4:  MOVFF  BB,C5
2ED8:  MOVFF  BA,C4
2EDC:  MOVFF  03,CB
2EE0:  MOVFF  02,CA
2EE4:  MOVFF  01,C9
2EE8:  MOVFF  00,C8
2EEC:  CALL   1AA0
2EF0:  MOVFF  C3,FEA
2EF4:  MOVFF  C2,FE9
2EF8:  MOVFF  03,2C
2EFC:  MOVFF  02,2B
2F00:  MOVFF  01,2A
2F04:  MOVFF  00,29
.................... 		tick = tick/(act_max_stroke-act_min_stroke); 
2F08:  MOVF   x9D,W
2F0A:  SUBWF  x9B,W
2F0C:  MOVWF  00
2F0E:  MOVF   x9E,W
2F10:  SUBWFB x9C,W
2F12:  MOVWF  03
2F14:  MOVFF  00,BA
2F18:  MOVWF  xBB
2F1A:  CLRF   18
2F1C:  BTFSC  FF2.7
2F1E:  BSF    18.7
2F20:  BCF    FF2.7
2F22:  MOVFF  2C,C1
2F26:  MOVFF  2B,C0
2F2A:  MOVFF  2A,BF
2F2E:  MOVFF  29,BE
2F32:  CLRF   xC5
2F34:  CLRF   xC4
2F36:  MOVWF  xC3
2F38:  MOVFF  00,C2
2F3C:  CALL   0658
2F40:  BTFSC  18.7
2F42:  BSF    FF2.7
2F44:  MOVFF  03,2C
2F48:  MOVFF  02,2B
2F4C:  MOVFF  01,2A
2F50:  MOVFF  00,29
.................... 		target_act_position = (unsigned int16) tick; 
2F54:  MOVFF  2A,92
2F58:  MOVFF  29,91
.................... 	} 
....................  
.................... } 
2F5C:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////// 
.................... void move_act(int16 nPulse,int16 time_out_sec,int16 stuck_sec,int8 direction,unsigned int8 nActuator) { 
....................    // direction 0 = east, 1=west 
....................    unsigned int16 xxx=0; 
*
222E:  CLRF   xBC
2230:  CLRF   xBD
....................    unsigned int16 yyy=0;    
2232:  CLRF   xBE
2234:  CLRF   xBF
....................    output_low(CCW); 
2236:  BCF    F93.4
2238:  BCF    F8A.4
....................    output_low(EN0); 
223A:  BCF    F93.0
223C:  BCF    F8A.0
....................    output_low(EN1); 
223E:  BCF    F93.1
2240:  BCF    F8A.1
....................    output_low(EN2); 
2242:  BCF    F93.2
2244:  BCF    F8A.2
....................    output_low(EN3); 
2246:  BCF    F93.3
2248:  BCF    F8A.3
....................    delay_ms(20); 
224A:  MOVLW  14
224C:  MOVWF  xC1
224E:  CALL   08FE
....................    if (nActuator > 3) return; // actuator exceed max number allowable 
2252:  MOVF   xBB,W
2254:  SUBLW  03
2256:  BC    225A
2258:  BRA    24F2
....................    flag2.is_moving =1; 
225A:  BSF    20.6
....................    switch (nActuator) { 
225C:  MOVF   xBB,W
225E:  ADDLW  FC
2260:  BC    2290
2262:  ADDLW  04
2264:  GOTO   24F4
.................... 		case 0: { flag.prev_pulse_state = input(SENSE_0); break;} 
2268:  BSF    F92.1
226A:  BCF    1F.2
226C:  BTFSC  F80.1
226E:  BSF    1F.2
2270:  BRA    2290
.................... 		case 1: { flag.prev_pulse_state = input(SENSE_1); break;} 
2272:  BSF    F92.2
2274:  BCF    1F.2
2276:  BTFSC  F80.2
2278:  BSF    1F.2
227A:  BRA    2290
.................... 		case 2: { flag.prev_pulse_state = input(SENSE_2); break;} 
227C:  BSF    F92.3
227E:  BCF    1F.2
2280:  BTFSC  F80.3
2282:  BSF    1F.2
2284:  BRA    2290
.................... 		case 3: { flag.prev_pulse_state = input(SENSE_3); break;} 
2286:  BSF    F92.4
2288:  BCF    1F.2
228A:  BTFSC  F80.4
228C:  BSF    1F.2
228E:  BRA    2290
....................    } 
....................  
....................    if (!direction)   { 
2290:  MOVF   xBA,F
2292:  BNZ   2298
....................       output_high(CCW); 
2294:  BCF    F93.4
2296:  BSF    F8A.4
....................    } 
....................  
....................    delay_ms(200); 
2298:  MOVLW  C8
229A:  MOVWF  xC1
229C:  CALL   08FE
....................    switch (nActuator) { 
22A0:  MOVF   xBB,W
22A2:  ADDLW  FC
22A4:  BC    22C4
22A6:  ADDLW  04
22A8:  GOTO   2520
.................... 		case 0: {output_high(EN0); break;} 
22AC:  BCF    F93.0
22AE:  BSF    F8A.0
22B0:  BRA    22C4
.................... 		case 1: {output_high(EN1); break;} 
22B2:  BCF    F93.1
22B4:  BSF    F8A.1
22B6:  BRA    22C4
.................... 		case 2: {output_high(EN2); break;} 
22B8:  BCF    F93.2
22BA:  BSF    F8A.2
22BC:  BRA    22C4
.................... 		case 3: {output_high(EN3); break;} 
22BE:  BCF    F93.3
22C0:  BSF    F8A.3
22C2:  BRA    22C4
....................    } 
....................    delay_ms(10); 
22C4:  MOVLW  0A
22C6:  MOVWF  xC1
22C8:  CALL   08FE
....................  
....................    tick = timer_sec; 
22CC:  MOVFF  24,2C
22D0:  MOVFF  23,2B
22D4:  MOVFF  22,2A
22D8:  MOVFF  21,29
....................    tick2 = timer_sec; 
22DC:  MOVFF  24,30
22E0:  MOVFF  23,2F
22E4:  MOVFF  22,2E
22E8:  MOVFF  21,2D
....................    actuator_pulse =0; 
22EC:  CLRF   x84
22EE:  CLRF   x83
....................    while(1) { 
....................       restart_wdt(); 
22F0:  CLRWDT
....................       xxx = (int16) (timer_sec-tick); 
22F2:  MOVF   29,W
22F4:  SUBWF  21,W
22F6:  MOVWF  00
22F8:  MOVF   2A,W
22FA:  SUBWFB 22,W
22FC:  MOVWF  01
22FE:  MOVF   2B,W
2300:  SUBWFB 23,W
2302:  MOVF   2C,W
2304:  SUBWFB 24,W
2306:  MOVFF  01,BD
230A:  MOVFF  00,BC
....................       yyy = (int16) (timer_sec-tick2); 
230E:  MOVF   2D,W
2310:  SUBWF  21,W
2312:  MOVWF  00
2314:  MOVF   2E,W
2316:  SUBWFB 22,W
2318:  MOVWF  01
231A:  MOVF   2F,W
231C:  SUBWFB 23,W
231E:  MOVF   30,W
2320:  SUBWFB 24,W
2322:  MOVFF  01,BF
2326:  MOVFF  00,BE
....................    	  switch (nActuator) { 
232A:  MOVF   xBB,W
232C:  ADDLW  FC
232E:  BC    235E
2330:  ADDLW  04
2332:  GOTO   254C
.................... 		case 0: { flag2.current_pulse_state = input(SENSE_0); break;} 
2336:  BSF    F92.1
2338:  BCF    20.4
233A:  BTFSC  F80.1
233C:  BSF    20.4
233E:  BRA    235E
.................... 		case 1: { flag2.current_pulse_state = input(SENSE_1); break;} 
2340:  BSF    F92.2
2342:  BCF    20.4
2344:  BTFSC  F80.2
2346:  BSF    20.4
2348:  BRA    235E
.................... 		case 2: { flag2.current_pulse_state = input(SENSE_2); break;} 
234A:  BSF    F92.3
234C:  BCF    20.4
234E:  BTFSC  F80.3
2350:  BSF    20.4
2352:  BRA    235E
.................... 		case 3: { flag2.current_pulse_state = input(SENSE_3); break;} 
2354:  BSF    F92.4
2356:  BCF    20.4
2358:  BTFSC  F80.4
235A:  BSF    20.4
235C:  BRA    235E
....................       } 
....................  
.................... 	  if (flag2.allow_manual_move_act) { 
235E:  BTFSS  20.3
2360:  BRA    2380
.................... 		  if (((!direction && (nButton==3)) || (direction && (nButton==5))) && flag2.button_pressed)  
2362:  MOVF   xBA,F
2364:  BNZ   236C
2366:  MOVF   4C,W
2368:  SUBLW  03
236A:  BZ    2376
236C:  MOVF   xBA,F
236E:  BZ    237E
2370:  MOVF   4C,W
2372:  SUBLW  05
2374:  BNZ   237E
2376:  BTFSS  20.1
2378:  BRA    237E
.................... 			flag2.allow_manual_move_act=1; 
237A:  BSF    20.3
.................... 		  else 
237C:  BRA    2380
.................... 			flag2.allow_manual_move_act=0;	 
237E:  BCF    20.3
.................... 	  } 
.................... 	  if (!flag2.allow_manual_move_act) {  
2380:  BTFSC  20.3
2382:  BRA    23DE
....................       if (flag2.abort_current_activity ==1) { 
2384:  BTFSS  20.2
2386:  BRA    238C
.................... 		 flag2.abort_current_activity=0; 
2388:  BCF    20.2
.................... 		 break; 
238A:  BRA    24C2
....................       } 
....................       if ( xxx>= time_out_sec)  
238C:  MOVF   xB7,W
238E:  SUBWF  xBD,W
2390:  BNC   239C
2392:  BNZ   239A
2394:  MOVF   xB6,W
2396:  SUBWF  xBC,W
2398:  BNC   239C
....................          break; 
239A:  BRA    24C2
....................        if (actuator_pulse >= nPulse) 
239C:  MOVF   xB5,W
239E:  SUBWF  x84,W
23A0:  BNC   23CE
23A2:  BNZ   23AA
23A4:  MOVF   xB4,W
23A6:  SUBWF  x83,W
23A8:  BNC   23CE
.................... 	    switch (nActuator) { 
23AA:  MOVF   xBB,W
23AC:  ADDLW  FC
23AE:  BC    23CE
23B0:  ADDLW  04
23B2:  GOTO   2578
.................... 			case 0: {output_low(EN0); break;} 
23B6:  BCF    F93.0
23B8:  BCF    F8A.0
23BA:  BRA    23CE
.................... 			case 1: {output_low(EN1); break;} 
23BC:  BCF    F93.1
23BE:  BCF    F8A.1
23C0:  BRA    23CE
.................... 			case 2: {output_low(EN2); break;} 
23C2:  BCF    F93.2
23C4:  BCF    F8A.2
23C6:  BRA    23CE
.................... 			case 3: {output_low(EN3); break;} 
23C8:  BCF    F93.3
23CA:  BCF    F8A.3
23CC:  BRA    23CE
....................    		} 
....................       if ( yyy >=stuck_sec) 
23CE:  MOVF   xB9,W
23D0:  SUBWF  xBF,W
23D2:  BNC   23DE
23D4:  BNZ   23DC
23D6:  MOVF   xB8,W
23D8:  SUBWF  xBE,W
23DA:  BNC   23DE
....................          break; 
23DC:  BRA    24C2
....................       }    
....................       if (flag.prev_pulse_state != flag2.current_pulse_state) { 
23DE:  CLRF   00
23E0:  BTFSC  20.4
23E2:  BSF    00.2
23E4:  MOVF   1F,W
23E6:  XORWF  00,W
23E8:  ANDLW  04
23EA:  BZ    24C0
....................          tick2 = timer_sec; 
23EC:  MOVFF  24,30
23F0:  MOVFF  23,2F
23F4:  MOVFF  22,2E
23F8:  MOVFF  21,2D
....................          flag.prev_pulse_state = flag2.current_pulse_state; 
23FC:  BCF    1F.2
23FE:  BTFSC  20.4
2400:  BSF    1F.2
....................          if (!direction && (current_act_position[nActuator] >0)) current_act_position[nActuator]--; 
2402:  MOVF   xBA,F
2404:  BNZ   2442
2406:  BCF    FD8.0
2408:  RLCF   xBB,W
240A:  CLRF   03
240C:  ADDLW  89
240E:  MOVWF  FE9
2410:  MOVLW  00
2412:  ADDWFC 03,W
2414:  MOVWF  FEA
2416:  MOVFF  FEC,C1
241A:  MOVF   FED,F
241C:  MOVFF  FEF,C0
2420:  MOVF   xC0,F
2422:  BNZ   2428
2424:  MOVF   xC1,F
2426:  BZ    2442
2428:  BCF    FD8.0
242A:  RLCF   xBB,W
242C:  CLRF   03
242E:  ADDLW  89
2430:  MOVWF  FE9
2432:  MOVLW  00
2434:  ADDWFC 03,W
2436:  MOVWF  FEA
2438:  MOVLW  FF
243A:  ADDWF  FEF,F
243C:  BC    2442
243E:  MOVF   FEE,F
2440:  DECF   FED,F
....................          if (direction && (current_act_position[nActuator] < act_full_stroke_tick[nActuator])) current_act_position[nActuator]++; 
2442:  MOVF   xBA,F
2444:  BZ    24A0
2446:  BCF    FD8.0
2448:  RLCF   xBB,W
244A:  CLRF   03
244C:  ADDLW  89
244E:  MOVWF  FE9
2450:  MOVLW  00
2452:  ADDWFC 03,W
2454:  MOVWF  FEA
2456:  MOVFF  FEC,C1
245A:  MOVF   FED,F
245C:  MOVFF  FEF,C0
2460:  BCF    FD8.0
2462:  RLCF   xBB,W
2464:  CLRF   03
2466:  ADDLW  93
2468:  MOVWF  FE9
246A:  MOVLW  00
246C:  ADDWFC 03,W
246E:  MOVWF  FEA
2470:  MOVFF  FEC,03
2474:  MOVF   FED,F
2476:  MOVFF  FEF,01
247A:  MOVF   xC1,W
247C:  SUBWF  03,W
247E:  BNC   24A0
2480:  BNZ   2488
2482:  MOVF   01,W
2484:  SUBWF  xC0,W
2486:  BC    24A0
2488:  BCF    FD8.0
248A:  RLCF   xBB,W
248C:  CLRF   03
248E:  ADDLW  89
2490:  MOVWF  FE9
2492:  MOVLW  00
2494:  ADDWFC 03,W
2496:  MOVWF  FEA
2498:  MOVLW  01
249A:  ADDWF  FEE,F
249C:  BNC   24A0
249E:  INCF   FEF,F
....................          actuator_pulse=actuator_pulse+1; 
24A0:  MOVLW  01
24A2:  ADDWF  x83,F
24A4:  MOVLW  00
24A6:  ADDWFC x84,F
.................... 	     printf("\r%ld",actuator_pulse); 
24A8:  MOVLW  0D
24AA:  BTFSS  F9E.4
24AC:  BRA    24AA
24AE:  MOVWF  FAD
24B0:  MOVLW  10
24B2:  MOVWF  FE9
24B4:  MOVFF  84,C1
24B8:  MOVFF  83,C0
24BC:  CALL   1616
.................... 		 //led_status.operation = !led_status.operation; 
.................... 		 //display_LED(); 
....................       } 
....................    } 
24C0:  BRA    22F0
....................    flag2.abort_current_activity=0; 
24C2:  BCF    20.2
....................    output_low(EN0); 
24C4:  BCF    F93.0
24C6:  BCF    F8A.0
....................    output_low(EN1); 
24C8:  BCF    F93.1
24CA:  BCF    F8A.1
....................    output_low(EN2); 
24CC:  BCF    F93.2
24CE:  BCF    F8A.2
....................    output_low(EN3); 
24D0:  BCF    F93.3
24D2:  BCF    F8A.3
....................    delay_ms(500); 
24D4:  MOVLW  02
24D6:  MOVWF  xC0
24D8:  MOVLW  FA
24DA:  MOVWF  xC1
24DC:  CALL   08FE
24E0:  DECFSZ xC0,F
24E2:  BRA    24D8
....................    output_low(CCW); 
24E4:  BCF    F93.4
24E6:  BCF    F8A.4
....................    delay_ms(20); 
24E8:  MOVLW  14
24EA:  MOVWF  xC1
24EC:  CALL   08FE
....................    //led_status.operation = 1; 
....................    //display_LED(); 
....................    flag2.is_moving =0; 
24F0:  BCF    20.6
....................  
....................  
.................... } 
24F2:  RETLW  00
....................  
.................... void actuator_move_execute(nActuator) { 
....................     if(current_act_position[nActuator] > (target_act_position+5))// move east 
*
3056:  BCF    FD8.0
3058:  RLCF   xAF,W
305A:  CLRF   03
305C:  ADDLW  89
305E:  MOVWF  FE9
3060:  MOVLW  00
3062:  ADDWFC 03,W
3064:  MOVWF  FEA
3066:  MOVFF  FEC,B1
306A:  MOVF   FED,F
306C:  MOVFF  FEF,B0
3070:  MOVLW  05
3072:  ADDWF  x91,W
3074:  MOVWF  01
3076:  MOVLW  00
3078:  ADDWFC x92,W
307A:  MOVWF  03
307C:  MOVF   03,W
307E:  SUBWF  xB1,W
3080:  BNC   30D2
3082:  BNZ   308A
3084:  MOVF   xB0,W
3086:  SUBWF  01,W
3088:  BC    30D2
....................             move_act(current_act_position[nActuator]-target_act_position,4500,move_act_time_out,0,nActuator); 
308A:  BCF    FD8.0
308C:  RLCF   xAF,W
308E:  CLRF   03
3090:  ADDLW  89
3092:  MOVWF  FE9
3094:  MOVLW  00
3096:  ADDWFC 03,W
3098:  MOVWF  FEA
309A:  MOVFF  FEC,B1
309E:  MOVF   FED,F
30A0:  MOVFF  FEF,B0
30A4:  MOVF   x91,W
30A6:  SUBWF  xB0,W
30A8:  MOVWF  xB2
30AA:  MOVF   x92,W
30AC:  SUBWFB xB1,W
30AE:  MOVWF  xB3
30B0:  MOVWF  xB5
30B2:  MOVFF  B2,B4
30B6:  MOVLW  11
30B8:  MOVWF  xB7
30BA:  MOVLW  94
30BC:  MOVWF  xB6
30BE:  MOVFF  82,B9
30C2:  MOVFF  81,B8
30C6:  CLRF   xBA
30C8:  MOVFF  AF,BB
30CC:  CALL   222E
....................     else if((current_act_position[nActuator]+5) < target_act_position)// move west 
30D0:  BRA    31F0
30D2:  BCF    FD8.0
30D4:  RLCF   xAF,W
30D6:  CLRF   03
30D8:  ADDLW  89
30DA:  MOVWF  FE9
30DC:  MOVLW  00
30DE:  ADDWFC 03,W
30E0:  MOVWF  FEA
30E2:  MOVFF  FEC,B1
30E6:  MOVF   FED,F
30E8:  MOVFF  FEF,B0
30EC:  MOVLW  05
30EE:  ADDWF  xB0,W
30F0:  MOVWF  xB2
30F2:  MOVLW  00
30F4:  ADDWFC xB1,W
30F6:  MOVWF  xB3
30F8:  SUBWF  x92,W
30FA:  BNC   314A
30FC:  BNZ   3104
30FE:  MOVF   x91,W
3100:  SUBWF  xB2,W
3102:  BC    314A
....................             move_act(target_act_position-current_act_position[nActuator],4500,move_act_time_out,1,nActuator); 
3104:  BCF    FD8.0
3106:  RLCF   xAF,W
3108:  CLRF   03
310A:  ADDLW  89
310C:  MOVWF  FE9
310E:  MOVLW  00
3110:  ADDWFC 03,W
3112:  MOVWF  FEA
3114:  MOVFF  FEC,03
3118:  MOVF   FED,F
311A:  MOVF   FEF,W
311C:  SUBWF  x91,W
311E:  MOVWF  xB0
3120:  MOVF   03,W
3122:  SUBWFB x92,W
3124:  MOVWF  xB1
3126:  MOVWF  xB5
3128:  MOVFF  B0,B4
312C:  MOVLW  11
312E:  MOVWF  xB7
3130:  MOVLW  94
3132:  MOVWF  xB6
3134:  MOVFF  82,B9
3138:  MOVFF  81,B8
313C:  MOVLW  01
313E:  MOVWF  xBA
3140:  MOVFF  AF,BB
3144:  CALL   222E
....................     else if (target_act_position == 0x00)  // move east all the way 
3148:  BRA    31F0
314A:  MOVF   x91,F
314C:  BNZ   3190
314E:  MOVF   x92,F
3150:  BNZ   3190
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,0,nActuator); 
3152:  BCF    FD8.0
3154:  RLCF   xAF,W
3156:  CLRF   03
3158:  ADDLW  93
315A:  MOVWF  FE9
315C:  MOVLW  00
315E:  ADDWFC 03,W
3160:  MOVWF  FEA
3162:  MOVFF  FEC,B1
3166:  MOVF   FED,F
3168:  MOVFF  FEF,B0
316C:  MOVFF  B1,B5
3170:  MOVFF  B0,B4
3174:  MOVLW  11
3176:  MOVWF  xB7
3178:  MOVLW  94
317A:  MOVWF  xB6
317C:  MOVFF  82,B9
3180:  MOVFF  81,B8
3184:  CLRF   xBA
3186:  MOVFF  AF,BB
318A:  CALL   222E
....................     else if (target_act_position == act_full_stroke_tick[nActuator]) // move west all the way 
318E:  BRA    31F0
3190:  BCF    FD8.0
3192:  RLCF   xAF,W
3194:  CLRF   03
3196:  ADDLW  93
3198:  MOVWF  FE9
319A:  MOVLW  00
319C:  ADDWFC 03,W
319E:  MOVWF  FEA
31A0:  MOVFF  FEC,03
31A4:  MOVF   FED,F
31A6:  MOVF   FEF,W
31A8:  SUBWF  x91,W
31AA:  BNZ   31F0
31AC:  MOVF   03,W
31AE:  SUBWF  x92,W
31B0:  BNZ   31F0
....................             move_act(act_full_stroke_tick[nActuator],4500,move_act_time_out,1,nActuator); 
31B2:  BCF    FD8.0
31B4:  RLCF   xAF,W
31B6:  CLRF   03
31B8:  ADDLW  93
31BA:  MOVWF  FE9
31BC:  MOVLW  00
31BE:  ADDWFC 03,W
31C0:  MOVWF  FEA
31C2:  MOVFF  FEC,B1
31C6:  MOVF   FED,F
31C8:  MOVFF  FEF,B0
31CC:  MOVFF  B1,B5
31D0:  MOVFF  B0,B4
31D4:  MOVLW  11
31D6:  MOVWF  xB7
31D8:  MOVLW  94
31DA:  MOVWF  xB6
31DC:  MOVFF  82,B9
31E0:  MOVFF  81,B8
31E4:  MOVLW  01
31E6:  MOVWF  xBA
31E8:  MOVFF  AF,BB
31EC:  CALL   222E
.................... } 
31F0:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... void read_eeprom_data() 
.................... { 
....................    int8 i,j; 
....................    int16 temp_mem;    
....................  
....................    temp_mem= &timer_sec; 
*
0B22:  CLRF   xAF
0B24:  MOVLW  21
0B26:  MOVWF  xAE
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i),1); 
0B28:  CLRF   xAC
0B2A:  MOVF   xAC,W
0B2C:  SUBLW  03
0B2E:  BNC   0B72
0B30:  MOVF   xAC,W
0B32:  ADDWF  xAE,W
0B34:  MOVWF  xB0
0B36:  MOVLW  00
0B38:  ADDWFC xAF,W
0B3A:  MOVWF  xB1
0B3C:  MOVLW  20
0B3E:  ADDWF  xAC,W
0B40:  MOVWF  xB2
0B42:  MOVFF  FF2,B3
0B46:  BCF    FF2.7
0B48:  MOVFF  B2,FA9
0B4C:  BCF    FA6.6
0B4E:  BCF    FA6.7
0B50:  BSF    FA6.0
0B52:  MOVF   FA8,W
0B54:  BTFSC  xB3.7
0B56:  BSF    FF2.7
0B58:  MOVWF  xB3
0B5A:  MOVFF  B1,FEA
0B5E:  MOVFF  B0,FE9
0B62:  MOVFF  B3,B5
0B66:  CLRF   xB7
0B68:  MOVLW  01
0B6A:  MOVWF  xB6
0B6C:  RCALL  0B08
0B6E:  INCF   xAC,F
0B70:  BRA    0B2A
....................  
....................    temp_mem= &nDay; 
0B72:  CLRF   xAF
0B74:  MOVLW  31
0B76:  MOVWF  xAE
....................    for (i=0;i<4;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_TIME+i+4),1); 
0B78:  CLRF   xAC
0B7A:  MOVF   xAC,W
0B7C:  SUBLW  03
0B7E:  BNC   0BC4
0B80:  MOVF   xAC,W
0B82:  ADDWF  xAE,W
0B84:  MOVWF  xB0
0B86:  MOVLW  00
0B88:  ADDWFC xAF,W
0B8A:  MOVWF  xB1
0B8C:  MOVLW  20
0B8E:  ADDWF  xAC,W
0B90:  ADDLW  04
0B92:  MOVWF  xB3
0B94:  MOVFF  FF2,B4
0B98:  BCF    FF2.7
0B9A:  MOVFF  B3,FA9
0B9E:  BCF    FA6.6
0BA0:  BCF    FA6.7
0BA2:  BSF    FA6.0
0BA4:  MOVF   FA8,W
0BA6:  BTFSC  xB4.7
0BA8:  BSF    FF2.7
0BAA:  MOVWF  xB4
0BAC:  MOVFF  B1,FEA
0BB0:  MOVFF  B0,FE9
0BB4:  MOVFF  B4,B5
0BB8:  CLRF   xB7
0BBA:  MOVLW  01
0BBC:  MOVWF  xB6
0BBE:  RCALL  0B08
0BC0:  INCF   xAC,F
0BC2:  BRA    0B7A
....................  
....................  
....................    temp_mem= &startup_counter; 
0BC4:  CLRF   xAF
0BC6:  MOVLW  35
0BC8:  MOVWF  xAE
....................    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_START_COUNTER+i),1); 
0BCA:  CLRF   xAC
0BCC:  MOVF   xAC,W
0BCE:  SUBLW  01
0BD0:  BNC   0C14
0BD2:  MOVF   xAC,W
0BD4:  ADDWF  xAE,W
0BD6:  MOVWF  xB0
0BD8:  MOVLW  00
0BDA:  ADDWFC xAF,W
0BDC:  MOVWF  xB1
0BDE:  MOVLW  30
0BE0:  ADDWF  xAC,W
0BE2:  MOVWF  xB2
0BE4:  MOVFF  FF2,B3
0BE8:  BCF    FF2.7
0BEA:  MOVFF  B2,FA9
0BEE:  BCF    FA6.6
0BF0:  BCF    FA6.7
0BF2:  BSF    FA6.0
0BF4:  MOVF   FA8,W
0BF6:  BTFSC  xB3.7
0BF8:  BSF    FF2.7
0BFA:  MOVWF  xB3
0BFC:  MOVFF  B1,FEA
0C00:  MOVFF  B0,FE9
0C04:  MOVFF  B3,B5
0C08:  CLRF   xB7
0C0A:  MOVLW  01
0C0C:  MOVWF  xB6
0C0E:  RCALL  0B08
0C10:  INCF   xAC,F
0C12:  BRA    0BCC
....................  
....................    for (j=0;j<4;j++) { 
0C14:  CLRF   xAD
0C16:  MOVF   xAD,W
0C18:  SUBLW  03
0C1A:  BTFSS  FD8.0
0C1C:  BRA    0DB0
....................    		temp_mem= &act_full_stroke_tick[j]; 
0C1E:  BCF    FD8.0
0C20:  RLCF   xAD,W
0C22:  CLRF   03
0C24:  ADDLW  93
0C26:  MOVWF  01
0C28:  MOVLW  00
0C2A:  ADDWFC 03,F
0C2C:  MOVFF  01,AE
0C30:  MOVFF  03,AF
.................... 	   	for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_FULL_STROKE+i+j*2),1); 
0C34:  CLRF   xAC
0C36:  MOVF   xAC,W
0C38:  SUBLW  01
0C3A:  BNC   0C80
0C3C:  MOVF   xAC,W
0C3E:  ADDWF  xAE,W
0C40:  MOVWF  xB0
0C42:  MOVLW  00
0C44:  ADDWFC xAF,W
0C46:  MOVWF  xB1
0C48:  BCF    FD8.0
0C4A:  RLCF   xAD,W
0C4C:  ADDWF  xAC,W
0C4E:  MOVWF  xB2
0C50:  MOVFF  FF2,B3
0C54:  BCF    FF2.7
0C56:  MOVFF  B2,FA9
0C5A:  BCF    FA6.6
0C5C:  BCF    FA6.7
0C5E:  BSF    FA6.0
0C60:  MOVF   FA8,W
0C62:  BTFSC  xB3.7
0C64:  BSF    FF2.7
0C66:  MOVWF  xB3
0C68:  MOVFF  B1,FEA
0C6C:  MOVFF  B0,FE9
0C70:  MOVFF  B3,B5
0C74:  CLRF   xB7
0C76:  MOVLW  01
0C78:  MOVWF  xB6
0C7A:  RCALL  0B08
0C7C:  INCF   xAC,F
0C7E:  BRA    0C36
....................    		if (act_full_stroke_tick[j] > MAX_FULL_STROKE) act_full_stroke_tick[j] = MAX_FULL_STROKE; 
0C80:  BCF    FD8.0
0C82:  RLCF   xAD,W
0C84:  CLRF   03
0C86:  ADDLW  93
0C88:  MOVWF  FE9
0C8A:  MOVLW  00
0C8C:  ADDWFC 03,W
0C8E:  MOVWF  FEA
0C90:  MOVFF  FEC,B1
0C94:  MOVF   FED,F
0C96:  MOVFF  FEF,B0
0C9A:  MOVF   xB1,W
0C9C:  SUBLW  06
0C9E:  BC    0CC4
0CA0:  XORLW  FF
0CA2:  BNZ   0CAA
0CA4:  MOVF   xB0,W
0CA6:  SUBLW  D0
0CA8:  BC    0CC4
0CAA:  BCF    FD8.0
0CAC:  RLCF   xAD,W
0CAE:  CLRF   03
0CB0:  ADDLW  93
0CB2:  MOVWF  FE9
0CB4:  MOVLW  00
0CB6:  ADDWFC 03,W
0CB8:  MOVWF  FEA
0CBA:  MOVLW  07
0CBC:  MOVWF  FEC
0CBE:  MOVF   FED,F
0CC0:  MOVLW  D0
0CC2:  MOVWF  FEF
....................    		temp_mem= &current_act_position[j]; 
0CC4:  BCF    FD8.0
0CC6:  RLCF   xAD,W
0CC8:  CLRF   03
0CCA:  ADDLW  89
0CCC:  MOVWF  01
0CCE:  MOVLW  00
0CD0:  ADDWFC 03,F
0CD2:  MOVFF  01,AE
0CD6:  MOVFF  03,AF
.................... 	    for (i=0;i<2;i++) memset(temp_mem+i,read_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2),1); 
0CDA:  CLRF   xAC
0CDC:  MOVF   xAC,W
0CDE:  SUBLW  01
0CE0:  BNC   0D2C
0CE2:  MOVF   xAC,W
0CE4:  ADDWF  xAE,W
0CE6:  MOVWF  xB0
0CE8:  MOVLW  00
0CEA:  ADDWFC xAF,W
0CEC:  MOVWF  xB1
0CEE:  MOVLW  10
0CF0:  ADDWF  xAC,W
0CF2:  MOVWF  xB2
0CF4:  BCF    FD8.0
0CF6:  RLCF   xAD,W
0CF8:  ADDWF  xB2,W
0CFA:  MOVWF  xB3
0CFC:  MOVFF  FF2,B4
0D00:  BCF    FF2.7
0D02:  MOVFF  B3,FA9
0D06:  BCF    FA6.6
0D08:  BCF    FA6.7
0D0A:  BSF    FA6.0
0D0C:  MOVF   FA8,W
0D0E:  BTFSC  xB4.7
0D10:  BSF    FF2.7
0D12:  MOVWF  xB4
0D14:  MOVFF  B1,FEA
0D18:  MOVFF  B0,FE9
0D1C:  MOVFF  B4,B5
0D20:  CLRF   xB7
0D22:  MOVLW  01
0D24:  MOVWF  xB6
0D26:  RCALL  0B08
0D28:  INCF   xAC,F
0D2A:  BRA    0CDC
....................    		if (current_act_position[j] > act_full_stroke_tick[j]) current_act_position[j] = act_full_stroke_tick[j]; 
0D2C:  BCF    FD8.0
0D2E:  RLCF   xAD,W
0D30:  CLRF   03
0D32:  ADDLW  89
0D34:  MOVWF  FE9
0D36:  MOVLW  00
0D38:  ADDWFC 03,W
0D3A:  MOVWF  FEA
0D3C:  MOVFF  FEC,B1
0D40:  MOVF   FED,F
0D42:  MOVFF  FEF,B0
0D46:  BCF    FD8.0
0D48:  RLCF   xAD,W
0D4A:  CLRF   03
0D4C:  ADDLW  93
0D4E:  MOVWF  FE9
0D50:  MOVLW  00
0D52:  ADDWFC 03,W
0D54:  MOVWF  FEA
0D56:  MOVFF  FEC,03
0D5A:  MOVF   FED,F
0D5C:  MOVFF  FEF,01
0D60:  MOVF   03,W
0D62:  SUBWF  xB1,W
0D64:  BNC   0DAC
0D66:  BNZ   0D6E
0D68:  MOVF   xB0,W
0D6A:  SUBWF  01,W
0D6C:  BC    0DAC
0D6E:  BCF    FD8.0
0D70:  RLCF   xAD,W
0D72:  CLRF   03
0D74:  ADDLW  89
0D76:  MOVWF  01
0D78:  MOVLW  00
0D7A:  ADDWFC 03,F
0D7C:  MOVFF  03,B1
0D80:  BCF    FD8.0
0D82:  RLCF   xAD,W
0D84:  CLRF   03
0D86:  ADDLW  93
0D88:  MOVWF  FE9
0D8A:  MOVLW  00
0D8C:  ADDWFC 03,W
0D8E:  MOVWF  FEA
0D90:  MOVFF  FEC,03
0D94:  MOVF   FED,F
0D96:  MOVFF  FEF,B2
0D9A:  MOVFF  B1,FEA
0D9E:  MOVFF  01,FE9
0DA2:  MOVFF  03,FEC
0DA6:  MOVF   FED,F
0DA8:  MOVFF  B2,FEF
....................    } 
0DAC:  INCF   xAD,F
0DAE:  BRA    0C16
....................  
....................  
.................... } 
0DB0:  GOTO   3FF0 (RETURN)
....................  
.................... void write_eeprom_data(int8 write_cal) 
.................... { 
....................    int8 i,j; 
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i,timer_sec>>(i*8)); 
*
1172:  CLRF   xAF
1174:  MOVF   xAF,W
1176:  SUBLW  03
1178:  BNC   11DA
117A:  MOVLW  20
117C:  ADDWF  xAF,W
117E:  MOVWF  xB1
1180:  MOVF   xAF,W
1182:  MULLW  08
1184:  MOVFF  FF3,B2
1188:  MOVFF  24,B6
118C:  MOVFF  23,B5
1190:  MOVFF  22,B4
1194:  MOVFF  21,B3
1198:  MOVF   xB2,F
119A:  BZ    11AA
119C:  BCF    FD8.0
119E:  RRCF   xB6,F
11A0:  RRCF   xB5,F
11A2:  RRCF   xB4,F
11A4:  RRCF   xB3,F
11A6:  DECFSZ xB2,F
11A8:  BRA    119C
11AA:  MOVFF  B1,FA9
11AE:  MOVFF  B3,FA8
11B2:  BCF    FA6.6
11B4:  BCF    FA6.7
11B6:  BSF    FA6.2
11B8:  MOVFF  FF2,00
11BC:  BCF    FF2.7
11BE:  MOVLB  F
11C0:  MOVLW  55
11C2:  MOVWF  FA7
11C4:  MOVLW  AA
11C6:  MOVWF  FA7
11C8:  BSF    FA6.1
11CA:  BTFSC  FA6.1
11CC:  BRA    11CA
11CE:  BCF    FA6.2
11D0:  MOVF   00,W
11D2:  IORWF  FF2,F
11D4:  MOVLB  0
11D6:  INCF   xAF,F
11D8:  BRA    1174
....................    for (i=0;i<4;i++) write_eeprom((int8)ADDR_TIME+i+4,nDay>>(i*8)); 
11DA:  CLRF   xAF
11DC:  MOVF   xAF,W
11DE:  SUBLW  03
11E0:  BNC   1244
11E2:  MOVLW  20
11E4:  ADDWF  xAF,W
11E6:  ADDLW  04
11E8:  MOVWF  xB2
11EA:  MOVF   xAF,W
11EC:  MULLW  08
11EE:  MOVFF  FF3,B3
11F2:  MOVFF  34,B7
11F6:  MOVFF  33,B6
11FA:  MOVFF  32,B5
11FE:  MOVFF  31,B4
1202:  MOVF   xB3,F
1204:  BZ    1214
1206:  BCF    FD8.0
1208:  RRCF   xB7,F
120A:  RRCF   xB6,F
120C:  RRCF   xB5,F
120E:  RRCF   xB4,F
1210:  DECFSZ xB3,F
1212:  BRA    1206
1214:  MOVFF  B2,FA9
1218:  MOVFF  B4,FA8
121C:  BCF    FA6.6
121E:  BCF    FA6.7
1220:  BSF    FA6.2
1222:  MOVFF  FF2,00
1226:  BCF    FF2.7
1228:  MOVLB  F
122A:  MOVLW  55
122C:  MOVWF  FA7
122E:  MOVLW  AA
1230:  MOVWF  FA7
1232:  BSF    FA6.1
1234:  BTFSC  FA6.1
1236:  BRA    1234
1238:  BCF    FA6.2
123A:  MOVF   00,W
123C:  IORWF  FF2,F
123E:  MOVLB  0
1240:  INCF   xAF,F
1242:  BRA    11DC
....................  
....................    for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_CURRENT_STROKE+i+j*2,current_act_position[j]>>(i*8)); 
1244:  CLRF   xB0
1246:  MOVF   xB0,W
1248:  SUBLW  03
124A:  BNC   12CE
124C:  CLRF   xAF
124E:  MOVF   xAF,W
1250:  SUBLW  01
1252:  BNC   12CA
1254:  MOVLW  10
1256:  ADDWF  xAF,W
1258:  MOVWF  xB1
125A:  BCF    FD8.0
125C:  RLCF   xB0,W
125E:  ADDWF  xB1,W
1260:  MOVWF  xB2
1262:  BCF    FD8.0
1264:  RLCF   xB0,W
1266:  CLRF   03
1268:  ADDLW  89
126A:  MOVWF  FE9
126C:  MOVLW  00
126E:  ADDWFC 03,W
1270:  MOVWF  FEA
1272:  MOVFF  FEC,B4
1276:  MOVF   FED,F
1278:  MOVFF  FEF,B3
127C:  MOVF   xAF,W
127E:  MULLW  08
1280:  MOVFF  FF3,00
1284:  MOVFF  B4,B6
1288:  MOVFF  B3,B5
128C:  MOVF   00,F
128E:  BZ    129A
1290:  BCF    FD8.0
1292:  RRCF   xB6,F
1294:  RRCF   xB5,F
1296:  DECFSZ 00,F
1298:  BRA    1290
129A:  MOVFF  B2,FA9
129E:  MOVFF  B5,FA8
12A2:  BCF    FA6.6
12A4:  BCF    FA6.7
12A6:  BSF    FA6.2
12A8:  MOVFF  FF2,00
12AC:  BCF    FF2.7
12AE:  MOVLB  F
12B0:  MOVLW  55
12B2:  MOVWF  FA7
12B4:  MOVLW  AA
12B6:  MOVWF  FA7
12B8:  BSF    FA6.1
12BA:  BTFSC  FA6.1
12BC:  BRA    12BA
12BE:  BCF    FA6.2
12C0:  MOVF   00,W
12C2:  IORWF  FF2,F
12C4:  MOVLB  0
12C6:  INCF   xAF,F
12C8:  BRA    124E
12CA:  INCF   xB0,F
12CC:  BRA    1246
....................    for (i=0;i<2;i++) write_eeprom((int8)ADDR_START_COUNTER+i,startup_counter>>(i*8)); 
12CE:  CLRF   xAF
12D0:  MOVF   xAF,W
12D2:  SUBLW  01
12D4:  BNC   132A
12D6:  MOVLW  30
12D8:  ADDWF  xAF,W
12DA:  MOVWF  xB1
12DC:  MOVF   xAF,W
12DE:  MULLW  08
12E0:  MOVFF  FF3,00
12E4:  MOVFF  36,B3
12E8:  MOVFF  35,B2
12EC:  MOVF   00,F
12EE:  BZ    12FA
12F0:  BCF    FD8.0
12F2:  RRCF   xB3,F
12F4:  RRCF   xB2,F
12F6:  DECFSZ 00,F
12F8:  BRA    12F0
12FA:  MOVFF  B1,FA9
12FE:  MOVFF  B2,FA8
1302:  BCF    FA6.6
1304:  BCF    FA6.7
1306:  BSF    FA6.2
1308:  MOVFF  FF2,00
130C:  BCF    FF2.7
130E:  MOVLB  F
1310:  MOVLW  55
1312:  MOVWF  FA7
1314:  MOVLW  AA
1316:  MOVWF  FA7
1318:  BSF    FA6.1
131A:  BTFSC  FA6.1
131C:  BRA    131A
131E:  BCF    FA6.2
1320:  MOVF   00,W
1322:  IORWF  FF2,F
1324:  MOVLB  0
1326:  INCF   xAF,F
1328:  BRA    12D0
....................    if (write_cal ==1) 
132A:  DECFSZ xAE,W
132C:  BRA    13B2
....................       for (j=0;j<4;j++) for (i=0;i<2;i++) write_eeprom((int8)ADDR_FULL_STROKE+i+j*2,act_full_stroke_tick[j]>>(i*8)); 
132E:  CLRF   xB0
1330:  MOVF   xB0,W
1332:  SUBLW  03
1334:  BNC   13B2
1336:  CLRF   xAF
1338:  MOVF   xAF,W
133A:  SUBLW  01
133C:  BNC   13AE
133E:  BCF    FD8.0
1340:  RLCF   xB0,W
1342:  ADDWF  xAF,W
1344:  MOVWF  xB1
1346:  BCF    FD8.0
1348:  RLCF   xB0,W
134A:  CLRF   03
134C:  ADDLW  93
134E:  MOVWF  FE9
1350:  MOVLW  00
1352:  ADDWFC 03,W
1354:  MOVWF  FEA
1356:  MOVFF  FEC,B3
135A:  MOVF   FED,F
135C:  MOVFF  FEF,B2
1360:  MOVF   xAF,W
1362:  MULLW  08
1364:  MOVFF  FF3,00
1368:  MOVFF  B3,B5
136C:  MOVFF  B2,B4
1370:  MOVF   00,F
1372:  BZ    137E
1374:  BCF    FD8.0
1376:  RRCF   xB5,F
1378:  RRCF   xB4,F
137A:  DECFSZ 00,F
137C:  BRA    1374
137E:  MOVFF  B1,FA9
1382:  MOVFF  B4,FA8
1386:  BCF    FA6.6
1388:  BCF    FA6.7
138A:  BSF    FA6.2
138C:  MOVFF  FF2,00
1390:  BCF    FF2.7
1392:  MOVLB  F
1394:  MOVLW  55
1396:  MOVWF  FA7
1398:  MOVLW  AA
139A:  MOVWF  FA7
139C:  BSF    FA6.1
139E:  BTFSC  FA6.1
13A0:  BRA    139E
13A2:  BCF    FA6.2
13A4:  MOVF   00,W
13A6:  IORWF  FF2,F
13A8:  MOVLB  0
13AA:  INCF   xAF,F
13AC:  BRA    1338
13AE:  INCF   xB0,F
13B0:  BRA    1330
.................... } 
13B2:  RETLW  00
....................  
....................  
....................  
....................  
.................... //////////////////////////////////////////////////////// 
....................  
.................... ////////////////////////////////// 
.................... /* 
.................... void button_scan() { 
.................... 	int8 i; 
....................     flag2.button_pressed=0; 
.................... 	for(i=0;i<6;i++) { 
.................... 		portd.data_bus=i; 
.................... 		portd.MUX_en =0; 
.................... 		delay_cycles(20); 
.................... 		if (!input(PIN_E0)) { 
.................... 			flag2.button_pressed=1; 
.................... 			nButton=i; 
.................... 		}  
.................... 		delay_cycles(20); 
.................... 		portd.MUX_en =1; 
.................... 	} 
.................... 	restart_wdt(); 
.................... } 
.................... */ 
....................  
.................... ////////////////////////////////// 
.................... #int_timer1 
.................... void timer1_ovf() 
.................... {   // overflow every 1 sec 
....................       //set_timer1(get_timer1()+0x7FB8); 
.................... 	  #asm 
.................... 		MOVLW 0x80; 
*
06F2:  MOVLW  80
.................... 		MOVWF TMR1H; 
06F4:  MOVWF  FCF
.................... 	  #endasm 
....................       timer_sec+=1; 
06F6:  MOVLW  01
06F8:  ADDWF  21,F
06FA:  MOVLW  00
06FC:  ADDWFC 22,F
06FE:  ADDWFC 23,F
0700:  ADDWFC 24,F
....................       last_command +=1; 
0702:  MOVLW  01
0704:  ADDWF  25,F
0706:  MOVLW  00
0708:  ADDWFC 26,F
070A:  ADDWFC 27,F
070C:  ADDWFC 28,F
.................... 	  //timer_sec = timer_sec/45; 
.................... 	  //timer_sec =timer_sec*45;  
....................       if (timer_sec>=86400) { 
070E:  MOVF   24,F
0710:  BNZ   072C
0712:  MOVF   23,W
0714:  SUBLW  00
0716:  BC    0772
0718:  XORLW  FF
071A:  BNZ   072C
071C:  MOVF   22,W
071E:  SUBLW  50
0720:  BC    0772
0722:  XORLW  FF
0724:  BNZ   072C
0726:  MOVF   21,W
0728:  SUBLW  7F
072A:  BC    0772
.................... 		nDay = (nDay%1461)+1; 
072C:  MOVFF  34,C1
0730:  MOVFF  33,C0
0734:  MOVFF  32,BF
0738:  MOVFF  31,BE
073C:  CLRF   xC5
073E:  CLRF   xC4
0740:  MOVLW  05
0742:  MOVWF  xC3
0744:  MOVLW  B5
0746:  MOVWF  xC2
0748:  RCALL  0658
074A:  MOVFF  FEF,D6
074E:  MOVFF  FEC,D7
0752:  MOVFF  FEC,D8
0756:  MOVFF  FEC,D9
075A:  MOVLW  01
075C:  ADDWF  xD6,W
075E:  MOVWF  31
0760:  MOVLW  00
0762:  ADDWFC xD7,W
0764:  MOVWF  32
0766:  MOVLW  00
0768:  ADDWFC xD8,W
076A:  MOVWF  33
076C:  MOVLW  00
076E:  ADDWFC xD9,W
0770:  MOVWF  34
.................... 	  } 
.................... 	  timer_sec = timer_sec % 86400; 
0772:  MOVFF  24,C1
0776:  MOVFF  23,C0
077A:  MOVFF  22,BF
077E:  MOVFF  21,BE
0782:  CLRF   xC5
0784:  MOVLW  01
0786:  MOVWF  xC4
0788:  MOVLW  51
078A:  MOVWF  xC3
078C:  MOVLW  80
078E:  MOVWF  xC2
0790:  RCALL  0658
0792:  MOVFF  FEF,21
0796:  MOVFF  FEC,22
079A:  MOVFF  FEC,23
079E:  MOVFF  FEC,24
.................... 	  if (last_command > 180)// if no command recv in 3 minutes, reset the RS232 
07A2:  MOVF   28,F
07A4:  BNZ   07B4
07A6:  MOVF   27,F
07A8:  BNZ   07B4
07AA:  MOVF   26,F
07AC:  BNZ   07B4
07AE:  MOVF   25,W
07B0:  SUBLW  B4
07B2:  BC    07C0
.................... 	  {	 init_rs232(); 
07B4:  RCALL  06D2
.................... 		 last_command =0; 
07B6:  CLRF   28
07B8:  CLRF   27
07BA:  CLRF   26
07BC:  CLRF   25
.................... 		 cmd_len =0; 
07BE:  CLRF   4B
....................       }    
....................  
.................... /* // ADC for wall power is not available in this version 
.................... 	  if (read_adc()<650) { 
.................... 		 if (flag2.is_moving) flag2.abort_current_activity=1; 
.................... 		 flag2.power = 0; 
.................... 		 disable_interrupts(INT_RDA); 
.................... 		 led_status =0xFE; 
.................... 		 display_LED(); 
.................... 		 delay_ms(10); 
.................... 		 led_status =0xFF; 
.................... 		 display_LED(); 
....................          return; 
.................... 	  } else { 
.................... 		 if (flag2.power==0) { 
.................... 			enable_interrupts(INT_RDA); 
.................... 			init_rs232(); 
.................... 		 } 
.................... 		 flag2.power=1; 
.................... 	  } 
.................... */ 
....................        
....................       if (flag2.en_operate == 1) { 
07C0:  BTFSS  20.0
07C2:  BRA    0870
.................... 		flag.update_time = true; 
07C4:  BSF    1F.1
.................... //	  	led_status.power = !led_status.power; // blink power led 
.................... 		// display morning, noon, evening 
.................... //	    if(timer_sec >64800 || timer_sec <21600) { 
.................... //			led_status.aux=3; 
.................... //		} else if ( timer_sec < 36000 ) { 
.................... //			led_status.aux=2; 
.................... //		} else if ( timer_sec < 50400) { 
.................... //			led_status.aux=0; 
.................... //		} else { 
.................... //			led_status.aux=1; 
.................... //		} 
....................  
.................... //	  	display_LED(); 
....................       	if ((timer_sec%15) ==0) flag.measure_current=true; 
07C6:  MOVFF  24,C1
07CA:  MOVFF  23,C0
07CE:  MOVFF  22,BF
07D2:  MOVFF  21,BE
07D6:  CLRF   xC5
07D8:  CLRF   xC4
07DA:  CLRF   xC3
07DC:  MOVLW  0F
07DE:  MOVWF  xC2
07E0:  RCALL  0658
07E2:  MOVFF  FEF,D6
07E6:  MOVFF  FEC,D7
07EA:  MOVFF  FEC,D8
07EE:  MOVFF  FEC,D9
07F2:  MOVF   xD6,F
07F4:  BNZ   0804
07F6:  MOVF   xD7,F
07F8:  BNZ   0804
07FA:  MOVF   xD8,F
07FC:  BNZ   0804
07FE:  MOVF   xD9,F
0800:  BTFSC  FD8.2
0802:  BSF    1F.7
.................... 	  	switch ((unsigned int16) (timer_sec % 450)) { 
0804:  MOVFF  24,C1
0808:  MOVFF  23,C0
080C:  MOVFF  22,BF
0810:  MOVFF  21,BE
0814:  CLRF   xC5
0816:  CLRF   xC4
0818:  MOVLW  01
081A:  MOVWF  xC3
081C:  MOVLW  C2
081E:  MOVWF  xC2
0820:  RCALL  0658
0822:  MOVFF  FEF,00
0826:  MOVFF  FEC,01
082A:  MOVFF  FEC,02
082E:  MOVFF  FEC,03
0832:  MOVF   01,W
0834:  MOVWF  03
0836:  BNZ   083C
0838:  MOVF   00,F
083A:  BZ    085E
083C:  MOVF   03,W
083E:  BNZ   0846
0840:  MOVLW  6E
0842:  SUBWF  00,W
0844:  BZ    0864
0846:  MOVF   03,W
0848:  BNZ   0850
084A:  MOVLW  DC
084C:  SUBWF  00,W
084E:  BZ    0868
0850:  MOVLW  01
0852:  SUBWF  03,W
0854:  BNZ   085C
0856:  MOVLW  4A
0858:  SUBWF  00,W
085A:  BZ    086C
085C:  BRA    0870
.................... 			case 0: {	bit_set(actuator_move_mask,0); flag.measure_current = true; break;} 
085E:  BSF    xA7.0
0860:  BSF    1F.7
0862:  BRA    0870
.................... 			case 110: {	bit_set(actuator_move_mask,1); break;} 
0864:  BSF    xA7.1
0866:  BRA    0870
.................... 			case 220: {	bit_set(actuator_move_mask,2); break;} 
0868:  BSF    xA7.2
086A:  BRA    0870
.................... 			case 330: {	bit_set(actuator_move_mask,3); break;} 
086C:  BSF    xA7.3
086E:  BRA    0870
.................... 	  	} 
.................... 	  } 
.................... //	  button_scan(); 
.................... //	  if (nButton == 0) flag2.abort_current_activity=1; 
....................  
.................... } 
....................  
0870:  BCF    F9E.0
0872:  GOTO   0064
.................... void init_spi() { 
.................... 	setup_spi(spi_master |spi_h_to_l | spi_clk_div_16 ); 
*
08E6:  BCF    FC6.5
08E8:  BCF    F94.5
08EA:  BSF    F94.4
08EC:  BCF    F94.3
08EE:  MOVLW  31
08F0:  MOVWF  FC6
08F2:  MOVLW  40
08F4:  MOVWF  FC7
....................     SSPSTAT = 0xC0; 
08F6:  MOVLW  C0
08F8:  MOVWF  FC7
.................... } 
08FA:  GOTO   3ECA (RETURN)
....................  
.................... #int_rda 
.................... void recive_cmd() 
.................... { 
....................    char c; 
....................    c=getc(); 
*
0876:  BTFSS  F9E.5
0878:  BRA    0876
087A:  MOVFF  FAE,D6
....................    switch (c) {	 
087E:  MOVF   xD6,W
0880:  XORLW  08
0882:  BZ    088E
0884:  XORLW  05
0886:  BZ    0892
0888:  XORLW  07
088A:  BZ    08AE
088C:  BRA    08B0
.................... 	 case(8): 	cmd_len--; break; 
088E:  DECF   4B,F
0890:  BRA    08E0
....................      case(13): 	cmd_msg[cmd_len]=0; 
0892:  CLRF   03
0894:  MOVF   4B,W
0896:  ADDLW  37
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  CLRF   FEF
....................    				if(cmd_len>=1)flag.cmd_posted=true; 
08A2:  MOVF   4B,W
08A4:  SUBLW  00
08A6:  BTFSS  FD8.0
08A8:  BSF    1F.3
....................    				cmd_len =0; 
08AA:  CLRF   4B
.................... 				break; 
08AC:  BRA    08E0
....................      case(10):  break; 
08AE:  BRA    08E0
....................      default: 	if ((c>=' ')&&(c<='~'))  
08B0:  MOVF   xD6,W
08B2:  SUBLW  1F
08B4:  BC    08DE
08B6:  MOVF   xD6,W
08B8:  SUBLW  7E
08BA:  BNC   08DE
.................... 				 if(cmd_len<=MAX_CMD_LEN) { 
08BC:  MOVF   4B,W
08BE:  SUBLW  12
08C0:  BNC   08DE
.................... 					cmd_msg[cmd_len++]=c; 
08C2:  MOVF   4B,W
08C4:  INCF   4B,F
08C6:  CLRF   03
08C8:  ADDLW  37
08CA:  MOVWF  FE9
08CC:  MOVLW  00
08CE:  ADDWFC 03,W
08D0:  MOVWF  FEA
08D2:  MOVFF  D6,FEF
.................... 				    last_command =0;  
08D6:  CLRF   28
08D8:  CLRF   27
08DA:  CLRF   26
08DC:  CLRF   25
.................... 				} 
.................... 				break;  
08DE:  BRA    08E0
....................    } 
.................... } 
....................  
08E0:  BCF    F9E.5
08E2:  GOTO   0064
.................... void process_cmd_msg(){ 
....................    int8 i,j; 
....................    flag.cmd_posted =false; 
*
31F2:  BCF    1F.3
....................    last_command =0; 
31F4:  CLRF   28
31F6:  CLRF   27
31F8:  CLRF   26
31FA:  CLRF   25
....................    printf("\r\n>%s\r\n",cmd_msg); 
31FC:  MOVLW  0D
31FE:  BTFSS  F9E.4
3200:  BRA    31FE
3202:  MOVWF  FAD
3204:  MOVLW  0A
3206:  BTFSS  F9E.4
3208:  BRA    3206
320A:  MOVWF  FAD
320C:  MOVLW  3E
320E:  BTFSS  F9E.4
3210:  BRA    320E
3212:  MOVWF  FAD
3214:  CLRF   FEA
3216:  MOVLW  37
3218:  MOVWF  FE9
321A:  MOVLW  00
321C:  IORWF  FEF,W
321E:  BZ    3230
3220:  MOVF   FEF,W
3222:  BTFSS  F9E.4
3224:  BRA    3222
3226:  MOVWF  FAD
3228:  INCF   FE9,F
322A:  BTFSC  FD8.2
322C:  INCF   FEA,F
322E:  BRA    321A
3230:  MOVLW  0D
3232:  BTFSS  F9E.4
3234:  BRA    3232
3236:  MOVWF  FAD
3238:  MOVLW  0A
323A:  BTFSS  F9E.4
323C:  BRA    323A
323E:  MOVWF  FAD
....................    switch (cmd_msg[0]) { 
3240:  MOVLW  62
3242:  SUBWF  37,W
3244:  ADDLW  E7
3246:  BTFSC  FD8.0
3248:  GOTO   3A5A
324C:  ADDLW  19
324E:  GOTO   3A5E
....................       case 'e': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3252:  CLRF   FEA
3254:  MOVLW  37
3256:  MOVWF  FE9
3258:  CLRF   FE2
325A:  MOVLW  38
325C:  MOVWF  FE1
325E:  MOVLW  12
3260:  MOVWF  01
3262:  MOVFF  FE6,FEE
3266:  DECFSZ 01,F
3268:  BRA    3262
....................          if (atol(cmd_msg)!=22) break; 
326A:  CLRF   xAF
326C:  MOVLW  37
326E:  MOVWF  xAE
3270:  CALL   13D4
3274:  MOVFF  02,AF
3278:  MOVF   01,W
327A:  MOVWF  xAE
327C:  SUBLW  16
327E:  BNZ   3284
3280:  MOVF   xAF,F
3282:  BZ    3288
3284:  GOTO   3A5A
.................... 		 printf("\r\n Block erase\r\n"); 
3288:  CLRF   xAE
328A:  MOVF   xAE,W
328C:  CALL   02BE
3290:  INCF   xAE,F
3292:  MOVWF  00
3294:  MOVF   00,W
3296:  BTFSS  F9E.4
3298:  BRA    3296
329A:  MOVWF  FAD
329C:  MOVLW  10
329E:  SUBWF  xAE,W
32A0:  BNZ   328A
....................          flash_block_erase(); 
32A2:  GOTO   15BC
....................          break; } 
....................  
....................       case 'r': { 
....................          disable_interrupts(GLOBAL); 
32A6:  BCF    FF2.6
32A8:  BCF    FF2.7
32AA:  BTFSC  FF2.7
32AC:  BRA    32A8
....................          memcpy(cmd_msg,cmd_msg+1,18); 
32AE:  CLRF   FEA
32B0:  MOVLW  37
32B2:  MOVWF  FE9
32B4:  CLRF   FE2
32B6:  MOVLW  38
32B8:  MOVWF  FE1
32BA:  MOVLW  12
32BC:  MOVWF  01
32BE:  MOVFF  FE6,FEE
32C2:  DECFSZ 01,F
32C4:  BRA    32BE
.................... 		 setup_WDT(WDT_OFF); 
32C6:  BCF    FD1.0
....................          printf("\r\n PAGE %ld:",atol(cmd_msg)); 
32C8:  CLRF   xAF
32CA:  MOVLW  37
32CC:  MOVWF  xAE
32CE:  CALL   13D4
32D2:  MOVFF  02,AF
32D6:  MOVFF  01,AE
32DA:  CLRF   xB0
32DC:  MOVF   xB0,W
32DE:  CALL   02EA
32E2:  INCF   xB0,F
32E4:  MOVWF  00
32E6:  MOVF   00,W
32E8:  BTFSS  F9E.4
32EA:  BRA    32E8
32EC:  MOVWF  FAD
32EE:  MOVLW  08
32F0:  SUBWF  xB0,W
32F2:  BNZ   32DC
32F4:  MOVLW  10
32F6:  MOVWF  FE9
32F8:  MOVFF  AF,C1
32FC:  MOVFF  AE,C0
3300:  CALL   1616
3304:  MOVLW  3A
3306:  BTFSS  F9E.4
3308:  BRA    3306
330A:  MOVWF  FAD
....................          print_page_data(atol(cmd_msg)); 
330C:  CLRF   xAF
330E:  MOVLW  37
3310:  MOVWF  xAE
3312:  CALL   13D4
3316:  MOVFF  02,AF
331A:  MOVFF  01,AE
331E:  MOVFF  02,B1
3322:  MOVFF  01,B0
3326:  GOTO   16F2
.................... 		 setup_WDT(WDT_ON); 
332A:  BSF    FD1.0
....................          enable_interrupts(GLOBAL); 
332C:  MOVLW  C0
332E:  IORWF  FF2,F
....................          break; 
3330:  GOTO   3A5A
....................       } 
....................       case 'b': { 
....................          disable_interrupts(GLOBAL); 
3334:  BCF    FF2.6
3336:  BCF    FF2.7
3338:  BTFSC  FF2.7
333A:  BRA    3336
....................          memcpy(cmd_msg,cmd_msg+1,18); 
333C:  CLRF   FEA
333E:  MOVLW  37
3340:  MOVWF  FE9
3342:  CLRF   FE2
3344:  MOVLW  38
3346:  MOVWF  FE1
3348:  MOVLW  12
334A:  MOVWF  01
334C:  MOVFF  FE6,FEE
3350:  DECFSZ 01,F
3352:  BRA    334C
....................          printf("\r\n Write buffer1 -> PAGE %ld:",atol(cmd_msg)); 
3354:  CLRF   xAF
3356:  MOVLW  37
3358:  MOVWF  xAE
335A:  CALL   13D4
335E:  MOVFF  02,AF
3362:  MOVFF  01,AE
3366:  CLRF   xB0
3368:  MOVF   xB0,W
336A:  CALL   0312
336E:  INCF   xB0,F
3370:  MOVWF  00
3372:  MOVF   00,W
3374:  BTFSS  F9E.4
3376:  BRA    3374
3378:  MOVWF  FAD
337A:  MOVLW  19
337C:  SUBWF  xB0,W
337E:  BNZ   3368
3380:  MOVLW  10
3382:  MOVWF  FE9
3384:  MOVFF  AF,C1
3388:  MOVFF  AE,C0
338C:  CALL   1616
3390:  MOVLW  3A
3392:  BTFSS  F9E.4
3394:  BRA    3392
3396:  MOVWF  FAD
....................          flash_write_buffer1_to_main_memory(atol(cmd_msg)); 
3398:  CLRF   xAF
339A:  MOVLW  37
339C:  MOVWF  xAE
339E:  CALL   13D4
33A2:  MOVFF  02,AF
33A6:  MOVFF  01,AE
33AA:  MOVFF  02,BB
33AE:  MOVFF  01,BA
33B2:  CALL   1788
....................          enable_interrupts(GLOBAL); 
33B6:  MOVLW  C0
33B8:  IORWF  FF2,F
....................          break; 
33BA:  BRA    3A5A
....................       } 
....................  
....................       case 'c': { 
....................          disable_interrupts(GLOBAL); 
33BC:  BCF    FF2.6
33BE:  BCF    FF2.7
33C0:  BTFSC  FF2.7
33C2:  BRA    33BE
....................          memcpy(cmd_msg,cmd_msg+1,18); 
33C4:  CLRF   FEA
33C6:  MOVLW  37
33C8:  MOVWF  FE9
33CA:  CLRF   FE2
33CC:  MOVLW  38
33CE:  MOVWF  FE1
33D0:  MOVLW  12
33D2:  MOVWF  01
33D4:  MOVFF  FE6,FEE
33D8:  DECFSZ 01,F
33DA:  BRA    33D4
....................          printf("\r\n Read PAGE %ld -> buffer1",atol(cmd_msg)); 
33DC:  CLRF   xAF
33DE:  MOVLW  37
33E0:  MOVWF  xAE
33E2:  CALL   13D4
33E6:  MOVFF  02,AF
33EA:  MOVFF  01,AE
33EE:  CLRF   xB0
33F0:  MOVF   xB0,W
33F2:  CALL   034A
33F6:  INCF   xB0,F
33F8:  MOVWF  00
33FA:  MOVF   00,W
33FC:  BTFSS  F9E.4
33FE:  BRA    33FC
3400:  MOVWF  FAD
3402:  MOVLW  0D
3404:  SUBWF  xB0,W
3406:  BNZ   33F0
3408:  MOVLW  10
340A:  MOVWF  FE9
340C:  MOVFF  AF,C1
3410:  MOVFF  AE,C0
3414:  CALL   1616
3418:  MOVLW  10
341A:  MOVWF  xB1
341C:  MOVF   xB1,W
341E:  CALL   034A
3422:  INCF   xB1,F
3424:  MOVWF  00
3426:  MOVF   00,W
3428:  BTFSS  F9E.4
342A:  BRA    3428
342C:  MOVWF  FAD
342E:  MOVLW  1B
3430:  SUBWF  xB1,W
3432:  BNZ   341C
....................          flash_read_main_memory_to_buffer1(atol(cmd_msg)); 
3434:  CLRF   xAF
3436:  MOVLW  37
3438:  MOVWF  xAE
343A:  CALL   13D4
343E:  MOVFF  02,AF
3442:  MOVFF  01,AE
3446:  MOVFF  02,BB
344A:  MOVFF  01,BA
344E:  CALL   17CE
....................          enable_interrupts(GLOBAL); 
3452:  MOVLW  C0
3454:  IORWF  FF2,F
....................          break; 
3456:  BRA    3A5A
....................       } 
....................  
....................       case 'f': { 
....................          disable_interrupts(GLOBAL); 
3458:  BCF    FF2.6
345A:  BCF    FF2.7
345C:  BTFSC  FF2.7
345E:  BRA    345A
.................... 		 setup_WDT(WDT_OFF); 
3460:  BCF    FD1.0
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3462:  CLRF   FEA
3464:  MOVLW  37
3466:  MOVWF  FE9
3468:  CLRF   FE2
346A:  MOVLW  38
346C:  MOVWF  FE1
346E:  MOVLW  12
3470:  MOVWF  01
3472:  MOVFF  FE6,FEE
3476:  DECFSZ 01,F
3478:  BRA    3472
....................          printf("\r\n WRITE PAGE %ld:",atol(cmd_msg)); 
347A:  CLRF   xAF
347C:  MOVLW  37
347E:  MOVWF  xAE
3480:  CALL   13D4
3484:  MOVFF  02,AF
3488:  MOVFF  01,AE
348C:  CLRF   xB0
348E:  MOVF   xB0,W
3490:  CALL   0380
3494:  INCF   xB0,F
3496:  MOVWF  00
3498:  MOVF   00,W
349A:  BTFSS  F9E.4
349C:  BRA    349A
349E:  MOVWF  FAD
34A0:  MOVLW  0E
34A2:  SUBWF  xB0,W
34A4:  BNZ   348E
34A6:  MOVLW  10
34A8:  MOVWF  FE9
34AA:  MOVFF  AF,C1
34AE:  MOVFF  AE,C0
34B2:  CALL   1616
34B6:  MOVLW  3A
34B8:  BTFSS  F9E.4
34BA:  BRA    34B8
34BC:  MOVWF  FAD
....................          flash_write_page(atol(cmd_msg)); 
34BE:  CLRF   xAF
34C0:  MOVLW  37
34C2:  MOVWF  xAE
34C4:  CALL   13D4
34C8:  MOVFF  02,AF
34CC:  MOVFF  01,AE
34D0:  MOVFF  02,B1
34D4:  MOVFF  01,B0
34D8:  GOTO   180A
.................... 		 printf("\r\n."); 
34DC:  MOVLW  0D
34DE:  BTFSS  F9E.4
34E0:  BRA    34DE
34E2:  MOVWF  FAD
34E4:  MOVLW  0A
34E6:  BTFSS  F9E.4
34E8:  BRA    34E6
34EA:  MOVWF  FAD
34EC:  MOVLW  2E
34EE:  BTFSS  F9E.4
34F0:  BRA    34EE
34F2:  MOVWF  FAD
.................... 		 setup_WDT(WDT_ON); 
34F4:  BSF    FD1.0
....................          enable_interrupts(GLOBAL); 
34F6:  MOVLW  C0
34F8:  IORWF  FF2,F
....................          break; 
34FA:  BRA    3A5A
....................       } 
....................       case 'g': { 
....................          print_date_time(0x01); 
34FC:  MOVLW  01
34FE:  MOVWF  xAE
3500:  CALL   1E7E
....................          break; 
3504:  BRA    3A5A
....................       } 
....................       case 'w': { //buffer1 read 
....................          disable_interrupts(GLOBAL); 
3506:  BCF    FF2.6
3508:  BCF    FF2.7
350A:  BTFSC  FF2.7
350C:  BRA    3508
.................... 		 printf("\r\n Buffer1:"); 
350E:  CLRF   xAE
3510:  MOVF   xAE,W
3512:  CALL   03AE
3516:  INCF   xAE,F
3518:  MOVWF  00
351A:  MOVF   00,W
351C:  BTFSS  F9E.4
351E:  BRA    351C
3520:  MOVWF  FAD
3522:  MOVLW  0B
3524:  SUBWF  xAE,W
3526:  BNZ   3510
....................     	for(i=0;i<16;i++) { 
3528:  CLRF   xAC
352A:  MOVF   xAC,W
352C:  SUBLW  0F
352E:  BNC   35BC
....................       		printf("\r\n%02X : ",i*16); 
3530:  MOVF   xAC,W
3532:  MULLW  10
3534:  MOVFF  FF3,AE
3538:  MOVLW  0D
353A:  BTFSS  F9E.4
353C:  BRA    353A
353E:  MOVWF  FAD
3540:  MOVLW  0A
3542:  BTFSS  F9E.4
3544:  BRA    3542
3546:  MOVWF  FAD
3548:  MOVFF  AE,B4
354C:  MOVLW  37
354E:  MOVWF  xB5
3550:  CALL   0AC6
3554:  MOVLW  20
3556:  BTFSS  F9E.4
3558:  BRA    3556
355A:  MOVWF  FAD
355C:  MOVLW  3A
355E:  BTFSS  F9E.4
3560:  BRA    355E
3562:  MOVWF  FAD
3564:  MOVLW  20
3566:  BTFSS  F9E.4
3568:  BRA    3566
356A:  MOVWF  FAD
....................       		for (j=0;j<8;j++) { 
356C:  CLRF   xAD
356E:  MOVF   xAD,W
3570:  SUBLW  07
3572:  BNC   35B8
....................         		flash_buffer1_read(i*16+j*2); 
3574:  MOVF   xAC,W
3576:  MULLW  10
3578:  MOVFF  FF3,AE
357C:  BCF    FD8.0
357E:  RLCF   xAD,W
3580:  ADDWF  xAE,W
3582:  MOVWF  xAF
3584:  MOVWF  xB0
3586:  GOTO   21D8
.................... 				printf("%02X %02X ",flash_page_data,flash_page_data2); 
358A:  MOVFF  7F,B4
358E:  MOVLW  37
3590:  MOVWF  xB5
3592:  CALL   0AC6
3596:  MOVLW  20
3598:  BTFSS  F9E.4
359A:  BRA    3598
359C:  MOVWF  FAD
359E:  MOVFF  80,B4
35A2:  MOVLW  37
35A4:  MOVWF  xB5
35A6:  CALL   0AC6
35AA:  MOVLW  20
35AC:  BTFSS  F9E.4
35AE:  BRA    35AC
35B0:  MOVWF  FAD
.................... 				restart_wdt(); 
35B2:  CLRWDT
.................... 	  	 	} 
35B4:  INCF   xAD,F
35B6:  BRA    356E
....................          }     
35B8:  INCF   xAC,F
35BA:  BRA    352A
....................          enable_interrupts(GLOBAL);          
35BC:  MOVLW  C0
35BE:  IORWF  FF2,F
....................          break;	} 
35C0:  BRA    3A5A
....................       case 'm':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
35C2:  CLRF   FEA
35C4:  MOVLW  37
35C6:  MOVWF  FE9
35C8:  CLRF   FE2
35CA:  MOVLW  38
35CC:  MOVWF  FE1
35CE:  MOVLW  12
35D0:  MOVWF  01
35D2:  MOVFF  FE6,FEE
35D6:  DECFSZ 01,F
35D8:  BRA    35D2
....................          if (atol(cmd_msg)==0) break; 
35DA:  CLRF   xAF
35DC:  MOVLW  37
35DE:  MOVWF  xAE
35E0:  CALL   13D4
35E4:  MOVFF  02,AF
35E8:  MOVFF  01,AE
35EC:  MOVF   xAE,F
35EE:  BNZ   35F6
35F0:  MOVF   xAF,F
35F2:  BNZ   35F6
35F4:  BRA    3A5A
....................          move_act(atol(cmd_msg),9000,move_act_time_out,1,0); 
35F6:  CLRF   xAF
35F8:  MOVLW  37
35FA:  MOVWF  xAE
35FC:  CALL   13D4
3600:  MOVFF  02,AF
3604:  MOVFF  01,AE
3608:  MOVFF  02,B5
360C:  MOVFF  01,B4
3610:  MOVLW  23
3612:  MOVWF  xB7
3614:  MOVLW  28
3616:  MOVWF  xB6
3618:  MOVFF  82,B9
361C:  MOVFF  81,B8
3620:  MOVLW  01
3622:  MOVWF  xBA
3624:  CLRF   xBB
3626:  CALL   222E
....................          break;    } 
362A:  BRA    3A5A
....................       case 'n':{  
....................          memcpy(cmd_msg,cmd_msg+1,18); 
362C:  CLRF   FEA
362E:  MOVLW  37
3630:  MOVWF  FE9
3632:  CLRF   FE2
3634:  MOVLW  38
3636:  MOVWF  FE1
3638:  MOVLW  12
363A:  MOVWF  01
363C:  MOVFF  FE6,FEE
3640:  DECFSZ 01,F
3642:  BRA    363C
....................          if (atol(cmd_msg)==0) break; 
3644:  CLRF   xAF
3646:  MOVLW  37
3648:  MOVWF  xAE
364A:  CALL   13D4
364E:  MOVFF  02,AF
3652:  MOVFF  01,AE
3656:  MOVF   xAE,F
3658:  BNZ   3660
365A:  MOVF   xAF,F
365C:  BNZ   3660
365E:  BRA    3A5A
....................          move_act(atol(cmd_msg),9000,move_act_time_out,0,0); 
3660:  CLRF   xAF
3662:  MOVLW  37
3664:  MOVWF  xAE
3666:  CALL   13D4
366A:  MOVFF  02,AF
366E:  MOVFF  01,AE
3672:  MOVFF  02,B5
3676:  MOVFF  01,B4
367A:  MOVLW  23
367C:  MOVWF  xB7
367E:  MOVLW  28
3680:  MOVWF  xB6
3682:  MOVFF  82,B9
3686:  MOVFF  81,B8
368A:  CLRF   xBA
368C:  CLRF   xBB
368E:  CALL   222E
....................          break;    } 
3692:  BRA    3A5A
....................       case 'p': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3694:  CLRF   FEA
3696:  MOVLW  37
3698:  MOVWF  FE9
369A:  CLRF   FE2
369C:  MOVLW  38
369E:  MOVWF  FE1
36A0:  MOVLW  12
36A2:  MOVWF  01
36A4:  MOVFF  FE6,FEE
36A8:  DECFSZ 01,F
36AA:  BRA    36A4
....................          if (atol(cmd_msg)!=22) break; 
36AC:  CLRF   xAF
36AE:  MOVLW  37
36B0:  MOVWF  xAE
36B2:  CALL   13D4
36B6:  MOVFF  02,AF
36BA:  MOVF   01,W
36BC:  MOVWF  xAE
36BE:  SUBLW  16
36C0:  BNZ   36C6
36C2:  MOVF   xAF,F
36C4:  BZ    36C8
36C6:  BRA    3A5A
.................... 		 printf("\r\n Set 256 page size\r\n"); 
36C8:  CLRF   xAE
36CA:  MOVF   xAE,W
36CC:  CALL   03D4
36D0:  INCF   xAE,F
36D2:  MOVWF  00
36D4:  MOVF   00,W
36D6:  BTFSS  F9E.4
36D8:  BRA    36D6
36DA:  MOVWF  FAD
36DC:  MOVLW  16
36DE:  SUBWF  xAE,W
36E0:  BNZ   36CA
....................          flash_set_256_page_size(); 
36E2:  GOTO   25A4
....................          break; } 
....................  
.................... 	  case 'z': { 
.................... 		 print_fw_info(); 
36E6:  CALL   0F46
.................... 		 printf("\r\n startup = %ld",startup_counter); 
36EA:  CLRF   xAE
36EC:  MOVF   xAE,W
36EE:  CALL   0406
36F2:  INCF   xAE,F
36F4:  MOVWF  00
36F6:  MOVF   00,W
36F8:  BTFSS  F9E.4
36FA:  BRA    36F8
36FC:  MOVWF  FAD
36FE:  MOVLW  0D
3700:  SUBWF  xAE,W
3702:  BNZ   36EC
3704:  MOVLW  10
3706:  MOVWF  FE9
3708:  MOVFF  36,C1
370C:  MOVFF  35,C0
3710:  CALL   1616
.................... 		 break; 
3714:  BRA    3A5A
.................... 	  } 
.................... 	  case 'd': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3716:  CLRF   FEA
3718:  MOVLW  37
371A:  MOVWF  FE9
371C:  CLRF   FE2
371E:  MOVLW  38
3720:  MOVWF  FE1
3722:  MOVLW  12
3724:  MOVWF  01
3726:  MOVFF  FE6,FEE
372A:  DECFSZ 01,F
372C:  BRA    3726
....................          if (atol(cmd_msg)==0) break; 
372E:  CLRF   xAF
3730:  MOVLW  37
3732:  MOVWF  xAE
3734:  CALL   13D4
3738:  MOVFF  02,AF
373C:  MOVFF  01,AE
3740:  MOVF   xAE,F
3742:  BNZ   374A
3744:  MOVF   xAF,F
3746:  BNZ   374A
3748:  BRA    3A5A
....................          nDay= atol(cmd_msg); 
374A:  CLRF   xAF
374C:  MOVLW  37
374E:  MOVWF  xAE
3750:  CALL   13D4
3754:  MOVFF  01,00
3758:  MOVFF  02,01
375C:  CLRF   02
375E:  CLRF   03
3760:  MOVFF  03,34
3764:  MOVFF  02,33
3768:  MOVFF  01,32
376C:  MOVFF  00,31
....................          break;    } 
3770:  BRA    3A5A
.................... 	  case 't': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
3772:  CLRF   FEA
3774:  MOVLW  37
3776:  MOVWF  FE9
3778:  CLRF   FE2
377A:  MOVLW  38
377C:  MOVWF  FE1
377E:  MOVLW  12
3780:  MOVWF  01
3782:  MOVFF  FE6,FEE
3786:  DECFSZ 01,F
3788:  BRA    3782
....................          timer_sec = atoi32(cmd_msg); 
378A:  CLRF   xAF
378C:  MOVLW  37
378E:  MOVWF  xAE
3790:  GOTO   25E6
3794:  MOVFF  03,24
3798:  MOVFF  02,23
379C:  MOVFF  01,22
37A0:  MOVFF  00,21
.................... 		 timer_sec = timer_sec; // rouding to 60 sec 
.................... 		 n_avg=0; 
37A4:  CLRF   x79
.................... 		 accumulate_current=0; 
37A6:  CLRF   x78
37A8:  CLRF   x77
....................          break;    } 
37AA:  BRA    3A5A
.................... 	  case 'l': { 
....................          memcpy(cmd_msg,cmd_msg+1,18); 
37AC:  CLRF   FEA
37AE:  MOVLW  37
37B0:  MOVWF  FE9
37B2:  CLRF   FE2
37B4:  MOVLW  38
37B6:  MOVWF  FE1
37B8:  MOVLW  12
37BA:  MOVWF  01
37BC:  MOVFF  FE6,FEE
37C0:  DECFSZ 01,F
37C2:  BRA    37BC
....................          solar_get_act_length(atoi(cmd_msg)); 
37C4:  CLRF   xB0
37C6:  MOVLW  37
37C8:  MOVWF  xAF
37CA:  CALL   28CE
37CE:  MOVFF  01,AE
37D2:  MOVFF  01,AF
37D6:  CALL   2A68
.................... 		 disable_interrupts(GLOBAL); 
37DA:  BCF    FF2.6
37DC:  BCF    FF2.7
37DE:  BTFSC  FF2.7
37E0:  BRA    37DC
.................... 		 printf("\r\n Act#%d Len=%lu Now=%lu\r\n",atoi(cmd_msg), target_act_position, current_act_position[atoi(cmd_msg)]); 
37E2:  CLRF   xB0
37E4:  MOVLW  37
37E6:  MOVWF  xAF
37E8:  CALL   28CE
37EC:  MOVFF  01,AE
37F0:  CLRF   xB0
37F2:  MOVLW  37
37F4:  MOVWF  xAF
37F6:  CALL   28CE
37FA:  MOVFF  01,B6
37FE:  MOVLW  02
3800:  MOVWF  xB7
3802:  CALL   2884
3806:  MOVF   01,W
3808:  CLRF   03
380A:  ADDLW  89
380C:  MOVWF  FE9
380E:  MOVLW  00
3810:  ADDWFC 03,W
3812:  MOVWF  FEA
3814:  MOVFF  FEC,B1
3818:  MOVF   FED,F
381A:  MOVFF  FEF,B0
381E:  CLRF   xB2
3820:  MOVF   xB2,W
3822:  CALL   0432
3826:  INCF   xB2,F
3828:  MOVWF  00
382A:  MOVF   00,W
382C:  BTFSS  F9E.4
382E:  BRA    382C
3830:  MOVWF  FAD
3832:  MOVLW  07
3834:  SUBWF  xB2,W
3836:  BNZ   3820
3838:  MOVFF  AE,B3
383C:  MOVLW  1F
383E:  MOVWF  xB4
3840:  CALL   2F86
3844:  MOVLW  09
3846:  MOVWF  xB3
3848:  MOVF   xB3,W
384A:  CALL   0432
384E:  INCF   xB3,F
3850:  MOVWF  00
3852:  MOVF   00,W
3854:  BTFSS  F9E.4
3856:  BRA    3854
3858:  MOVWF  FAD
385A:  MOVLW  0E
385C:  SUBWF  xB3,W
385E:  BNZ   3848
3860:  MOVLW  10
3862:  MOVWF  FE9
3864:  MOVFF  92,B6
3868:  MOVFF  91,B5
386C:  CALL   0EA2
3870:  MOVLW  11
3872:  MOVWF  xB4
3874:  MOVF   xB4,W
3876:  CALL   0432
387A:  INCF   xB4,F
387C:  MOVWF  00
387E:  MOVF   00,W
3880:  BTFSS  F9E.4
3882:  BRA    3880
3884:  MOVWF  FAD
3886:  MOVLW  16
3888:  SUBWF  xB4,W
388A:  BNZ   3874
388C:  MOVLW  10
388E:  MOVWF  FE9
3890:  MOVFF  B1,B6
3894:  MOVFF  B0,B5
3898:  CALL   0EA2
389C:  MOVLW  0D
389E:  BTFSS  F9E.4
38A0:  BRA    389E
38A2:  MOVWF  FAD
38A4:  MOVLW  0A
38A6:  BTFSS  F9E.4
38A8:  BRA    38A6
38AA:  MOVWF  FAD
.................... 		 enable_interrupts(GLOBAL); 
38AC:  MOVLW  C0
38AE:  IORWF  FF2,F
.................... 		 actuator_move_execute(atoi(cmd_msg)); 
38B0:  CLRF   xB0
38B2:  MOVLW  37
38B4:  MOVWF  xAF
38B6:  CALL   28CE
38BA:  MOVFF  01,AE
38BE:  MOVFF  01,AF
38C2:  CALL   3056
....................          break;    } 
38C6:  BRA    3A5A
....................       case 'h' : { //return home 
.................... 	     memcpy(cmd_msg,cmd_msg+1,18); 
38C8:  CLRF   FEA
38CA:  MOVLW  37
38CC:  MOVWF  FE9
38CE:  CLRF   FE2
38D0:  MOVLW  38
38D2:  MOVWF  FE1
38D4:  MOVLW  12
38D6:  MOVWF  01
38D8:  MOVFF  FE6,FEE
38DC:  DECFSZ 01,F
38DE:  BRA    38D8
....................          if(strlen(cmd_msg)>0) { 
38E0:  CLRF   xB2
38E2:  MOVLW  37
38E4:  MOVWF  xB1
38E6:  CALL   1D98
38EA:  MOVF   01,F
38EC:  BZ    39B0
.................... 	     flag2.en_operate =0; 
38EE:  BCF    20.0
....................          move_act(2000,0xFFFF,move_act_time_out,1,atoi(cmd_msg)); // move actuator to west 
38F0:  CLRF   xB0
38F2:  MOVLW  37
38F4:  MOVWF  xAF
38F6:  CALL   28CE
38FA:  MOVFF  01,AE
38FE:  MOVLW  07
3900:  MOVWF  xB5
3902:  MOVLW  D0
3904:  MOVWF  xB4
3906:  MOVLW  FF
3908:  MOVWF  xB7
390A:  MOVWF  xB6
390C:  MOVFF  82,B9
3910:  MOVFF  81,B8
3914:  MOVLW  01
3916:  MOVWF  xBA
3918:  MOVFF  01,BB
391C:  CALL   222E
....................          move_act(2000,0xFFFF,move_act_time_out,0,atoi(cmd_msg)); // move actuator to home position 
3920:  CLRF   xB0
3922:  MOVLW  37
3924:  MOVWF  xAF
3926:  CALL   28CE
392A:  MOVFF  01,AE
392E:  MOVLW  07
3930:  MOVWF  xB5
3932:  MOVLW  D0
3934:  MOVWF  xB4
3936:  MOVLW  FF
3938:  MOVWF  xB7
393A:  MOVWF  xB6
393C:  MOVFF  82,B9
3940:  MOVFF  81,B8
3944:  CLRF   xBA
3946:  MOVFF  01,BB
394A:  CALL   222E
....................          act_full_stroke_tick[atoi(cmd_msg)]= actuator_pulse; 
394E:  CLRF   xB0
3950:  MOVLW  37
3952:  MOVWF  xAF
3954:  CALL   28CE
3958:  MOVFF  01,B6
395C:  MOVLW  02
395E:  MOVWF  xB7
3960:  CALL   2884
3964:  MOVF   01,W
3966:  CLRF   03
3968:  ADDLW  93
396A:  MOVWF  FE9
396C:  MOVLW  00
396E:  ADDWFC 03,W
3970:  MOVWF  FEA
3972:  MOVFF  84,FEC
3976:  MOVF   FED,F
3978:  MOVFF  83,FEF
....................          current_act_position[atoi(cmd_msg)] =0; 
397C:  CLRF   xB0
397E:  MOVLW  37
3980:  MOVWF  xAF
3982:  CALL   28CE
3986:  MOVFF  01,B6
398A:  MOVLW  02
398C:  MOVWF  xB7
398E:  CALL   2884
3992:  MOVF   01,W
3994:  CLRF   03
3996:  ADDLW  89
3998:  MOVWF  FE9
399A:  MOVLW  00
399C:  ADDWFC 03,W
399E:  MOVWF  FEA
39A0:  CLRF   FEC
39A2:  MOVF   FED,F
39A4:  CLRF   FEF
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
39A6:  MOVLW  01
39A8:  MOVWF  xAE
39AA:  CALL   1172
.................... 	     flag2.en_operate =1;  
39AE:  BSF    20.0
.................... 		 } 
....................  
....................          break; 
39B0:  BRA    3A5A
....................       } 
.................... 		  
....................       case 'j': { 
....................          write_eeprom_data(1); // save full_stroke_tick and current_position 
39B2:  MOVLW  01
39B4:  MOVWF  xAE
39B6:  CALL   1172
....................          break; 
39BA:  BRA    3A5A
....................       } 
....................  
.................... 	  case 'o': { 
.................... 		 flag2.en_operate = !flag2.en_operate; 
39BC:  BTG    20.0
.................... 		 if (flag2.en_operate) printf("\r\n Normal operation"); else printf("\r\n Halt operation"); 
39BE:  BTFSS  20.0
39C0:  BRA    39DE
39C2:  CLRF   xAE
39C4:  MOVF   xAE,W
39C6:  CALL   0468
39CA:  INCF   xAE,F
39CC:  MOVWF  00
39CE:  MOVF   00,W
39D0:  BTFSS  F9E.4
39D2:  BRA    39D0
39D4:  MOVWF  FAD
39D6:  MOVLW  13
39D8:  SUBWF  xAE,W
39DA:  BNZ   39C4
39DC:  BRA    39F8
39DE:  CLRF   xAE
39E0:  MOVF   xAE,W
39E2:  CALL   0496
39E6:  INCF   xAE,F
39E8:  MOVWF  00
39EA:  MOVF   00,W
39EC:  BTFSS  F9E.4
39EE:  BRA    39EC
39F0:  MOVWF  FAD
39F2:  MOVLW  11
39F4:  SUBWF  xAE,W
39F6:  BNZ   39E0
.................... 		 break; 
39F8:  BRA    3A5A
.................... 	  } 
....................  
....................       case 'y': { //adc conversion 
....................          set_adc_channel(0); 
39FA:  MOVLW  00
39FC:  MOVWF  01
39FE:  MOVF   FC2,W
3A00:  ANDLW  C7
3A02:  IORWF  01,W
3A04:  MOVWF  FC2
....................          delay_us(20); 
3A06:  MOVLW  10
3A08:  MOVWF  00
3A0A:  DECFSZ 00,F
3A0C:  BRA    3A0A
3A0E:  NOP   
....................          printf("\r\nADC= %lu",read_adc()); 
3A10:  BSF    FC2.2
3A12:  BTFSC  FC2.2
3A14:  BRA    3A12
3A16:  MOVFF  FC4,03
3A1A:  MOVFF  FC3,AE
3A1E:  MOVFF  FC4,AF
3A22:  CLRF   xB0
3A24:  MOVF   xB0,W
3A26:  CALL   04C2
3A2A:  INCF   xB0,F
3A2C:  MOVWF  00
3A2E:  MOVF   00,W
3A30:  BTFSS  F9E.4
3A32:  BRA    3A30
3A34:  MOVWF  FAD
3A36:  MOVLW  07
3A38:  SUBWF  xB0,W
3A3A:  BNZ   3A24
3A3C:  MOVLW  10
3A3E:  MOVWF  FE9
3A40:  MOVFF  AF,B6
3A44:  MOVFF  AE,B5
3A48:  CALL   0EA2
....................          break; 
3A4C:  BRA    3A5A
....................       } 
....................  
....................       case 'k': { 
.................... 		 disable_interrupts(GLOBAL); 
3A4E:  BCF    FF2.6
3A50:  BCF    FF2.7
3A52:  BTFSC  FF2.7
3A54:  BRA    3A50
....................          while(1); 
3A56:  BRA    3A56
....................          break; 
3A58:  BRA    3A5A
....................       } 
....................  
....................  
....................  
....................       }// end case       
.................... } 
3A5A:  GOTO   4062 (RETURN)
.................... ////////////////////////////////////// 
.................... /* 
.................... void button_menu() { 
.................... 	int8 k; 
.................... 	int8 target_act=0; 
....................     flag2.en_operate = 0; // enter halt operation 
.................... 	LED_status.power = 0; // always red 
.................... 	LED_status.operation =0; 
.................... 	LED_status.aux =3; // both turned off 
.................... 	display_LED(); 
....................     flag2.abort_current_activity =0; 
.................... 	while(flag2.button_pressed ==1)	button_scan(); 
.................... 	delay_ms(10); 
.................... 	// button release 
....................  
....................     while(1) { 
.................... 		nButton =-1; 
.................... 		button_scan(); 
.................... 		restart_wdt(); 
.................... 		if (nButton != -1){ 
.................... 		switch (nButton) { 
.................... 			case 0: { // operate/halt button  
.................... 					while (flag2.button_pressed ==1) button_scan(); 
.................... 					delay_ms(10); 
.................... 					nButton=-1; 
.................... 					flag2.en_operate =1; 
.................... 					flag2.abort_current_activity =0; 
.................... 					return;} 
.................... 			case 1: { // actuator select button 
.................... 					while (flag2.button_pressed ==1) button_scan(); 
.................... 					delay_ms(10); 
.................... 					target_act++; 
.................... 					target_act = target_act%4; 
.................... 					LED_status.aux=target_act ^ 0xFF ; 
.................... 					display_LED(); 
.................... 					break;} 
....................       		case 2: { //return home 
....................          			move_act(2000,9000,move_act_time_out,1,target_act); // move actuator to west 
....................          			move_act(2000,9000,move_act_time_out,0,target_act); // move actuator to home position 
....................          			act_full_stroke_tick[target_act]= actuator_pulse; 
....................          			current_act_position[target_act] =0; 
....................          			write_eeprom_data(1); // save full_stroke_tick and current_position 
....................          			break; 
....................       				} 
.................... 			case 3: { // move east 
.................... 					flag2.allow_manual_move_act=1; 
.................... 					move_act(10,4500,move_act_time_out,0,target_act); 
.................... 					flag2.allow_manual_move_act=0; 
.................... 					break; } 
.................... 			case 4: { // move safty 
.................... 				    while (flag2.button_pressed ==1) button_scan(); 
.................... 					delay_ms(10); 
.................... 					tick = (int32)act_full_stroke_tick[target_act]*(int32)(act_safety_stroke-act_min_stroke); 
.................... 					tick = tick/(act_max_stroke-act_min_stroke); 
.................... 					target_act_position = (unsigned int16) tick; 
.................... 					disable_interrupts(GLOBAL); 
.................... 			 		printf("\r\n Act#%d Len=%lu Now=%lu\r\n",target_act, target_act_position, current_act_position[target_act]); 
.................... 					enable_interrupts(GLOBAL); 
.................... 					actuator_move_execute(target_act); 
.................... 					break; } 
.................... 			case 5: { // move west 
.................... 					flag2.allow_manual_move_act=1; 
.................... 					move_act(10,4500,move_act_time_out,1,target_act); 
.................... 					flag2.allow_manual_move_act=0; 
.................... 					break; } 
....................  
....................  
....................  
.................... 			} 
.................... 			 
.................... 		} 
.................... 		} 
.................... 		 
.................... } 
.................... */ 
....................  
.................... void log_data() { 
....................  
.................... 	unsigned int16 current_period; 
.................... 	unsigned int16 sun_rise_period; 
.................... 	unsigned int16 average_current; 
.................... 	int8 index_to_write; 
.................... 	current_period = (timer_sec+225)/450; 
*
3B5C:  MOVLW  E1
3B5E:  ADDWF  21,W
3B60:  MOVWF  xB3
3B62:  MOVLW  00
3B64:  ADDWFC 22,W
3B66:  MOVWF  xB4
3B68:  MOVLW  00
3B6A:  ADDWFC 23,W
3B6C:  MOVWF  xB5
3B6E:  MOVLW  00
3B70:  ADDWFC 24,W
3B72:  MOVWF  xB6
3B74:  CLRF   18
3B76:  BTFSC  FF2.7
3B78:  BSF    18.7
3B7A:  BCF    FF2.7
3B7C:  MOVWF  xC1
3B7E:  MOVFF  B5,C0
3B82:  MOVFF  B4,BF
3B86:  MOVFF  B3,BE
3B8A:  CLRF   xC5
3B8C:  CLRF   xC4
3B8E:  MOVLW  01
3B90:  MOVWF  xC3
3B92:  MOVLW  C2
3B94:  MOVWF  xC2
3B96:  CALL   0658
3B9A:  BTFSC  18.7
3B9C:  BSF    FF2.7
3B9E:  MOVFF  01,AD
3BA2:  MOVFF  00,AC
....................     flash_read_page(nDay,0x02); // get sun rise time 
3BA6:  MOVFF  32,B4
3BAA:  MOVFF  31,B3
3BAE:  MOVFF  32,C0
3BB2:  MOVFF  31,BF
3BB6:  MOVLW  02
3BB8:  MOVWF  xC1
3BBA:  CALL   0DB4
.................... 	sun_rise_period=make16(flash_page_data2,flash_page_data); 
3BBE:  MOVFF  80,AF
3BC2:  MOVFF  7F,AE
....................     // write the sunrise time to buffer1 
....................     flash_read_main_memory_to_buffer1(LOGGER_START_PAGE+((nDay-1)%365)+1); 
3BC6:  MOVLW  01
3BC8:  SUBWF  31,W
3BCA:  MOVWF  xB3
3BCC:  MOVLW  00
3BCE:  SUBWFB 32,W
3BD0:  MOVWF  xB4
3BD2:  MOVLW  00
3BD4:  SUBWFB 33,W
3BD6:  MOVWF  xB5
3BD8:  MOVLW  00
3BDA:  SUBWFB 34,W
3BDC:  MOVWF  xB6
3BDE:  CLRF   18
3BE0:  BTFSC  FF2.7
3BE2:  BSF    18.7
3BE4:  BCF    FF2.7
3BE6:  MOVWF  xC1
3BE8:  MOVFF  B5,C0
3BEC:  MOVFF  B4,BF
3BF0:  MOVFF  B3,BE
3BF4:  CLRF   xC5
3BF6:  CLRF   xC4
3BF8:  MOVLW  01
3BFA:  MOVWF  xC3
3BFC:  MOVLW  6D
3BFE:  MOVWF  xC2
3C00:  CALL   0658
3C04:  BTFSC  18.7
3C06:  BSF    FF2.7
3C08:  MOVFF  FEF,00
3C0C:  MOVFF  FEC,01
3C10:  MOVFF  FEC,02
3C14:  MOVFF  FEC,03
3C18:  MOVLW  DC
3C1A:  ADDWF  00,W
3C1C:  MOVWF  xB4
3C1E:  MOVLW  05
3C20:  ADDWFC 01,W
3C22:  MOVWF  xB5
3C24:  MOVLW  00
3C26:  ADDWFC 02,W
3C28:  MOVWF  xB6
3C2A:  MOVLW  00
3C2C:  ADDWFC 03,W
3C2E:  MOVWF  xB7
3C30:  MOVLW  01
3C32:  ADDWF  xB4,W
3C34:  MOVWF  xB8
3C36:  MOVLW  00
3C38:  ADDWFC xB5,W
3C3A:  MOVWF  xB9
3C3C:  MOVWF  xBB
3C3E:  MOVFF  B8,BA
3C42:  CALL   17CE
....................     if (current_period < sun_rise_period) {  
3C46:  MOVF   xAD,W
3C48:  SUBWF  xAF,W
3C4A:  BNC   3C70
3C4C:  BNZ   3C54
3C4E:  MOVF   xAE,W
3C50:  SUBWF  xAC,W
3C52:  BC    3C70
.................... 		printf("\r\n too early \r\n"); 
3C54:  CLRF   xB3
3C56:  MOVF   xB3,W
3C58:  CALL   04E8
3C5C:  INCF   xB3,F
3C5E:  MOVWF  00
3C60:  MOVF   00,W
3C62:  BTFSS  F9E.4
3C64:  BRA    3C62
3C66:  MOVWF  FAD
3C68:  MOVLW  0F
3C6A:  SUBWF  xB3,W
3C6C:  BNZ   3C56
.................... 		return;} 
3C6E:  BRA    3E0C
....................     if (current_period == sun_rise_period) { // start of day, clear the page first 
3C70:  MOVF   xAE,W
3C72:  SUBWF  xAC,W
3C74:  BNZ   3CA0
3C76:  MOVF   xAF,W
3C78:  SUBWF  xAD,W
3C7A:  BNZ   3CA0
.................... 		printf("\r\n star new log \r\n"); 
3C7C:  CLRF   xB3
3C7E:  MOVF   xB3,W
3C80:  CALL   0512
3C84:  INCF   xB3,F
3C86:  MOVWF  00
3C88:  MOVF   00,W
3C8A:  BTFSS  F9E.4
3C8C:  BRA    3C8A
3C8E:  MOVWF  FAD
3C90:  MOVLW  12
3C92:  SUBWF  xB3,W
3C94:  BNZ   3C7E
.................... 		flash_buffer1_write(0x00, 0x00, 255); 
3C96:  CLRF   xB5
3C98:  CLRF   xB6
3C9A:  MOVLW  FF
3C9C:  MOVWF  xB7
3C9E:  RCALL  3AB4
.................... 	}  
....................     if (current_period - sun_rise_period < 124) { 
3CA0:  MOVF   xAE,W
3CA2:  SUBWF  xAC,W
3CA4:  MOVWF  xB3
3CA6:  MOVF   xAF,W
3CA8:  SUBWFB xAD,W
3CAA:  MOVWF  xB4
3CAC:  MOVF   xB4,F
3CAE:  BTFSS  FD8.2
3CB0:  BRA    3DF2
3CB2:  MOVF   xB3,W
3CB4:  SUBLW  7B
3CB6:  BTFSS  FD8.0
3CB8:  BRA    3DF2
.................... 		// write day 
.................... 		average_current = accumulate_current / n_avg; 
3CBA:  MOVFF  78,B4
3CBE:  MOVFF  77,B3
3CC2:  CLRF   xB6
3CC4:  MOVFF  79,B5
3CC8:  BRA    3B18
3CCA:  MOVFF  02,B1
3CCE:  MOVFF  01,B0
.................... 		accumulate_current =0; 
3CD2:  CLRF   x78
3CD4:  CLRF   x77
.................... 		n_avg=0; 
3CD6:  CLRF   x79
.................... 		printf("\r\n log \r\n"); 
3CD8:  CLRF   xB3
3CDA:  MOVF   xB3,W
3CDC:  CALL   0540
3CE0:  INCF   xB3,F
3CE2:  MOVWF  00
3CE4:  MOVF   00,W
3CE6:  BTFSS  F9E.4
3CE8:  BRA    3CE6
3CEA:  MOVWF  FAD
3CEC:  MOVLW  09
3CEE:  SUBWF  xB3,W
3CF0:  BNZ   3CDA
.................... 		flash_buffer1_write(flash_page_data, 0x02, 1); 
3CF2:  MOVFF  7F,B5
3CF6:  MOVLW  02
3CF8:  MOVWF  xB6
3CFA:  MOVLW  01
3CFC:  MOVWF  xB7
3CFE:  RCALL  3AB4
.................... 		flash_buffer1_write(flash_page_data2, 0x03, 1); 
3D00:  MOVFF  80,B5
3D04:  MOVLW  03
3D06:  MOVWF  xB6
3D08:  MOVLW  01
3D0A:  MOVWF  xB7
3D0C:  RCALL  3AB4
.................... 		flash_buffer1_write(make8(nDay,0), 0x00, 1); 
3D0E:  MOVFF  31,B3
3D12:  MOVFF  31,B5
3D16:  CLRF   xB6
3D18:  MOVLW  01
3D1A:  MOVWF  xB7
3D1C:  RCALL  3AB4
.................... 		flash_buffer1_write(make8(nDay,1), 0x01, 1); 
3D1E:  MOVFF  32,B3
3D22:  MOVFF  32,B5
3D26:  MOVLW  01
3D28:  MOVWF  xB6
3D2A:  MOVWF  xB7
3D2C:  RCALL  3AB4
.................... 		index_to_write = (int8) 4+(current_period-sun_rise_period)*2; 
3D2E:  MOVF   xAE,W
3D30:  SUBWF  xAC,W
3D32:  MOVWF  xB3
3D34:  MOVF   xAF,W
3D36:  SUBWFB xAD,W
3D38:  MOVWF  xB4
3D3A:  BCF    FD8.0
3D3C:  RLCF   xB3,W
3D3E:  MOVWF  02
3D40:  RLCF   xB4,W
3D42:  MOVF   02,W
3D44:  ADDLW  04
3D46:  MOVWF  xB2
.................... 		flash_buffer1_write(make8(average_current,0),index_to_write, 1); 
3D48:  MOVFF  B0,B3
3D4C:  MOVFF  B0,B5
3D50:  MOVFF  B2,B6
3D54:  MOVLW  01
3D56:  MOVWF  xB7
3D58:  RCALL  3AB4
.................... 		flash_buffer1_write(make8(average_current,1),index_to_write+1, 1); 
3D5A:  MOVFF  B1,B3
3D5E:  MOVLW  01
3D60:  ADDWF  xB2,W
3D62:  MOVWF  xB4
3D64:  MOVFF  B1,B5
3D68:  MOVWF  xB6
3D6A:  MOVLW  01
3D6C:  MOVWF  xB7
3D6E:  RCALL  3AB4
.................... 		flash_write_buffer1_to_main_memory(LOGGER_START_PAGE+((nDay-1)%365)+1); 
3D70:  MOVLW  01
3D72:  SUBWF  31,W
3D74:  MOVWF  xB3
3D76:  MOVLW  00
3D78:  SUBWFB 32,W
3D7A:  MOVWF  xB4
3D7C:  MOVLW  00
3D7E:  SUBWFB 33,W
3D80:  MOVWF  xB5
3D82:  MOVLW  00
3D84:  SUBWFB 34,W
3D86:  MOVWF  xB6
3D88:  CLRF   18
3D8A:  BTFSC  FF2.7
3D8C:  BSF    18.7
3D8E:  BCF    FF2.7
3D90:  MOVWF  xC1
3D92:  MOVFF  B5,C0
3D96:  MOVFF  B4,BF
3D9A:  MOVFF  B3,BE
3D9E:  CLRF   xC5
3DA0:  CLRF   xC4
3DA2:  MOVLW  01
3DA4:  MOVWF  xC3
3DA6:  MOVLW  6D
3DA8:  MOVWF  xC2
3DAA:  CALL   0658
3DAE:  BTFSC  18.7
3DB0:  BSF    FF2.7
3DB2:  MOVFF  FEF,00
3DB6:  MOVFF  FEC,01
3DBA:  MOVFF  FEC,02
3DBE:  MOVFF  FEC,03
3DC2:  MOVLW  DC
3DC4:  ADDWF  00,W
3DC6:  MOVWF  xB4
3DC8:  MOVLW  05
3DCA:  ADDWFC 01,W
3DCC:  MOVWF  xB5
3DCE:  MOVLW  00
3DD0:  ADDWFC 02,W
3DD2:  MOVWF  xB6
3DD4:  MOVLW  00
3DD6:  ADDWFC 03,W
3DD8:  MOVWF  xB7
3DDA:  MOVLW  01
3DDC:  ADDWF  xB4,W
3DDE:  MOVWF  xB8
3DE0:  MOVLW  00
3DE2:  ADDWFC xB5,W
3DE4:  MOVWF  xB9
3DE6:  MOVWF  xBB
3DE8:  MOVFF  B8,BA
3DEC:  CALL   1788
....................  	}  else printf("\r\n too late \r\n");  
3DF0:  BRA    3E0C
3DF2:  CLRF   xB3
3DF4:  MOVF   xB3,W
3DF6:  CALL   0564
3DFA:  INCF   xB3,F
3DFC:  MOVWF  00
3DFE:  MOVF   00,W
3E00:  BTFSS  F9E.4
3E02:  BRA    3E00
3E04:  MOVWF  FAD
3E06:  MOVLW  0E
3E08:  SUBWF  xB3,W
3E0A:  BNZ   3DF4
.................... } 
3E0C:  GOTO   40A6 (RETURN)
....................  
.................... ////////////////////////////////////// 
.................... void main() { 
3E10:  CLRF   FF8
3E12:  BCF    FD0.7
3E14:  BSF    0D.7
3E16:  CLRF   FEA
3E18:  CLRF   FE9
3E1A:  MOVLW  03
3E1C:  MOVWF  FAF
3E1E:  MOVLW  A2
3E20:  MOVWF  FAC
3E22:  MOVLW  90
3E24:  MOVWF  FAB
3E26:  BSF    F94.4
3E28:  BCF    F94.5
3E2A:  BCF    F94.3
3E2C:  BCF    F8B.3
3E2E:  BSF    FC1.0
3E30:  BSF    FC1.1
3E32:  BSF    FC1.2
3E34:  BCF    FC1.3
3E36:  MOVLW  07
3E38:  MOVWF  FB4
3E3A:  CLRF   19
3E3C:  CLRF   1A
3E3E:  CLRF   21
3E40:  CLRF   22
3E42:  CLRF   23
3E44:  CLRF   24
3E46:  CLRF   25
3E48:  CLRF   26
3E4A:  CLRF   27
3E4C:  CLRF   28
3E4E:  CLRF   29
3E50:  CLRF   2A
3E52:  CLRF   2B
3E54:  CLRF   2C
3E56:  CLRF   2D
3E58:  CLRF   2E
3E5A:  CLRF   2F
3E5C:  CLRF   30
3E5E:  MOVLW  01
3E60:  MOVWF  31
3E62:  CLRF   32
3E64:  CLRF   33
3E66:  CLRF   34
3E68:  CLRF   35
3E6A:  CLRF   36
3E6C:  CLRF   4B
3E6E:  MOVLW  FF
3E70:  MOVWF  4C
3E72:  CLRF   x77
3E74:  CLRF   x78
3E76:  CLRF   x79
3E78:  CLRF   x7E
3E7A:  CLRF   x7F
3E7C:  CLRF   x80
3E7E:  MOVLW  03
3E80:  MOVWF  x81
3E82:  CLRF   x82
3E84:  CLRF   x83
3E86:  CLRF   x84
3E88:  CLRF   x89
3E8A:  CLRF   x8A
3E8C:  CLRF   x8B
3E8E:  CLRF   x8C
3E90:  CLRF   x8D
3E92:  CLRF   x8E
3E94:  CLRF   x8F
3E96:  CLRF   x90
3E98:  CLRF   x91
3E9A:  CLRF   x92
3E9C:  CLRF   x93
3E9E:  CLRF   x94
3EA0:  CLRF   x95
3EA2:  CLRF   x96
3EA4:  CLRF   x97
3EA6:  CLRF   x98
3EA8:  CLRF   x99
3EAA:  CLRF   x9A
3EAC:  CLRF   x9B
3EAE:  CLRF   x9C
3EB0:  CLRF   x9D
3EB2:  CLRF   x9E
3EB4:  CLRF   x9F
3EB6:  CLRF   xA0
3EB8:  CLRF   xA1
3EBA:  CLRF   xA2
3EBC:  CLRF   xA3
3EBE:  CLRF   xA4
3EC0:  CLRF   xA5
3EC2:  CLRF   xA6
3EC4:  CLRF   xA7
.................... 	int16 relay_time; 
.................... 	int8 act_loop,i; 
.................... 	init_spi(); 
3EC6:  GOTO   08E6
....................     setup_adc_ports(AN0); 
3ECA:  BCF    FC1.0
3ECC:  BSF    FC1.1
3ECE:  BSF    FC1.2
3ED0:  BSF    FC1.3
....................     setup_adc(ADC_CLOCK_INTERNAL); 
3ED2:  BCF    FC1.6
3ED4:  BSF    FC2.6
3ED6:  BSF    FC2.7
3ED8:  BSF    FC1.7
3EDA:  BSF    FC2.0
....................     set_adc_channel(0); 
3EDC:  MOVLW  00
3EDE:  MOVWF  01
3EE0:  MOVF   FC2,W
3EE2:  ANDLW  C7
3EE4:  IORWF  01,W
3EE6:  MOVWF  FC2
.................... /* 
....................  
.................... 	set_tris_a(0xFF); 
.................... 	set_tris_b(0xFF); 
.................... 	set_tris_d(0x00); 
.................... */ 
....................  
....................    set_tris_d(0x00); // all D are output 
3EE8:  MOVLW  00
3EEA:  MOVWF  F95
....................    set_tris_e(0b00000010); // RE1 = emergnecy input 
3EEC:  BCF    F96.0
3EEE:  BSF    F96.1
3EF0:  BCF    F96.2
....................    set_tris_a(0b11111111); // A0 -1 is output 
3EF2:  MOVLW  FF
3EF4:  MOVWF  F92
....................    set_tris_b(0xA0); 
3EF6:  MOVLW  A0
3EF8:  MOVWF  F93
....................    set_tris_c(0b10010000); 
3EFA:  MOVLW  90
3EFC:  MOVWF  F94
....................    delay_ms(1000); 
3EFE:  MOVLW  04
3F00:  MOVWF  xAC
3F02:  MOVLW  FA
3F04:  MOVWF  xC1
3F06:  CALL   08FE
3F0A:  DECFSZ xAC,F
3F0C:  BRA    3F02
.................... /* // ADC for wall power is not valid here // 
....................  
.................... 	while(read_adc() < 650) { 
.................... 		 led_status =0xFE; 
.................... 		 display_LED(); 
.................... 		 delay_ms(2); 
.................... 		 led_status =0xFF; 
.................... 		 display_LED();			 
.................... 		 delay_ms(50); 
.................... 	} // trap here  until voltage level is good 
.................... */ 
.................... 	delay_ms(200); 
3F0E:  MOVLW  C8
3F10:  MOVWF  xC1
3F12:  CALL   08FE
.................... 	flag2.power=1; 
3F16:  BSF    20.5
.................... 	output_high(PIN_D6); //always on for power control 
3F18:  MOVLW  00
3F1A:  MOVWF  F95
3F1C:  BSF    F8C.6
....................  
.................... 	porte.tx_en=1; 
3F1E:  BSF    F84.2
....................     lcd_init(); 
3F20:  CALL   0988
....................  
....................  
.................... 	printf("\r\n init"); 
3F24:  CLRF   xAC
3F26:  MOVF   xAC,W
3F28:  CALL   058E
3F2C:  INCF   xAC,F
3F2E:  MOVWF  00
3F30:  MOVF   00,W
3F32:  BTFSS  F9E.4
3F34:  BRA    3F32
3F36:  MOVWF  FAD
3F38:  MOVLW  07
3F3A:  SUBWF  xAC,W
3F3C:  BNZ   3F26
.................... 	flash_wait_until_ready(); 
3F3E:  CALL   0A48
.................... 	printf("\r\n read flash"); 
3F42:  CLRF   xAC
3F44:  MOVF   xAC,W
3F46:  CALL   05B0
3F4A:  INCF   xAC,F
3F4C:  MOVWF  00
3F4E:  MOVF   00,W
3F50:  BTFSS  F9E.4
3F52:  BRA    3F50
3F54:  MOVWF  FAD
3F56:  MOVLW  0D
3F58:  SUBWF  xAC,W
3F5A:  BNZ   3F44
.................... 	flash_read_mfg_id(); 
3F5C:  GOTO   0A6C
.................... 	printf("\r\n Mfg:%02X %02X %02X %02X",flash_mfg_id[0],flash_mfg_id[1],flash_mfg_id[2],flash_mfg_id[3]); 
3F60:  CLRF   xAC
3F62:  MOVF   xAC,W
3F64:  CALL   05D8
3F68:  INCF   xAC,F
3F6A:  MOVWF  00
3F6C:  MOVF   00,W
3F6E:  BTFSS  F9E.4
3F70:  BRA    3F6E
3F72:  MOVWF  FAD
3F74:  MOVLW  07
3F76:  SUBWF  xAC,W
3F78:  BNZ   3F62
3F7A:  MOVFF  7A,B4
3F7E:  MOVLW  37
3F80:  MOVWF  xB5
3F82:  CALL   0AC6
3F86:  MOVLW  20
3F88:  BTFSS  F9E.4
3F8A:  BRA    3F88
3F8C:  MOVWF  FAD
3F8E:  MOVFF  7B,B4
3F92:  MOVLW  37
3F94:  MOVWF  xB5
3F96:  CALL   0AC6
3F9A:  MOVLW  20
3F9C:  BTFSS  F9E.4
3F9E:  BRA    3F9C
3FA0:  MOVWF  FAD
3FA2:  MOVFF  7C,B4
3FA6:  MOVLW  37
3FA8:  MOVWF  xB5
3FAA:  CALL   0AC6
3FAE:  MOVLW  20
3FB0:  BTFSS  F9E.4
3FB2:  BRA    3FB0
3FB4:  MOVWF  FAD
3FB6:  MOVFF  7D,B4
3FBA:  MOVLW  37
3FBC:  MOVWF  xB5
3FBE:  CALL   0AC6
.................... 	flash_read_stat(); // stat & 0xBF == 0x9C means device ready 
3FC2:  CALL   0A14
.................... 	printf("\r\n Stat: %02X",flash_stat); 
3FC6:  CLRF   xAC
3FC8:  MOVF   xAC,W
3FCA:  CALL   060E
3FCE:  INCF   xAC,F
3FD0:  MOVWF  00
3FD2:  MOVF   00,W
3FD4:  BTFSS  F9E.4
3FD6:  BRA    3FD4
3FD8:  MOVWF  FAD
3FDA:  MOVLW  09
3FDC:  SUBWF  xAC,W
3FDE:  BNZ   3FC8
3FE0:  MOVFF  7E,B4
3FE4:  MOVLW  37
3FE6:  MOVWF  xB5
3FE8:  CALL   0AC6
....................     // check flash readiness here // 
.................... 	read_eeprom_data(); 
3FEC:  GOTO   0B22
.................... 	print_fw_info(); 
3FF0:  CALL   0F46
....................     T1CON = 0b00001111;  // 0b10011011 
3FF4:  MOVLW  0F
3FF6:  MOVWF  FCD
....................  
....................     enable_interrupts(INT_RDA); 
3FF8:  BSF    F9D.5
....................     enable_interrupts(INT_TIMER1);   // Setup interrupt on falling edge 
3FFA:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
3FFC:  MOVLW  C0
3FFE:  IORWF  FF2,F
.................... 	init_rs232(); 
4000:  CALL   06D2
.................... 	relay_time =0; 
4004:  CLRF   xA9
4006:  CLRF   xA8
.................... 	flag2.en_operate =1; 
4008:  BSF    20.0
.................... 	flag2.button_pressed=0; 
400A:  BCF    20.1
.................... 	flag2.allow_manual_move_act=0; 
400C:  BCF    20.3
.................... //	LED_status =0x00; 
....................  
.................... 	delay_ms(200); 
400E:  MOVLW  C8
4010:  MOVWF  xC1
4012:  CALL   08FE
.................... 	while(read_eeprom((int8)0xf00040)!=0x34); 
4016:  MOVFF  FF2,AC
401A:  BCF    FF2.7
401C:  MOVLW  40
401E:  MOVWF  FA9
4020:  BCF    FA6.6
4022:  BCF    FA6.7
4024:  BSF    FA6.0
4026:  MOVF   FA8,W
4028:  BTFSC  xAC.7
402A:  BSF    FF2.7
402C:  SUBLW  34
402E:  BNZ   4016
.................... 	while(read_eeprom((int8)0xf00041)!=0x12); 
4030:  MOVFF  FF2,AC
4034:  BCF    FF2.7
4036:  MOVLW  41
4038:  MOVWF  FA9
403A:  BCF    FA6.6
403C:  BCF    FA6.7
403E:  BSF    FA6.0
4040:  MOVF   FA8,W
4042:  BTFSC  xAC.7
4044:  BSF    FF2.7
4046:  SUBLW  12
4048:  BNZ   4030
.................... //	display_LED(); 
.................... 	startup_counter++; 
404A:  INCF   35,F
404C:  BTFSC  FD8.2
404E:  INCF   36,F
.................... 	write_eeprom_data(0); 
4050:  CLRF   xAE
4052:  CALL   1172
.................... 	setup_wdt(WDT_ON); 
4056:  BSF    FD1.0
.................... 	while(1) { 
.................... 	    restart_wdt(); 
4058:  CLRWDT
.................... 		if (flag.cmd_posted==1) process_cmd_msg(); 
405A:  BTFSS  1F.3
405C:  BRA    4062
405E:  GOTO   31F2
.................... 		if (flag.update_time) { 
4062:  BTFSS  1F.1
4064:  BRA    4070
.................... 			flag.update_time=false; 
4066:  BCF    1F.1
.................... 			print_date_time(0x02); 
4068:  MOVLW  02
406A:  MOVWF  xAE
406C:  CALL   1E7E
.................... 		} 
....................  
.................... 		if (flag.measure_current) { 
4070:  BTFSS  1F.7
4072:  BRA    4086
.................... 			flag.measure_current = false; 
4074:  BCF    1F.7
.................... 			accumulate_current += read_adc(); 
4076:  BSF    FC2.2
4078:  BTFSC  FC2.2
407A:  BRA    4078
407C:  MOVF   FC3,W
407E:  ADDWF  x77,F
4080:  MOVF   FC4,W
4082:  ADDWFC x78,F
.................... 			n_avg++; 
4084:  INCF   x79,F
.................... 		} 
.................... 		for(act_loop=0;act_loop<1;act_loop++) // limit to work only act 0 
4086:  CLRF   xAA
4088:  MOVF   xAA,F
408A:  BTFSS  FD8.2
408C:  BRA    41D8
.................... 		{ 
.................... 			if (bit_test(actuator_move_mask,act_loop)==1){ 
408E:  MOVFF  A7,00
4092:  MOVF   xAA,W
4094:  MOVWF  01
4096:  BZ    40A0
4098:  BCF    FD8.0
409A:  RRCF   00,F
409C:  DECFSZ 01,F
409E:  BRA    4098
40A0:  BTFSS  00.0
40A2:  BRA    41D4
.................... 				log_data(); // save measured current into flash first 
40A4:  BRA    3B5C
.................... 				if (act_full_stroke_tick[act_loop]>0x0010) { 
40A6:  BCF    FD8.0
40A8:  RLCF   xAA,W
40AA:  CLRF   03
40AC:  ADDLW  93
40AE:  MOVWF  FE9
40B0:  MOVLW  00
40B2:  ADDWFC 03,W
40B4:  MOVWF  FEA
40B6:  MOVFF  FEC,AD
40BA:  MOVF   FED,F
40BC:  MOVFF  FEF,AC
40C0:  MOVF   xAD,F
40C2:  BNZ   40CC
40C4:  MOVF   xAC,W
40C6:  SUBLW  10
40C8:  BTFSC  FD8.0
40CA:  BRA    41D4
....................          		solar_get_act_length(act_loop); 
40CC:  MOVFF  AA,AF
40D0:  CALL   2A68
.................... 				disable_interrupts(GLOBAL); 
40D4:  BCF    FF2.6
40D6:  BCF    FF2.7
40D8:  BTFSC  FF2.7
40DA:  BRA    40D6
.................... 		 		printf("\r\n Act#%d Len=%lu Now=%lu\r\n",act_loop, target_act_position, current_act_position[act_loop]); 
40DC:  BCF    FD8.0
40DE:  RLCF   xAA,W
40E0:  CLRF   03
40E2:  ADDLW  89
40E4:  MOVWF  FE9
40E6:  MOVLW  00
40E8:  ADDWFC 03,W
40EA:  MOVWF  FEA
40EC:  MOVFF  FEC,AD
40F0:  MOVF   FED,F
40F2:  MOVFF  FEF,AC
40F6:  CLRF   xAE
40F8:  MOVF   xAE,W
40FA:  CALL   0432
40FE:  INCF   xAE,F
4100:  MOVWF  00
4102:  MOVF   00,W
4104:  BTFSS  F9E.4
4106:  BRA    4104
4108:  MOVWF  FAD
410A:  MOVLW  07
410C:  SUBWF  xAE,W
410E:  BNZ   40F8
4110:  MOVFF  AA,B3
4114:  MOVLW  1F
4116:  MOVWF  xB4
4118:  CALL   2F86
411C:  MOVLW  09
411E:  MOVWF  xAF
4120:  MOVF   xAF,W
4122:  CALL   0432
4126:  INCF   xAF,F
4128:  MOVWF  00
412A:  MOVF   00,W
412C:  BTFSS  F9E.4
412E:  BRA    412C
4130:  MOVWF  FAD
4132:  MOVLW  0E
4134:  SUBWF  xAF,W
4136:  BNZ   4120
4138:  MOVLW  10
413A:  MOVWF  FE9
413C:  MOVFF  92,B6
4140:  MOVFF  91,B5
4144:  CALL   0EA2
4148:  MOVLW  11
414A:  MOVWF  xB0
414C:  MOVF   xB0,W
414E:  CALL   0432
4152:  INCF   xB0,F
4154:  MOVWF  00
4156:  MOVF   00,W
4158:  BTFSS  F9E.4
415A:  BRA    4158
415C:  MOVWF  FAD
415E:  MOVLW  16
4160:  SUBWF  xB0,W
4162:  BNZ   414C
4164:  MOVLW  10
4166:  MOVWF  FE9
4168:  MOVFF  AD,B6
416C:  MOVFF  AC,B5
4170:  CALL   0EA2
4174:  MOVLW  0D
4176:  BTFSS  F9E.4
4178:  BRA    4176
417A:  MOVWF  FAD
417C:  MOVLW  0A
417E:  BTFSS  F9E.4
4180:  BRA    417E
4182:  MOVWF  FAD
.................... 				enable_interrupts(GLOBAL); 
4184:  MOVLW  C0
4186:  IORWF  FF2,F
.................... 		 		actuator_move_execute(act_loop); 
4188:  MOVFF  AA,AF
418C:  CALL   3056
.................... 		 		printf("done \r\n"); 
4190:  CLRF   xAC
4192:  MOVF   xAC,W
4194:  CALL   0636
4198:  INCF   xAC,F
419A:  MOVWF  00
419C:  MOVF   00,W
419E:  BTFSS  F9E.4
41A0:  BRA    419E
41A2:  MOVWF  FAD
41A4:  MOVLW  07
41A6:  SUBWF  xAC,W
41A8:  BNZ   4192
.................... 		   		bit_clear(actuator_move_mask,act_loop); 
41AA:  MOVLW  01
41AC:  MOVWF  00
41AE:  MOVF   xAA,W
41B0:  MOVWF  01
41B2:  BZ    41BC
41B4:  BCF    FD8.0
41B6:  RLCF   00,F
41B8:  DECFSZ 01,F
41BA:  BRA    41B4
41BC:  MOVF   00,W
41BE:  XORLW  FF
41C0:  ANDWF  xA7,F
.................... 				write_eeprom_data(0); 
41C2:  CLRF   xAE
41C4:  CALL   1172
.................... 				print_date_time(0x03); 
41C8:  MOVLW  03
41CA:  MOVWF  xAE
41CC:  CALL   1E7E
.................... 				lcd_init(); 
41D0:  CALL   0988
.................... 			}  
.................... 			} 
.................... 		} 
41D4:  INCF   xAA,F
41D6:  BRA    4088
....................  
.................... //		if (nButton==0) { 
.................... //		    button_menu(); 
.................... //		} 
.................... 		restart_wdt(); 
41D8:  CLRWDT
.................... 	} 
41DA:  BRA    4058
....................  
.................... DEAD_TRAP: while(1); 
41DC:  BRA    41DC
.................... } 
41DE:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0C   NOBROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 7E 04 7F 03 80 02 81 01 

F00010: 00 00 01 00 02 00 03 00 

F00020: 00 00 00 00 01 00 00 00 

F00030: 00 00 

F00040: 34 12 
